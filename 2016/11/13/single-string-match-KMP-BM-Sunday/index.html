<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="fonts.useso.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="字符串匹配,BM,KMP,Sunday,"><link rel="alternate" href="/atom.xml" title="下定青年的个人博客" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="概述字符串匹配(查找)算法是一类重要的字符串算法，给定一个长度为n的字符串text（文本串），要求找出text中是否存在另一个长度为m的字符串pattern（模式串）。如果使用蛮力法，那么时间复杂度为O(m*n)，只有在长度较短的场景下才能勉强使用。
本文涉及的3种算法，KMP、BM、Sunday，都是目前比较主流的单字符串匹配算法。所谓单字符串匹配，就是在一个文本串中找一个模式串，多字符串匹配便"><meta property="og:type" content="article"><meta property="og:title" content="单字符串匹配算法--KMP、BM 和 Sunday"><meta property="og:url" content="http://vinoit.me/2016/11/13/single-string-match-KMP-BM-Sunday/index.html"><meta property="og:site_name" content="下定青年的个人博客"><meta property="og:description" content="概述字符串匹配(查找)算法是一类重要的字符串算法，给定一个长度为n的字符串text（文本串），要求找出text中是否存在另一个长度为m的字符串pattern（模式串）。如果使用蛮力法，那么时间复杂度为O(m*n)，只有在长度较短的场景下才能勉强使用。
本文涉及的3种算法，KMP、BM、Sunday，都是目前比较主流的单字符串匹配算法。所谓单字符串匹配，就是在一个文本串中找一个模式串，多字符串匹配便"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-0.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-1.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-2.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-3.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-4.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-5.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-6.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-7.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-8.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-9.png"><meta property="og:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-10.png"><meta property="og:updated_time" content="2016-11-13T12:49:11.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="单字符串匹配算法--KMP、BM 和 Sunday"><meta name="twitter:description" content="概述字符串匹配(查找)算法是一类重要的字符串算法，给定一个长度为n的字符串text（文本串），要求找出text中是否存在另一个长度为m的字符串pattern（模式串）。如果使用蛮力法，那么时间复杂度为O(m*n)，只有在长度较短的场景下才能勉强使用。
本文涉及的3种算法，KMP、BM、Sunday，都是目前比较主流的单字符串匹配算法。所谓单字符串匹配，就是在一个文本串中找一个模式串，多字符串匹配便"><meta name="twitter:image" content="http://vinoit.me/images/algorithm/KMP-BM-Sunday-0.png"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0x5735d8da4b000400,author:"博主"}}</script><title> 单字符串匹配算法--KMP、BM 和 Sunday | 下定青年的个人博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div style="display:none"><script src="//s6.cnzz.com/stat.php?id=1259121680&web_id=1259121680" type="text/javascript"></script></div><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">下定青年的个人博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">VinoZhu's Blog</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"> <a href="/" rel="section">首页</a></li><li class="menu-item menu-item-categories"> <a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-archives"> <a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"> <a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-about"> <a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-search"> <a href="javascript:;" class="popup-trigger">搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> 单字符串匹配算法--KMP、BM 和 Sunday</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-11-13T19:19:51+08:00" content="2016-11-13">2016-11-13</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法与数据结构/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a></span></span> <span class="post-comments-count">&nbsp; | &nbsp;<a href="/2016/11/13/single-string-match-KMP-BM-Sunday/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/11/13/single-string-match-KMP-BM-Sunday/" itemprop="commentsCount"></span></a></span> &nbsp; | &nbsp;<span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>字符串匹配(查找)算法是一类重要的字符串算法，给定一个长度为n的字符串text（文本串），要求找出text中是否存在另一个长度为m的字符串pattern（模式串）。如果使用蛮力法，那么时间复杂度为O(m*n)，只有在长度较短的场景下才能勉强使用。</p><p>本文涉及的3种算法，KMP、BM、Sunday，都是目前比较主流的单字符串匹配算法。所谓单字符串匹配，就是在一个文本串中找一个模式串，多字符串匹配便是一个文本串中找多个模式串，多字符串匹配算法中主流的有ac自动机。</p><p>这3种单字符串匹配算法的具体说明在这里就不详细展开了，网络上有很多图文并茂的教程，在这里只提一下每个算法中最核心的几点，并分别给出java实现的算法。</p><p><strong>一些名称</strong></p><ul><li>text:文本串</li><li>pattern:模式串</li><li>i为文本串中当前比较字符的下标</li><li>j为模式串中当前比较字符的下标</li></ul><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>KMP算法是对蛮力法的改进，在蛮力法中，i和j都是一步一步往后移的，这就会做大量无用的循环判断。在KMP中，通过提前计算出一个next数组。从左到右匹配时，当模式串中的某个字符匹配失败了，取出next数组中对应下标的值，这个值就是j的下一个值。考虑以下情况：<br><img src="/images/algorithm/KMP-BM-Sunday-0.png" alt=""><br>此时pattern中的最后一个字符匹配失败，如果是蛮力法，那么pattern会向后移动一位。但是仔细观察pattern，就会发现有更好的移动方案：<br><img src="/images/algorithm/KMP-BM-Sunday-1.png" alt=""><br>在pattern移动到此位置之前的所有移动都属于无用功，这正是KMP中的正确做法。</p><p><strong>KMP中的一些概念</strong></p><ul><li>前缀：指除了最后一个字符以外，一个字符串的全部头部组合；</li><li>后缀：指除了第一个字符以外，一个字符串的全部尾部组合；</li><li><p>最大前后缀匹配：”前缀”和”后缀”的最长的共有元素的长度；</p><p> “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p><p> “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p></li></ul><p>KMP中的next数组便是用来存放这个最大前后缀匹配的情况。对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<br><img src="/images/algorithm/KMP-BM-Sunday-2.png" alt=""></p><p><strong>java实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">package singleStrMatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//模式串下标</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>;<span class="comment">//最大前后缀匹配中前缀的下一个下标（最大前后缀匹配的长度）</span></div><div class="line">        <span class="keyword">int</span> len = pattern.length();</div><div class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &lt; len - <span class="number">1</span>) &#123;<span class="comment">//j为计算当前next值的前一个下标</span></div><div class="line">            <span class="comment">//k == -1表示0～j的字符串中没有前后缀匹配</span></div><div class="line">            <span class="comment">//如果pattern.charAt(k) == pattern.charAt(j)，最大前后缀匹配长度加1</span></div><div class="line">            <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern.charAt(k) == pattern.charAt(j)) &#123;</div><div class="line"></div><div class="line">                j++;</div><div class="line">                k++;</div><div class="line">                next[j] = k;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">//此时不存在前后缀匹配。若k&gt;1,则p[0 ～ k-1]字符串和p[j-k ～ j-1]字符串相等。</span></div><div class="line"></div><div class="line">                k = next[k];<span class="comment">//（前缀中最大前后缀匹配）的前缀的下一个下标</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String text, String pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> slen = text.length();</div><div class="line">        <span class="keyword">int</span> plen = pattern.length();</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] next = getNext(pattern);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; slen &amp;&amp; j &lt; plen) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (text.charAt(i) == pattern.charAt(j)) &#123;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (next[j] == <span class="number">-1</span>) &#123;</div><div class="line">                    i++;</div><div class="line">                    j = <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    j = next[j];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == plen) &#123;</div><div class="line">                <span class="keyword">return</span> i - j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        String text = <span class="string">"HERE IS A SIMPLE EXAMPLE"</span>;</div><div class="line">        String pattern = <span class="string">"EXAMPLE"</span>;</div><div class="line">        System.out.println(<span class="string">"字符串匹配的位置为:"</span> + kmp(text, pattern));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h4><p>KMP算法其实并不是效率最高的字符串匹配算法，实际应用的并不多，各种文本编辑器的“查找(CTRL F)”功能大多采用的是BM算法(Boyer Moore)。BM算法效率更高，更容易理解,BM算法往往比KMP算法快上3－5倍。</p><p>BM算法从尾部开始比较，如果匹配失败，此时存在2种规则：</p><ol><li>坏字符规则</li></ol><ul><li>后移位数 = 坏字符的位置 - 模式串中的上一次出现位置值</li></ul><p>假如在模式串中未出现，则为-1</p><p>假定文本串为”HERE IS A SIMPLE EXAMPLE”，模式串为”EXAMPLE”。</p><p>首先，”字符串”与”搜索词”头部对齐，从<code>尾部</code>开始比较。<br><img src="/images/algorithm/KMP-BM-Sunday-3.png" alt=""><br>S就是坏字符,移动<code>6-(-1)</code>。</p><p>依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在搜索词”EXAMPLE”之中。所以，将搜索词后移两位，两个”P”对齐。<br><img src="/images/algorithm/KMP-BM-Sunday-4.png" alt=""><br>移动<code>6-4</code>。<br><img src="/images/algorithm/KMP-BM-Sunday-5.png" alt=""></p><ol><li>好后缀规则</li></ol><ul><li>后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置</li></ul><p>同样，未出现则为-1</p><p><img src="/images/algorithm/KMP-BM-Sunday-6.png" alt=""><br>这个规则有三个注意点：</p><ul><li>“好后缀”的位置以最后一个字符为准。假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5（从0开始计算）。 　　</li><li>如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）。 　　</li><li>如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，请问这时”好后缀”的上一次出现位置是什么？回答是，此时采用的好后缀是”B”，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”。</li></ul><p>回到上图，此时，所有的”好后缀”（MPLE、PLE、LE、E）之中，只有”E”在”EXAMPLE”还出现在头部，所以后移 6 - 0 = 6位。<br><img src="/images/algorithm/KMP-BM-Sunday-7.png" alt=""><br>那什么时候用坏字符规则，什么时候用好后缀规则呢？Boyer-Moore算法的基本思想是，每次后移这两个规则之中的较大值。因为模式串已经确定了，所以可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。</p><p><strong>java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> singleStrMatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BM</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CARD_CHAR_SET = <span class="number">256</span>;<span class="comment">// 字符集规模</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param text 主串</div><div class="line">     * @param pattern 模式串</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMatchIndex</span><span class="params">(String text, String pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] BC = BuildBC(pattern); <span class="comment">// 坏字符表</span></div><div class="line">        <span class="keyword">int</span>[] GS = BuildGS(pattern); <span class="comment">// 好后缀表</span></div><div class="line"></div><div class="line">        <span class="comment">// 查找匹配</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 模式串相对于主串的起始位置（初始时与主串左对齐）</span></div><div class="line">        <span class="keyword">while</span> (text.length() - pattern.length() &gt;= i) &#123; <span class="comment">// 在到达最右端前，不断右移模式串</span></div><div class="line">            <span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; <span class="comment">// 从模式串最末尾的字符开始</span></div><div class="line">            <span class="keyword">while</span> (pattern.charAt(j) == text.charAt(i + j))</div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> &gt; --j) <span class="comment">// 自右向左比较</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span> (<span class="number">0</span> &gt; j) <span class="comment">// 若最大匹配后缀 == 整个模式串（说明已经完全匹配）</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                i += MAX(GS[j], j - BC[text.charAt(i + j)]);<span class="comment">// 在位移量BC和GS之间选择大者，相应地移动模式串</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 构造Bad Charactor Shift表BC[] - 坏字符表</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BuildBC(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span>[] BC = <span class="keyword">new</span> <span class="keyword">int</span>[CARD_CHAR_SET]; <span class="comment">// 初始化坏字符表</span></div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CARD_CHAR_SET; j++)</div><div class="line">            BC[j] = -<span class="number">1</span>; <span class="comment">// 首先假设该字符没有在P中出现</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pattern.length(); j++) <span class="comment">// 自左向右迭代：更新各字符的BC[]值</span></div><div class="line">            BC[pattern.charAt(j)] = j;</div><div class="line">        <span class="keyword">return</span> BC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 构造Good Suffix Shift表GS[] - 好后缀表</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BuildGS(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span> m = pattern.length();</div><div class="line">        <span class="keyword">int</span>[] SS = ComputeSuffixSize(pattern); <span class="comment">// 计算各字符对应的最长匹配后缀长度</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] GS = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">// Good Suffix Index</span></div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</div><div class="line">            GS[j] = m;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= -<span class="number">1</span>; j--)</div><div class="line">            <span class="keyword">if</span> (-<span class="number">1</span> == j || j + <span class="number">1</span> == SS[j]) <span class="comment">// 若定义SS[-1] = 0，则可统一为：if (j+1 == SS[j])</span></div><div class="line">                <span class="keyword">for</span> (; i &lt; m - j - <span class="number">1</span>; i++)</div><div class="line">                    <span class="keyword">if</span> (GS[i] == m)</div><div class="line">                        GS[i] = m - j - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++)</div><div class="line">            GS[m - SS[j] - <span class="number">1</span>] = m - j - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> GS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 计算P的各前缀与P的各后缀的最大匹配长度</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ComputeSuffixSize(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span> m = pattern.length();</div><div class="line">        <span class="keyword">int</span>[] SS = <span class="keyword">new</span> <span class="keyword">int</span>[m];<span class="comment">// Suffix Size Table</span></div><div class="line">        <span class="keyword">int</span> s, t; <span class="comment">// 子串P[s+1, ..., t]与后缀P[m+s-t, ..., m-1]匹配</span></div><div class="line">        <span class="keyword">int</span> j; <span class="comment">// 当前字符的位置</span></div><div class="line"></div><div class="line">        SS[m - <span class="number">1</span>] = m; <span class="comment">// 对最后一个字符而言，与之匹配的最长后缀就是整个P串</span></div><div class="line"></div><div class="line">        s = m - <span class="number">1</span>; <span class="comment">// 从倒数第二个字符起，自右向左扫描P，依次计算出SS[]其余各项</span></div><div class="line">        t = m - <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span> (j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> ((j &gt; s) &amp;&amp; (j - s &gt; SS[(m - <span class="number">1</span> - t) + j]))</div><div class="line">                SS[j] = SS[(m - <span class="number">1</span> - t) + j];</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                t = j; <span class="comment">// 与后缀匹配之子串的终点，就是当前字符</span></div><div class="line">                s = MIN(s, j); <span class="comment">// 与后缀匹配之子串的起点</span></div><div class="line">                <span class="keyword">while</span> ((<span class="number">0</span> &lt;= s) &amp;&amp; (pattern.charAt(s) == pattern.charAt((m - <span class="number">1</span> - t) + s)))</div><div class="line">                    s--;</div><div class="line">                SS[j] = t - s;<span class="comment">// 与后缀匹配之最长子串的长度</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> SS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (a &gt; b) ? a : b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (a &lt; b) ? a : b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String text = <span class="string">"HERE IS A SIMPLE EXAMPLE"</span>;</div><div class="line">        String pattern = <span class="string">"EXAMPLE"</span>;</div><div class="line">        System.out.println(<span class="string">"字符串匹配的位置为: "</span> + getMatchIndex(text, pattern));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h4><p>Sunday算法的思想和BM算法中的坏字符思想非常类似。差别只是在于Sunday算法在匹配失败之后，是取文本串中当前和模式串对应的部分后面一个位置的字符来做坏字符匹配。</p><p>Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。</p><ul><li>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；</li><li>否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。</li></ul><p>下面举个例子说明下Sunday算法。假定现在要在主串”substring searching”中查找模式串”search”。</p><ul><li><p>刚开始时，把模式串与文主串左边对齐：<br><img src="/images/algorithm/KMP-BM-Sunday-8.png" alt=""></p></li><li><p>结果发现在第2个字符处发现不匹配，不匹配时关注主串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：<br><img src="/images/algorithm/KMP-BM-Sunday-9.png" alt=""></p></li><li><p>结果第一个字符就不匹配，再看主串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（m - 3 = 6 - 3 = r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：<br><img src="/images/algorithm/KMP-BM-Sunday-10.png" alt=""></p></li><li><p>匹配成功<br> 和BM一样，Sunday也需要提前计算出一个表来获取移动的长度。</p></li></ul><p><strong>java实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> singleStrMatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sunday</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 统计pattern每个字符出现的位置 -1为没有出现在模式字符串中</div><div class="line">     * <span class="doctag">@since</span>: 1.0.0</div><div class="line">     * <span class="doctag">@param</span> pattern</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map <span class="title">calculateCharsTable</span><span class="params">(String pattern)</span> </span>&#123;</div><div class="line">        Map badTables = <span class="keyword">new</span> HashMap();</div><div class="line">        <span class="comment">// 从右到左遍历，也可以从左到右（0，plen-1)，只不过右边重复的字符会覆盖之前的index</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (!badTables.containsKey(pattern.charAt(j))) &#123;</div><div class="line">                <span class="comment">// 模式字符串最右边出现的位置</span></div><div class="line">                badTables.put(pattern.charAt(j), j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> badTables;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * sunday 算法</div><div class="line">     * <span class="doctag">@since</span>: 1.0.0</div><div class="line">     * <span class="doctag">@param</span> text</div><div class="line">     * <span class="doctag">@param</span> pattern</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sundaySerarch</span><span class="params">(String text, String pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.isEmpty() || pattern == <span class="keyword">null</span> || pattern.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> tlen = text.length();</div><div class="line">        <span class="keyword">int</span> plen = pattern.length();</div><div class="line">        <span class="keyword">if</span> (tlen &lt; plen) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxCount = tlen - plen;</div><div class="line">        Map badCharsTable = calculateCharsTable(pattern);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">while</span> (i &lt;= maxCount) &#123;</div><div class="line">            j = <span class="number">0</span>;</div><div class="line">            <span class="comment">//子串比较</span></div><div class="line">            <span class="keyword">while</span> ( j&lt; plen &amp;&amp; text.charAt(i + j) == pattern.charAt(j))&#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//全部匹配</span></div><div class="line">            <span class="keyword">if</span> (j == plen) &#123;</div><div class="line">                <span class="comment">//System.out.println(text + "=================&gt;found:" + pattern + ",i=" + i);</span></div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//有字符不匹配</span></div><div class="line">            i += plen;</div><div class="line">            <span class="keyword">if</span> (i &lt; tlen) &#123;</div><div class="line">                <span class="comment">// 从下一个字符（bad char）处查找出现的位置</span></div><div class="line">                Integer badCharFound = (Integer) badCharsTable.get(text.charAt(i));</div><div class="line">                <span class="keyword">if</span> (badCharFound == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 没有在模式串中找到</span></div><div class="line">                    badCharFound = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                i -= badCharFound;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// not found</span></div><div class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="comment">//System.out.println(text + "=================&gt;not found:" + pattern);</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String text = <span class="string">"HERE IS A SIMPLE EXAMPLE"</span>;</div><div class="line">        String pattern = <span class="string">"EXAMPLE"</span>;</div><div class="line">        System.out.println(<span class="string">"字符串匹配的位置为:"</span> + sundaySerarch(text,pattern));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>3种算法的效率和时间复杂度可参照此文：<a href="http://www.voidcn.com/blog/cy_cai/article/p-6305505.html" target="_blank" rel="external">http://www.voidcn.com/blog/cy_cai/article/p-6305505.html</a></p><ul><li>BM比KMP查找效率好2-6倍。</li><li>随着搜索字符增长，BM与KMP查找效率比差距越来越大。</li><li>Sunday比BM查找效率又稍微好点。</li><li>随着搜索字符增长，BM和Sunday效率越来越突出。</li></ul><p>参考：</p><ul><li><a href="http://blog.csdn.net/q547550831/article/details/51860017" target="_blank" rel="external">http://blog.csdn.net/q547550831/article/details/51860017</a></li><li><a href="http://www.youzhixu.com/reading/HgSWfRL#toc--0" target="_blank" rel="external">http://www.youzhixu.com/reading/HgSWfRL#toc--0</a></li><li><a href="http://blog.csdn.net/zdp072/article/details/13168605" target="_blank" rel="external">http://blog.csdn.net/zdp072/article/details/13168605</a></li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/字符串匹配/" rel="tag">#字符串匹配</a> <a href="/tags/BM/" rel="tag">#BM</a> <a href="/tags/KMP/" rel="tag">#KMP</a> <a href="/tags/Sunday/" rel="tag">#Sunday</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/11/09/programmer-self-culture-link-load-and-lib-notes/" rel="next" title="《程序员的自我修养-链接、装载与库》学习笔记"><i class="fa fa-chevron-left"></i> 《程序员的自我修养-链接、装载与库》学习笔记</a></div><div class="post-nav-prev post-nav-item"></div></div></footer></article><div class="post-spread"><div class="ds-share flat" data-thread-key="2016/11/13/single-string-match-KMP-BM-Sunday/" data-title="单字符串匹配算法--KMP、BM 和 Sunday" data-content="" data-url="http://vinoit.me/2016/11/13/single-string-match-KMP-BM-Sunday/"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li><li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div></div></div></div><div class="comments" id="comments"><div class="ds-thread" data-thread-key="2016/11/13/single-string-match-KMP-BM-Sunday/" data-title="单字符串匹配算法--KMP、BM 和 Sunday" data-url="http://vinoit.me/2016/11/13/single-string-match-KMP-BM-Sunday/"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Vino Zhu"><p class="site-author-name" itemprop="name">Vino Zhu</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">55</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">14</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">50</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/vinoZHU" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/vinozhu" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP"><span class="nav-number">2.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BM"><span class="nav-number">3.</span> <span class="nav-text">BM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sunday"><span class="nav-number">4.</span> <span class="nav-text">Sunday</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2016&nbsp;&nbsp;|&nbsp;&nbsp;</span><i class="fa fa-pencil"></i> <span class="author" itemprop="copyrightHolder">Vino Zhu&nbsp;&nbsp;|&nbsp;&nbsp;</span><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">var duoshuoQuery={short_name:"vinozly"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>