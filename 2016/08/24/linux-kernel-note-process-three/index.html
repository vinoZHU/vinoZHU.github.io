<!doctype html><html class="theme-next mist use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="fonts.useso.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Linux,内核,"><link rel="alternate" href="/atom.xml" title="是非之地" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。
硬件上下文尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。
进"><meta property="og:type" content="article"><meta property="og:title" content="linux内核笔记之进程（三）"><meta property="og:url" content="http://vinoit.me/2016/08/24/linux-kernel-note-process-three/index.html"><meta property="og:site_name" content="是非之地"><meta property="og:description" content="进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。
硬件上下文尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。
进"><meta property="og:image" content="http://vinoit.me/images/linux-kernel-note/process-three-0.png"><meta property="og:updated_time" content="2016-08-24T15:23:41.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="linux内核笔记之进程（三）"><meta name="twitter:description" content="进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。
硬件上下文尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。
进"><meta name="twitter:image" content="http://vinoit.me/images/linux-kernel-note/process-three-0.png"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0x5735d8da4b000400,author:"博主"}}</script><title> linux内核笔记之进程（三） | 是非之地</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?3f40b10d467e7138df85fd64143bc8bd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">是非之地</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Vino Zhu's Blog</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"> <a href="/" rel="section">首页</a></li><li class="menu-item menu-item-categories"> <a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-archives"> <a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"> <a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-about"> <a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-cnblogs"> <a href="http://www.cnblogs.com/vinozly/" rel="section">博客园</a></li><li class="menu-item menu-item-search"> <a href="javascript:;" class="popup-trigger">搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> linux内核笔记之进程（三）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-24T13:42:48+08:00" content="2016-08-24">2016-08-24</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-comments-count">&nbsp; | &nbsp;<a href="/2016/08/24/linux-kernel-note-process-three/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/08/24/linux-kernel-note-process-three/" itemprop="commentsCount"></span></a></span> &nbsp; | &nbsp;<span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。</p><h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。</p><p>进程恢复执行前必须装入寄存器的一组数据成为硬件上下文（hardware context）。硬件上下文是进程可执行上下文的一个自己，因为可执行上下文包含进程执行时所需要的所有信息。在Linux中，进程硬件上下午的一部分存放在<code>TSS段</code>，而剩余部分存放在<code>内核态堆栈</code>中。</p><p>在下面描述中，假定用prev局部变量表示切换出的进程描述符，next表示切换进的进程描述符,<code>这2个局部变量都存放在进程的内核堆栈中</code>。因此，我们把进程切换定义为这样的行为：保存prev硬件上下文，用next硬件上下文代替prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。</p><p>早期Linux版本利用80x86体系结构所需提供的硬件支持，并通过far jmp1指令跳到next进程TSS描述符的选择符来执行进程切换。当执行这条指令时，CPU通过自动保存原来的硬件上下文，装入新的硬件上下文来执行硬件上下文切换。但Linux2.6使用软件执行进程切换，原因有：</p><p>通过一组mov指令逐步执行切换，这样能较好地控制所装入的数据的合法性，一面被恶意用户伪造。far jmp指令不会有这样的检查。<br>旧方法和新方法所需时间大致相同。<br>进程切换值发生在<code>内核态</code>，在执行进程切换之前，用户态进程使用的所有寄存器内容已保存在内核堆栈上，这也包括ss和esp这对寄存器的内容。</p><h4 id="任务状态段"><a href="#任务状态段" class="headerlink" title="任务状态段"></a>任务状态段</h4><p>80x86体系结构包含了一个特殊的段类型，叫任务状态段（Task State Segment，TSS）来存放硬件上下文，尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS，这样做主要有两个理由：</p><p>当80x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址。<br>当用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存放在TSS中的I/O许可位图以检查该进程是否有访问端口的权利。<br>更确切的说，当进程在用户态执行in或out指令时，控制单元执行下列操作：</p><p>检查eflags寄存器中的2位IOPL字段，如果字段的值为3，控制单元就执行I/O指令。否则，执行下一个检查。<br>访问tr寄存器以确定当前的TSS和相应的I/O许可权位图。<br>检查I/O指令中指定的I/O端口在I/O许可权位图中对应的位，如果该位清，这条指令就执行，否则控制单元产生一个异常。<br>tss_struct结构描述TSS的格式，<code>init_tss数组</code>为系统上每个不同的CPU存放一个TSS。在每次进程切换时，内核都更新TSS的某些字段以便相应的CPU控制单元可以安全地检索到它需要的信息。因此，<code>TSS反映了CPU上当前进程的特权级，但不必为没有在运行的进程保留TSS</code>。</p><p>每个TSS有它自己8字节的任务状态段描述符（Task State Segment Descriptor，TSSD）。和其他描述符一样，这个描述符包括指向TSS起始地址的32位Base字段，20位Limit字段。TSSD的S标志位被清0，以表示相应的TSS是<code>系统段</code>的事实。</p><p>Type字段被置位11或9以表示这个段实际上是一个TSS。在Intel的原始设计中，<code>系统中的每个进程都应当指向自己的TSS</code>；Type字段的第二个有效位叫Busy位；如果进程正由CPU执行，则该位置1，否则为0。在Linux的设计中，<code>每个CPU只有一个TSS</code>，因此Busy位总是为1.</p><p>由Linux创建的TSSD存放在全局描述符表（GDT）中，GDT的基地址存放在每个CPU的gdtr寄存器中。<br><img src="/images/linux-kernel-note/process-three-0.png" alt=""><br>每个CPU的tr寄存器包含相应TSS的TSSD选择符，也包含了两个<code>隐藏的非编程字段</code>：TSSD的Base字段和Limit字段。这样，处理器就能够直接TSS寻址而不需要从GDT中检索TSS地址。</p><h4 id="thread字段"><a href="#thread字段" class="headerlink" title="thread字段"></a>thread字段</h4><p>在每次进程切换时，被替换的进程的硬件上下文必须保存在别处。不能像Intel原始设计那样保存在TSS中，因为<code>Linux为每个处理器而不是为每个进程使用TSS</code>。</p><p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后可以看到，这个数据结构包含的字段涉及大部分CPU寄存器，但不包括eax、ebx等等这些通用寄存器。它们的值保留在内核堆栈中。</p><h4 id="执行进程切换"><a href="#执行进程切换" class="headerlink" title="执行进程切换"></a>执行进程切换</h4><p>进程切换可能只发生在精心定义的点：schedule()函数，这个函数在专门整理进程调度的篇幅里讲解。这里，只关注内核如何执行一个进程切换。</p><p>进程切换由两步组成：</p><ul><li>切换页全局目录以安装一个新的地址空间。</li><li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</li></ul><p>第二步由<code>switch_to</code>宏来完成，源码如下:</p><p><a href="http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*</span></div><div class="line">  * Context switching is now performed out-of-line in switch_to.S</div><div class="line">  */</div><div class="line"> <span class="keyword">extern</span> <span class="keyword">struct</span> task_struct *<span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *,</div><div class="line">                                        <span class="keyword">struct</span> task_struct *);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev, next, last)                                      											                         \</span></div><div class="line">        do &#123;                                                            \</div><div class="line">                ((last) = __switch_to((prev), (next)));                 			                                                   \</div><div class="line">        &#125; while (0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ASM_GENERIC_SWITCH_TO_H */</span></span></div></pre></td></tr></table></figure><p>首先，该宏有三个参数，prev、next和last，prev和next的作用仅是<code>内核堆栈中</code>的局部变量prev和next的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。</p><p>在任何进程切换中，涉及到的是三个进程而不是两个。假设内核决定暂停进程A而激活进程B，在schedule()函数中，prev指向A的描述符，而next指向B的进程描述符。switch_to宏一旦使A暂停，A的执行流就被冻结。</p><p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。B的内核堆栈中的<code>prev</code>指向B的描述符，<code>next</code>指向other(下一个要调度的进程描述符，目前未知)。</strong></p><p>随后，当内核想再次激活A，就必须暂停另一个进程C，因为这通常不是B，因为B有可能被其他进程比如C切换。于是就要用prev指向C而next指向A来执行另一个switch_to宏。当A恢复它执行的流时，就会找到它原来的内核栈，于是prev局部变量还是指向A的描述符而next指向B的描述符。</p><p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。C的内核堆栈中的<code>prev</code>指向C的描述符，<code>next</code>指向A的描述符。</strong></p><p>所以，<code>代表进程A执行的内核就失去了对C的任何引用</code>。但引用对于完成进程切换是有用的，所以需要保留。</p><p>switch_to宏的最后一个参数是输出参数，它表示宏把进程C的描述符地址写在内存的什么位置了，不过，这个是在恢复A执行之后完成的。在进程切换之前，宏把第一个输入参数prev表示的变量存入CPU的eax寄存器。在完成进程切换，A已经恢复执行时，宏把CPU的eax寄存器的内容写入由第三个参数last所指示的A在内存中的位置。因为CPU寄存器不会在切换点发生变化，所以C的描述符地址也存在内存的这个位置。在schedule()执行过程中，last参数指向A的局部变量prev，所以prev被C的地址覆盖。</p><h4 id="switch-to-函数"><a href="#switch-to-函数" class="headerlink" title="__switch_to()函数"></a>__switch_to()函数</h4><p><strong>switch_to()函数执行大多数开始于switch_to()宏的进程切换。这个函数作用于prev_p和next_p参数，这两个参数表示前一个进程和新进程。这个函数的调用不同于一般的函数调用。因为</strong>switch_to()从eax和edx取参数prev_p和next_p，而不像大多数函数一样从栈中取参数。</p><p><a href="http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *prev_p, <span class="keyword">struct</span> task_struct *next_p)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> thread_struct *prev = &amp;prev_p-&gt;thread,</div><div class="line">                             *next = &amp;next_p-&gt;thread;</div><div class="line">        <span class="keyword">struct</span> fpu *prev_fpu = &amp;prev-&gt;fpu;</div><div class="line">        <span class="keyword">struct</span> fpu *next_fpu = &amp;next-&gt;fpu;</div><div class="line">        <span class="keyword">int</span> cpu = smp_processor_id();</div><div class="line">        <span class="keyword">struct</span> tss_struct *tss = &amp;per_cpu(cpu_tss, cpu);</div><div class="line">        <span class="keyword">fpu_switch_t</span> fpu_switch;</div><div class="line"></div><div class="line">        <span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></div><div class="line"></div><div class="line">        fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Save away %gs. No need to save %fs, as it was saved on the</div><div class="line">         * stack on entry.  No need to save %es and %ds, as those are</div><div class="line">         * always kernel segments while inside the kernel.  Doing this</div><div class="line">         * before setting the new TLS descriptors avoids the situation</div><div class="line">         * where we temporarily have non-reloadable segments in %fs</div><div class="line">         * and %gs.  This could be an issue if the NMI handler ever</div><div class="line">         * used %fs or %gs (it does not today), or if the kernel is</div><div class="line">         * running inside of a hypervisor layer.</div><div class="line">         */</div><div class="line">        lazy_save_gs(prev-&gt;gs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Load the per-thread Thread-Local Storage descriptor.</div><div class="line">         */</div><div class="line">        load_TLS(next, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore IOPL if needed.  In normal use, the flags restore</div><div class="line">         * in the switch assembly will handle this.  But if the kernel</div><div class="line">         * is running virtualized at a non-zero CPL, the popf will</div><div class="line">         * not restore flags, so it must be done in a separate step.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</div><div class="line">                set_iopl_mask(next-&gt;iopl);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Now maybe handle debug registers and/or IO bitmaps</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (unlikely(task_thread_info(prev_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_PREV ||</div><div class="line">                     task_thread_info(next_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_NEXT))</div><div class="line">                <span class="number">__</span>switch_to_xtra(prev_p, next_p, tss);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Leave lazy mode, flushing any hypercalls made here.</div><div class="line">         * This must be done before restoring TLS segments so</div><div class="line">         * the GDT and LDT are properly updated, and must be</div><div class="line">         * done before fpu__restore(), so the TS bit is up</div><div class="line">         * to date.</div><div class="line">         */</div><div class="line">        arch_end_context_switch(next_p);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Reload esp0 and cpu_current_top_of_stack.  This changes</div><div class="line">         * current_thread_info().</div><div class="line">         */</div><div class="line">        load_sp0(tss, next);</div><div class="line">        this_cpu_write(cpu_current_top_of_stack,</div><div class="line">                       (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task_stack_page(next_p) +</div><div class="line">                       THREAD_SIZE);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore %gs if needed (which is common)</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</div><div class="line">                lazy_load_gs(next-&gt;gs);</div><div class="line"></div><div class="line">        switch_fpu_finish(next_fpu, fpu_switch);</div><div class="line"></div><div class="line">        this_cpu_write(current_task, next_p);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> prev_p;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个函数执行步骤如下：</p><ul><li><p>执行由__unlay_fpu()宏代码产生的代码，以有选择地保存prev_p进程的FPU、MMX以及XMM寄存器的内容。</p></li><li><p>执行smp_processor_id()宏获得本地CPU的下标，即执行代码当前的CPU。该宏从当前进程的thread_info结构的cpu字段获得下标并保存到cpu局部变量。</p></li><li><p>把next_p-&gt;thread.esp0装入对应于本地CPU的TSS的esp0字段。其实，任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址拷贝到esp寄存器中。</p></li><li><p>把next_p进程使用的线程局部存储（TLS）段装载入本地CPU的全局描述符表。</p></li><li><p>把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中。esi寄存器指向prev_p-&gt;thread结构。</p></li><li><p>如果fs或gs段寄存器已经被prev_p或next_p进程中的任意一个使用，则将next_p进程的thread_struct描述符中保存的值装入这些寄存器。</p></li><li><p>用next_p-&gt;thread.debugreg数组内容装载dr0…dr7中的6个调试寄存器。只有在next_p被挂起时正在使用调试寄存器，这种操作才能进行。</p></li><li><p>如果必要，则更新TSS中的I/O位图。因为进程很少修改I/O权限位图，所以当且仅当一个进程在当前时间片内实际访问I/O端口时，真实的位图才被拷贝到本地CPU的TSS中。进程的定制I/O权限位图被保存在thread_info结构的io_bitmap_ptr字段指向的缓冲区中。当prev_p或者next_p拥有自己定制的I/O权限位图（io_bitmap_ptr不为null）时,TSS的io_bitmap字段被设为0x9000,否则为0x8000。</p></li><li><p>终止，prev_p参数被拷贝到eax，<code>因为缺省情况下任何C函数的返回值被传给eax寄存器</code>。所以eax的值在调用__switch_to()的过程中被保护起来；这很重要，因为调用该函数时会假定eax总是用来存放将被替换的进程描述符地址。</p></li><li><p>汇编语言指令ret把栈顶保存的返回地址装入eip程序计数器。不过，__swtich_to()函数时通过简单的跳转被调用的。因此，ret汇编指令在栈中找到标号为1的指令地址，其中标号为1的地址是由switch_to()宏推入堆栈的。</p></li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Linux/" rel="tag">#Linux</a> <a href="/tags/内核/" rel="tag">#内核</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/08/19/maven-common-command-and-operation/" rel="next" title="Maven常用命令和操作"><i class="fa fa-chevron-left"></i> Maven常用命令和操作</a></div><div class="post-nav-prev post-nav-item"> <a href="/2016/08/24/linux-x86-assembly-inline/" rel="prev" title="Linux中x86的内联汇编">Linux中x86的内联汇编<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="ds-share flat" data-thread-key="2016/08/24/linux-kernel-note-process-three/" data-title="linux内核笔记之进程（三）" data-content="" data-url="http://vinoit.me/2016/08/24/linux-kernel-note-process-three/"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li><li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div></div></div></div><div class="comments" id="comments"><div class="ds-thread" data-thread-key="2016/08/24/linux-kernel-note-process-three/" data-title="linux内核笔记之进程（三）" data-url="http://vinoit.me/2016/08/24/linux-kernel-note-process-three/"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Vino Zhu"><p class="site-author-name" itemprop="name">Vino Zhu</p><p class="site-description motion-element" itemprop="description">more than programmer and less than geek</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">48</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">29</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/vinoZHU" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/vinozhu" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程切换"><span class="nav-number">1.</span> <span class="nav-text">进程切换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件上下文"><span class="nav-number">1.1.</span> <span class="nav-text">硬件上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务状态段"><span class="nav-number">1.2.</span> <span class="nav-text">任务状态段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#thread字段"><span class="nav-number">1.3.</span> <span class="nav-text">thread字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行进程切换"><span class="nav-number">1.4.</span> <span class="nav-text">执行进程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch-to-函数"><span class="nav-number">1.5.</span> <span class="nav-text">__switch_to()函数</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2016</span><span class="with-love"><i class="fa fa-pencil"></i></span> <span class="author" itemprop="copyrightHolder">Vino Zhu</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">var duoshuoQuery={short_name:"vinozly"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>