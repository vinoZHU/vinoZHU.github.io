<!doctype html><html class="theme-next mist use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="fonts.useso.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="理解计算机,Linux,"><link rel="alternate" href="/atom.xml" title="是非之地" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。
ptrace()系统调用Linux下的调试器实现的主要组成部分就是ptrace(),这是一个功能众多且相当复杂的工具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。其中这2个进程是父子进程的关系，调试的进程是父进程，被"><meta property="og:type" content="article"><meta property="og:title" content="调试器基本工作原理"><meta property="og:url" content="http://vinoit.me/2016/08/12/how-debugger-work/index.html"><meta property="og:site_name" content="是非之地"><meta property="og:description" content="在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。
ptrace()系统调用Linux下的调试器实现的主要组成部分就是ptrace(),这是一个功能众多且相当复杂的工具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。其中这2个进程是父子进程的关系，调试的进程是父进程，被"><meta property="og:updated_time" content="2016-08-18T14:17:16.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="调试器基本工作原理"><meta name="twitter:description" content="在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。
ptrace()系统调用Linux下的调试器实现的主要组成部分就是ptrace(),这是一个功能众多且相当复杂的工具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。其中这2个进程是父子进程的关系，调试的进程是父进程，被"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0x5735d8da4b000400,author:"博主"}}</script><title> 调试器基本工作原理 | 是非之地</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?3f40b10d467e7138df85fd64143bc8bd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">是非之地</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Vino Zhu's Blog</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"> <a href="/" rel="section">首页</a></li><li class="menu-item menu-item-categories"> <a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-archives"> <a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"> <a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-about"> <a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-cnblogs"> <a href="http://www.cnblogs.com/vinozly/" rel="section">博客园</a></li><li class="menu-item menu-item-search"> <a href="javascript:;" class="popup-trigger">搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> 调试器基本工作原理</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-08-12T16:34:29+08:00" content="2016-08-12">2016-08-12</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/理解计算机/" itemprop="url" rel="index"><span itemprop="name">理解计算机</span></a></span></span> <span class="post-comments-count">&nbsp; | &nbsp;<a href="/2016/08/12/how-debugger-work/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/08/12/how-debugger-work/" itemprop="commentsCount"></span></a></span> &nbsp; | &nbsp;<span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。</p><h4 id="ptrace-系统调用"><a href="#ptrace-系统调用" class="headerlink" title="ptrace()系统调用"></a>ptrace()系统调用</h4><p>Linux下的调试器实现的主要组成部分就是<code>ptrace()</code>,这是一个功能众多且相当复杂的工具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。其中这2个进程是父子进程的关系，调试的进程是父进程，被调试的则是子进程。</p><p>OS X下<code>ptrace()</code>的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">int</span> request, <span class="keyword">pid_t</span> pid, <span class="keyword">caddr_t</span> addr, <span class="keyword">int</span> data)</span></span>;</div></pre></td></tr></table></figure><p>其中man手册如此描述参数：</p><p><code>The request argument specifies what operation is being performed; the meaning of the rest of the arguments depends on the operation, but except for one special case noted below, all ptrace() calls are made by the tracing process, and the pid argument specifies the process ID of the traced process.</code></p><p>也就是说<code>request</code>参数表示操作的类型，其他3个参数在不同的操作下意义可能不同，<code>pid</code>永远指向<strong>被调试</strong>的进程。<br><code>request</code>可以有以下值：</p><ul><li>PT_TRACE_ME</li><li>PT_DENY_ATTACH</li><li>PT_CONTINUE</li><li>PT_STEP</li><li>PT_KILL</li><li>PT_ATTACH</li><li>PT_ATTACHEXC</li><li>PT_DETACH</li></ul><p>某些值由父进程使用，某些则由子进程使用，比如<code>PT_TRACE_ME</code>由子进程调用，从命名上也可以看出来(追踪我)。其中的具体含义可以查看man手册，此处就不多解释了。</p><h4 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h4><p>从高层设计来说，我们要写一个程序，它产生一个子进程用来执行一个用户指定的命令，而父进程跟踪这个子进程。首先，main函数是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> child_pid;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Expected a program name as argument\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    child_pid = fork();</div><div class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</div><div class="line">        run_target(argv[<span class="number">1</span>]);<span class="comment">//子进程执行需要被追踪的指令</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</div><div class="line">        run_debugger(child_pid);<span class="comment">//父进程追踪子进程</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        perror(<span class="string">"fork"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中<code>run_target(char arg)</code>函数的核心内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ptrace(PT_TRACE_ME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">execl(arg, arg, <span class="number">0</span>);</div></pre></td></tr></table></figure><p>首先执行ptrace系统调用，request值为PT_TRACE_ME，表明进程期待被父进程追踪，这时候一旦调用了<code>execl()</code>,进程被停止运行，然后接收到一个SIGTRAP信号，并等待父进程的操作。</p><p>父进程<code>run_debugger()</code>函数的核心内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wait(&amp;wait_status);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (WIFSTOPPED(wait_status)) &#123;</div><div class="line">        <span class="comment">/* Make the child execute another instruction */</span></div><div class="line">        <span class="keyword">if</span> (ptrace(PT_STEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">            perror(<span class="string">"ptrace"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></div><div class="line">        wait(&amp;wait_status);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>循环外面的<code>wait()</code>调用阻塞父进程，直到有子进程停止运行。此时执行while循环的内容，如果子进程由于发送的信号而停止运行，WIFSTOPPED就返回true。循环内的代码就做了2件事，首先调用<code>ptrace()</code>,request值为PT_STEP，使得pid为child_pid的进程单步执行下一条指令。然后再次调用<code>wait()</code>,阻塞等待子进程停止。依次循环，直到子进程结束。</p><h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>在调试的时候我们可以在期望的地方打上断点，程序运行到断点处自动停止运行。这在Linux中是通过中断机制来实现的，将断点处的指令用<code>int 3</code>来替代，int指令可以产生一个中断，后面的数字是中断号，每个中断号都对应一个处理例程，3号例程专门用来处理调试时的断点。</p><p>要在被调试进程中的某个目标地址上设定一个断点，调试器需要做下面两件事情：</p><ol><li><p>保存目标地址上的数据</p></li><li><p>将目标地址上的第一个字节替换为int 3指令</p></li></ol><p>然后，当调试器向操作系统请求开始运行进程时，进程最终一定会碰到int 3指令。此时进程停止，操作系统将发送一个信号。这时就是调试器(父进程)再次出马的时候了，接收到一个其子进程（或被跟踪进程）停止的信号，然后调试器要做下面几件事：</p><ol><li><p>在目标地址上用原来的指令替换掉int 3</p></li><li><p>将被跟踪进程中的指令指针向后递减1。这么做是必须的，因为现在指令指针指向的是已经执行过的int 3之后的下一条指令。</p></li><li><p>由于进程此时仍然是停止的，用户可以同被调试进程进行某种形式的交互。这里调试器可以让你查看变量的值，检查调用栈等等。</p></li><li><p>当用户希望进程继续运行时，调试器负责将断点再次加到目标地址上（由于在第一步中断点已经被移除了），除非用户希望取消断点。</p></li></ol><h4 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h4><p>当你在某些函数的入口处设置断点时，调试器如何知道该在哪里停止目标进程的运行呢？当你希望查看一个变量的值时，调试器又是如何找到它并展示给你呢？答案就是——调试信息。</p><p><strong>调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码<code>一起存储</code>。</strong>许多年以来，针对不同的平台和可执行文件，人们发明了许多这样的编码格式。其中一种最重要的格式就是DWARF，作为Linux以及其他类Unix平台上的ELF可执行文件的调试信息格式，如今的DWARF可以说是无处不在。</p><p>通过下面的C代码构建一个名为traceprog2的可执行文件来做下实验:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">int</span> my_arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> my_local = my_arg + <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; my_local; ++i)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    do_stuff(<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过objdump –h导出ELF可执行文件中的段头信息，我们注意到其中有几个段的名字是以.debug_打头的，这些就是DWARF格式的调试段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">26</span> .debug_aranges <span class="number">00000020</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001037</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">27</span> .debug_pubnames <span class="number">00000028</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001057</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">28</span> .debug_info   <span class="number">000000</span>cc  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">0000107f</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">29</span> .debug_abbrev <span class="number">0000008</span>a  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">0000114b</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">30</span> .debug_line   <span class="number">0000006b</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">000011</span>d5</div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">31</span> .debug_frame  <span class="number">00000044</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001240</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">32</span> .debug_str    <span class="number">000000</span>ae  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001284</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">33</span> .debug_loc    <span class="number">00000058</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001332</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div></pre></td></tr></table></figure><p>每行的第一个数字表示每个段的大小，而最后一个数字表示距离ELF文件开始处的偏移量。调试器就是利用这个信息来从可执行文件中读取相关的段信息，从而找到可执行程序和源代码之间的关系。</p><blockquote> <font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/理解计算机/" rel="tag">#理解计算机</a> <a href="/tags/Linux/" rel="tag">#Linux</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/07/05/java-ordernum-generate/" rel="next" title="java实现的订单号生成工具类"><i class="fa fa-chevron-left"></i> java实现的订单号生成工具类</a></div><div class="post-nav-prev post-nav-item"> <a href="/2016/08/13/java-memeory-model-sequential-consistency/" rel="prev" title="深入理解Java内存模型（三）——顺序一致性">深入理解Java内存模型（三）——顺序一致性<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="ds-share flat" data-thread-key="2016/08/12/how-debugger-work/" data-title="调试器基本工作原理" data-content="" data-url="http://vinoit.me/2016/08/12/how-debugger-work/"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li><li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div></div></div></div><p>热评文章</p><div class="ds-top-threads" data-range="weekly" data-num-items="4"></div><div class="comments" id="comments"><div class="ds-thread" data-thread-key="2016/08/12/how-debugger-work/" data-title="调试器基本工作原理" data-url="http://vinoit.me/2016/08/12/how-debugger-work/"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Vino Zhu"><p class="site-author-name" itemprop="name">Vino Zhu</p><p class="site-description motion-element" itemprop="description">more than programmer and less than geek</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">42</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">23</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/vinoZHU" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/vinozhu" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#ptrace-系统调用"><span class="nav-number">1.</span> <span class="nav-text">ptrace()系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单步调试"><span class="nav-number">2.</span> <span class="nav-text">单步调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#断点"><span class="nav-number">3.</span> <span class="nav-text">断点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试信息"><span class="nav-number">4.</span> <span class="nav-text">调试信息</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2016</span><span class="with-love"><i class="fa fa-pencil"></i></span> <span class="author" itemprop="copyrightHolder">Vino Zhu</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">var duoshuoQuery={short_name:"vinozly"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>