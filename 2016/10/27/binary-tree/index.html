<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="fonts.useso.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="数据结构,二叉树,"><link rel="alternate" href="/atom.xml" title="下定青年的个人博客" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="常见基本概念
节点的度：某节点的度定义为该节点孩子节点的个数。
叶子节点：度为0 的结点称为叶结点，或者称为终端结点。
树的度：树中各结点度的最大值。
节点的高度：从该节点起到叶子节点的最长简单路径的边数。(简单路径：无重复边的路径)
树的高度：根节点的高度。
节点的层数：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1。
节点的深度：即该节点的层数。
树的层数：树中所有节点的最"><meta property="og:type" content="article"><meta property="og:title" content="二叉树基础以及常用操作"><meta property="og:url" content="http://vinoit.me/2016/10/27/binary-tree/index.html"><meta property="og:site_name" content="下定青年的个人博客"><meta property="og:description" content="常见基本概念
节点的度：某节点的度定义为该节点孩子节点的个数。
叶子节点：度为0 的结点称为叶结点，或者称为终端结点。
树的度：树中各结点度的最大值。
节点的高度：从该节点起到叶子节点的最长简单路径的边数。(简单路径：无重复边的路径)
树的高度：根节点的高度。
节点的层数：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1。
节点的深度：即该节点的层数。
树的层数：树中所有节点的最"><meta property="og:image" content="http://vinoit.me/images/data-structure/binary-tree-0.png"><meta property="og:image" content="http://vinoit.me/images/data-structure/binary-tree-1.png"><meta property="og:updated_time" content="2016-11-02T01:12:28.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="二叉树基础以及常用操作"><meta name="twitter:description" content="常见基本概念
节点的度：某节点的度定义为该节点孩子节点的个数。
叶子节点：度为0 的结点称为叶结点，或者称为终端结点。
树的度：树中各结点度的最大值。
节点的高度：从该节点起到叶子节点的最长简单路径的边数。(简单路径：无重复边的路径)
树的高度：根节点的高度。
节点的层数：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1。
节点的深度：即该节点的层数。
树的层数：树中所有节点的最"><meta name="twitter:image" content="http://vinoit.me/images/data-structure/binary-tree-0.png"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0x5735d8da4b000400,author:"博主"}}</script><title> 二叉树基础以及常用操作 | 下定青年的个人博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div style="display:none"><script src="//s6.cnzz.com/stat.php?id=1259121680&web_id=1259121680" type="text/javascript"></script></div><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">下定青年的个人博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">VinoZhu's Blog</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"> <a href="/" rel="section">首页</a></li><li class="menu-item menu-item-categories"> <a href="/categories" rel="section">分类</a></li><li class="menu-item menu-item-archives"> <a href="/archives" rel="section">归档</a></li><li class="menu-item menu-item-tags"> <a href="/tags" rel="section">标签</a></li><li class="menu-item menu-item-about"> <a href="/about" rel="section">关于</a></li><li class="menu-item menu-item-search"> <a href="javascript:;" class="popup-trigger">搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> 二叉树基础以及常用操作</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-10-27T13:47:14+08:00" content="2016-10-27">2016-10-27</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span></span> <span class="post-comments-count">&nbsp; | &nbsp;<a href="/2016/10/27/binary-tree/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/10/27/binary-tree/" itemprop="commentsCount"></span></a></span> &nbsp; | &nbsp;<span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="常见基本概念"><a href="#常见基本概念" class="headerlink" title="常见基本概念"></a>常见基本概念</h4><ul><li>节点的度：某节点的度定义为该节点孩子节点的个数。</li><li>叶子节点：度为0 的结点称为叶结点，或者称为终端结点。</li><li>树的度：树中各结点度的最大值。</li><li>节点的高度：从该节点起到叶子节点的最长简单路径的边数。(简单路径：无重复边的路径)</li><li>树的高度：根节点的高度。</li><li>节点的层数：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1。</li><li>节点的深度：即该节点的层数。</li><li>树的层数：树中所有节点的最大层数。</li><li>树的深度：树中所有结点的最大层数。</li><li>外节点：叶子节点。</li><li>内节点：除叶子节点之外的节点。</li><li>满二叉树：所有终端都在同一层次，且非终端结点的度数为2。在满二叉树中若其深度为k，则其所包含的结点数必为2^k-1。</li><li>完全二叉树：除最后一层，每一层的节点数都达到最大。最后一层若是没满，则节点集中在左边，空的只能是右边。对于完全二叉树，设一个结点为i则其父节点为i/2，2i为左子节点，2i+1为右子节点。</li><li>扩充二叉树：对二叉树中度为1的节点和叶子节点添加空节点，使之成为满二叉树。<br>二叉树的每个结点最多有两棵子树，左子树和右子树，次序不可以颠倒。</li></ul><p>与树不同，树的节点个数至少为1，而二叉树的节点个数可以为0；树中节点的最大度数没有限制，而二叉树节点的最大度数为2；树的节点无左、右之分，而二叉树的节点有左、右之分。</p><p>注：关于树深度、层数、高度的定义会有不同的说法：有从0开始计数的，也有从1开始计数的。从哪儿开始计数不是关键，关键在于一致性，量的写法要一致。</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><h5 id="顺序存储表示"><a href="#顺序存储表示" class="headerlink" title="顺序存储表示"></a>顺序存储表示</h5><p>二叉树可以用数组或链接串列来存储，而且如果这是满二叉树，这种方法不会浪费空间。用这种紧凑排列，如果一个节点的索引为i，它的子节点能在索引2i+1和2i+2找到，并且它的父节点（如果有）能在索引floor((i-1)/2)找到（假设根节点的索引为0）。这种方法更有利于紧凑存储和更好的访问的局部性，特别是在[前序遍历]中。然而，它需要连续的存储空间，这样在存储高度为h的n个结点组成的一般普通树时将会浪费很多空间。一种最极坏的情况下如果深度为h的二叉树每个节点只有右孩子需要占用2的h次幂减1，而实际却只有h个结点，空间的浪费太大，这是顺序存储结构的一大缺点。</p><p><img src="/images/data-structure/binary-tree-0.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大节点数 */</span></span></div><div class="line"> <span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE]; <span class="comment">/* 顺序存储的数组 */</span></div><div class="line"></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line"> &#123;</div><div class="line">   <span class="keyword">int</span> level,order; <span class="comment">/* 节点所在层以及在该层的序号 */</span></div><div class="line"> &#125;position;</div></pre></td></tr></table></figure><h5 id="二叉链表存储表示"><a href="#二叉链表存储表示" class="headerlink" title="二叉链表存储表示"></a>二叉链表存储表示</h5><p>在使用记录或内存地址指针的程序设计语言中，二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 二叉树的二叉链表存储表示 */</span></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> BiTNode</div><div class="line"> &#123;</div><div class="line">   TElemType data;</div><div class="line">   <span class="keyword">struct</span> BiTNode *lchild,*rchild; <span class="comment">/* 左右孩子指針 */</span></div><div class="line"> &#125;BiTNode,*BiTree;</div></pre></td></tr></table></figure><h5 id="三叉链表存储表示"><a href="#三叉链表存储表示" class="headerlink" title="三叉链表存储表示"></a>三叉链表存储表示</h5><p>改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。 当二叉树用三叉链表表示时，有N个结点，就会有N+2个空指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 二叉树的三叉链表存储表示 */</span></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> BiTPNode</div><div class="line"> &#123;</div><div class="line">   TElemType data;</div><div class="line">   <span class="keyword">struct</span> BiTPNode *parent,*lchild,*rchild; <span class="comment">/* 父、左右孩子指針 */</span></div><div class="line"> &#125;BiTPNode,*BiPTree;</div></pre></td></tr></table></figure><h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><p>本文使用二叉树的二叉链表存储表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> dataType;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> treeNode&#123;</div><div class="line">    dataType val;</div><div class="line">    <span class="keyword">struct</span> treeNode * leftChild;</div><div class="line">    <span class="keyword">struct</span> treeNode * rightChild;</div><div class="line">    <span class="keyword">int</span> visit = <span class="number">0</span>;<span class="comment">//后序遍历时使用</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeNode * treeNodeP;</div></pre></td></tr></table></figure><p>创建如下这样一颗二叉树：<br><img src="/images/data-structure/binary-tree-1.png" alt=""></p><h5 id="括号表示法创建"><a href="#括号表示法创建" class="headerlink" title="括号表示法创建"></a>括号表示法创建</h5><p>对应的括号表示法为：<code>A(B(D(H),E(I,J)),C(F,G))</code>,括号表示法中，对应<code>()</code>中的内容为<code>(</code>前节点的孩子，<code>()</code>中的<code>,</code>用于分隔左右孩子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(treeNodeP &amp;root,<span class="keyword">char</span>* str)</span></span>&#123;</div><div class="line">    root = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;<span class="comment">//字符串遍历时的当前位置</span></div><div class="line">    <span class="keyword">char</span> ch = str[pos];</div><div class="line">    treeNodeP node = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> type= <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)&#123;</div><div class="line">        <span class="keyword">switch</span> (ch) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'('</span>:<span class="comment">//遇到'('时，表示下一个节点是上一个节点的左孩子。</span></div><div class="line">                push(&amp;<span class="built_in">stack</span>, node);<span class="comment">//此时node保存着上一个节点，将上一个节点入栈。</span></div><div class="line">                ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">                type = <span class="number">1</span>;<span class="comment">//表示下一个元素是左孩子</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">','</span>:</div><div class="line">                type = <span class="number">2</span>;<span class="comment">//表示下一个孩子是右孩子</span></div><div class="line">                ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">')'</span>:<span class="comment">//遇到`)`时，表示栈顶元素的孩子输入完毕了，可以将栈顶节点出栈了。</span></div><div class="line">                pop(&amp;<span class="built_in">stack</span>);<span class="comment">//栈顶节点出栈</span></div><div class="line">                ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:<span class="comment">//表示遇到的是节点的内容值</span></div><div class="line">                node = <span class="keyword">new</span> treeNode();<span class="comment">//新建节点并初始化</span></div><div class="line">                node-&gt;val = ch;</div><div class="line">                node-&gt;leftChild = <span class="literal">NULL</span>;</div><div class="line">                node-&gt;rightChild = <span class="literal">NULL</span>;</div><div class="line">                <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//如果root节点为NULL,则当前输入的节点为根节点</span></div><div class="line">                    root = node;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>)&#123;<span class="comment">//栈不为空</span></div><div class="line">                    treeNodeP t = top(&amp;<span class="built_in">stack</span>);<span class="comment">//获取栈顶节点（不弹出）</span></div><div class="line">                    <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</div><div class="line">                        t-&gt;leftChild = node;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</div><div class="line">                        t-&gt;rightChild = node;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ch = str[++pos];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="按前序遍历输入"><a href="#按前序遍历输入" class="headerlink" title="按前序遍历输入"></a>按前序遍历输入</h5><p>表示为：<code>ABDH###EI##J##CF##G##</code>，此表示法按照<code>前序遍历</code>的顺序输入，<code>#</code>表示<code>NULL</code>。</p><p>核心思想：如果字符连续的出现，则下一个字符为上一个字符的左孩子，在<code>#</code>出现之前，所有的字符按照顺序都入栈。如果字符在<code>#</code>后第一次出现，则必为栈顶节点的右节点。当出现第一个<code>#</code>时，说明上一个字符为当前分支的最左节点，上一个字符的左孩子赋值NULL。连续出现第二个<code>#</code>时，说第一个<code>#</code>前的字符的右孩子也赋值NULL。当一个节点的右孩子赋值完成时，便可以从栈中弹出了。如果连续出现2个以上的<code>#</code>,则栈顶的节点的右孩子依次置NULL，并弹出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createByPreorder</span><span class="params">(treeNodeP &amp;root, <span class="keyword">char</span>* str)</span></span>&#123;</div><div class="line">    root = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> ch = str[pos];</div><div class="line">    treeNodeP node = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录`#`连续出现的记录</span></div><div class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(ch != <span class="string">'#'</span>)&#123;</div><div class="line">            count = <span class="number">0</span>;<span class="comment">//一旦`#`终止连续出现，count赋0</span></div><div class="line">            node = <span class="keyword">new</span> treeNode();<span class="comment">//新建节点并初始化</span></div><div class="line">            node-&gt;val = ch;</div><div class="line">            node-&gt;leftChild = <span class="literal">NULL</span>;</div><div class="line">            node-&gt;rightChild = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//如果root节点为NULL,则当前输入的节点为根节</span></div><div class="line">                root = node;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>((&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>)&#123;<span class="comment">//栈不为空</span></div><div class="line">            <span class="comment">//遇见一个字符，既然栈中存在节点，则不为左节点便为右节点</span></div><div class="line">                <span class="keyword">if</span>(top(&amp;<span class="built_in">stack</span>)-&gt;leftChild)&#123;</div><div class="line">                    pop(&amp;<span class="built_in">stack</span>)-&gt;rightChild = node;<span class="comment">//如果是右节点，则赋值完整后便可以将节点弹出栈</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    top(&amp;<span class="built_in">stack</span>)-&gt;leftChild = node;</div><div class="line">                &#125;   </div><div class="line">            &#125;        </div><div class="line">            push(&amp;<span class="built_in">stack</span>, node);<span class="comment">//节点入栈</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            count++;</div><div class="line">            <span class="keyword">if</span>((&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;<span class="comment">//`#`第一次出现时，必然是栈顶节点的左孩子</span></div><div class="line">                    top(&amp;<span class="built_in">stack</span>)-&gt;leftChild = <span class="literal">NULL</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(count == <span class="number">2</span>)&#123;<span class="comment">//`#`第二次连续出现时，必然是栈顶节点的右孩子</span></div><div class="line">                    pop(&amp;<span class="built_in">stack</span>)-&gt;rightChild = <span class="literal">NULL</span>;<span class="comment">//此时栈顶节点已完成左右孩子的赋值，可以弹出。</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(count &gt; <span class="number">2</span>)&#123;<span class="comment">//将栈中的元素弹出并将右孩子置NULL</span></div><div class="line">                    pop(&amp;<span class="built_in">stack</span>)-&gt;rightChild = <span class="literal">NULL</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="非递归的前序遍历"><a href="#非递归的前序遍历" class="headerlink" title="非递归的前序遍历"></a>非递归的前序遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="comment">//只有栈空（所有节点的右孩子都已开始访问或已访问完成）或者</span></div><div class="line">    <span class="comment">//节点为NULL（栈空时，当访问到最右孩子时tmp为NULL）遍历才算完成</span></div><div class="line">    <span class="keyword">while</span> (tmp || (&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(tmp)&#123;<span class="comment">//此循环的目的是遍历到当前分支的最左节点，将遍历的节点依次输出并入栈。</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);<span class="comment">//栈中的所有节点的右孩子都没有开始访问</span></div><div class="line">            tmp = tmp-&gt;leftChild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//上面的循环结束表示当前分支的所有左孩子都入栈了，此时弹出最后一个左孩子节点。</span></div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        tmp = tmp-&gt;rightChild;<span class="comment">//这里考虑的逻辑就是右孩子是否为NULL，</span></div><div class="line">        <span class="comment">//若为NULL，则弹出栈顶节点，弹出节点为此节点的父节点，此节点后的内容遍历完成，开始父节点的右孩子的前序遍历。</span></div><div class="line">        <span class="comment">//若不为NULL，开始上面的循环，遍历到此节点右孩子分支的最左节点。</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果为：<code>ABDHEIJCFG</code>。</p><h4 id="非递归的中序遍历"><a href="#非递归的中序遍历" class="headerlink" title="非递归的中序遍历"></a>非递归的中序遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="keyword">while</span> (tmp || (&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(tmp)&#123;</div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);</div><div class="line">            tmp = tmp-&gt;leftChild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//来到当前分支的最左，弹出最左节点，输出。</span></div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">        tmp = tmp-&gt;rightChild;<span class="comment">//这里考虑的逻辑就是右孩子是否为NULL，</span></div><div class="line">        <span class="comment">//若为NULL，则弹出栈顶节点，弹出节点为此节点的父节点，并输出，此节点后的内容遍历完成，开始父节点的右孩子的遍历。</span></div><div class="line">        <span class="comment">//若不为NULL，则再次上面的循环，开始当前节点右孩子的遍历。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与前序遍历唯一的不同就是输出字符的位置变了。前序遍历先是父节点，而中序遍历则是左孩子先。两个输出位置可以细细体味一下。</p><p>输出结果为：<code>HDBIEJAFCG</code>。</p><h4 id="非递归的后序遍历"><a href="#非递归的后序遍历" class="headerlink" title="非递归的后序遍历"></a>非递归的后序遍历</h4><p>考虑到后序遍历时父节点需要被回溯2次，所以用一个int型的visit变量加以区分，初始值为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="keyword">while</span> (tmp || (&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(tmp)&#123;</div><div class="line">            <span class="keyword">if</span>(tmp-&gt;visit == <span class="number">1</span>)&#123;<span class="comment">//入栈次数为1，表示还未访问过右孩子，需要先访问右孩子，此节点入栈，入栈次数+1，同时切换到右孩子分支。</span></div><div class="line">                push(&amp;<span class="built_in">stack</span>, tmp);</div><div class="line">                tmp-&gt;visit++;</div><div class="line">                tmp = tmp-&gt;rightChild;</div><div class="line">                <span class="keyword">goto</span> right;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp-&gt;visit == <span class="number">2</span>)&#123;<span class="comment">//入栈次数为2，表示右孩子以访问完成，可以输出。输出完毕后从栈中取下一个访问节点，也就是此节点的父节点，开始内循环。</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">                tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">                <span class="keyword">goto</span> right;</div><div class="line">            &#125;</div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);</div><div class="line">            tmp-&gt;visit = <span class="number">1</span>;<span class="comment">//第一次入栈</span></div><div class="line">            tmp = tmp-&gt;leftChild;</div><div class="line">        &#125;</div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;rightChild)&#123;<span class="comment">//如果最左节点有右孩子，因为后序遍历时右孩子前于父节点，所以右孩子入栈。</span></div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);<span class="comment">//此节点需再次入栈</span></div><div class="line">            tmp-&gt;visit++;<span class="comment">//入栈次数+1</span></div><div class="line">            tmp = tmp-&gt;rightChild;<span class="comment">//切换到右孩子</span></div><div class="line">            <span class="keyword">continue</span>;<span class="comment">//继续内循环，遍历到右孩子的最左节点</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//节点无右孩子，则可以输出。</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        </div><div class="line">    right:;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为visit一开始都为0，所以内循环中直接遍历到最左节点，并将节点依次入栈。</p><p>输出结果为：<code>HDIJEBFGCA</code>。</p><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>层次遍历的思想即使将当前节点的孩子依次从左到右入队列，此节点访问后便从队列中取下一个节点。重复以上过程。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeQueue <span class="built_in">queue</span>;</div><div class="line">    (&amp;<span class="built_in">queue</span>)-&gt;front = <span class="number">-1</span>;</div><div class="line">    (&amp;<span class="built_in">queue</span>)-&gt;rear = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="keyword">while</span>(tmp)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;leftChild)&#123;</div><div class="line">            enterNode(&amp;<span class="built_in">queue</span>, tmp-&gt;leftChild);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;rightChild)&#123;</div><div class="line">            enterNode(&amp;<span class="built_in">queue</span>, tmp-&gt;rightChild);</div><div class="line">        &#125;</div><div class="line">        tmp = getNode(&amp;<span class="built_in">queue</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>输出结果为：<code>ABCDEFGHIJ</code>。</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">treeNodeP <span class="title">findNode</span><span class="params">(treeNodeP root,<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root-&gt;val == ch)&#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        treeNodeP node = findNode(root-&gt;leftChild, ch);</div><div class="line">        <span class="keyword">if</span>(node)&#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            node = findNode(root-&gt;rightChild, ch);</div><div class="line">            <span class="keyword">if</span>(node)&#123;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="求高度"><a href="#求高度" class="headerlink" title="求高度"></a>求高度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHigh</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> h1 = getHigh(root-&gt;leftChild);</div><div class="line">    <span class="keyword">int</span> h2 = getHigh(root-&gt;rightChild);</div><div class="line">    <span class="keyword">return</span> h1 &gt; h2 ? h1 + <span class="number">1</span> : h2 +<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="所使用的栈、队列数据结构"><a href="#所使用的栈、队列数据结构" class="headerlink" title="所使用的栈、队列数据结构"></a>所使用的栈、队列数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> treeStack&#123;</div><div class="line">    treeNodeP node[SIZE];</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeStack * treeStackP;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(treeStackP <span class="built_in">stack</span>, treeNodeP node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top &lt; SIZE - <span class="number">1</span>)&#123;</div><div class="line">        <span class="built_in">stack</span>-&gt;node[++<span class="built_in">stack</span>-&gt;top] = node;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the stack is full!\n"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">treeNodeP <span class="title">pop</span><span class="params">(treeStackP <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top &gt; <span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;node[<span class="built_in">stack</span>-&gt;top--];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">treeNodeP <span class="title">top</span><span class="params">(treeStackP <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top &gt; <span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;node[<span class="built_in">stack</span>-&gt;top];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> treeQueue &#123;</div><div class="line">    treeNodeP node[SIZE];</div><div class="line">    <span class="keyword">int</span> front;</div><div class="line">    <span class="keyword">int</span> rear;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeQueue * treeQueueP;</div><div class="line"></div><div class="line"><span class="function">treeNodeP <span class="title">getNode</span><span class="params">(treeQueueP <span class="built_in">queue</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % SIZE;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;node[<span class="built_in">queue</span>-&gt;front];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enterNode</span><span class="params">(treeQueueP <span class="built_in">queue</span>, treeNodeP node)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % SIZE == <span class="built_in">queue</span>-&gt;front)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the queue is full!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>)% SIZE;</div><div class="line">    <span class="built_in">queue</span>-&gt;node[<span class="built_in">queue</span>-&gt;rear] = node;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote> <font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font></blockquote></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/数据结构/" rel="tag">#数据结构</a> <a href="/tags/二叉树/" rel="tag">#二叉树</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/10/07/codePoint-in-java-and-utf16/" rel="next" title="聊聊java中codepoint和UTF-16相关的一些事"><i class="fa fa-chevron-left"></i> 聊聊java中codepoint和UTF-16相关的一些事</a></div><div class="post-nav-prev post-nav-item"> <a href="/2016/10/30/rb-tree/" rel="prev" title="红黑树介绍及实现">红黑树介绍及实现<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><div class="ds-share flat" data-thread-key="2016/10/27/binary-tree/" data-title="二叉树基础以及常用操作" data-content="" data-url="http://vinoit.me/2016/10/27/binary-tree/"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li><li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div></div></div></div><div class="comments" id="comments"><div class="ds-thread" data-thread-key="2016/10/27/binary-tree/" data-title="二叉树基础以及常用操作" data-url="http://vinoit.me/2016/10/27/binary-tree/"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Vino Zhu"><p class="site-author-name" itemprop="name">Vino Zhu</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">35</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/vinoZHU" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/vinozhu" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#常见基本概念"><span class="nav-number">1.</span> <span class="nav-text">常见基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储方式"><span class="nav-number">2.</span> <span class="nav-text">存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序存储表示"><span class="nav-number">2.1.</span> <span class="nav-text">顺序存储表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉链表存储表示"><span class="nav-number">2.2.</span> <span class="nav-text">二叉链表存储表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三叉链表存储表示"><span class="nav-number">2.3.</span> <span class="nav-text">三叉链表存储表示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建二叉树"><span class="nav-number">3.</span> <span class="nav-text">创建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#括号表示法创建"><span class="nav-number">3.1.</span> <span class="nav-text">括号表示法创建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按前序遍历输入"><span class="nav-number">3.2.</span> <span class="nav-text">按前序遍历输入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非递归的前序遍历"><span class="nav-number">4.</span> <span class="nav-text">非递归的前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非递归的中序遍历"><span class="nav-number">5.</span> <span class="nav-text">非递归的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非递归的后序遍历"><span class="nav-number">6.</span> <span class="nav-text">非递归的后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次遍历"><span class="nav-number">7.</span> <span class="nav-text">层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找节点"><span class="nav-number">8.</span> <span class="nav-text">查找节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求高度"><span class="nav-number">9.</span> <span class="nav-text">求高度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#所使用的栈、队列数据结构"><span class="nav-number">10.</span> <span class="nav-text">所使用的栈、队列数据结构</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2016&nbsp;&nbsp;|&nbsp;&nbsp;</span><i class="fa fa-pencil"></i> <span class="author" itemprop="copyrightHolder">Vino Zhu&nbsp;&nbsp;|&nbsp;&nbsp;</span><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">var duoshuoQuery={short_name:"vinozly"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>