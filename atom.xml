<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vino</title>
  <subtitle>Vino&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.vino.ren/"/>
  <updated>2016-05-18T02:11:17.372Z</updated>
  <id>http://blog.vino.ren/</id>
  
  <author>
    <name>Vino Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 虚拟内存和物理内存的理解</title>
    <link href="http://blog.vino.ren/2016/05/17/linux-vm-rm/"/>
    <id>http://blog.vino.ren/2016/05/17/linux-vm-rm/</id>
    <published>2016-05-17T13:59:06.000Z</published>
    <updated>2016-05-18T02:11:17.372Z</updated>
    
    <content type="html">&lt;h3 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h3&gt;&lt;h4 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。&lt;/li&gt;
&lt;li&gt;一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录。&lt;/li&gt;
&lt;li&gt;每个进程已经分配的内存空间，都与对应的磁盘空间映射。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-0.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二&quot;&gt;&lt;a href=&quot;#二&quot; class=&quot;headerlink&quot; title=&quot;二&quot;&gt;&lt;/a&gt;二&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。&lt;/li&gt;
&lt;li&gt;所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。&lt;/li&gt;
&lt;li&gt;进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录。&lt;/li&gt;
&lt;li&gt;页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。&lt;/li&gt;
&lt;li&gt;当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常。&lt;/li&gt;
&lt;li&gt;缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处&lt;/li&gt;
&lt;li&gt;当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存&lt;/li&gt;
&lt;li&gt;在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如&lt;code&gt;.text&lt;/code&gt; &lt;code&gt;.data&lt;/code&gt;段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如&lt;code&gt;malloc&lt;/code&gt;时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。&lt;/p&gt;
&lt;h4 id=&quot;补充理解&quot;&gt;&lt;a href=&quot;#补充理解&quot; class=&quot;headerlink&quot; title=&quot;补充理解&quot;&gt;&lt;/a&gt;补充理解&lt;/h4&gt;&lt;p&gt;虚拟存储器涉及三个概念： 虚拟存储空间，磁盘空间，内存空间&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以认为虚拟空间都被映射到了磁盘空间中，（事实上也是按需要映射到磁盘空间上，通过mmap），并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap&lt;/code&gt;是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过&lt;code&gt;manmap&lt;/code&gt;可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这也是一种读写磁盘文件的方法，也是一种进程共享数据的方法 共享内存&lt;/p&gt;
&lt;h3 id=&quot;物理内存&quot;&gt;&lt;a href=&quot;#物理内存&quot; class=&quot;headerlink&quot; title=&quot;物理内存&quot;&gt;&lt;/a&gt;物理内存&lt;/h3&gt;&lt;p&gt;在内核态申请内存比在用户态申请内存要更为直接，它没有采用用户态那种延迟分配内存技术。内核认为一旦有内核函数申请内存，那么就必须立刻满足该申请内存的请求，并且这个请求一定是正确合理的。相反，对于用户态申请内存的请求，内核总是尽量延后分配物理内存，用户进程总是先获得一个虚拟内存区的使用权，最终通过缺页异常获得一块真正的物理内存。&lt;/p&gt;
&lt;h4 id=&quot;物理内存的内核映射&quot;&gt;&lt;a href=&quot;#物理内存的内核映射&quot; class=&quot;headerlink&quot; title=&quot;物理内存的内核映射&quot;&gt;&lt;/a&gt;物理内存的内核映射&lt;/h4&gt;&lt;p&gt;IA32架构中内核虚拟地址空间只有1GB大小（从3GB到4GB），因此可以直接将1GB大小的物理内存（即常规内存）映射到内核地址空间，但超出1GB大小的物理内存（即高端内存）就不能映射到内核空间。为此，内核采取了下面的方法使得内核可以使用所有的物理内存。&lt;/p&gt;
&lt;p&gt;1). 高端内存不能全部映射到内核空间，也就是说这些物理内存没有对应的线性地址。不过，内核为每个物理页框都分配了对应的页框描述符，所有的页框描述符都保存在mem_map数组中，因此每个页框描述符的线性地址都是固定存在的。内核此时可以使用alloc_pages()和alloc_page()来分配高端内存，因为这些函数返回页框描述符的线性地址。&lt;/p&gt;
&lt;p&gt;2). 内核地址空间的后128MB专门用于映射高端内存，否则，没有线性地址的高端内存不能被内核所访问。这些高端内存的内核映射显然是暂时映射的，否则也只能映射128MB的高端内存。当内核需要访问高端内存时就临时在这个区域进行地址映射，使用完毕之后再用来进行其他高端内存的映射。&lt;/p&gt;
&lt;p&gt;由于要进行高端内存的内核映射，因此直接能够映射的物理内存大小只有896MB，该值保存在high_memory中。内核地址空间的线性地址区间如下图所示：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。&lt;/p&gt;
&lt;h4 id=&quot;物理内存管理机制&quot;&gt;&lt;a href=&quot;#物理内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;物理内存管理机制&quot;&gt;&lt;/a&gt;物理内存管理机制&lt;/h4&gt;&lt;p&gt;基于物理内存在内核空间中的映射原理，物理内存的管理方式也有所不同。内核中物理内存的管理机制主要有伙伴算法，slab高速缓存和vmalloc机制。其中伙伴算法和slab高速缓存都在物理内存映射区分配物理内存，而vmalloc机制则在高端内存映射区分配物理内存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;伙伴算法&lt;/code&gt;&lt;br&gt;伙伴算法负责大块连续物理内存的分配和释放，以页框为基本单位。该机制可以避免外部碎片。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;per-CPU页框高速缓存&lt;/code&gt;&lt;br&gt;内核经常请求和释放单个页框，该缓存包含预先分配的页框，用于满足本地CPU发出的单一页框请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slab缓存&lt;/code&gt;&lt;br&gt;slab缓存负责小块物理内存的分配，并且它也作为高速缓存，主要针对内核中经常分配并释放的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vmalloc机制&lt;/code&gt;&lt;br&gt;vmalloc机制使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大限度的使用高端物理内存。&lt;/p&gt;
&lt;h4 id=&quot;物理内存的分配&quot;&gt;&lt;a href=&quot;#物理内存的分配&quot; class=&quot;headerlink&quot; title=&quot;物理内存的分配&quot;&gt;&lt;/a&gt;物理内存的分配&lt;/h4&gt;&lt;p&gt;内核发出内存申请的请求时，根据内核函数调用接口将启用不同的内存分配器。&lt;/p&gt;
&lt;h5 id=&quot;分区页框分配器&quot;&gt;&lt;a href=&quot;#分区页框分配器&quot; class=&quot;headerlink&quot; title=&quot;分区页框分配器&quot;&gt;&lt;/a&gt;分区页框分配器&lt;/h5&gt;&lt;p&gt;分区页框分配器 (zoned page frame allocator) ,处理对连续页框的内存分配请求。分区页框管理器分为两大部分:前端的管理区分配器和伙伴系统，如下图：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;管理区分配器负责搜索一个能满足请求页框块大小的管理区。在每个管理区中,具体的页框分配工作由伙伴系统负责。为了达到更好的系统性能,单个页框的申请工作直接通过per-CPU页框高速缓存完成。&lt;/p&gt;
&lt;p&gt;该分配器通过几个函数和宏来请求页框,它们之间的封装关系如下图所示。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这些函数和宏将核心的分配函数&lt;code&gt;__alloc_pages_nodemask()&lt;/code&gt;封装,形成满足不同分配需求的分配函数。其中，&lt;code&gt;alloc_pages()&lt;/code&gt;系列函数返回物理内存首页框描述符，&lt;code&gt;__get_free_pages()&lt;/code&gt;系列函数返回内存的线性地址。&lt;/p&gt;
&lt;h5 id=&quot;slab分配器&quot;&gt;&lt;a href=&quot;#slab分配器&quot; class=&quot;headerlink&quot; title=&quot;slab分配器&quot;&gt;&lt;/a&gt;slab分配器&lt;/h5&gt;&lt;p&gt;slab 分配器最初是为了解决物理内存的内部碎片而提出的，它将内核中常用的数据结构看做对象。slab分配器为每一种对象建立高速缓存。内核对该对象的分配和释放均是在这块高速缓存中操作。一种对象的slab分配器结构图如下：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以看到每种对象的高速缓存是由若干个slab组成，每个slab是由若干个页框组成的。虽然slab分配器可以分配比单个页框更小的内存块，但它所需的所有内存都是通过&lt;code&gt;伙伴算法&lt;/code&gt;分配的。&lt;/p&gt;
&lt;p&gt;slab高速缓存分专用缓存和通用缓存。专用缓存是对特定的对象，比如为内存描述符创建高速缓存。通用缓存则是针对一般情况，适合分配任意大小的物理内存，其接口即为&lt;code&gt;kmalloc()&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;非连续内存区的分配&quot;&gt;&lt;a href=&quot;#非连续内存区的分配&quot; class=&quot;headerlink&quot; title=&quot;非连续内存区的分配&quot;&gt;&lt;/a&gt;非连续内存区的分配&lt;/h5&gt;&lt;p&gt;内核通过&lt;code&gt;vmalloc()&lt;/code&gt;来申请非连续的物理内存，若申请成功，该函数返回连续内存区的起始地址，否则，返回&lt;code&gt;NULL&lt;/code&gt;。&lt;code&gt;vmalloc()&lt;/code&gt;和&lt;code&gt;kmalloc()&lt;/code&gt;申请的内存有所不同，&lt;code&gt;kmalloc()&lt;/code&gt;所申请内存的线性地址与物理地址都是连续的，而&lt;code&gt;vmalloc()&lt;/code&gt;所申请的内存线性地址连续而物理地址则是离散的，两个地址之间通过内核页表进行映射。 &lt;code&gt;vmalloc()&lt;/code&gt;的工作方式理解起来很简单：&lt;br&gt;1). 寻找一个新的连续线性地址空间；&lt;br&gt;2). 依次分配一组非连续的页框；&lt;br&gt;3). 为线性地址空间和非连续页框建立映射关系，即修改内核页表；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vmalloc()&lt;/code&gt;的内存分配原理与用户态的内存分配相似，都是通过连续的虚拟内存来访问离散的物理内存，并且虚拟地址和物理地址之间是通过页表进行连接的，通过这种方式可以有效的使用物理内存。但是应该注意的是，&lt;code&gt;vmalloc()&lt;/code&gt;申请物理内存时是立即分配的，因为内核认为这种内存分配请求是正当而且紧急的；相反，用户态有内存请求时，内核总是尽可能的延后，毕竟用户态跟内核态不在一个特权级。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h3&gt;&lt;h4 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h4&gt;&lt;o
    
    </summary>
    
      <category term="Linux" scheme="http://blog.vino.ren/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://blog.vino.ren/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://blog.vino.ren/tags/Linux/"/>
    
      <category term="内存" scheme="http://blog.vino.ren/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》学习整理--cpu加载数据（初阶）</title>
    <link href="http://blog.vino.ren/2016/05/17/computer-system-roaming/"/>
    <id>http://blog.vino.ren/2016/05/17/computer-system-roaming/</id>
    <published>2016-05-17T09:58:53.000Z</published>
    <updated>2016-05-17T11:55:11.036Z</updated>
    
    <content type="html">&lt;p&gt;断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。&lt;/p&gt;
&lt;h4 id=&quot;从一条汇编指令开始&quot;&gt;&lt;a href=&quot;#从一条汇编指令开始&quot; class=&quot;headerlink&quot; title=&quot;从一条汇编指令开始&quot;&gt;&lt;/a&gt;从一条汇编指令开始&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;movl (%ebp) %edx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;%ebp&lt;/code&gt; 和 &lt;code&gt;%edx&lt;/code&gt;这两个都是寄存器文件，处于CPU中，如图&lt;br&gt;&lt;img src=&quot;/images/computer-system/computer-system-all.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;每个cpu中都有着有限数量的寄存器在，一个IA32的处理器中包含一组8个存储32位值得寄存器。&lt;br&gt;一般每个寄存器都会存放特定的数据，例如&lt;code&gt;%esp&lt;/code&gt;是用来存放栈指针的，&lt;code&gt;%ebp&lt;/code&gt;是用来存放帧指针的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl A B&lt;/code&gt;指令是将A的数据移动到B（覆盖B的数据），&lt;code&gt;(%ebp)&lt;/code&gt;中括号的作用是取得主存中地址为&lt;code&gt;%ebp&lt;/code&gt;的值的数据。也就是说先取得&lt;code&gt;%ebp&lt;/code&gt;的值，然后将该值作为一个地址，去内存中找到这个地址，获取数据，然后将这个数据赋给&lt;code&gt;%edx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在来看看这个过程具体是什么样的：&lt;/p&gt;
&lt;h4 id=&quot;获取虚拟地址&quot;&gt;&lt;a href=&quot;#获取虚拟地址&quot; class=&quot;headerlink&quot; title=&quot;获取虚拟地址&quot;&gt;&lt;/a&gt;获取虚拟地址&lt;/h4&gt;&lt;p&gt;在系统的运行着的每一个进程（程序），它们所接触的都是一个虚拟内存地址，假如系统内存为4G，那么每一个进程在运行时，它都会认为自己拥有着所有的4G内存。假如这些都是物理内存地址，那么每个进程在不经意间都可能会去修改其他进程的数据，造成数据丢失。所以我们从&lt;code&gt;%ebp&lt;/code&gt;中获取到了一个虚拟地址。&lt;/p&gt;
&lt;h4 id=&quot;翻译虚拟地址&quot;&gt;&lt;a href=&quot;#翻译虚拟地址&quot; class=&quot;headerlink&quot; title=&quot;翻译虚拟地址&quot;&gt;&lt;/a&gt;翻译虚拟地址&lt;/h4&gt;&lt;p&gt;获取到虚拟地址之后，需要将虚拟地址转换为物理地址。这时候用到了页表和TLB，这个时候如果页表命中，则将物理地址返回。如果不命中，将产生缺页异常，需要从磁盘中获取数据，并将数据加载到主存，然后将对应地址记录到页表中。接着翻译机制再从页表中获取物理地址。具体细节以后再整理。&lt;/p&gt;
&lt;h4 id=&quot;根据物理地址获取数据&quot;&gt;&lt;a href=&quot;#根据物理地址获取数据&quot; class=&quot;headerlink&quot; title=&quot;根据物理地址获取数据&quot;&gt;&lt;/a&gt;根据物理地址获取数据&lt;/h4&gt;&lt;p&gt;cache中存放着主存中的数据，如果缓存命中，则直接将缓存中的数据返回。如果不命中，则cache从主存中获取值，存放到本地（cache）。cpu再向cache发送一次请求，cache将数据发给cpu。&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h4&gt;&lt;p&gt;以上是一个很粗糙的cpu加载数据的流程，但是基本上几个核心都提到了，以后整理细节的时候就根据这个流程来了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="理解计算机" scheme="http://blog.vino.ren/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理解计算机" scheme="http://blog.vino.ren/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://blog.vino.ren/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件描述符与打开文件之间的关系</title>
    <link href="http://blog.vino.ren/2016/05/17/linux-fd-file/"/>
    <id>http://blog.vino.ren/2016/05/17/linux-fd-file/</id>
    <published>2016-05-17T04:37:06.000Z</published>
    <updated>2016-05-17T05:00:25.894Z</updated>
    
    <content type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。&lt;code&gt;POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。&lt;/code&gt;标准文件描述符图如下：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-fd-file-0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;文件描述与打开的文件对应模型如下图：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-fd-file-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;文件描述限制&quot;&gt;&lt;a href=&quot;#文件描述限制&quot; class=&quot;headerlink&quot; title=&quot;文件描述限制&quot;&gt;&lt;/a&gt;文件描述限制&lt;/h4&gt;&lt;p&gt;在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用&lt;code&gt;sysctl -a | grep fs.file-max&lt;/code&gt;命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用&lt;code&gt;ulimit -n&lt;/code&gt;命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看&lt;a href=&quot;http://blog.csdn.net/kumu_linux/article/details/7877770。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kumu_linux/article/details/7877770。&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;文件描述符合打开文件之间的关系&quot;&gt;&lt;a href=&quot;#文件描述符合打开文件之间的关系&quot; class=&quot;headerlink&quot; title=&quot;文件描述符合打开文件之间的关系&quot;&gt;&lt;/a&gt;文件描述符合打开文件之间的关系&lt;/h4&gt;&lt;p&gt;每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程级的文件描述符表&lt;/li&gt;
&lt;li&gt;系统级的打开文件描述符表&lt;/li&gt;
&lt;li&gt;文件系统的i-node表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程级的描述符表的每一条目记录了单个文件描述符的相关信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即&lt;code&gt;close-on-exec&lt;/code&gt;标志）&lt;/li&gt;
&lt;li&gt;对打开文件句柄的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示：&lt;br&gt;当前文件偏移量（调用&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;时更新，或使用&lt;code&gt;lseek()&lt;/code&gt;直接修改）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当前文件偏移量（调用`read()`和`write()`时更新，或使用`lseek()`直接修改）
2. 打开文件时所使用的状态标识（即，`open()`的flags参数）
3. 文件访问模式（如调用`open()`时所设置的只读模式、只写模式或读写模式）
4. 与信号驱动相关的设置
5. 对该文件i-node对象的引用
6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限
7. 一个指针，指向该文件所持有的锁列表
8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下图展示了文件描述符、打开的文件句柄以及i-node之间的关系，图中，两个进程拥有诸多打开的文件描述符。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-fd-file-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用&lt;code&gt;dup()&lt;/code&gt;、&lt;code&gt;dup2()&lt;/code&gt;、&lt;code&gt;fcntl()&lt;/code&gt;或者对同一个文件多次调用了&lt;code&gt;open()&lt;/code&gt;函数而形成的。&lt;br&gt;   进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用&lt;code&gt;fork()&lt;/code&gt;后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。&lt;br&gt;   此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了&lt;code&gt;open()&lt;/code&gt;调用。同一个进程两次打开同一个文件，也会发生类似情况。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
3. 要获取和修改打开的文件标志（例如：`O_APPEND、O_NONBLOCK`和`O_ASYNC`），可执行`fcntl()`的`F_GETFL`和`F_SETFL`操作，其对作用域的约束与上一条颇为类似。
4. 文件描述符标志（即，`close-on-exec`）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.csdn.net/cywosp/article/details/38965239&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/cywosp/article/details/38965239&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;br&gt;[1] &lt;a href=&quot;http://blog.chinaunix.net/uid-20633888-id-2747146.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.chinaunix.net/uid-20633888-id-2747146.html&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;http://blog.csdn.net/kumu_linux/article/details/7877770&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kumu_linux/article/details/7877770&lt;/a&gt;&lt;br&gt;[4] 《Linux/UNIX系统编程手册》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是
    
    </summary>
    
      <category term="Linux" scheme="http://blog.vino.ren/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.vino.ren/tags/Linux/"/>
    
      <category term="文件描述符" scheme="http://blog.vino.ren/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>理解git分支-远程分支</title>
    <link href="http://blog.vino.ren/2016/05/16/git-branch-remote/"/>
    <id>http://blog.vino.ren/2016/05/16/git-branch-remote/</id>
    <published>2016-05-16T11:16:26.000Z</published>
    <updated>2016-05-16T11:47:52.156Z</updated>
    
    <content type="html">&lt;h3 id=&quot;远程分支&quot;&gt;&lt;a href=&quot;#远程分支&quot; class=&quot;headerlink&quot; title=&quot;远程分支&quot;&gt;&lt;/a&gt;远程分支&lt;/h3&gt;&lt;p&gt;远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。&lt;/p&gt;
&lt;p&gt;远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。&lt;/p&gt;
&lt;p&gt;它们以 (remote)/(branch) 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支；但是在服务器上的分支会指向 origin/iss53 的提交。&lt;/p&gt;
&lt;p&gt;这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。&lt;/p&gt;
&lt;h4 id=&quot;“origin”-并无特殊含义&quot;&gt;&lt;a href=&quot;#“origin”-并无特殊含义&quot; class=&quot;headerlink&quot; title=&quot;“origin” 并无特殊含义&quot;&gt;&lt;/a&gt;“origin” 并无特殊含义&lt;/h4&gt;&lt;p&gt;远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;克隆之后的服务器与本地仓库&quot;&gt;&lt;a href=&quot;#克隆之后的服务器与本地仓库&quot; class=&quot;headerlink&quot; title=&quot;克隆之后的服务器与本地仓库&quot;&gt;&lt;/a&gt;克隆之后的服务器与本地仓库&lt;/h4&gt;&lt;p&gt;如果你在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;本地与远程的工作可以分叉&quot;&gt;&lt;a href=&quot;#本地与远程的工作可以分叉&quot; class=&quot;headerlink&quot; title=&quot;本地与远程的工作可以分叉&quot;&gt;&lt;/a&gt;本地与远程的工作可以分叉&lt;/h4&gt;&lt;p&gt;如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动origin/master 指针指向新的、更新后的位置。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;git-fetch-更新你的远程仓库引用&quot;&gt;&lt;a href=&quot;#git-fetch-更新你的远程仓库引用&quot; class=&quot;headerlink&quot; title=&quot;git fetch 更新你的远程仓库引用&quot;&gt;&lt;/a&gt;git fetch 更新你的远程仓库引用&lt;/h4&gt;&lt;p&gt;为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为整个 URL 的缩写。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加另一个远程仓库&quot;&gt;&lt;a href=&quot;#添加另一个远程仓库&quot; class=&quot;headerlink&quot; title=&quot;添加另一个远程仓库&quot;&gt;&lt;/a&gt;添加另一个远程仓库&lt;/h4&gt;&lt;p&gt;现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支teamone/master 指向 teamone 的 master 分支。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;远程跟踪分支-teamone-master&quot;&gt;&lt;a href=&quot;#远程跟踪分支-teamone-master&quot; class=&quot;headerlink&quot; title=&quot;远程跟踪分支 teamone/master&quot;&gt;&lt;/a&gt;远程跟踪分支 teamone/master&lt;/h3&gt;&lt;h4 id=&quot;推送&quot;&gt;&lt;a href=&quot;#推送&quot; class=&quot;headerlink&quot; title=&quot;推送&quot;&gt;&lt;/a&gt;推送&lt;/h4&gt;&lt;p&gt;当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。&lt;/p&gt;
&lt;p&gt;如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch):&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Counting objects: 24, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Delta compression using up to 8 threads.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Compressing objects: 100% (15/15), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Total 24 (delta 2), reused 0 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To https://github.com/schacon/simplegit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      serverfix -&amp;gt; serverfix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分，但是现在可以先把它放在儿。 你也可以运行 git push origin serverfix:serverfix，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的awesomebranch 分支。&lt;/p&gt;
&lt;h5 id=&quot;如何避免每次输入密码&quot;&gt;&lt;a href=&quot;#如何避免每次输入密码&quot; class=&quot;headerlink&quot; title=&quot;如何避免每次输入密码&quot;&gt;&lt;/a&gt;如何避免每次输入密码&lt;/h5&gt;&lt;p&gt;如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。&lt;/p&gt;
&lt;p&gt;如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config –global credential.helper cache 来设置它。&lt;/p&gt;
&lt;p&gt;想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。&lt;/p&gt;
&lt;p&gt;下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Counting objects: 7, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Compressing objects: 100% (2/2), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Total 3 (delta 0), reused 3 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unpacking objects: 100% (3/3), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;From https://github.com/schacon/simplegit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      serverfix    -&amp;gt; origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix指针。&lt;/p&gt;
&lt;p&gt;可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的serverfix 分支上工作，可以将其建立在远程跟踪分支之上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b serverfix origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch serverfix set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;serverfix&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。&lt;/p&gt;
&lt;h4 id=&quot;跟踪分支&quot;&gt;&lt;a href=&quot;#跟踪分支&quot; class=&quot;headerlink&quot; title=&quot;跟踪分支&quot;&gt;&lt;/a&gt;跟踪分支&lt;/h4&gt;&lt;p&gt;从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。&lt;/p&gt;
&lt;p&gt;当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout --track origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch serverfix set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;serverfix&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b sf origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch sf set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;sf&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在，本地分支 sf 会自动从 origin/serverfix 拉取。&lt;/p&gt;
&lt;p&gt;设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -u origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch serverfix set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###　上游快捷方式&lt;br&gt;当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代git merge origin/master。&lt;/p&gt;
&lt;p&gt;如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -vv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  master    1ae2a45 [origin/master] deploying index fix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  testing   5ea463a trying something new&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 2 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。&lt;/p&gt;
&lt;p&gt;需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：$ git fetch –all; git branch -vv&lt;/p&gt;
&lt;h3 id=&quot;拉取&quot;&gt;&lt;a href=&quot;#拉取&quot; class=&quot;headerlink&quot; title=&quot;拉取&quot;&gt;&lt;/a&gt;拉取&lt;/h3&gt;&lt;p&gt;当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。&lt;/p&gt;
&lt;p&gt;由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。&lt;/p&gt;
&lt;h3 id=&quot;删除远程分支&quot;&gt;&lt;a href=&quot;#删除远程分支&quot; class=&quot;headerlink&quot; title=&quot;删除远程分支&quot;&gt;&lt;/a&gt;删除远程分支&lt;/h3&gt;&lt;p&gt;假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 –delete 选项的 git push命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin --delete serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To https://github.com/schacon/simplegit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - [deleted]         serverfix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;远程分支&quot;&gt;&lt;a href=&quot;#远程分支&quot; class=&quot;headerlink&quot; title=&quot;远程分支&quot;&gt;&lt;/a&gt;远程分支&lt;/h3&gt;&lt;p&gt;远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获
    
    </summary>
    
      <category term="Git" scheme="http://blog.vino.ren/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.vino.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>理解git对象</title>
    <link href="http://blog.vino.ren/2016/05/16/git-object/"/>
    <id>http://blog.vino.ren/2016/05/16/git-object/</id>
    <published>2016-05-16T10:51:22.000Z</published>
    <updated>2016-05-16T11:06:16.765Z</updated>
    
    <content type="html">&lt;h5 id=&quot;首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot;&gt;&lt;a href=&quot;#首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot; class=&quot;headerlink&quot; title=&quot;首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：&quot;&gt;&lt;/a&gt;首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：&lt;/h5&gt;&lt;p&gt; &lt;img src=&quot;/images/git/git-object-0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; 如图所示，生成了 3 个对象，一个 commit 对象，一个 tree 对象，一个 blob 对象。图上蓝底是 commit 对象，灰底的是 tree 对象，白底的是 blob 对象，每个对象节点的标题是对象的 key (SHA 摘要)缩略表示。&lt;br&gt; 对于 commit 对象，tree 内容表示这个 commit 对应根目录的 tree 对象，parent 表示父 commit 节点，通常commit 只有一个父节点，也可能没有（首次提交时 parent 为空），也可能有多个（合并节点），commit 对象还保存了 commit message 等信息。&lt;br&gt; 对于 tree 对象，里面的内容包含了文件名，文件对应的 blob 对象的 key，或者是目录名和目录对应 tree 对象的 key。&lt;br&gt; 对于 blob 对象，表示一个实际文件对象的内容，但不包括文件名，文件名是在 tree 对象里存的。&lt;/p&gt;
&lt;p&gt; 这个图怎么得到的呢？主要是两个命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 git log 命令获取最新 commit 的 key&lt;/li&gt;
&lt;li&gt;通过 git cat-file -p &lt;object key=&quot;&quot;&gt; 获取 key 对应 object 的内容，根据 object 里的内容，继续探索，就可以访问到所有关联 object&lt;/object&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;第-2-次提交，修改了-a-txt-文件：&quot;&gt;&lt;a href=&quot;#第-2-次提交，修改了-a-txt-文件：&quot; class=&quot;headerlink&quot; title=&quot;第 2 次提交，修改了 a.txt 文件：&quot;&gt;&lt;/a&gt;第 2 次提交，修改了 a.txt 文件：&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;因为 a.txt 文件已经修改，生成了一个新的 blob 对象，tree 对象和 commit 对象。如图所示，commit 对象之间是有关联的，新提交的 commit 对象的 parent 是上一次提交的 commit 对象。&lt;/p&gt;
&lt;h5 id=&quot;第-3-次提交，这次已稍微复杂一点，增加一个新文件-b-txt-，一个新目录-lib-，lib-里增加一个文件-c-txt&quot;&gt;&lt;a href=&quot;#第-3-次提交，这次已稍微复杂一点，增加一个新文件-b-txt-，一个新目录-lib-，lib-里增加一个文件-c-txt&quot; class=&quot;headerlink&quot; title=&quot;第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt&quot;&gt;&lt;/a&gt;第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如图所示，目录是有一个 tree 对象表示的，里面的内容指明了目录包含的文件或子目录。&lt;/p&gt;
&lt;h5 id=&quot;第-4-次提交，这次弄出一个新的分支-test1，并且在新分支中做了一次-commit&quot;&gt;&lt;a href=&quot;#第-4-次提交，这次弄出一个新的分支-test1，并且在新分支中做了一次-commit&quot; class=&quot;headerlink&quot; title=&quot;第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit&quot;&gt;&lt;/a&gt;第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;0c5ca 对应的 commit 对象就是生成的分支 test1 中的。分支在 Git 中是一个非常轻量化的操作，建立分支甚至都不增加新的对象。&lt;/p&gt;
&lt;h5 id=&quot;第-5-次提交，这次涉及到一个合并操作，图已经变得比较复杂了&quot;&gt;&lt;a href=&quot;#第-5-次提交，这次涉及到一个合并操作，图已经变得比较复杂了&quot; class=&quot;headerlink&quot; title=&quot;第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了&quot;&gt;&lt;/a&gt;第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;def18 就是合并后的 commit 对象。合并生成了一个新的commit ，这个 commit 的 parent 有两个，指向合并的两个原分支对应的 commit 上。&lt;/p&gt;
&lt;p&gt;作者:vincent (谢文威)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot;&gt;&lt;a href=&quot;#首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot; class=&quot;headerlink&quot; title=&quot;首次提交，提交一个简单的文件 a.txt
    
    </summary>
    
      <category term="Git" scheme="http://blog.vino.ren/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.vino.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git操作手册|命令速查表</title>
    <link href="http://blog.vino.ren/2016/05/16/git-operate-command/"/>
    <id>http://blog.vino.ren/2016/05/16/git-operate-command/</id>
    <published>2016-05-16T06:23:19.000Z</published>
    <updated>2016-05-16T10:50:15.781Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Git与SVN差异&quot;&gt;&lt;a href=&quot;#Git与SVN差异&quot; class=&quot;headerlink&quot; title=&quot;Git与SVN差异&quot;&gt;&lt;/a&gt;Git与SVN差异&lt;/h2&gt;&lt;p&gt;Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。&lt;/p&gt;
&lt;p&gt;Git 和 SVN 思想最大的差别有四个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去中心化&lt;/li&gt;
&lt;li&gt;直接记录快照，而非差异&lt;/li&gt;
&lt;li&gt;不一样的分支概念&lt;/li&gt;
&lt;li&gt;三个文件状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;去中心化&quot;&gt;&lt;a href=&quot;#去中心化&quot; class=&quot;headerlink&quot; title=&quot;去中心化&quot;&gt;&lt;/a&gt;去中心化&lt;/h3&gt;&lt;p&gt;Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/git/git.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;直接记录快照，而非差异&quot;&gt;&lt;a href=&quot;#直接记录快照，而非差异&quot; class=&quot;headerlink&quot; title=&quot;直接记录快照，而非差异&quot;&gt;&lt;/a&gt;直接记录快照，而非差异&lt;/h3&gt;&lt;p&gt;Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：&lt;/p&gt;
&lt;p&gt;SVN：&lt;br&gt;&lt;img src=&quot;/images/git/svn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git:&lt;br&gt;&lt;img src=&quot;/images/git/git.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。&lt;/p&gt;
&lt;h3 id=&quot;不一样的分支概念异&quot;&gt;&lt;a href=&quot;#不一样的分支概念异&quot; class=&quot;headerlink&quot; title=&quot;不一样的分支概念异&quot;&gt;&lt;/a&gt;不一样的分支概念异&lt;/h3&gt;&lt;p&gt;Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。&lt;/p&gt;
&lt;h3 id=&quot;三个文件状态&quot;&gt;&lt;a href=&quot;#三个文件状态&quot; class=&quot;headerlink&quot; title=&quot;三个文件状态&quot;&gt;&lt;/a&gt;三个文件状态&lt;/h3&gt;&lt;p&gt;在Git中文件有三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已提交（committed）：该文件被安全地保存在了本地数据库&lt;/li&gt;
&lt;li&gt;已修改（modified）：修改了某个文件，但还没有保存&lt;/li&gt;
&lt;li&gt;已暂存（staged）：把已修改的文件放下下次保存的清单中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Git常用命令&quot;&gt;&lt;a href=&quot;#Git常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令&quot;&gt;&lt;/a&gt;Git常用命令&lt;/h2&gt;&lt;h3 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h3&gt;&lt;p&gt;复制一个已创建的仓库:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone ssh://user@domain.com/repo.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个新的本地仓库:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地修改&quot;&gt;&lt;a href=&quot;#本地修改&quot; class=&quot;headerlink&quot; title=&quot;本地修改&quot;&gt;&lt;/a&gt;本地修改&lt;/h3&gt;&lt;p&gt;显示工作路径下已修改的文件：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示与上次提交版本文件的不同：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git diff&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把当前所有修改添加到下次提交中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把对某个文件的修改添加到下次提交中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add -p &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提交本地的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提交之前已标记的变化：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;附加消息提交：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &amp;apos;message here&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提交，并将提交时间设置为之前的某个日期:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit --date=&amp;quot;`date --date=&amp;apos;n day ago&amp;apos;`&amp;quot; -am &amp;quot;Commit Message&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改上次提交&quot;&gt;&lt;a href=&quot;#修改上次提交&quot; class=&quot;headerlink&quot; title=&quot;修改上次提交&quot;&gt;&lt;/a&gt;修改上次提交&lt;/h3&gt;&lt;p&gt;请勿修改已发布的提交记录!&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit --amend&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把当前分支中未提交的修改移动到其他分支&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git stash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout branch2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;搜索&quot;&gt;&lt;a href=&quot;#搜索&quot; class=&quot;headerlink&quot; title=&quot;搜索&quot;&gt;&lt;/a&gt;搜索&lt;/h3&gt;&lt;p&gt;从当前目录的所有文件中查找文本内容：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git grep &amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在某一版本中搜索文本：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git grep &amp;quot;Hello&amp;quot; v2.5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;提交历史&quot;&gt;&lt;a href=&quot;#提交历史&quot; class=&quot;headerlink&quot; title=&quot;提交历史&quot;&gt;&lt;/a&gt;提交历史&lt;/h3&gt;&lt;p&gt;从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示所有提交（仅显示提交的hash和message）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --oneline&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示某个用户的所有提交：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --author=&amp;quot;username&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示某个文件的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log -p &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;谁，在什么时间，修改了文件的什么内容：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git blame &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;分支与标签&quot;&gt;&lt;a href=&quot;#分支与标签&quot; class=&quot;headerlink&quot; title=&quot;分支与标签&quot;&gt;&lt;/a&gt;分支与标签&lt;/h3&gt;&lt;p&gt;列出所有的分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;切换分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建并切换到新分支:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于当前分支创建新分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch &amp;lt;new-branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于远程分支创建新的可追溯的分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch --track &amp;lt;new-branch&amp;gt; &amp;lt;remote-branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除本地分支:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch -d &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;给当前版本打标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git tag &amp;lt;tag-name&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新与发布&quot;&gt;&lt;a href=&quot;#更新与发布&quot; class=&quot;headerlink&quot; title=&quot;更新与发布&quot;&gt;&lt;/a&gt;更新与发布&lt;/h3&gt;&lt;p&gt;列出当前配置的远程端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote -v&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示远程端的信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote show &amp;lt;remote&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加新的远程端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下载远程端版本，但不合并到HEAD中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git fetch &amp;lt;remote&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下载远程端版本，并自动与HEAD版本合并：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote pull &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将远程端版本合并到本地版本中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git pull origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将本地版本发布到远程端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push remote &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除远程端分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push &amp;lt;remote&amp;gt; :&amp;lt;branch&amp;gt; (since Git v1.5.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push &amp;lt;remote&amp;gt; --delete &amp;lt;branch&amp;gt; (since Git v1.7.0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发布标签:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push --tags&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;合并与重置&quot;&gt;&lt;a href=&quot;#合并与重置&quot; class=&quot;headerlink&quot; title=&quot;合并与重置&quot;&gt;&lt;/a&gt;合并与重置&lt;/h3&gt;&lt;p&gt;将分支合并到当前HEAD中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git merge &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将当前HEAD版本重置到分支中:&lt;br&gt;请勿重置已发布的提交!&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rebase &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;退出重置:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rebase --abort&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决冲突后继续重置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rebase --continue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用配置好的merge tool 解决冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git mergetool&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在编辑器中手动解决冲突后，标记文件为已解决冲突:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add &amp;lt;resolved-file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rm &amp;lt;resolved-file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;撤销&quot;&gt;&lt;a href=&quot;#撤销&quot; class=&quot;headerlink&quot; title=&quot;撤销&quot;&gt;&lt;/a&gt;撤销&lt;/h3&gt;&lt;p&gt;放弃工作目录下的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移除缓存区的所有文件（i.e. 撤销上次git add）:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;放弃某个文件的所有本地修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout HEAD &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;重置一个提交（通过创建一个截然不同的新提交）:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git revert &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将HEAD重置到上一次提交的版本，并保留未提交的本地修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset --keep &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Git进阶指南&quot;&gt;&lt;a href=&quot;#Git进阶指南&quot; class=&quot;headerlink&quot; title=&quot;Git进阶指南&quot;&gt;&lt;/a&gt;Git进阶指南&lt;/h2&gt;&lt;h3 id=&quot;问：如何修改-origin-仓库信息？&quot;&gt;&lt;a href=&quot;#问：如何修改-origin-仓库信息？&quot; class=&quot;headerlink&quot; title=&quot;问：如何修改 origin 仓库信息？&quot;&gt;&lt;/a&gt;问：如何修改 origin 仓库信息？&lt;/h3&gt;&lt;h4 id=&quot;1、添加-origin-仓库信息&quot;&gt;&lt;a href=&quot;#1、添加-origin-仓库信息&quot; class=&quot;headerlink&quot; title=&quot;1、添加 origin 仓库信息&quot;&gt;&lt;/a&gt;1、添加 origin 仓库信息&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin &amp;lt;git仓库地址&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2、查看-origin-仓库信息&quot;&gt;&lt;a href=&quot;#2、查看-origin-仓库信息&quot; class=&quot;headerlink&quot; title=&quot;2、查看 origin 仓库信息&quot;&gt;&lt;/a&gt;2、查看 origin 仓库信息&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#以下三种方式均可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config get --remote.origin.url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote show origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3、删除-origin-仓库信息&quot;&gt;&lt;a href=&quot;#3、删除-origin-仓库信息&quot; class=&quot;headerlink&quot; title=&quot;3、删除 origin 仓库信息&quot;&gt;&lt;/a&gt;3、删除 origin 仓库信息&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote rm origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;问：如何配置-git-ssh-keys-？&quot;&gt;&lt;a href=&quot;#问：如何配置-git-ssh-keys-？&quot; class=&quot;headerlink&quot; title=&quot;问：如何配置 git ssh keys ？&quot;&gt;&lt;/a&gt;问：如何配置 git ssh keys ？&lt;/h3&gt;&lt;p&gt;在本地生成 ssh 私钥 / 公钥 文件&lt;br&gt;将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台&lt;br&gt;测试 git ssh 连接是否成功&lt;br&gt;接下来以添加 github ssh keys 为例，请注意替换 github 文件名。&lt;/p&gt;
&lt;p&gt;注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#运行以下命令，一直回车，文件名可随意指定&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;kaiye@macbook&amp;quot; -f ~/.ssh/github&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-add -K ~/.ssh/github&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#将 pub 公钥的内容粘贴到线上网站的后台&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat ~/.ssh/github.pub&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#测试 git ssh 是否连接成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -T git@github.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问：如何撤销修改？&quot;&gt;&lt;a href=&quot;#问：如何撤销修改？&quot; class=&quot;headerlink&quot; title=&quot;问：如何撤销修改？&quot;&gt;&lt;/a&gt;问：如何撤销修改？&lt;/h3&gt;&lt;p&gt;修改包含四种情况，需单独区分。&lt;/p&gt;
&lt;h4 id=&quot;1、新建的文件和目录，且从未提交至版本库&quot;&gt;&lt;a href=&quot;#1、新建的文件和目录，且从未提交至版本库&quot; class=&quot;headerlink&quot; title=&quot;1、新建的文件和目录，且从未提交至版本库&quot;&gt;&lt;/a&gt;1、新建的文件和目录，且从未提交至版本库&lt;/h4&gt;&lt;p&gt;此类文件的状态为 Untracked files ，撤销方法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clean -fd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中,”.”表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。&lt;/p&gt;
&lt;h4 id=&quot;2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）&quot;&gt;&lt;a href=&quot;#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）&quot; class=&quot;headerlink&quot; title=&quot;2、提交过版本库，但未提交至暂存区的文件（未执行 git add）&quot;&gt;&lt;/a&gt;2、提交过版本库，但未提交至暂存区的文件（未执行 git add）&lt;/h4&gt;&lt;p&gt;此类文件的状态为&lt;code&gt;Changes not staged for commit&lt;/code&gt;，撤销方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;3、已提交至暂存区的文件&quot;&gt;&lt;a href=&quot;#3、已提交至暂存区的文件&quot; class=&quot;headerlink&quot; title=&quot;3、已提交至暂存区的文件&quot;&gt;&lt;/a&gt;3、已提交至暂存区的文件&lt;/h4&gt;&lt;p&gt;此类文件的状态为 Changes to be committed，撤销方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。&lt;/p&gt;
&lt;h4 id=&quot;4、已提交至版本库（执行了-git-commit）&quot;&gt;&lt;a href=&quot;#4、已提交至版本库（执行了-git-commit）&quot; class=&quot;headerlink&quot; title=&quot;4、已提交至版本库（执行了 git commit）&quot;&gt;&lt;/a&gt;4、已提交至版本库（执行了 git commit）&lt;/h4&gt;&lt;p&gt;每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reset &amp;lt;版本号&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果需要「回滚至上一次提交」，可直接使用以下命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset head~1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。&lt;/p&gt;
&lt;h4 id=&quot;5、如果回滚了之后又不想回滚了怎么办？&quot;&gt;&lt;a href=&quot;#5、如果回滚了之后又不想回滚了怎么办？&quot; class=&quot;headerlink&quot; title=&quot;5、如果回滚了之后又不想回滚了怎么办？&quot;&gt;&lt;/a&gt;5、如果回滚了之后又不想回滚了怎么办？&lt;/h4&gt;&lt;p&gt;如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。&lt;/p&gt;
&lt;p&gt;如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &amp;lt;版本号&amp;gt; 。&lt;/p&gt;
&lt;h3 id=&quot;问：遇到冲突了怎么解决？&quot;&gt;&lt;a href=&quot;#问：遇到冲突了怎么解决？&quot; class=&quot;headerlink&quot; title=&quot;问：遇到冲突了怎么解决？&quot;&gt;&lt;/a&gt;问：遇到冲突了怎么解决？&lt;/h3&gt;&lt;p&gt;两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。&lt;/p&gt;
&lt;h4 id=&quot;1、最快的办法&quot;&gt;&lt;a href=&quot;#1、最快的办法&quot; class=&quot;headerlink&quot; title=&quot;1、最快的办法&quot;&gt;&lt;/a&gt;1、最快的办法&lt;/h4&gt;&lt;p&gt;大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 使用当前分支 HEAD 版本，通常是冲突源文件的 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 标记部分，======= 的上方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout --ours &amp;lt;文件名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; # 使用合并分支版本，通常是源冲突文件的 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 标记部分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; git checkout --theirs &amp;lt;文件名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 标记为解决状态加入暂存区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add &amp;lt;文件名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、最通用的办法&quot;&gt;&lt;a href=&quot;#2、最通用的办法&quot; class=&quot;headerlink&quot; title=&quot;2、最通用的办法&quot;&gt;&lt;/a&gt;2、最通用的办法&lt;/h4&gt;&lt;p&gt;用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。&lt;/p&gt;
&lt;p&gt;在 Mac 系统下，运行 git mergetool &amp;lt;文件名&amp;gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。&lt;/p&gt;
&lt;h4 id=&quot;3、最好的习惯&quot;&gt;&lt;a href=&quot;#3、最好的习惯&quot; class=&quot;headerlink&quot; title=&quot;3、最好的习惯&quot;&gt;&lt;/a&gt;3、最好的习惯&lt;/h4&gt;&lt;p&gt;有三个好的习惯，可以减少代码的冲突：&lt;br&gt;在开始修改代码前先 git pull 一下；&lt;br&gt;将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；&lt;br&gt;通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性&lt;/p&gt;
&lt;h4 id=&quot;4、最复杂的情况&quot;&gt;&lt;a href=&quot;#4、最复杂的情况&quot; class=&quot;headerlink&quot; title=&quot;4、最复杂的情况&quot;&gt;&lt;/a&gt;4、最复杂的情况&lt;/h4&gt;&lt;p&gt;如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。&lt;/p&gt;
&lt;p&gt;它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。&lt;/p&gt;
&lt;p&gt;rebase 大概的操作步骤如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 将当前分支的版本追加到从远程 pull 回来的节点之后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull --rebase&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 若发生冲突，则按以上其他方法进行解决，解决后继续&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 直到所有冲突得以解决，待项目最后上线前再执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --skip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问：如何在不提交修改的前提下，执行-pull-merge-等操作？&quot;&gt;&lt;a href=&quot;#问：如何在不提交修改的前提下，执行-pull-merge-等操作？&quot; class=&quot;headerlink&quot; title=&quot;问：如何在不提交修改的前提下，执行 pull / merge 等操作？&quot;&gt;&lt;/a&gt;问：如何在不提交修改的前提下，执行 pull / merge 等操作？&lt;/h3&gt;&lt;p&gt;有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。&lt;/p&gt;
&lt;p&gt;这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。&lt;/p&gt;
&lt;p&gt;以下是 git stash 常用命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看 stash 队列中已暂存了多少 WIP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 恢复上一次的 WIP 状态，并从队列中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 恢复指定编号的 WIP，同时从队列中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop stash@&amp;#123;num&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 恢复指定编号的 WIP，但不从队列中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash apply stash@&amp;#123;num&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问：如何在-git-log-中查看修改的文件列表？&quot;&gt;&lt;a href=&quot;#问：如何在-git-log-中查看修改的文件列表？&quot; class=&quot;headerlink&quot; title=&quot;问：如何在 git log 中查看修改的文件列表？&quot;&gt;&lt;/a&gt;问：如何在 git log 中查看修改的文件列表？&lt;/h3&gt;&lt;p&gt;默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --name-status --oneline&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.ls &amp;apos;log --name-status --oneline --graph&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.st &amp;apos;status --porcelain&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更多 git log 参数，可通过 git help log 查看手册。&lt;/p&gt;
&lt;p&gt;如果是看上一次提交的版本日志，直接运行 git show 即可。&lt;/p&gt;
&lt;p&gt;此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。&lt;/p&gt;
&lt;h3 id=&quot;问：git-submodule-update-时出错怎么解决？&quot;&gt;&lt;a href=&quot;#问：git-submodule-update-时出错怎么解决？&quot; class=&quot;headerlink&quot; title=&quot;问：git submodule update 时出错怎么解决？&quot;&gt;&lt;/a&gt;问：git submodule update 时出错怎么解决？&lt;/h3&gt;&lt;p&gt;例如，在执行 git submodule update 时有以下错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5&lt;br&gt;Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。&lt;/p&gt;
&lt;p&gt;解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。&lt;/p&gt;
&lt;h3 id=&quot;其他问题&quot;&gt;&lt;a href=&quot;#其他问题&quot; class=&quot;headerlink&quot; title=&quot;其他问题&quot;&gt;&lt;/a&gt;其他问题&lt;/h3&gt;&lt;p&gt;设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin master -u&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config core.quotepath off&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;常用的打 tag 操作，更多请查看《Git 基础 - 打标签》&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有本地 tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 本地新增一个 tag，推送至 origin 服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag -a v1.0.0 -m &amp;apos;tag description&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin v1.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 删除本地与 origin tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag -d v1.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin --delete v1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &amp;lt;分支名&amp;gt;，以下是常用命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 新建分支 branch1，并切换过去&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b branch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看所有本地与远程分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 修改完成后，切换回 master 分支，将 branch1 分支合并进来&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge branch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 删除已完成合并的分支 branch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -d branch1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Pro Git 简体中文版&lt;/li&gt;
&lt;li&gt;Git权威指南&lt;/li&gt;
&lt;li&gt;命令行man手册&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址&lt;a href=&quot;http://www.ezlippi.com/blog/2016/02/git-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ezlippi.com/blog/2016/02/git-guide.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.vino.ren/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.vino.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://blog.vino.ren/2016/05/16/hexo-create-blog/"/>
    <id>http://blog.vino.ren/2016/05/16/hexo-create-blog/</id>
    <published>2016-05-16T03:21:13.000Z</published>
    <updated>2016-05-16T06:29:03.584Z</updated>
    
    <content type="html">&lt;p&gt;不得不说，hexo给程序猿提供了一种高逼格的写作方式。配置也比较方便，而且目录、Rss和sitemap都是自动生成，你只需花几个小时就能掌握用hexo来编写博客。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;p&gt;安装hexo之前请确保机器上已正确安装、配置了git,node.js,如果出现npm安装太慢，请更换npm源:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm config set registry https://registry.npm.taobao.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm info underscore （如果上面配置正确这个命令会有字符串response）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir hexoblog  #创建一个文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd hexoblog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;创建博客&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;生成静态站点文件&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;运行服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;启动成功的话浏览器输入&lt;code&gt;http://localhost:4000/&lt;/code&gt;&lt;br&gt;应该能看到默认的页面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装hexo插件：自动生成sitemap,Rss，部署到git等，建议安装&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-index --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-archive --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-category --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-tag --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-server --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-heroku --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-rsync --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-openshift --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-renderer-marked@0.2 --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-renderer-stylus@0.2 --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-feed@1 --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-sitemap@1 --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;部署到github&quot;&gt;&lt;a href=&quot;#部署到github&quot; class=&quot;headerlink&quot; title=&quot;部署到github&quot;&gt;&lt;/a&gt;部署到github&lt;/h2&gt;&lt;p&gt;部署到Github前需要配置_config.yml文件&lt;/p&gt;
&lt;p&gt;添加如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: https://github.com/vinoZHU/vinoZHU.github.io.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;fancybox&quot;&gt;&lt;a href=&quot;#fancybox&quot; class=&quot;headerlink&quot; title=&quot;fancybox&quot;&gt;&lt;/a&gt;fancybox&lt;/h2&gt;&lt;p&gt;本篇博客开头的图片是这样实现的，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: hexo搭建个人博客&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2016-05-16 11:21:13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;categories: hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;photos:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题设置&quot;&gt;&lt;a href=&quot;#主题设置&quot; class=&quot;headerlink&quot; title=&quot;主题设置&quot;&gt;&lt;/a&gt;主题设置&lt;/h2&gt;&lt;p&gt;本博客采用了iissnan的Next主题，他的博客有详细的安装教程，这里贴下链接&lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;next&lt;/a&gt;，其中对next主题的设置讲的很详细了，我在这就不多讲了。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll迁移到Hexo搭建个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;external&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/&quot; target=&quot;_blank&quot;&gt;知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议&lt;/a&gt;进行许可,转载请在正文明显处注明原文地址。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，hexo给程序猿提供了一种高逼格的写作方式。配置也比较方便，而且目录、Rss和sitemap都是自动生成，你只需花几个小时就能掌握用hexo来编写博客。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="hexo" scheme="http://blog.vino.ren/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.vino.ren/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基础语法学习</title>
    <link href="http://blog.vino.ren/2016/05/16/learn-markdown-basic/"/>
    <id>http://blog.vino.ren/2016/05/16/learn-markdown-basic/</id>
    <published>2016-05-16T01:34:01.000Z</published>
    <updated>2016-05-16T06:31:04.796Z</updated>
    
    <content type="html">&lt;h2 id=&quot;优点-emsp-emsp&quot;&gt;&lt;a href=&quot;#优点-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;优点&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;优点&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总结 Markdown 的优点如下&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯文本，所以兼容性极强，可以用所有文本编辑器打开。&lt;/li&gt;
&lt;li&gt;让你专注于文字而不是排版。&lt;/li&gt;
&lt;li&gt;格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。&lt;/li&gt;
&lt;li&gt;Markdown 的标记语法有极好的可读性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;语法介绍-emsp-emsp&quot;&gt;&lt;a href=&quot;#语法介绍-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;语法介绍&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;语法介绍&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;p&gt;这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。&lt;/p&gt;
&lt;p&gt;而在 Markdown 中，你只需要在文本前面加上 &lt;code&gt;#&lt;/code&gt; 即可，同理、你&lt;br&gt;还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加  &lt;code&gt;#&lt;/code&gt; 即可，标题字号相应降低。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h3&gt;&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;
&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*   Red&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   Green&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   Blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;等同于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+   Red&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   Green&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   Blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也等同于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-   Red&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-   Green&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-   Blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.  Bird&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  McHale&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  Parish&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中数字的数值大小并不影响最后的结果&lt;/p&gt;
&lt;h3 id=&quot;分隔线&quot;&gt;&lt;a href=&quot;#分隔线&quot; class=&quot;headerlink&quot; title=&quot;分隔线&quot;&gt;&lt;/a&gt;分隔线&lt;/h3&gt;&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* * *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*****&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- - -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---------------------------------------&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &lt;code&gt;&amp;gt;&lt;/code&gt; 就好了，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; 引用的文字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终显示的就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用的文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;粗体和斜体&quot;&gt;&lt;a href=&quot;#粗体和斜体&quot; class=&quot;headerlink&quot; title=&quot;粗体和斜体&quot;&gt;&lt;/a&gt;粗体和斜体&lt;/h3&gt;&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 &lt;code&gt;*&lt;/code&gt; 包含一段文本就是粗体的语法，用一个 &lt;code&gt;*&lt;/code&gt; 包含一段文本就是斜体的语法。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*这是斜体* ， **这是粗体**&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终显示的就是：&lt;br&gt;&lt;em&gt;这是斜体&lt;/em&gt; ， &lt;strong&gt;这是粗体&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h3&gt;&lt;p&gt;相关代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;| Tables        | Are           | Cool  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ------------- |:-------------:| -----:|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| col 3 is      | right-aligned | $1600 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| col 2 is      | centered      |   $12 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| zebra stripes | are neat      |    $1 |&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Are&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;Cool&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col 3 is&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;right-aligned&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;$1600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col 2 is&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;centered&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;$12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zebra stripes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;are neat&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;$1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;相关代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dog | bird | cat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----|------|----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo | foo  | foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar | bar  | bar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baz | baz  | baz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;dog&lt;/th&gt;
&lt;th&gt;bird&lt;/th&gt;
&lt;th&gt;cat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;baz&lt;/td&gt;
&lt;td&gt;baz&lt;/td&gt;
&lt;td&gt;baz&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;行内链接&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[link text](link.address.here)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行外链接&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方便在文中多个地方引用相同的链接，集中管理，文本内容查看也整洁&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[link_name][link_id]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[link_id]: http://link.address.here &amp;quot;注释: 要加 http:// 不然会解析为本地路径&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片&quot;&gt;&lt;a href=&quot;#图片&quot; class=&quot;headerlink&quot; title=&quot;图片&quot;&gt;&lt;/a&gt;图片&lt;/h3&gt;&lt;p&gt;和链接模式类似，只要在前面添加一个 &lt;code&gt;!&lt;/code&gt; 叹号即可&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;![inline text](/path/to/img.jpg &amp;quot;Optional title&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![outline text][id]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[id]: url/to/image  &amp;quot;Optional title attribute&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;p&gt;行内的一小段代码，可以使用反引号（在TAB上面的那位）来将其包起来&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;``There is a back door here.``&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整段代码可以用三个反引号&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;以上几种格式是比较常用的格式，Markdown 还有其他语法，如想了解和学习更多，可以参考&lt;a href=&quot;http://wowubuntu.com/markdown/#link&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Markdown 语法说明 (简体中文版)》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;external&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/&quot; target=&quot;_blank&quot;&gt;知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议&lt;/a&gt;进行许可,转载请在正文明显处注明原文地址。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优点-emsp-emsp&quot;&gt;&lt;a href=&quot;#优点-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;优点&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;优点&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总结 Markdown 的优点如下&lt;
    
    </summary>
    
      <category term="markdown" scheme="http://blog.vino.ren/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://blog.vino.ren/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>开始我的hexo之旅</title>
    <link href="http://blog.vino.ren/2016/05/16/start-my-blog/"/>
    <id>http://blog.vino.ren/2016/05/16/start-my-blog/</id>
    <published>2016-05-15T23:51:05.000Z</published>
    <updated>2016-05-16T06:33:49.253Z</updated>
    
    <content type="html">&lt;h2 id=&quot;第一次hexo之旅-emsp-emsp&quot;&gt;&lt;a href=&quot;#第一次hexo之旅-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;第一次hexo之旅&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;第一次hexo之旅&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;p&gt;之前一直用博客园来记录学习的过程，虽说比较方便，只需无脑地写到文本框就行了，但是内心一直是想搞一个独立博客的。前几天在github上fork了一份hexo的博客源码，还没了解hexo是怎么用的就直接在源码上改了起来，花了一个周末把博客内容改成了自己的，但是改的都是代码，这样就没有一个可持续的效果。于是乎就开始研究了这个hexo,花了一天时间把博客配了一下，同时也了解了整个博客发布的流程，学习了一下markdown语法，瞬间觉得写博客变成了一种享受，以后可以好好写了。&lt;/p&gt;
&lt;p&gt;顺便贴一下我的&lt;a href=&quot;http://www.cnblogs.com/vinozly/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客园地址&lt;/a&gt; ,记录了我之前的学习过程，有兴趣的同学可以去看看，嘻嘻^^。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一次hexo之旅-emsp-emsp&quot;&gt;&lt;a href=&quot;#第一次hexo之旅-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;第一次hexo之旅&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;第一次hexo之旅&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
