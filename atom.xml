<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>是非之地</title>
  <subtitle>Vino Zhu&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vinoit.me/"/>
  <updated>2016-08-10T08:29:34.000Z</updated>
  <id>http://vinoit.me/</id>
  
  <author>
    <name>Vino Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java实现的订单号生成工具类</title>
    <link href="http://vinoit.me/2016/07/05/java-ordernum-generate/"/>
    <id>http://vinoit.me/2016/07/05/java-ordernum-generate/</id>
    <published>2016-07-05T03:31:05.000Z</published>
    <updated>2016-08-10T08:29:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一个自己在项目里写的订单号生成工具类，不当之处望各位指出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.project.utils;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Vino on 16/5/7.</div><div class="line"> * 订单生成规则:</div><div class="line"> * 正常情况下:年(2位)+月(2位)+日(2位)+秒(5位)+循环自增值(3位)+随机码(2位)共16位</div><div class="line"> * 非正常情况下:年(2位)+月(2位)+日(2位)+秒(5位)+随机码(5位)共16位</div><div class="line"> * 注:非正常情况在同时开启1W个线程的情况下并未发生</div><div class="line"> * 业务编码(1位)：自营、通用件、全车件待定</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNumGen</span> </span>&#123;</div><div class="line">    <span class="comment">//循环自增上限,超出则从初始值开始</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxLoop = <span class="number">999</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initNum  = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger atomicInteger;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: DCL获取单例atomicInteger</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger <span class="title">getAtomicInteger</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (atomicInteger == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (OrderNumGen.class) &#123;</div><div class="line">                <span class="keyword">if</span> (atomicInteger == <span class="keyword">null</span>)</div><div class="line">                    atomicInteger = <span class="keyword">new</span> AtomicInteger(initNum);<span class="comment">//初始值为100</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> atomicInteger;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: 订单号生成</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取单例</span></div><div class="line">        AtomicInteger atomicInteger = getAtomicInteger();</div><div class="line">        <span class="comment">//原子性自增并返回自增前的值</span></div><div class="line">        <span class="keyword">int</span> nextValue = atomicInteger.getAndIncrement();</div><div class="line">        <span class="comment">//若循环次数已超过上限</span></div><div class="line">        <span class="keyword">if</span> (nextValue &gt; maxLoop) &#123;</div><div class="line">            <span class="comment">//CAS更新值成功</span></div><div class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(nextValue + <span class="number">1</span>, initNum)) &#123;</div><div class="line">                atomicInteger.getAndIncrement();</div><div class="line">                <span class="keyword">return</span> getNextNormally(initNum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">//CAS更新值失败</span></div><div class="line">                <span class="comment">//重新获取</span></div><div class="line">                nextValue = atomicInteger.getAndIncrement();</div><div class="line">                <span class="keyword">if</span> (nextValue &lt;= maxLoop)</div><div class="line">                    <span class="keyword">return</span> getNextNormally(nextValue);</div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//非正常情况下</span></div><div class="line">                    <span class="keyword">return</span> getNextUnNormally();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getNextNormally(nextValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getNextNormally</span><span class="params">(<span class="keyword">int</span> nextValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> randomNum=(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>)+<span class="number">10</span>;<span class="comment">//2位随机码</span></div><div class="line">        <span class="keyword">return</span> Long.valueOf(getDateNum()+nextValue+randomNum);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getNextUnNormally</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>)(Math.random()*<span class="number">90000</span>)+<span class="number">10000</span>;<span class="comment">//5位随机码</span></div><div class="line">        <span class="keyword">return</span> Long.valueOf(getDateNum()+randomNum);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: 获取订单号中的时间部分</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateNum</span><span class="params">()</span></span>&#123;</div><div class="line">        Date date = <span class="keyword">new</span> Date();</div><div class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyMMddHHmmss"</span>);</div><div class="line">        String sTime = simpleDateFormat.format(date);</div><div class="line">        Integer nSecond = Integer.valueOf(sTime.substring(<span class="number">6</span>,<span class="number">8</span>)) * <span class="number">60</span> * <span class="number">60</span> +Integer.valueOf(sTime.substring(<span class="number">8</span>,<span class="number">10</span>)) * <span class="number">60</span></div><div class="line">                + Integer.valueOf(sTime.substring(<span class="number">10</span>,<span class="number">12</span>));</div><div class="line">        String sSecond = String.valueOf(nSecond);</div><div class="line">        <span class="keyword">if</span>(sSecond.length() &lt; <span class="number">5</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>,j = sSecond.length(); i &gt; j; i--)&#123;</div><div class="line">                sSecond = <span class="string">"0"</span> + sSecond;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sTime.substring(<span class="number">0</span>,<span class="number">6</span>)+sSecond;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一个自己在项目里写的订单号生成工具类，不当之处望各位指出。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="订单生成" scheme="http://vinoit.me/tags/%E8%AE%A2%E5%8D%95%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux slab机制中的colouroff</title>
    <link href="http://vinoit.me/2016/06/29/linux-slab-colour/"/>
    <id>http://vinoit.me/2016/06/29/linux-slab-colour/</id>
    <published>2016-06-29T10:52:25.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="slab简介"><a href="#slab简介" class="headerlink" title="slab简介"></a>slab简介</h4><p>slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。</p>
<h4 id="slab数据结构"><a href="#slab数据结构" class="headerlink" title="slab数据结构"></a>slab数据结构</h4><p>用于描述和管理cache的数据结构是struct kmem_cache，在struct kmem_cache中有一个struct kmem_list3*nodelists[<code>MAX_NUMNODES</code>]，<br>每个nodelists中都有着3条slab双向链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_list3 &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_partial; <span class="comment">/*slab链表，包含空闲对象和已分配对象的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_full;   <span class="comment">/*slab链表，只包含非空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_free;   <span class="comment">/*slab链表，只包含空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;    <span class="comment">/*高速缓存中空闲对象的个数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;       <span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;       <span class="comment">/*下一个slab使用的颜色*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> list_lock;  </div><div class="line">    <span class="keyword">struct</span> array_cache *shared; <span class="comment">/* shared per node */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache **alien; <span class="comment">/* on other nodes */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;    <span class="comment">/* updated without locking */</span>  </div><div class="line">    <span class="keyword">int</span> free_touched;       <span class="comment">/* updated without locking */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>（其中的<code>MAX_NUMNODES</code>在UMA机制中为1，Linux把物理内存划分为三个层次来管理：存储节点（Node）、管理区（Zone）和页面（Page）。UMA对应一致存储结构，它只需要一个Node就可以描述当前系统中的物理内存）。</p>
<p>每个slab由一个或多个页框组成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> slab &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;  <span class="comment">/*用于将slab链入kmem_list3的链表*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;<span class="comment">/*该slab的着色偏移*/</span>  </div><div class="line">    <span class="keyword">void</span> *s_mem;            <span class="comment">/*指向slab中的第一个对象*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;     <span class="comment">/*已分配出去的对象*/</span>  </div><div class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;     <span class="comment">/*下一个空闲对象的下标*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;  <span class="comment">/*节点标识号*/</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>其中的colouroff代表的是什么呢？</strong></p>
<h4 id="为什么要colouroff"><a href="#为什么要colouroff" class="headerlink" title="为什么要colouroff?"></a>为什么要colouroff?</h4><p>比如cache line 32 字节,  字节0-31一次从内存写入/读取, 字节32-63一次从内存写入/读取…..</p>
<p>另外cache对应到内存位置不是任意的</p>
<p>Cache 地址0 对应到 内存地址0 , 32 ,64 ….</p>
<p>Cache 地址1 对应到 内存地址1 , 33 ,65 ….</p>
<p>…</p>
<p>一个slab大小肯定是整数页,所以起始地址末12位为零, 即都于cache0 对应.</p>
<p>然后2个slab的每一个obj大小一样, 所以2个slab每个obj都对应相同的cache line.</p>
<p>这样2个位置相同的obj都要频繁访问,比较容易使cache来回刷新,效率降低.</p>
<p>着色就是在第二个slab的起始位置空一个cache line出来, 这样2个slab每个obj对应的cache错开一个, 这样2个位置相同的obj即使频繁访问,也不会用一个相同cache line.</p>
<h4 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h4><p>一个L1 DATA CACHE相当于一块小的内存，<code>我们假设它为16K大</code>，它会与一般物理内存交互。<br>它和内存交互一般一次传输16个字节(32个字节),也就是:  </p>
<p>CACHE 字节0-15一次写到/读取物理内存 ，字节16-31一次写到/读取物理内存.32-47 … …  </p>
<p>这些一次被传输的字节被称为cache line。  </p>
<p><strong>注意!!!这里的cache line中的cache指的是cpu中的L1 DATA CACHE ,而不是slab算法中的结构cache,这两个容易混淆。下面提到的cache都是指L1 DATA CACHE,而不是slab算法中的结构cache</strong>  </p>
<hr>
<h4 id="cache-line对齐和colouroff"><a href="#cache-line对齐和colouroff" class="headerlink" title="cache line对齐和colouroff"></a>cache line对齐和colouroff</h4><p>另外，cache写到物理内存的位置不是任意的，<br>我们假定内存为64K,那么cache地址0的数值只能和物理内存的地址0, 16K, 32K交互；cache地址1的数值只能和物理内存的地址1, 16K+1, 32K+1交互<br>。。。 。。。cache地址16K-1的数值只能和物理内存的地址6K-1, 16K+16K-1, 32K+16K -1交互  </p>
<p>这说明了两点:  </p>
<p>(1)假设对象A的一个字段长为16个字节，如果它放在物理地址 0-15,那么它将和cache的第一个cache line 交互，如果放在物理地址 8-23,那么<br>如果CPU要访问这个字段，必须将第一个和第二个cache line 都读入，才能获得这个字段的信息，显然这样速度慢，所以一般字段需要<code>cache line对齐</code>，<br>在这里就是16个字节对齐。  </p>
<p>(2)关于colouroff  </p>
<p>一般一个对象某些字段访问频繁些。<br>假定一个cache(这个cache指slab的cache,不是上面提到CPU的L1 DATA CACHE)占用5个页面也就是20K.<br>假定其中对象大小为32个字节，前16个字节访问频繁许多。  </p>
<p>假定对象A起始于物理地址0，对象C起始于31,对象B起始于物理地址16K,那么对象A，对象B的前16个字节都和第一个cache line 交互，后16个字节都和第二个cache line 交互<br>对象C前16个字节与第3个cache交互。  </p>
<p>我们假定内核访问A后就访问B,再访问A,交错进行，并且前16个字节次数都是50次，后16个为10次。C也是。  </p>
<p>这样第一个cache line 要交互100次，第二个20次，一共120次。  </p>
<p>如果让对象B向后移动16个字节，也就是对象B的前16个字节与第二个cache line 交互，后16个与第3个交互。<br>那么第一个为2次，因为只有开头结尾2次要与内存交互，其它每次都在L1 DATACACHE 中写就可以了。第2个cache line为20次左右(后面的只须在CACHE中读写),第3个cache line为20次，<br>3个line一共才41次，你不妨仔细模拟一下。  </p>
<p>所以进行错位能降低CACHE的交互次数，从而提高CPU处理速度能力。  </p>
<p>这个错位(也就是上面的16个字节)就是colouroff.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;slab简介&quot;&gt;&lt;a href=&quot;#slab简介&quot; class=&quot;headerlink&quot; title=&quot;slab简介&quot;&gt;&lt;/a&gt;slab简介&lt;/h4&gt;&lt;p&gt;slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的冷热页机制概述</title>
    <link href="http://vinoit.me/2016/06/28/linux-cold-hot-page/"/>
    <id>http://vinoit.me/2016/06/28/linux-cold-hot-page/</id>
    <published>2016-06-28T11:01:36.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是冷热页？"><a href="#什么是冷热页？" class="headerlink" title="什么是冷热页？"></a>什么是冷热页？</h4><p>在Linux Kernel的物理内存管理的<a href="/2016/06/28/linux-buddy-system/">Buddy System</a>中，引入了冷热页的概念。冷页表示该空闲页已经不再高速缓存中了(一般是指L2 Cache)，热页表示该空闲页仍然在高速缓存中。冷热页是针对于每CPU的，每个zone中，都会针对于所有的CPU初始化一个冷热页的per-cpu-pageset.</p>
<h4 id="为什么要有冷热页？"><a href="#为什么要有冷热页？" class="headerlink" title="为什么要有冷热页？"></a>为什么要有冷热页？</h4><p>作用有3点：</p>
<ul>
<li><p>Buddy Allocator在分配order为0的空闲页的时候，如果分配一个热页，那么由于该页已经存在于L2 Cache中了。CPU写访问的时候，不需要先把内存中的内容读到Cache中，然后再写。如果分配一个冷页，说明该页不在L2 Cache中。一般情况下，尽可能用热页，是容易理解的。什么时候用冷页呢？While allocating a physical page frame, there is a bit specifying whether we would like a hot or a cold page (that is, a page likely to be in the CPU cache, or a page not likely to be there). If the page will be used by the CPU, a hot page will be faster. If the page will be used for device <code>DMA</code> the CPU cache would be invalidated anyway, and a cold page does not waste precious cache contents.<br>简单翻译一下：当内核分配<code>一个</code>物理页框时，有一些规范来约束我们是分配热页还是冷页。当页框是CPU使用的，则分配热页。当页框是DMA设备使用的，则分配冷页。因为DMA设备不会用到CPU高速缓存，所以没必要使用热页。</p>
</li>
<li><p>Buddy System在给某个进程分配某个zone中空闲页的时候，首先需要用自旋锁锁住该zone,然后分配页。这样，如果多个CPU上的进程同时进行分配页，便会竞争。引入了per-cpu-set后，当多个CPU上的进程同时分配页的时候，竞争便不会发生，提高了效率。另外当释放单个页面时，空闲页面首先放回到per-cpu-pageset中，以减少zone中自旋锁的使用。当页面缓存中的页面数量超过阀值时，再将页面放回到伙伴系统中。</p>
</li>
<li><p>使用每CPU冷热页还有一个好处是，能保证某个页一直黏在1个CPU上，这有助于提高Cache的命中率。</p>
</li>
</ul>
<h4 id="冷热页的数据结构"><a href="#冷热页的数据结构" class="headerlink" title="冷热页的数据结构"></a>冷热页的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> per_cpu_pages &#123;</div><div class="line">        <span class="keyword">int</span> count;              <span class="comment">// number of pages in the list</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> high;               <span class="comment">// high watermark, emptying needed</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> batch;              <span class="comment">// chunk size for buddy add/remove</span></div><div class="line"></div><div class="line">         <span class="comment">// Lists of pages, one per migrate type stored on the pcp-lists</span></div><div class="line">         每个CPU在每个zone上都有MIGRATE_PCPTYPES个冷热页链表（根据迁移类型划分）</div><div class="line">         <span class="keyword">struct</span> list_head lists[MIGRATE_PCPTYPES];</div><div class="line"></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>在Linux中，对于UMA的架构，冷热页是在一条链表上进行管理。热页在前，冷页在后。CPU每释放一个order为0的页，如果per-cpu-pageset中的页数少于其指定的阈值，便会将释放的页插入到冷热页链表的开始处。这样，之前插入的热页便会随着其后热页源源不断的插入向后移动，其页由热变冷的几率便大大增加。</p>
<h4 id="怎样分配冷热页"><a href="#怎样分配冷热页" class="headerlink" title="怎样分配冷热页"></a>怎样分配冷热页</h4><p>在分配order为0页的时候(冷热页机制只处理单页分配的情况)，先找到合适的zone,然后根据需要的<code>migratetype</code>类型定位冷热页链表（每个zone，对于每个cpu,有3条冷热页链表，对应于：MIGRATE_UNMOVABLE、MIGRATE_RECLAIMABLE、MIGRATE_MOVABLE）。若需要热页，则从链表头取下一页（此页最“热”）；若需要冷页，则从链表尾取下一页（此页最“冷”）。</p>
<p>分配函数（关键部分已添加注释）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Really, prep_compound_page() should be called from __rmqueue_bulk().  But</div><div class="line"> * we cheat by calling it from here, in the order &gt; 0 path.  Saves a branch</div><div class="line"> * or two.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span></div><div class="line"><span class="keyword">struct</span> page *<span class="title">buffered_rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></div><div class="line">            <span class="keyword">struct</span> zone *zone, <span class="keyword">int</span> order, <span class="keyword">gfp_t</span> gfp_flags,</div><div class="line">            <span class="keyword">int</span> migratetype)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">    <span class="keyword">struct</span> page *page;</div><div class="line">    <span class="comment">//分配标志是__GFP_COLD才分配冷页</span></div><div class="line">    <span class="keyword">int</span> cold = !!(gfp_flags &amp; <span class="number">__</span>GFP_COLD);</div><div class="line"></div><div class="line">again:</div><div class="line">    <span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">struct</span> per_cpu_pages *pcp;</div><div class="line">        <span class="keyword">struct</span> list_head *<span class="built_in">list</span>;</div><div class="line"></div><div class="line">        local_irq_save(flags);</div><div class="line">        pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</div><div class="line">        <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</div><div class="line">        <span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</div><div class="line">          <span class="comment">//如果缺少页，则从Buddy System中分配。</span></div><div class="line">            pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</div><div class="line">                    pcp-&gt;batch, <span class="built_in">list</span>,</div><div class="line">                    migratetype, cold);</div><div class="line">            <span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</div><div class="line">                <span class="keyword">goto</span> failed;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cold)</div><div class="line">        <span class="comment">//分配冷页时，从链表尾部分配，list为链表头，list-&gt;prev表示链表尾</span></div><div class="line">            page = list_entry(<span class="built_in">list</span>-&gt;prev, <span class="keyword">struct</span> page, lru);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="comment">//分配热页时，从链表头分配</span></div><div class="line">            page = list_entry(<span class="built_in">list</span>-&gt;next, <span class="keyword">struct</span> page, lru);</div><div class="line">       <span class="comment">//分配完一个页框后从冷热页链表中删去该页</span></div><div class="line">        list_del(&amp;page-&gt;lru);</div><div class="line">        pcp-&gt;count--;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果order!=0(页框数&gt;1)，则不从冷热页链表中分配</span></div><div class="line">        <span class="keyword">if</span> (unlikely(gfp_flags &amp; <span class="number">__</span>GFP_NOFAIL)) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * __GFP_NOFAIL is not to be used in new code.</div><div class="line">             *</div><div class="line">             * All __GFP_NOFAIL callers should be fixed so that they</div><div class="line">             * properly detect and handle allocation failures.</div><div class="line">             *</div><div class="line">             * We most definitely don't want callers attempting to</div><div class="line">             * allocate greater than order-1 page units with</div><div class="line">             * __GFP_NOFAIL.</div><div class="line">             */</div><div class="line">            WARN_ON_ONCE(order &gt; <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        spin_lock_irqsave(&amp;zone-&gt;lock, flags);</div><div class="line">        page = <span class="number">__</span>rmqueue(zone, order, migratetype);</div><div class="line">        spin_unlock(&amp;zone-&gt;lock);</div><div class="line">        <span class="keyword">if</span> (!page)</div><div class="line">            <span class="keyword">goto</span> failed;</div><div class="line">        <span class="number">__</span>mod_zone_page_state(zone, NR_FREE_PAGES, -(<span class="number">1</span> &lt;&lt; order));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="number">__</span>count_zone_vm_events(PGALLOC, zone, <span class="number">1</span> &lt;&lt; order);</div><div class="line">    zone_statistics(preferred_zone, zone, gfp_flags);</div><div class="line">    local_irq_restore(flags);</div><div class="line"></div><div class="line">    VM_BUG_ON(bad_range(zone, page));</div><div class="line">    <span class="keyword">if</span> (prep_new_page(page, order, gfp_flags))</div><div class="line">        <span class="keyword">goto</span> again;</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line"></div><div class="line">failed:</div><div class="line">    local_irq_restore(flags);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linuxarm-%E4%B8%AD%E7%9A%84%E5%86%B7%E7%83%AD%E9%A1%B5/" target="_blank" rel="external">认识Linux/ARM 中的冷热页</a></li>
<li>Linux源码</li>
</ul>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是冷热页？&quot;&gt;&lt;a href=&quot;#什么是冷热页？&quot; class=&quot;headerlink&quot; title=&quot;什么是冷热页？&quot;&gt;&lt;/a&gt;什么是冷热页？&lt;/h4&gt;&lt;p&gt;在Linux Kernel的物理内存管理的&lt;a href=&quot;/2016/06/28/linux-bu
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的Buddy System</title>
    <link href="http://vinoit.me/2016/06/28/linux-buddy-system/"/>
    <id>http://vinoit.me/2016/06/28/linux-buddy-system/</id>
    <published>2016-06-28T02:49:31.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Buddy-System"><a href="#什么是Buddy-System" class="headerlink" title="什么是Buddy System?"></a>什么是Buddy System?</h4><p>Buddy System是Linux Kernel 进行物理内存页管理的一个子系统。在Buddy System中，管理的一个基本单位是block，每一个block有若干个连续的物理页组成，物理页的个数为2^n，这个n在buddy system中被称为order。<code>相同order的block，挂载一条双向链表上。</code>当某个block空闲时，只要发现对应的伙伴也是空闲的，就和伙伴组成一个页数为2^（n+1）的block，挂载在order为(n+1)的双向链表上，换句话说一个页数为2^n的block，是由两个页数为2^（n-1）的伙伴block组成的。因此，一个block的伙伴肯定是和这个block在 <strong>物理地址上是连续</strong> 的。在Linux中，order的默认的取值范围是[0,10]。</p>
<p>linux中用<code>struct zone</code>来描述一个内存管理区(<em>ZONE_DMA:0~16MB  ZONE_NORMAL:16MB~896MB  ZONE_HIGHMEM:896MB~end</em>)<br>其中的struct free_area中的<code>每一个元素</code>表示的是由相同order的block构成的<code>双向链表</code>。free_area[i]表示该free_area处的链表的order为i。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> zone &#123;  </div><div class="line">    ...  </div><div class="line">         ...      </div><div class="line">    <span class="keyword">struct</span> free_area    free_area[MAX_ORDER];  </div><div class="line">    ...  </div><div class="line">    ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> free_area &#123;  </div><div class="line">  <span class="comment">//每个free_area内有MIGRATE_TYPES个双向链表，根据迁移类型划分()*迁移类型请查看文末*）。</span></div><div class="line">  <span class="comment">//free_list和struct page中的lru相连</span></div><div class="line">    <span class="keyword">struct</span> list_head    free_list[MIGRATE_TYPES];  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_free;  <span class="comment">//空闲块数量</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在buddy system中，存入一个页会进行一次伙伴整合的迭代操作，直到不能再合并为止。那么，如何查找某个block的伙伴呢？在Linux中，一个block的伙伴信息记录在该block的<code>第一个物理页</code>的<code>struct page</code>上。也就是说，假若一个页在伙伴系统中，page-&gt;private的值为n,则后面连续的2^(n-1)个页面就在buddy system中。一个页面在buddy System中，就代表了该页是空闲的，可以被分配。</p>
<h4 id="查找伙伴"><a href="#查找伙伴" class="headerlink" title="查找伙伴"></a>查找伙伴</h4><p>内核代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mm/page_alloc.c</div><div class="line">		buddy_idx = <span class="number">__f</span>ind_buddy_index(page_idx, order);</div><div class="line">		buddy = page + (buddy_idx - page_idx);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></div><div class="line"><span class="number">__f</span>ind_buddy_index(<span class="keyword">unsigned</span> <span class="keyword">long</span> page_idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> page_idx ^ (<span class="number">1</span> &lt;&lt; order);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找一个页数为2^n的block的伙伴计算方法是buddy_index=page_index^(1&lt;&lt;n)(此处的^表示异或)，buddy_index 表示伙伴块首页的页索引，page_index是该block首页的页索引，n代表order。</p>
<p>举例：<br><img src="/images/linux/linux-buddy-system-2.png" alt=""></p>
<p><img src="/images/linux/linux-buddy-system-3.png" alt=""></p>
<h4 id="从buddy-System中分配页"><a href="#从buddy-System中分配页" class="headerlink" title="从buddy System中分配页"></a>从buddy System中分配页</h4><p>buddy System用来管理空闲的物理内存，接受进程的内存页申请。Linux提供给用户进程申请内存的接口函数中包含两个参数：一个是<code>GFP_***</code>，另一个是<code>order</code>。前者表示分配标志信息，从标志中可以知道进程要从哪个zone中申请物理内存，并在内存紧缺的情况下指导内存何时回收内存；后者表示需要分配2^order个连续的物理页。<br>buddy system根据参数order，在要求的zone中查找对应的链表。若该order的双向链表非空，则把该双向链表上的第一个block从buddy system中脱链，同时更新该双向链表上的block的数量，完成内存分配。若该order的双向链表为空，则查找order+1的双向链表，如果order+1的双向链表为空，则查找order+2的双向链表，直到查找到。假设查找到了第n个双向链表(n&gt;order)，由于查找到的连续物理内存页的数量大于order，因此将该block一分为二，将后半部分block挂载到2^(n-1)的双向链表上，将前半部分再一分为二，将前半部分的后半部分挂载到2^(n-2)的双向链表上，将前半部分的前半部分再一分为二。。。直到与请求的order相等为止。</p>
<h4 id="释放页到buddy-System"><a href="#释放页到buddy-System" class="headerlink" title="释放页到buddy System"></a>释放页到buddy System</h4><p>当非空闲的页被进程释放后，需要把页放回到伙伴系统中。由于block是作为一个整体被申请的，因此其释放也是以block为单位。若该block有2^n个连续的物理页，在释放的时候，根据buddy_index = page_index^(1&lt;&lt;n)查找该block的order为n的伙伴。若查找到伙伴，则将两个order为n的block合并为一个order为n+1的block。同时再查找order为n+1 block的伙伴，若找到则两个order为n+1的block继续合并…直到其不能合并为止，插入到最终order的双向链表的最前端。释放的迭代过程是分配页的逆过程.</p>
<h4 id="linux中的迁移类型"><a href="#linux中的迁移类型" class="headerlink" title="linux中的迁移类型"></a>linux中的迁移类型</h4><p>在2.6.24之前的内核版本中，free_area结构中只有一个free_list数组，而从2.6.24开始，free_area结构中存有MIGRATE_TYPES个free_list,这些数组是根据页框的移动性来划分的，为什么要进行这样的划分呢?实际上也是为了减少碎片而提出的，我们考虑下面的情况：</p>
<p><img src="/images/linux/linux-buddy-system-0.png" alt=""><br>图中一共有32个页，只分配出了4个页框，但是能够分配的最大连续内存也只有8个页框(因为伙伴系统分配出去的内存必须是2的整数次幂个页框)，内核解决这种问题的办法就是将不同类型的页进行分组。分配出去的页面可分为三种类型：</p>
<ul>
<li>不可移动页(Non-movable pages)：这类页在内存当中有固定的位置，不能移动。内核的核心分配的内存大多属于这种类型</li>
<li>可回收页(Reclaimable pages)：这类页不能直接移动，但可以删除，其内容页可以从其他地方重新生成，例如，映射自文件的数据属于这种类型，针对这种页，内核有专门的页面回收处理</li>
<li>可移动页:这类页可以随意移动，用户空间应用程序所用到的页属于该类别。它们通过页表来映射，如果他们复制到新的位置，页表项也会相应的更新，应用程序不会注意到任何改变。</li>
</ul>
<p>假如上图中大部分页都是可移动页，而分配出去的四个页都是不可移动页，由于不可移动页插在了其他类型页的中间，就导致了无法从原本空闲的连续内存区中分配较大的内存块。考虑下图的情况:<br><img src="/images/linux/linux-buddy-system-1.png" alt=""></p>
<p>将可回收页和不可移动页分开，这样虽然在不可移动页的区域当中无法分配大块的连续内存，但是可回收页的区域却没有受其影响，可以分配大块的连续内存。</p>
<p><code>内核对于迁移类型的定义如下:</code></p>
<mmzone.h>

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_UNMOVABLE     0  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_RECLAIMABLE   1  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_MOVABLE       2  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_PCPTYPES      3 <span class="comment">/* the number of types on the pcp lists */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_RESERVE       3  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_ISOLATE       4 <span class="comment">/* can't allocate from here */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_TYPES         5</span></div></pre></td></tr></table></figure>
<p>前三种类型已经介绍过</p>
<p><code>MIGRATE_PCPTYPES</code>是per_cpu_pageset，即用来表示每CPU页框高速缓存的数据结构中的链表的迁移类型数目</p>
<p><code>MIGRATE_RESERVE</code>是在前三种的列表中都没用可满足分配的内存块时，就可以从MIGRATE_RESERVE分配</p>
<p><code>MIGRATE_ISOLATE</code>用于跨越NUMA节点移动物理内存页，在大型系统上，它有益于将物理内存页移动到接近于是用该页最频繁地CPU</p>
<p><code>MIGRATE_TYPES</code>表示迁移类型的数目<br>当一个指定的迁移类型所对应的链表中没有空闲块时，将会按以下定义的顺序到其他迁移类型的链表中寻找</p>
<p>参考：</p>
<ul>
<li><a href="http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/" target="_blank" rel="external">认识Linux物理内存管理系统–Buddy System</a></li>
<li><a href="http://blog.csdn.net/vanbreaker/article/details/7605367" target="_blank" rel="external">Linux伙伴系统(一)–伙伴系统的概述</a></li>
<li><a href="http://rick_stone.leanote.com/post/%E5%86%85%E5%AD%98%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%9F%A5%E6%89%BE%E4%BC%99%E4%BC%B4" target="_blank" rel="external">内存伙伴系统之查找伙伴算法</a></li>
</ul>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
</mmzone.h>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是Buddy-System&quot;&gt;&lt;a href=&quot;#什么是Buddy-System&quot; class=&quot;headerlink&quot; title=&quot;什么是Buddy System?&quot;&gt;&lt;/a&gt;什么是Buddy System?&lt;/h4&gt;&lt;p&gt;Buddy System是Lin
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内存管理" scheme="http://vinoit.me/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>当···时发生了什么？</title>
    <link href="http://vinoit.me/2016/06/13/what-happens-when/"/>
    <id>http://vinoit.me/2016/06/13/what-happens-when/</id>
    <published>2016-06-13T03:23:25.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>当你在浏览器中输入 google.com 并且按下回车之后发生了什么？</strong></p>
<h4 id="按下”g”键"><a href="#按下”g”键" class="headerlink" title="按下”g”键"></a>按下”g”键</h4><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 <code>&quot;google.com&quot;</code>，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 <code>&quot;google.com&quot;</code> 建议给你。</p>
<h4 id="回车键按下"><a href="#回车键按下" class="headerlink" title="回车键按下"></a>回车键按下</h4><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>
<h5 id="USB键盘："><a href="#USB键盘：" class="headerlink" title="USB键盘："></a>USB键盘：</h5><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压<br>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内<br>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供<br>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包<br>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）<br>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p>
<h5 id="虚拟键盘（触屏设备）："><a href="#虚拟键盘（触屏设备）：" class="headerlink" title="虚拟键盘（触屏设备）："></a>虚拟键盘（触屏设备）：</h5><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标<br>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮<br>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息<br>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p>
<h4 id="产生中断-非USB键盘"><a href="#产生中断-非USB键盘" class="headerlink" title="产生中断[非USB键盘]"></a>产生中断[非USB键盘]</h4><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>
<h4 id="Windows-一个-WM-KEYDOWN-消息被发往应用程序"><a href="#Windows-一个-WM-KEYDOWN-消息被发往应用程序" class="headerlink" title="(Windows)一个 WM_KEYDOWN 消息被发往应用程序"></a>(Windows)一个 WM_KEYDOWN 消息被发往应用程序</h4><p>HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>
<p>Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>
<p>Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p>
<p>当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p>
<h4 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 KeyDown NSEvent被发往应用程序</h4><p>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p>
<h4 id="GNU-Linux-Xorg-服务器监听键码值"><a href="#GNU-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU/Linux)Xorg 服务器监听键码值"></a>(GNU/Linux)Xorg 服务器监听键码值</h4><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>
<h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>浏览器通过 URL 能够知道下面的信息：</p>
<blockquote>
<ul>
<li>Protocol “http”<br>使用HTTP协议</li>
<li>Resource “/“<br>请求的资源是主页(index)</li>
</ul>
</blockquote>
<h4 id="输入的是-URL-还是搜索的关键字？"><a href="#输入的是-URL-还是搜索的关键字？" class="headerlink" title="输入的是 URL 还是搜索的关键字？"></a>输入的是 URL 还是搜索的关键字？</h4><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>
<h4 id="检查-HSTS-列表···"><a href="#检查-HSTS-列表···" class="headerlink" title="检查 HSTS 列表···"></a>检查 HSTS 列表···</h4><p>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站<br>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</p>
<h4 id="转换非-ASCII-的-Unicode-字符"><a href="#转换非-ASCII-的-Unicode-字符" class="headerlink" title="转换非 ASCII 的 Unicode 字符"></a>转换非 ASCII 的 Unicode 字符</h4><p>浏览器检查输入是否含有不是 <code>a-z， A-Z，0-9， -</code> 或者 <code>.</code> 的字符<br>这里主机名是 <code>google.com</code>，所以没有非ASCII的字符，如果有的话，浏览器会对主机名部分使用 Punycode 编码</p>
<h4 id="DNS-查询···"><a href="#DNS-查询···" class="headerlink" title="DNS 查询···"></a>DNS 查询···</h4><ul>
<li>浏览器检查域名是否在缓存当中</li>
<li>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询</li>
<li><code>gethostbyname</code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同</li>
<li>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li>
<li>查询本地 DNS 服务器</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li>
</ul>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>要想发送 ARP 广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>
<ul>
<li><p>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC<br>如果缓存没有命中：</p>
</li>
<li><p>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</p>
</li>
<li>查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层 ARP 请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ARP Request:</div><div class="line"></div><div class="line">Sender MAC: interface:mac:address:here</div><div class="line">Sender IP: interface.ip.goes.here</div><div class="line">Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)</div><div class="line">Target IP: target.ip.goes.here</div></pre></td></tr></table></figure>
<p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<p>直连：</p>
<ul>
<li><p>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。<br>集线器：</p>
</li>
<li><p>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。<br>交换机：</p>
</li>
<li><p>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</p>
</li>
<li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li>
<li>如果路由器也“连接”在其中，它会返回一个 ARP Reply</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ARP Reply:</div><div class="line"></div><div class="line">Sender MAC: target:mac:address:here</div><div class="line">Sender IP: target.ip.goes.here</div><div class="line">Target MAC: interface:mac:address:here</div><div class="line">Target IP: interface.ip.goes.here</div></pre></td></tr></table></figure>
<p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>
<ul>
<li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li>
<li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li>
</ul>
<h4 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h4><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET 和 SOCK_STREAM 。</p>
<ul>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。</li>
<li><p>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。<br>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>
</li>
<li><p>以太网</p>
</li>
<li>WiFi</li>
<li>蜂窝数据网络<br>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。</li>
</ul>
<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>
<ul>
<li><p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</p>
</li>
<li><p><em>服务器端接收到 SYN 包，如果它可以建立连接：</em></p>
<ul>
<li>服务器端选择它自己的初始序列号</li>
<li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li>
<li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li>
</ul>
</li>
<li><em>客户端通过发送下面一个封包来确认这次连接：</em><ul>
<li>自己的序列号+1</li>
<li>接收端 ACK+1</li>
<li>设置 ACK 位</li>
</ul>
</li>
<li><em>数据通过下面的方式传输：</em><ul>
<li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li>
<li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li>
</ul>
</li>
<li><em>关闭连接时：</em><ul>
<li>要关闭连接的一方发送一个 FIN 包</li>
<li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li>
<li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li>
</ul>
</li>
</ul>
<h4 id="UDP-数据包"><a href="#UDP-数据包" class="headerlink" title="UDP 数据包"></a>UDP 数据包</h4><h4 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h4><ul>
<li>客户端发送一个 <code>Client hello</code> 消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。</li>
<li>服务器端向客户端返回一个 <code>Server hello</code> 消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li>
<li>客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li>
<li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li>
<li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li>
<li>服务器端生成自己的 <code>hash</code> 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li>
<li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li>
</ul>
<h4 id="TCP-数据包"><a href="#TCP-数据包" class="headerlink" title="TCP 数据包"></a>TCP 数据包</h4><h4 id="HTTP-协议···"><a href="#HTTP-协议···" class="headerlink" title="HTTP 协议···"></a>HTTP 协议···</h4><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>
<p>如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求:</p>
<p><code>GET / HTTP/1.1
Host: google.com
[其他头部]</code></p>
<p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合<code>HTTP</code>协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反<code>HTTP</code>协议标准的bug，同时浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 GET 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。</p>
<p>HTTP/1.1 定义了“关闭连接”的选项 <code>&quot;close&quot;</code>，发送者使用这个选项指示这次连接在响应结束之后会断开:</p>
<p><code>Connection:close</code><br>不支持持久连接的<code>HTTP/1.1</code> 必须在每条消息中都包含 <code>&quot;close&quot;</code> 选项。</p>
<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>
<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>
<p><code>200 OK
[响应头部]</code></p>
<p>然后是一个换行，接下来有效载荷(payload)，也就是<code>www.google.com</code>的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。</p>
<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>
<p><code>304 Not Modified
[响应头部]</code></p>
<p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>
<p>在解析完 HTM L之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code>会变成 <code>GET /$(相对www.google.com的URL) HTTP/1.1</code>。</p>
<p>如果HTML引入了 <code>www.google.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code>头部会变成另外的域名。</p>
<h4 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h4><p>HTTPD(HTTP Daemon)在服务器端处理请求/相应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li><p>HTTPD 接收请求</p>
</li>
<li><p><em>服务器把请求拆分为以下几个参数：</em></p>
<ul>
<li>HTTP 请求方法(GET, POST, HEAD, PUT 和 DELETE)。在访问 Google 这种情况下，使用的是 GET 方法</li>
<li>域名：google.com</li>
<li>请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</li>
</ul>
</li>
<li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p>
</li>
<li><p>服务器验证 google.com 接受 GET 方法</p>
</li>
<li><p>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p>
</li>
<li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p>
</li>
<li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p>
</li>
<li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</p>
</li>
</ul>
<h4 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h4><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>
<ul>
<li>解析 HTML，CSS，JS</li>
<li>渲染——构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li>
</ul>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>
<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>
<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>
<ul>
<li>一个地址栏</li>
<li>后退和前进按钮</li>
<li>书签选项</li>
<li>刷新和停止按钮</li>
<li>主页按钮</li>
</ul>
<h5 id="浏览器高层架构"><a href="#浏览器高层架构" class="headerlink" title="浏览器高层架构"></a>浏览器高层架构</h5><p>组成浏览器的组件有：</p>
<ul>
<li>用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li>
<li>浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作</li>
<li>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li>
<li>网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li>
<li>UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li>
<li>Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码</li>
<li>数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li>
</ul>
<h4 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h4><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>
<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>
<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>
<h5 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h5><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>
<ul>
<li>语言本身的“宽容”特性</li>
<li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li>
<li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li>
</ul>
<p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
<h5 id="解析结束之后"><a href="#解析结束之后" class="headerlink" title="解析结束之后"></a>解析结束之后</h5><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>
<p>此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。</p>
<p>注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。</p>
<p>执行同步 Javascript 代码。</p>
<h4 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h4><p>根据 CSS词法和句法 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容<br>每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象<br>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</p>
<h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><ul>
<li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li>
<li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度</li>
<li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li>
<li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li>
<li>使用上面的计算结果构建每个节点的坐标</li>
<li>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code>或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/" target="_blank" rel="external">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work" target="_blank" rel="external">http://www.w3.org/Style/CSS/current-work</a></li>
<li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li>
<li>页面上的每个层都被分配了纹理(?)</li>
<li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制</li>
<li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li>
<li>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li>
</ul>
<h4 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h4><ul>
<li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li>
<li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li>
</ul>
<h4 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h4><p><strong>后期渲染与用户引发的处理</strong></p>
<p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<p><strong>原文地址：<a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">https://github.com/skyline75489/what-happens-when-zh_CN</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;当你在浏览器中输入 google.com 并且按下回车之后发生了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;按下”g”键&quot;&gt;&lt;a href=&quot;#按下”g”键&quot; class=&quot;headerlink&quot; title=&quot;按下”g”键&quot;&gt;&lt;/a&gt;按下”g”键&lt;/
    
    </summary>
    
      <category term="理解计算机" scheme="http://vinoit.me/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM中class文件结构--实例讲解</title>
    <link href="http://vinoit.me/2016/05/23/java-classfile-structure-example/"/>
    <id>http://vinoit.me/2016/05/23/java-classfile-structure-example/</id>
    <published>2016-05-23T05:25:43.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过一个简单的例子来讲解class文件结构,<strong>某些具体结构概念和信息需结合我之前的两篇博文<a href="/2016/05/22/java-classfile-structure-concept/">《理解JVM中class文件结构–概念部分》</a>，<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a></strong>，建议可以通过上面的两篇博文先了解这方面的一些知识再看本文。<br>java代码（jdk7）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> testInt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        testInt = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应class文件(十六进制)：<br><img src="/images/jvm/java-classfile-structure-example-0.PNG" alt=""><br>接下来的顺序和class文件结构顺序一致</p>
<h4 id="u4-magic"><a href="#u4-magic" class="headerlink" title="u4 magic;"></a><code>u4 magic;</code></h4><p>文件位置<code>0x0-0x3</code>为魔数 CA FE BA BE ,固定不变。</p>
<h4 id="u2-minor-version"><a href="#u2-minor-version" class="headerlink" title="u2 minor_version;"></a><code>u2 minor_version;</code></h4><p>文件位置<code>0x4-0x5</code>为副版本号，值为0x0000。</p>
<h4 id="u2-major-version"><a href="#u2-major-version" class="headerlink" title="u2 major_version;"></a><code>u2 major_version;</code></h4><p>文件位置<code>0x6-0x7</code>为主版本号，值为0x0033。</p>
<h4 id="u2-constant-pool-count"><a href="#u2-constant-pool-count" class="headerlink" title="u2 constant_pool_count;"></a><code>u2 constant_pool_count;</code></h4><p>文件位置<code>0x8-0x9</code>为常量池计数器，值为0x0015，十进制为21。</p>
<h4 id="反编译后的常量池信息"><a href="#反编译后的常量池信息" class="headerlink" title="反编译后的常量池信息"></a>反编译后的常量池信息</h4><p>此时通过<code>javap -v</code> 命令反编译class文件，查看常量池信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #4.#17         //  java/lang/Object."&lt;init&gt;":()V</div><div class="line">   #2 = Fieldref           #3.#18         //  pac1/TestClass.testInt:I</div><div class="line">   #3 = Class              #19            //  pac1/TestClass</div><div class="line">   #4 = Class              #20            //  java/lang/Object</div><div class="line">   #5 = Utf8               testInt</div><div class="line">   #6 = Utf8               I</div><div class="line">   #7 = Utf8               &lt;init&gt;</div><div class="line">   #8 = Utf8               ()V</div><div class="line">   #9 = Utf8               Code</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               LocalVariableTable</div><div class="line">  #12 = Utf8               this</div><div class="line">  #13 = Utf8               Lpac1/TestClass;</div><div class="line">  #14 = Utf8               test</div><div class="line">  #15 = Utf8               SourceFile</div><div class="line">  #16 = Utf8               TestClass.java</div><div class="line">  #17 = NameAndType        #7:#8          //  "&lt;init&gt;":()V</div><div class="line">  #18 = NameAndType        #5:#6          //  testInt:I</div><div class="line">  #19 = Utf8               pac1/TestClass</div><div class="line">  #20 = Utf8               java/lang/Object</div></pre></td></tr></table></figure></p>
<p>常量池中一共有20项，这也证明了<code>u2 constant_pool_count</code>的值为常量池项目数+1。<br>在class文件中各项之间<code>没有任何填充</code>或<code>对齐</code>作为各项间的分隔符号，紧接着的便是常量池项。</p>
<h4 id="cp-info-constant-pool-constant-pool-count-1"><a href="#cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="cp_info constant_pool[constant_pool_count-1];"></a><code>cp_info constant_pool[constant_pool_count-1];</code></h4><h5 id="常量池项1"><a href="#常量池项1" class="headerlink" title="常量池项1"></a>常量池项1</h5><p><strong>通过常量池项1来学习常量池</strong></p>
<p>通过常量池项的通用格式可知，文件位置<code>0x10</code>为常量池项的tagbyte,值为0x0A,查看常量池的 tag 项说明可知常量池项1类型为CONSTANT_Methodref。</p>
<p>接着通过查看CONSTANT_Methodref_info 结构具体信息，文件位置<code>0x11-0x12</code>为CONSTANT_Methodref的class_index,为常量池项中某一项的索引，类型必须是CONSTANT_Class。值为0x0004,指向常量池项4，通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_Class类型的。</p>
<p>文件位置<code>0x13-0x14</code>为CONSTANT_Methodref的name_and_type_index，同样指向常量池中的一项，类型必须是CONSTANT_NameAndType。值为0x0011,指向常量池项17，通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_NameAndType类型的。</p>
<p><strong>在这里把和常量池项1有关的所有常量池项（1-&gt; 4,17 -&gt; 20,7,8）都讲一下</strong></p>
<h6 id="常量池项4"><a href="#常量池项4" class="headerlink" title="常量池项4"></a>常量池项4</h6><p>常量池项4在文件的开始位置是<code>0x17</code>，属于常量池项4的tagbyte,值为0x07,是CONSTANT_Class类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_Class_info 结构具体信息，文件位置<code>0x18-0x19</code>为CONSTANT_Class的 name_index，指向常量池中的某一项，类型必须是CONSTANT_Utf8，表示字符串常量的值。值为0x0014,指向常量池项20，通过查看上面反编译后的常量池信息，可以看到常量池项20是CONSTANT_Utf8类型的。</p>
<h6 id="常量池项20"><a href="#常量池项20" class="headerlink" title="常量池项20"></a>常量池项20</h6><p>常量池项20在文件的开始位置是<code>0xbf</code>,属于常量池项20的tagbyte,值为0x01,是CONSTANT_Utf8类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_Utf8_info 结构具体信息，文件位置<code>0xc0-0xc1</code>为CONSTANT_Utf8的length，表示字符串常量的长度，值为0x0010,长度为16个字节。</p>
<p>文件位置<code>0xc2-0xd1</code>为具体内容，通过ascii码转换之后的值便是<code>java/lang/Object</code>,和反编译后的常量池信息一致。</p>
<h6 id="常量池项17"><a href="#常量池项17" class="headerlink" title="常量池项17"></a>常量池项17</h6><p>常量池项17在文件的开始位置是<code>0xa4</code>,属于常量池项17的tagbyte,值为0x0c,是CONSTANT_NameAndType类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_NameAndType_info 结构具体信息，文件位置<code>0xa5-0xa6</code>为CONSTANT_NameAndType的name_index，指向常量池项的某一项，类型必须为CONSTANT_Utf8，表示字符串常量的值。值为0x0007,指向常量池项7。通过查看上面反编译后的常量池信息，可以看到常量池项7是CONSTANT_Utf8类型的。</p>
<p>文件位置<code>0xa7-0xa8</code>为CONSTANT_NameAndType的descriptor_index，指向常量池项的某一项，类型必须为CONSTANT_Utf8，表示字符串常量的值。此字符串为方法描述符，具体可参考《JVM规范》。此处的值为0x0008,指向常量池项8。通过查看上面反编译后的常量池信息，可以看到常量池项8是CONSTANT_Utf8类型的。</p>
<h6 id="常量池项7和8"><a href="#常量池项7和8" class="headerlink" title="常量池项7和8"></a>常量池项7和8</h6><p>常量池项7和8均为CONSTANT_Utf8类型的,分析方法和常量池项20一样。</p>
<h6 id="常量池项1总结"><a href="#常量池项1总结" class="headerlink" title="常量池项1总结"></a>常量池项1总结</h6><p>常量池项1是CONSTANT_Methodref类型，表示一个方法的应用。通过查看上面反编译后的常量池信息，可以发现此方法为java/lang/Object.”<init>“:()V，但其中涉及到对其他多个常量池项的引用。一个方法是由类名和方法名决定的，所以分别引用了CONSTANT_Class和CONSTANT_NameAndType，其中CONSTANT_NameAndType表示一个方法名。然后CONSTANT_Class和CONSTANT_NameAndType又分别需要字符串信息来描述，所以又引用了CONSTANT_Utf8类型的项。</init></p>
<p><strong>其他常量池项可以按照这个方式来分析。</strong></p>
<h4 id="u2-access-flags"><a href="#u2-access-flags" class="headerlink" title="u2 access_flags"></a><code>u2 access_flags</code></h4><p>文件位置<code>0xd2-0xd3</code>表示的是access_flags，值为0x0021,通过查看access_flags的取值范围和相应含义表，得知该值的含义是ACC_PUBLIC（可以被包的类外访问。）和ACC_SUPER（当用到 invokespecial 指令时，需要特殊处理的父类方法。）和反编译之后的文件中的<code>flags: ACC_PUBLIC, ACC_SUPER</code>一致。其中invokespecial指令调用了<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>。</p>
<h4 id="u2-this-class"><a href="#u2-this-class" class="headerlink" title="u2 this_class"></a><code>u2 this_class</code></h4><p>文件位置<code>0xd4-0xd5</code>表示的是u2 this_class，为本类的引用，指向常量池中的某一项，类型必须为CONSTANT_Class。值为0x0003,表示指向常量池项3。通过查看上面反编译后的常量池信息，可以看到常量池项3是CONSTANT_Class类型的,最终值为pac1/TestClass。</p>
<h4 id="u2-super-class"><a href="#u2-super-class" class="headerlink" title="u2 super_class"></a><code>u2 super_class</code></h4><p>文件位置<code>0xd6-0xd7</code>表示的是u2 super_class，为父类的引用，指向常量池中的某一项，类型必须为CONSTANT_Class。值为0x0004,表示指向常量池项4。通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_Class类型的,最终值为java/lang/Object,Object是所有类的父类。</p>
<h4 id="u2-interfaces-count"><a href="#u2-interfaces-count" class="headerlink" title="u2 interfaces_count"></a><code>u2 interfaces_count</code></h4><p>文件位置<code>0xd8-0xd9</code>表示的是u2 interfaces_count，为接口计数器。值为0x0000,表示没有实现任何接口。所以接下来便不会有<code>u2 interfaces[interfaces_count]</code>（接口表）的字节信息。</p>
<h4 id="u2-fields-count"><a href="#u2-fields-count" class="headerlink" title="u2 fields_count"></a><code>u2 fields_count</code></h4><p>文件位置<code>0xda-0xdb</code>表示的是u2 fields_count，为字段计数器。值为0x0001,表示有一个字段。</p>
<h4 id="field-info-fields-fields-count"><a href="#field-info-fields-fields-count" class="headerlink" title="field_info fields[fields_count]"></a><code>field_info fields[fields_count]</code></h4><p>接下来便是表示字段信息的字节，文件位置<code>0xdc-0xdd</code>表示的是字段的access_flags，值为0x0000。查看字段 access_flags 标记列表及其含义表后发现没有含义是用0x0000表示的。因为源代码中字段前面没有任何修饰符，表示默认访问权限。access_flags 是一种掩码标志，0x0000表示没有一个是命中的。</p>
<p>文件位置<code>0xde-0xdf</code>表示的是字段信息的name_index,指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为字段名。值为0x0005,指向常量池项5，通过查看上面反编译后的常量池信息，可以看到常量池项5是CONSTANT_Utf8类型的,最终值为testInt，和源代码的字段名一致。</p>
<p>文件位置<code>0xe0-0xe1</code>表示的是字段信息的descriptor_index,指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为字段名。值为0x0006,指向常量池项6，通过查看上面反编译后的常量池信息，可以看到常量池项6是CONSTANT_Utf8类型的,最终值为I,表示int类型。更多基本类型字符解释可查看<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>中的字段基本类型字符解释表。</p>
<p>文件位置<code>0xe2-0xe3</code>表示的是字段信息的attributes_count，此处指为0。如果字段前面用了final或者字段被注解修饰等，则值便不为0，接下来便是各个属性的描述字节。具体属性信息可参看《JVM规范》。</p>
<h4 id="u2-methods-count"><a href="#u2-methods-count" class="headerlink" title="u2 methods_count"></a><code>u2 methods_count</code></h4><p>文件位置<code>0xe4-0xe5</code>表示的是u2 methods_count，为方法计数器。值为0x0002,表示有2个方法。</p>
<h4 id="method-info-methods-methods-count"><a href="#method-info-methods-methods-count" class="headerlink" title="method_info methods[methods_count]"></a><code>method_info methods[methods_count]</code></h4><p>文件位置<code>0xe6-0xe7</code>表示的是第一个方法的access_flags,值为0x0001,通过查看方法 access_flags 标记列表及其含义表可知，该方法为ACC_PUBLIC（public，方法可以从包外访问）。</p>
<p>文件位置<code>0xe8-0xe9</code>表示的是第一个方法的name_index，指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为方法名。值为0x0007,指向常量池项7，通过查看上面反编译后的常量池信息，可以看到常量池项7是CONSTANT_Utf8类型的,最终值为<code>&lt;init&gt;</code>。</p>
<p>文件位置<code>0xea-0xeb</code>表示的是第一个方法的descriptor_index，指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为方法名。值为0x0008,指向常量池项8，通过查看上面反编译后的常量池信息，可以看到常量池项8是CONSTANT_Utf8类型的,最终值为<code>()V</code>。</p>
<p>文件位置<code>0xec-0xed</code>表示的是第一个方法的attributes_count,为方法属性计数器。值为0x0001,表明有一个属性。</p>
<p>接下来的是表示属性信息的字节，<code>查看属性的通用格式后</code>，文件位置<code>0xee-0xef</code>表示的是第一个方法中属性信息的attribute_name_index，为属性名索引，指向常量池中的某一项，必须是CONSTANT_Utf8类型的。值为0x0009,指向常量池项9，通过查看上面反编译后的常量池信息，可以看到常量池项9是CONSTANT_Utf8类型的,最终值为<code>Code</code>。Code属性的属性名固定为“Code”。</p>
<p>文件位置<code>0xf0-0xf3</code>表示属性信息的attribute_length，值为0x0000002f,说明当前属性的长度为47，不包括开始的6个字节（attribute_name_index 和 attribute_length所占用的长度）。</p>
<p>文件位置<code>0xf4-0xf5</code>表示属性信息的max_stack，为操作数栈的最大深度值，jvm运行时根据该值分配栈帧。此处值为0x0001,说明此方法调用时分配的最大栈帧为1个字节。</p>
<p>文件位置<code>0xf6-0xf7</code>表示属性信息的max_locals，为局部变量表最大存储空间，单位是slot。此处值为0x0001,说明此方法局部变量的最大存储空间为1个字节。</p>
<p>文件位置<code>0xf8-0xfb</code>表示属性信息的code_length，为具体的字节码长度。此处值为0x00000005,说明此方法具体字节码长度为5个字节。接下来的5个字节的内容就是具体的字节码。</p>
<p><strong>剩下的一些属性信息可以按照这个方法，对照属性表来分析。</strong></p>
<h4 id="u2-attributes-count-amp-attribute-info-attributes-attributes-count"><a href="#u2-attributes-count-amp-attribute-info-attributes-attributes-count" class="headerlink" title="u2 attributes_count &amp; attribute_info attributes[attributes_count]"></a><code>u2 attributes_count</code> &amp; <code>attribute_info attributes[attributes_count]</code></h4><p>u2 attributes_count 和 attribute_info attributes[attributes_count] 和方法里的属性分析原理一样。</p>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过一个简单的例子来讲解class文件结构,&lt;strong&gt;某些具体结构概念和信息需结合我之前的两篇博文&lt;a href=&quot;/2016/05/22/java-classfile-structure-concept/&quot;&gt;《理解JVM中class文件结构–概念部分》&lt;/a&gt;，
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM中class文件结构--具体结构信息</title>
    <link href="http://vinoit.me/2016/05/22/java-classfile-structure-detail/"/>
    <id>http://vinoit.me/2016/05/22/java-classfile-structure-detail/</id>
    <published>2016-05-22T06:21:30.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述的是class结构的具体信息，排版顺序按照class结构。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h5><p>所有的常量池项都具有如下通用格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cp_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u1 info[];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="常量池的-tag-项说明"><a href="#常量池的-tag-项说明" class="headerlink" title="常量池的 tag 项说明"></a>常量池的 tag 项说明</h5><table>
<thead>
<tr>
<th style="text-align:left">常量类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Class</td>
<td>7</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Fieldref</td>
<td>9</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Methodref</td>
<td>10</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InterfaceMethodref</td>
<td>11</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_String</td>
<td>8</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Integer</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Float</td>
<td>4</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Long</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Double</td>
<td>6</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_NameAndType</td>
<td>12</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Utf8</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodHandle</td>
<td>15</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodType</td>
<td>16</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InvokeDynamic</td>
<td>18</td>
</tr>
</tbody>
</table>
<h5 id="CONSTANT-Class-info-结构"><a href="#CONSTANT-Class-info-结构" class="headerlink" title="CONSTANT_Class_info 结构"></a>CONSTANT_Class_info 结构</h5><p>CONSTANT_Class_info 结构用于表示类或接口，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Class_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-Fieldref-info-结构"><a href="#CONSTANT-Fieldref-info-结构" class="headerlink" title="CONSTANT_Fieldref_info 结构"></a>CONSTANT_Fieldref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Fieldref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Methodref-info-结构"><a href="#CONSTANT-Methodref-info-结构" class="headerlink" title="CONSTANT_Methodref_info 结构"></a>CONSTANT_Methodref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Methodref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-InterfaceMethodref-info-结构"><a href="#CONSTANT-InterfaceMethodref-info-结构" class="headerlink" title="CONSTANT_InterfaceMethodref_info 结构"></a>CONSTANT_InterfaceMethodref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_InterfaceMethodref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-String-info-结构"><a href="#CONSTANT-String-info-结构" class="headerlink" title="CONSTANT_String_info 结构"></a>CONSTANT_String_info 结构</h5><p>CONSTANT_String_info 用于表示 java.lang.String 类型的常量对象，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_String_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 string_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-Integer-info-结构"><a href="#CONSTANT-Integer-info-结构" class="headerlink" title="CONSTANT_Integer_info  结构"></a>CONSTANT_Integer_info  结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Integer_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Float-info-结构"><a href="#CONSTANT-Float-info-结构" class="headerlink" title="CONSTANT_Float_info 结构"></a>CONSTANT_Float_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Float_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Long-info-结构"><a href="#CONSTANT-Long-info-结构" class="headerlink" title="CONSTANT_Long_info 结构"></a>CONSTANT_Long_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Long_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 high_bytes;</div><div class="line">    u4 low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Double-info-结构"><a href="#CONSTANT-Double-info-结构" class="headerlink" title="CONSTANT_Double_info 结构"></a>CONSTANT_Double_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Double_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 high_bytes;</div><div class="line">    u4 low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-NameAndType-info-结构"><a href="#CONSTANT-NameAndType-info-结构" class="headerlink" title="CONSTANT_NameAndType_info 结构"></a>CONSTANT_NameAndType_info 结构</h5><p>CONSTANT_NameAndType_info 结构用于表示字段或方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CONSTANT_NameAndType_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 name_index; //name_index 项的值必须是对常量池的有效索引， 常量池在该索引处的项必须是</div><div class="line">    CONSTANT_Utf8_info（ §4.4.7）结构，这个结构要么表示特殊的方法名&lt;init&gt;，要么表示一个有效</div><div class="line">    的字段或方法的非限定名（ Unqualified Name）。</div><div class="line"></div><div class="line">    u2 descriptor_index;//descriptor_index 项的值必须是对常量池的有效索引， 常量池在该索引</div><div class="line">    处的项必须是CONSTANT_Utf8_info结构。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法描述符具体格式可参考《JVM规范》。</p>
<h5 id="CONSTANT-Utf8-info-结构"><a href="#CONSTANT-Utf8-info-结构" class="headerlink" title="CONSTANT_Utf8_info 结构"></a>CONSTANT_Utf8_info 结构</h5><p>CONSTANT_Utf8_info 结构用于表示字符串常量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Utf8_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 length;</div><div class="line">    u1 bytes[length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-MethodHandle-info-结构"><a href="#CONSTANT-MethodHandle-info-结构" class="headerlink" title="CONSTANT_MethodHandle_info 结构"></a>CONSTANT_MethodHandle_info 结构</h5><p>CONSTANT_MethodHandle_info 结构用于表示方法句柄，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CONSTANT_MethodHandle_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u1 reference_kind;//reference_kind 项的值必须在 1 至 9 之间（包括 1 和 9），它决定了方法句柄的类型。</div><div class="line">    方法句柄类型的值表示方法句柄的字节码行为。</div><div class="line"></div><div class="line">    u2 reference_index;//reference_index 项的值必须是对常量池的有效索引。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-MethodType-info-结构"><a href="#CONSTANT-MethodType-info-结构" class="headerlink" title="CONSTANT_MethodType_info 结构"></a>CONSTANT_MethodType_info 结构</h5><p>CONSTANT_MethodType_info 结构用于表示方法类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_MethodType_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-InvokeDynamic-info-结构"><a href="#CONSTANT-InvokeDynamic-info-结构" class="headerlink" title="CONSTANT_InvokeDynamic_info 结构"></a>CONSTANT_InvokeDynamic_info 结构</h5><p>CONSTANT_InvokeDynamic_info 用于表示 invokedynamic 指令所使用到的引导方法<br>（ Bootstrap Method）、 引导方法使用到动态调用名称（ Dynamic Invocation Name）、 参<br>数和请求返回类型、以及可以选择性的附加被称为静态参数（ Static Arguments） 的常量序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_InvokeDynamic_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 bootstrap_method_attr_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="access-flags的取值范围和相应含义表"><a href="#access-flags的取值范围和相应含义表" class="headerlink" title="access_flags的取值范围和相应含义表"></a>access_flags的取值范围和相应含义表</h4><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>可以被包的类外访问。</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>不允许有子类。</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td>0x0020</td>
<td>当用到 invokespecial 指令时，需要特殊处理的父类方法。</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识定义的是接口而不是类。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td>不能被实例化。</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识并非 Java 源码生成的代码。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识注解类型</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td>标识枚举类型</td>
</tr>
</tbody>
</table>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>field_info 结构格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">field_info &#123;</div><div class="line">    u2 access_flags;</div><div class="line">    u2 name_index;</div><div class="line">    u2 descriptor_index;</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="字段-access-flags-标记列表及其含义"><a href="#字段-access-flags-标记列表及其含义" class="headerlink" title="字段 access_flags 标记列表及其含义"></a>字段 access_flags 标记列表及其含义</h5><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，表示字段可以从任何包访问。</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，表示字段仅能该类自身调用。</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，表示字段可以被子类调用。</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td>0x0008</td>
<td>static，表示静态字段。</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>final，表示字段定义后值无法修改</td>
</tr>
<tr>
<td style="text-align:left">ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile，表示字段是易变的。</td>
</tr>
<tr>
<td style="text-align:left">ACC_TRANSIENT</td>
<td>0x0080</td>
<td>transient，表示字段不会被序列</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>表示字段由编译器自动产生。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td>enum，表示字段为枚举类型</td>
</tr>
</tbody>
</table>
<h5 id="基本类型字符解释表"><a href="#基本类型字符解释表" class="headerlink" title="基本类型字符解释表"></a>基本类型字符解释表</h5><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">B</td>
<td>byte</td>
<td>有符号字节型数</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td>char</td>
<td>Unicode 字符， UTF-16 编码</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td>int</td>
<td>整型数</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td>long</td>
<td>长整数</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td>short</td>
<td>有符号短整数</td>
</tr>
<tr>
<td style="text-align:left">Z</td>
<td>boolean</td>
<td>布尔值 true/false</td>
</tr>
<tr>
<td style="text-align:left">L Classname;</td>
<td>reference</td>
<td>一个名为<classname>的实例</classname></td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td>reference</td>
<td>一个一维数组</td>
</tr>
</tbody>
</table>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>method_info 结构格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">method_info &#123;</div><div class="line">    u2 access_flags;</div><div class="line">    u2 name_index;</div><div class="line">    u2 descriptor_index;</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="方法-access-flags-标记列表及其含义"><a href="#方法-access-flags-标记列表及其含义" class="headerlink" title="方法 access_flags 标记列表及其含义"></a>方法 access_flags 标记列表及其含义</h5><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类中访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>final，方法不能被重写（覆盖）</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>synchronized，方法由管程同步</td>
</tr>
<tr>
<td style="text-align:left">ACC_BRIDGE</td>
<td>0x0040</td>
<td>bridge，方法由编译器产生</td>
</tr>
<tr>
<td style="text-align:left">ACC_VARARGS</td>
<td>0x0080</td>
<td>表示方法带有变长参数</td>
</tr>
<tr>
<td style="text-align:left">ACC_NATIVE</td>
<td>0x0100</td>
<td>native，方法引用非 java 语言的本地方法</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td>abstract，方法没有具体实现</td>
</tr>
<tr>
<td style="text-align:left">ACC_STRICT</td>
<td>0x0800</td>
<td>strictfp，方法使用 FP-strict 浮点格式</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>方法在源文件中不出现，由编译器产生</td>
</tr>
</tbody>
</table>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。<br>关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。</p>
<h5 id="属性的通用格式如下："><a href="#属性的通用格式如下：" class="headerlink" title="属性的通用格式如下："></a>属性的通用格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute_info &#123;</div><div class="line">    u2 attribute_name_index;   //属性名索引</div><div class="line">    u4 attribute_length;       //属性长度</div><div class="line">    u1 info[attribute_length]; //属性的具体内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h5><p>ConstantValue 属性表示一个常量字段的值。位于 field_info结构的属性表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ConstantValue_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 constantvalue_index;//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是long型的，在常量池中便是CONSTANT_Long）</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Deprecated-属性"><a href="#Deprecated-属性" class="headerlink" title="Deprecated 属性"></a>Deprecated 属性</h5><p>Deprecated 属性是在 JDK 1.1 为了支持注释中的关键词@deprecated 而引入的。<br>Deprecated 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Deprecated_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Code-属性"><a href="#Code-属性" class="headerlink" title="Code 属性"></a>Code 属性</h5><p>Code 属性的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“</div><div class="line">    u4 attribute_length; //属性值长度，为整个属性表长度-6</div><div class="line">    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值分配栈帧</div><div class="line">    u2 max_locals;  //局部变量表最大存储空间，单位是slot</div><div class="line">    u4 code_length; // 字节码指令的个数</div><div class="line">    u1 code[code_length]; // 具体的字节码指令</div><div class="line">    u2 exception_table_length; //异常的个数</div><div class="line">    &#123;   u2 start_pc;</div><div class="line">        u2 end_pc;</div><div class="line">        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。</div><div class="line">        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理</div><div class="line">    &#125; exception_table[exception_table_length]; //具体的异常内容</div><div class="line">    u2 attributes_count;     //属性的个数</div><div class="line">    attribute_info attributes[attributes_count]; //具体的属性内容</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>其中slot为局部变量中的最小单位。boolean、 byte、 char、 short、 float、 reference和 returnAddress 等小于等于32位的用一个slot表示，double,long这些大于32位的用2个slot表示</li>
</ul>
<h5 id="InnerClasses-属性"><a href="#InnerClasses-属性" class="headerlink" title="InnerClasses 属性"></a>InnerClasses 属性</h5><p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个<br>CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的<br>ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。<br>InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的,位于 ClassFile结构的属性表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">InnerClasses_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_classes;</div><div class="line">    &#123;   u2 inner_class_info_index;</div><div class="line">        u2 outer_class_info_index;</div><div class="line">        u2 inner_name_index;</div><div class="line">        u2 inner_class_access_flags;</div><div class="line">    &#125; classes[number_of_classes];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LineNumberTable-属性"><a href="#LineNumberTable-属性" class="headerlink" title="LineNumberTable 属性"></a>LineNumberTable 属性</h5><p>LineNumberTable 属性是可选变长属性，位于 Code结构的属性表。它被调试<br>器用于确定源文件中行号表示的内容在 Java 虚拟机的 code[]数组中对应的部分。在 Code 属性<br>的属性表中， LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable<br>属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件<br>的行一一对应。<br>LineNumberTable 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LineNumberTable_attribute &#123;</div><div class="line">    u2 attribute_name_index;//属性名称在常量池的索引，指向一个 CONSTANT_Utf8_info结构。</div><div class="line">    u4 attribute_length;//属性长度</div><div class="line">    u2 line_number_table_length;//线性表长度</div><div class="line">    &#123;   u2 start_pc;</div><div class="line">        u2 line_number;</div><div class="line">      &#125; line_number_table[line_number_table_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LocalVariableTable-属性"><a href="#LocalVariableTable-属性" class="headerlink" title="LocalVariableTable 属性"></a>LocalVariableTable 属性</h5><p>LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调<br>试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，<br>LocalVariableTable 属性可以按照任意顺序出现。 Code 属性中的每个局部变量最多只能有一<br>个 LocalVariableTable 属性。<br>LocalVariableTable 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LocalVariableTable_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 local_variable_table_length</div><div class="line">    &#123; u2 start_pc;</div><div class="line">      u2 length;</div><div class="line">      u2 name_index;</div><div class="line">      u2 descriptor_index;</div><div class="line">      u2 index;</div><div class="line">    &#125; local_variable_table[local_variable_table_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h5><p>Signature 属性是可选的定长属性，位于 ClassFile， field_info<br>或 method_info结构的属性表中。在 Java 语言中，任何类、 接口、 初始化方法或成<br>员的泛型签名如果包含了类型变量（ Type Variables） 或参数化类型（ Parameterized<br>Types），则 Signature 属性会为它记录泛型签名信息。<br>Signature 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Signature_attribute &#123;</div><div class="line">    u2 attribute_name_index;//属性名称在常量池中的索引，指向一个 CONSTANT_Utf8_info结构。</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 signature_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>slot是虚拟机未局部变量分配内存使用的最小单位。对于byte/char/float/int/short/boolean/returnAddress等长度不超过32位的局部变量，每个占用1个Slot；对于long和double这两种64位的数据类型则需要2个Slot来存放。</li>
<li>实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。</li>
<li>max_locals，不是所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。</li>
<li>虚拟机规范限制严格方法不允许超过65535个字节码，否则拒绝编译。</li>
</ul>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述的是class结构的具体信息，排版顺序按照class结构。&lt;/p&gt;
&lt;h4 id=&quot;常量池&quot;&gt;&lt;a href=&quot;#常量池&quot; class=&quot;headerlink&quot; title=&quot;常量池&quot;&gt;&lt;/a&gt;常量池&lt;/h4&gt;&lt;h5 id=&quot;通用格式&quot;&gt;&lt;a href=&quot;#通用格式
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM中class文件结构--概念部分</title>
    <link href="http://vinoit.me/2016/05/22/java-classfile-structure-concept/"/>
    <id>http://vinoit.me/2016/05/22/java-classfile-structure-concept/</id>
    <published>2016-05-22T05:38:49.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是class文件"><a href="#什么是class文件" class="headerlink" title="什么是class文件"></a>什么是class文件</h4><p>java源代码（后缀名是.java）经过编译器编译之后会生成class文件（后缀名是.class），每一个 Class 文件都对应着唯一一个类或接口的定义信息，但是相对地， 类或接口并不一定都得定义在文件里，我们只是通俗地将任意一个有效的类或接口所应当满足的格式称为“ Class 文件格式”， 即使它不一定以磁盘文件的形式存在。</p>
<p>每个 Class 文件都是由 8 字节为单位的字节流组成，所有的 16 位、 32 位和 64 位长度的数据将被构造成 2 个、 4 个和 8 个 8 字节单位来表示。多字节数据项总是按照 <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">Big-Endian</a>的顺序进行存储。<br>JVM规范还定义了一组私有数据类型来表示 Class 文件的内容，它们包括 <code>u1， u2 和 u4</code>，分别代表了 <code>1、 2 和 4</code>个字节的无符号。</p>
<p>为了避免与类的字段、 类的实例等概念产生混淆， 在此把用于描述类结构格式的内容定义为<code>项</code>（ Item）。在 Class 文件中，各项按照<code>严格顺序连续存放</code>的， 它们之间没有任何填充或对齐作为各项间的分隔符号。</p>
<p><code>表</code>（ Table） 是由任意数量的可变长度的<code>项</code>组成，用于表示Class 文件内容的一系列复合结构。</p>
<h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>每一个 Class 文件对应于一个如下所示的 ClassFile 结构体：</p>
<p>ClassFile :<br>    <code>u4 magic;</code><br>    <strong>魔数值固定为 0xCAFEBABE,不会改变，唯一作用是确定这个文件是否为一个能被虚拟机所接受的 Class 文件。</strong><br>    <code>u2 minor_version;</code><strong>副版本号</strong><br>    <code>u2 major_version;</code><strong>主版本号</strong><br>    <strong>主副版本号共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m。一个 Java 虚拟机实例只能支持特定范围内的主版本号。</strong><br>    <code>u2 constant_pool_count;</code><br>    <strong>常量池计数器，constant_pool_count 的值等于 constant_pool 表中的成员数加 1。constant_pool 表的索引值只有在大于 0 且小于 constant_pool_count 时才会被认为是有效的。（0表示不引用常量池的任一项）</strong><br>    <code>cp_info constant_pool[constant_pool_count-1];</code><br>    <strong>常量池，constant_pool 是一种表结构， 它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，  称为“ tagbyte”。常量池的索引范围是 1 至 constant_pool_count−1。（索引1表示第一个常量项）具体结构信息可查看我的另<br>    一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 access_flags;</code><br>    <strong>访问标志， access_flags 是一种掩码标志， 用于表示某个类或者接口的访问权限及基础属性。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 this_class;</code><br>    <strong>类索引， this_class 的值必须是对 constant_pool 表中项目的一个有效索引值。constant_pool 表在这个索引处的项必须为 CONSTANT_Class_info 类型常量。</strong><br>    <code>u2 super_class;</code><br>    <strong>父类索引，对于类来说， super_class 的值必须为 0 或者是对 constant_pool 表中项目的一个有效索引值。 如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为 CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。</strong><br>    <code>u2 interfaces_count;</code><br>    <strong>接口计数器， interfaces_count 的值表示当前类或接口的直接父接口数量。</strong><br>    <code>u2 interfaces[interfaces_count];</code><br>    <strong>接口表， interfaces[]数组中的每个成员的值必须是一个对 constant_pool 表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 类型常量,成员所表示的接口顺序和对应的源代码中给定的接口顺序（ 从左至右）<br>    一样。</strong><br>    <code>u2 fields_count;</code><br>    <strong>字段计数器， fields_count 的值表示当前 Class 文件 fields[]数组的成员个数。</strong><br>    <code>field_info fields[fields_count];</code><br>    <strong>字段表， fields[]数组中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述。fields[]数组描述当前类或接口声明的所有字段，但<em>不包括</em>从父类或父接口继承的部分。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 methods_count;</code><br>    <strong>方法计数器， methods_count 的值表示当前 Class 文件 methods[]数组的成员个数。</strong><br>    <code>method_info methods[methods_count];</code><br>    <strong>方法表， methods[]数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。methods[]数组只描述当前类或接口中声明的方法，<code>不包括</code>从父类或父接口继承的方法。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 attributes_count;</code><br>    <strong>属性计数器， attributes_count 的值表示当前 Class 文件 attributes 表的成员个数。attributes 表中每一项都是一个attribute_info 结构的数据项。</strong><br>    <code>attribute_info attributes[attributes_count];</code><br>    <strong>属性表，和字段表、方法表中属性表中的内容<em>有所区别</em>。（某些属性只能用于class,某些属性只能用于字段或者方法，例如ConstantValue 属性用于字段，Code 属性用于方法）具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong></p>
<p><code>以下是JVM规范SE7中的原文：</code><br>JVM规范里， Class 文件结构中的 attributes 表的项包括下列定义的属性：InnerClasses、EnclosingMethod、Synthetic 、Signature、SourceFile，SourceDebugExtension、 Deprecated、 RuntimeVisibleAnnotations、 RuntimeInvisibleAnnotations以及BootstrapMethods属性。对于支持 Class 文件格式版本号为 49.0 或更高的 Java虚拟机实现，必须正确识别并读取 attributes表中的Signature、 RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。<br>对于支持 Class 文件格式版本号为 51.0 或更高的Java 虚拟机实现，必须正确识别并读取 attributes 表中的BootstrapMethods属性。<br>本规范要求任一 Java 虚拟机实现可以自动忽略Class文件的 attributes 表中的若干（ 甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响 Class 文件的语义，只能提供附加的描述信息。<br><code>概括一下：虚拟机可以忽视某些属性，不同版本的虚拟机实例中所需的属性有所区别，你也可以实现自己的属性，但是只能作为附加信息，不能对原语义做出修改。</code></p>
<p>以上结构便是整个class文件，建议和我的另两篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>以及<a href="/2016/05/23/java-classfile-structure-example/">《理解JVM中class文件结构–实例讲解》</a>结合的来看。</p>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是class文件&quot;&gt;&lt;a href=&quot;#什么是class文件&quot; class=&quot;headerlink&quot; title=&quot;什么是class文件&quot;&gt;&lt;/a&gt;什么是class文件&lt;/h4&gt;&lt;p&gt;java源代码（后缀名是.java）经过编译器编译之后会生成class文件（
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（二）——重排序</title>
    <link href="http://vinoit.me/2016/05/21/java-memeory-model-reorder/"/>
    <id>http://vinoit.me/2016/05/21/java-memeory-model-reorder/</id>
    <published>2016-05-21T08:37:49.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td style="text-align:left">写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td style="text-align:left">读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">//A</span></div><div class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">//B</span></div><div class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">//C</span></div></pre></td></tr></table></figure></p>
<p>上面三个操作的数据依赖关系如下图所示：<br><img src="/images/JMM/JMM-reorder-0.png" alt=""><br>如上图所示，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。下图是该程序的两种执行顺序：<br><img src="/images/JMM/JMM-reorder-1.png" alt=""><br>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h4 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h4><p>根据happens- before的程序顺序规则，上面计算圆的面积的示例代码存在三个happens- before关系：</p>
<p>1.A happens- before B；<br>2.B happens- before C；<br>3.A happens- before C；<br>这里的第3个happens- before关系，是根据happens- before的传递性推导出来的。</p>
<p>这里A happens- before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。</p>
<h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">            a = <span class="number">1</span>;                   <span class="comment">//1</span></div><div class="line">            flag = <span class="keyword">true</span>;             <span class="comment">//2</span></div><div class="line">      &#125;</div><div class="line">      <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i =  a * a;        <span class="comment">//4</span></div><div class="line">            ……</div><div class="line">          &#125;</div><div class="line">      &#125;       </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入？</p>
<p><code>答案是：不一定能看到。</code></p>
<p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图：<br><img src="/images/JMM/JMM-reorder-2.png" alt=""><br>如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！</p>
<p><code>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</code></p>
<p>下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作3和操作4重排序后，程序的执行时序图：<br><img src="/images/JMM/JMM-reorder-2.png" alt=""><br>在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据依赖性&quot;&gt;&lt;a href=&quot;#数据依赖性&quot; class=&quot;headerlink&quot; title=&quot;数据依赖性&quot;&gt;&lt;/a&gt;数据依赖性&lt;/h4&gt;&lt;p&gt;如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存分配的原理--molloc/brk/mmap</title>
    <link href="http://vinoit.me/2016/05/20/linux-memory-alloc/"/>
    <id>http://vinoit.me/2016/05/20/linux-memory-alloc/</id>
    <published>2016-05-20T14:06:51.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配的原理__进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<h4 id="如何查看进程发生缺页中断的次数？"><a href="#如何查看进程发生缺页中断的次数？" class="headerlink" title="如何查看进程发生缺页中断的次数？"></a>如何查看进程发生缺页中断的次数？</h4><p>用<code>ps -o majflt,minflt -C program</code>命令查看。</p>
<p>majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。这两个数值表示一个进程自启动以来所发生的缺页中断的次数。</p>
<p>发生缺页中断后，执行了那些操作？</p>
<h4 id="当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作："><a href="#当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：" class="headerlink" title="当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作："></a>当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：</h4><ol>
<li><p>检查要访问的虚拟地址是否合法</p>
</li>
<li><p>查找/分配一个物理页</p>
</li>
<li><p>填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）</p>
</li>
<li><p>建立映射关系（虚拟地址到物理地址）</p>
</li>
</ol>
<p>重新执行发生缺页中断的那条指令</p>
<p>如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。</p>
<h4 id="内存分配原理"><a href="#内存分配原理" class="headerlink" title="内存分配原理"></a>内存分配原理</h4><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<ul>
<li><p>brk是将数据段(.data)的最高地址指针_edata往高地址推；</p>
</li>
<li><p>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
</li>
</ul>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p>
<h5 id="下面以一个例子来说明内存分配的原理："><a href="#下面以一个例子来说明内存分配的原理：" class="headerlink" title="下面以一个例子来说明内存分配的原理："></a>下面以一个例子来说明内存分配的原理：</h5><p>情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：<br><img src="/images/linux/linux-memory-alloc-0.jpg" alt=""><br>1.进程启动的时候，其（虚拟）内存空间的初始布局如图1-(1)所示。</p>
<p>其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。</p>
<p><code>_edata</code>指针（glibc里面定义）指向数据段的最高地址。</p>
<p>2.进程调用<code>A=malloc(30K)</code>以后，内存空间如图1-(2)：</p>
<p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p>
<p>你可能会问：只要把<code>_edata+30K</code>就完成内存分配了？</p>
<p>事实是这样的，<code>_edata+30K</code>只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</p>
<p>3.进程调用<code>B=malloc(40K)</code>以后，内存空间如图1-(3)。</p>
<p>情况二、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：<br><img src="/images/linux/linux-memory-alloc-1.jpg" alt=""></p>
<p>4.进程调用<code>C=malloc(200K)</code>以后，内存空间如图2-(4)：</p>
<p>默认情况下，malloc函数分配内存，如果请求内存大于128K（可由<code>M_MMAP_THRESHOLD</code>选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</p>
<p>这样子做主要是因为::<br>brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p>
<p>5.进程调用<code>D=malloc(100K)</code>以后，内存空间如图2-(5)；</p>
<p>6.进程调用<code>free(C</code>)以后，C对应的虚拟内存和物理内存一起释放如图2-(6)。<br><img src="/images/linux/linux-memory-alloc-2.jpg" alt=""></p>
<p>7.进程调用free(B)以后，如图3-(7)所示：</p>
<p>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？</p>
<p>当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。</p>
<p>8.进程调用free(D)以后，如图3-(8)所示：</p>
<p>B和D连接起来，变成一块140K的空闲内存。</p>
<p>9.默认情况下：</p>
<p>当最高地址空间的空闲内存超过128K（可由<code>M_TRIM_THRESHOLD</code>选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图3-(9)所示。</p>
<hr>
<h4 id="mmap-样例"><a href="#mmap-样例" class="headerlink" title="mmap 样例"></a>mmap 样例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,l;</div><div class="line">	<span class="keyword">char</span> *mp;</div><div class="line">	mp = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">1000000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</div><div class="line">	*mp = <span class="string">'A'</span>;</div><div class="line">	munmap(mp, <span class="number">1000000</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,l;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">char</span> *mp;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/tmp/mmap"</span>, O_CREAT|O_RDWR, <span class="number">00777</span>);</div><div class="line">	lseek(fd, <span class="number">100</span>, SEEK_SET);</div><div class="line">	write(fd, <span class="string">""</span>, <span class="number">1</span>);</div><div class="line">	mp = <span class="built_in">malloc</span>(<span class="number">1000000</span>);</div><div class="line">	mp = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">100</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">	i = *mp;</div><div class="line">	*mp = <span class="string">'A'</span>;</div><div class="line">	munmap(mp, <span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配的原理__进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。&lt;/p&gt;
&lt;h4 id=&quot;如何查看进程发生缺页中断的次数？&quot;&gt;&lt;a href=&quot;#如何查看进程发生缺页中断的次数？&quot; class=&quot;headerlink&quot; title=&quot;如
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内存分配" scheme="http://vinoit.me/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM加载class原理--class加载的时机</title>
    <link href="http://vinoit.me/2016/05/19/when-jvm-load-class/"/>
    <id>http://vinoit.me/2016/05/19/when-jvm-load-class/</id>
    <published>2016-05-19T11:00:58.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java的动态性"><a href="#java的动态性" class="headerlink" title="java的动态性"></a>java的动态性</h3><p>Java 语言是一种具有动态性的解释型编程语言，当指定程序运行的时候， Java 虚拟机就将编译生成的 . class 文件按照需求和一定的规则加载进内存，并组织成为一个完整的 Java 应用程序。 Java 语言把每个单独的类 Class 和接口 Implements 编译成单独的一个 . class 文件，这些文件对于 Java 运行环境来说就是一个个可以动态加载的单元。正是因为 Java 的这种特性，我们可以在不重新编译其它代码的情况下，只编译需要修改的单元，并把修改文件编译后的 . class 文件放到 Java 的路径当中， 等到下次该 Java 虚拟机器重新激活时，这个逻辑上的 Java 应用程序就会因为加载了新修改的 .class 文件，自己的功能也做了更新，这就是 Java 的动态性。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（using）、和卸载（Unloading）七个阶段。其中验证、准备和解析三个部分统称为连接（Linking），这七个阶段的发生顺序如下图所示：<br> <img src="/images/jvm/when-jvm-load-class-0.PNG" alt=""><br> 如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始。</p>
<p>类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>Java虚拟机规范没有强制性约束在什么时候开始类加载过程，但是对于初始化阶段，虚拟机规范则严格规定了有且只有四种情况必需立即对类进行“初始化”（而加载、验证、准备阶段则必需在此之前开始），这四种情况归类如下：<br>1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时、以及调用一个类的静态方法的时候。<br>2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要触发父类的初始化。<br>4.当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的类），虚拟机会先初始化这个类。</p>
<p>对于这四种触发类进行初始化的场景，在java虚拟机规范中限定了“有且只有”这四种场景会触发。这四种场景的行为称为对类的<code>主动引用</code>，除此以外的所有引用类的方式都不会触发类的初始化，称为<code>被动引用</code>。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>下面通过三个实例来说明被动引用：</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p> 父类SuperClass.java<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子类SubClass.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(SubClass.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure></p>
<p>由结果可以看出只输出了“SuperClass init！”，没有输出“SubClass init！”。这是因为对于静态字段，只有直接定义该字段的类才会被初始化，因此当我们通过子类来引用父类中定义的静态字段时，只会触发父类的初始化，而不会触发子类的初始化。</p>
<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>父类SuperClass.java如上一个示例一样<br>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">      SuperClass[] scs = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>输出结果为空</code><br>没有输出“SuperClass init！”说明没有触发类com.chenzhou.classloading.SuperClass的初始化阶段，但是这段代码会触发“[Lcom.chenzhou.classloading.SuperClass”类的初始化阶段。这个类是由虚拟机自动生成的，该创建动作由newarray触发。<code>从这里可以看出，对象的数组在java里面是一个单独的类型。</code></p>
<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>常量类ConstClass.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          System.out.println(ConstClass.HELLOWORLD);  </div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>输出：hello world</code><br>上面的示例代码运行后也没有输出“SuperClass init！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，<code>但是在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中</code>，对于常量ConstClass.HELLOWORLD的引用实际上都被转化为NotInitialization类对自身常量池的引用了。实际上NotInitialization的Class文件之中已经不存在ConstClass类的符号引用入口了。</p>
<h3 id="接口加载与类加载的区别"><a href="#接口加载与类加载的区别" class="headerlink" title="接口加载与类加载的区别"></a>接口加载与类加载的区别</h3><p>接口的加载过程与类加载的区别在于当类在初始化时要求其父类都已经初始化过了，但是一个接口在初始化时，并不要求其父类都完成了初始化，只有在真正用到父类接口的时候（如引用父接口的常量）才会初始化。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          <span class="keyword">new</span> SubClass();</div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line">SubClass init!</div></pre></td></tr></table></figure></p>
<p>如果此时的父类是一个接口，则只输出<code>SubClass init!</code>。</p>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java的动态性&quot;&gt;&lt;a href=&quot;#java的动态性&quot; class=&quot;headerlink&quot; title=&quot;java的动态性&quot;&gt;&lt;/a&gt;java的动态性&lt;/h3&gt;&lt;p&gt;Java 语言是一种具有动态性的解释型编程语言，当指定程序运行的时候， Java 虚拟机就将
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型及垃圾收集策略解析</title>
    <link href="http://vinoit.me/2016/05/19/jvm-gc-tactics/"/>
    <id>http://vinoit.me/2016/05/19/jvm-gc-tactics/</id>
    <published>2016-05-19T05:26:25.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。</p>
<p>这五个区域既然是存储空间，那么为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。</p>
<p>这个垃圾收集者就是平常我们所说的“垃圾收集器”，那么垃圾收集器在何时清扫内存？清扫哪些数据？这就是接下来我们要解决的问题。</p>
<p>程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，也就是每条线程都拥有这三块区域，而且会随着线程的创建而创建，线程的结束而销毁。那么，垃圾收集器在何时清扫这三块区域的问题就解决了。</p>
<p>此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，方法的结束而出栈，并且每个栈帧中的本地变量表都是在类被加载的时候就确定的。因此以上三个区域的垃圾收集工作具有确定性，垃圾收集器能够清楚地知道何时清扫这三块区域中的哪些数据。</p>
<p>然而，堆和方法区中的内存清理工作就没那么容易了。<br>堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。</p>
<p>堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。</p>
<p>方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。<br>因此，堆和方法区的内存回收具有不确定性。</p>
<h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><p>JVM堆一般又可以分为以下三部分：<br><img src="/images/jvm/jvm-gc-tactics-0.jpg" alt=""></p>
<ul>
<li>Perm</li>
</ul>
<p>Perm代主要保存class,method,filed对象，这部门的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p>
<ul>
<li>Tenured</li>
</ul>
<p>Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p>
<ul>
<li>Young</li>
</ul>
<p>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Young区间变满的时候，minor GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p>
<h4 id="Sizing-the-Generations"><a href="#Sizing-the-Generations" class="headerlink" title="Sizing the Generations"></a>Sizing the Generations</h4><p>JVM提供了相应的参数来对内存大小进行配置。正如上面描述，JVM中堆被分为了3个大的区间，同时JVM也提供了一些选项对Young,Tenured的大小进行控制。<br><img src="/images/jvm/jvm-gc-tactics-1.jpg" alt=""></p>
<ul>
<li>Total Heap</li>
</ul>
<p><code>-Xms:</code>指定了JVM初始启动以后初始化内存</p>
<p><code>-Xmx：</code>指定JVM堆得最大内存，在JVM启动以后，会分配<code>-Xmx</code>参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存</p>
<p><code>-Xmx -Xms</code>之差就是三个Virtual空间的大小</p>
<ul>
<li>Young Generation</li>
</ul>
<p><code>-XX:NewRatio=8</code>意味着tenured 和 young的比值8：1，这样eden+2*survivor=1/9</p>
<p>堆内存</p>
<p><code>-XX:SurvivorRatio=32</code>意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.</p>
<p><code>-Xmn</code> 参数设置了年轻代的大小</p>
<ul>
<li>Perm Generation</li>
</ul>
<p><code>-XX:PermSize=16M -XX:MaxPermSize=64M</code></p>
<p>Thread Stack</p>
<p><code>-XX:Xss=128K</code></p>
<h4 id="堆栈分离的好处"><a href="#堆栈分离的好处" class="headerlink" title="堆栈分离的好处"></a>堆栈分离的好处</h4><p>如果从JAVA内存模型的角度去理解面向对象的设计，我们就会发现对象它完美的表示了堆和栈，对象的数据放在堆中，而我们编写的那些方法一般都是运行在栈中，因此面向对象的设计是一种非常完美的设计方式，它完美的统一了数据存储和运行。</p>
<h3 id="JAVA垃圾收集器"><a href="#JAVA垃圾收集器" class="headerlink" title="JAVA垃圾收集器"></a>JAVA垃圾收集器</h3><h4 id="常见的垃圾收集策略"><a href="#常见的垃圾收集策略" class="headerlink" title="常见的垃圾收集策略"></a>常见的垃圾收集策略</h4><p><img src="/images/jvm/jvm-gc-tactics-2.jpg" alt=""></p>
<p>所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面得不可到达主要是指应用程序已经没有内存块的引用了，而在JAVA中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。</p>
<h5 id="Reference-Counting-引用计数）"><a href="#Reference-Counting-引用计数）" class="headerlink" title="Reference Counting(引用计数）"></a>Reference Counting(引用计数）</h5><p>  引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。</p>
<p><code>优点：</code><br>简单，直接，不需要暂停整个应用<br><code>缺点：</code><br>1.需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作，比如每次将对象赋值给新的引用，或者者对象的引用超出了作用域等。<br>2.不能处理循环引用的问题</p>
<h5 id="跟踪收集器"><a href="#跟踪收集器" class="headerlink" title="跟踪收集器"></a>跟踪收集器</h5><p>跟踪收集器首先要暂停整个应用程序，然后开始从根对象扫描整个堆，判断扫描的对象是否有对象引用，这里面有三个问题需要搞清楚：<br><img src="/images/jvm/jvm-gc-tactics-3.jpg" alt=""><br>1．如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了分代收集，在新生代收集的时候minor gc只需要扫描新生代，而不需要扫描老生代。</p>
<p>2．JVM采用了分代收集以后，minor gc只扫描新生代，但是minor gc怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，卡片标记将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆。具体如下图：<br>3．GC在收集一个对象的时候会判断是否有引用指向对象，在JAVA中的引用主要有四种：Strong reference,Soft reference,Weak reference,Phantom reference.</p>
<ul>
<li>Strong Reference</li>
</ul>
<p>强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      Object referent = <span class="keyword">new</span> Object();  </div><div class="line">      Object strongReference = referent;  </div><div class="line">      referent = <span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNotNull(strongReference);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Soft Reference</li>
</ul>
<p>软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      String  str =  <span class="string">"test"</span>;  </div><div class="line">      SoftReference&lt;String&gt; softreference = <span class="keyword">new</span> SoftReference&lt;String&gt;(str);  </div><div class="line">      str=<span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNotNull(softreference.get());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Weak reference</li>
</ul>
<p>弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      String  str =  <span class="string">"test"</span>;  </div><div class="line">      WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);  </div><div class="line">      str=<span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNull(weakReference.get());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Phantom reference</li>
</ul>
<h6 id="Mark-Sweep-Collector-标记-清除收集器）"><a href="#Mark-Sweep-Collector-标记-清除收集器）" class="headerlink" title="Mark-Sweep Collector(标记-清除收集器）"></a>Mark-Sweep Collector(标记-清除收集器）</h6><p>标记清除收集器最早由Lisp的发明人于1960年提出，标记清除收集器停止所有的工作，从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。</p>
<p><code>优点：</code><br>1.解决循环引用的问题<br>2.不需要编译器的配合，从而就不执行额外的指令<br><code>缺点：</code><br>1.每个活跃的对象都要进行扫描，收集暂停的时间比较长。</p>
<h6 id="Copying-Collector-复制收集器）"><a href="#Copying-Collector-复制收集器）" class="headerlink" title="Copying Collector(复制收集器）"></a>Copying Collector(复制收集器）</h6><p>复制收集器将内存分为两块一样大小空间，某一个时刻，只有一个空间处于活跃的状态，当活跃的空间满的时候，GC就会将活跃的对象复制到未使用的空间中去，原来不活跃的空间就变为了活跃的空间。复制收集器具体过程可以参考下图：<br><img src="/images/jvm/jvm-gc-tactics-4.jpg" alt=""><br><code>优点：</code><br>1.只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间<br><code>缺点：</code><br>1.需要额外的空间消耗，某一个时刻，总是有一块内存处于未使用状态<br>2.复制对象需要一定的开销</p>
<h6 id="Mark-Compact-Collector-标记-整理收集器）"><a href="#Mark-Compact-Collector-标记-整理收集器）" class="headerlink" title="Mark-Compact Collector(标记-整理收集器）"></a>Mark-Compact Collector(标记-整理收集器）</h6><p>标记整理收集器汲取了标记清除和复制收集器的优点，它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的的对象复制到堆得底部。标记整理收集器的过程示意图请参考下图：Mark-compact策略极大的减少了内存碎片，并且不需要像Copy Collector一样需要两倍的空间。<br><img src="/images/jvm/jvm-gc-tactics-5.jpg" alt=""></p>
<h4 id="JVM的垃圾收集策略"><a href="#JVM的垃圾收集策略" class="headerlink" title="JVM的垃圾收集策略"></a>JVM的垃圾收集策略</h4><p>GC的执行时要耗费一定的CPU资源和时间的，因此在JDK1.2以后，JVM引入了分代收集的策略，其中对新生代采用<code>&quot;Copying Collector&quot;</code>策略，而对老生代采用了<code>“Mark-Compact&quot;</code>的策略。其中新生代的垃圾收集器命名为<code>“minor gc”</code>，老生代的GC命名为<code>&quot;Full Gc</code> 或者<code>Major GC&quot;</code>.其中用<code>System.gc()</code>强制执行的是<code>Full Gc</code>.</p>
<h5 id="新生代垃圾收集"><a href="#新生代垃圾收集" class="headerlink" title="新生代垃圾收集"></a>新生代垃圾收集</h5><p>在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。</p>
<p>通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。</p>
<p>但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。</p>
<h5 id="什么是分配担保？"><a href="#什么是分配担保？" class="headerlink" title="什么是分配担保？"></a>什么是分配担保？</h5><p>当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发MinorGC，对该区域的废弃对象进行回收。但如果MinorGC过后只有少量对象被回收，仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。</p>
<h5 id="老年代垃圾收集"><a href="#老年代垃圾收集" class="headerlink" title="老年代垃圾收集"></a>老年代垃圾收集</h5><p>老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。</p>
<h5 id="方法区垃圾收集"><a href="#方法区垃圾收集" class="headerlink" title="方法区垃圾收集"></a>方法区垃圾收集</h5><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p>
<p>加载该类的ClassLoader已经被回收。</p>
<p>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading</code>查看类的加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<p>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可,转载请在正文明显处注明原文地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h3&gt;&lt;p&gt;Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="GC" scheme="http://vinoit.me/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（一）——基础</title>
    <link href="http://vinoit.me/2016/05/19/java-memory-model-basis/"/>
    <id>http://vinoit.me/2016/05/19/java-memory-model-basis/</id>
    <published>2016-05-19T00:17:16.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：<br><img src="/images/JMM/JMM-0.png" alt=""><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：<br><img src="/images/JMM/JMM-1.png" alt=""><br>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/images/JMM/JMM-2.png" alt=""><br>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Process A</th>
<th style="text-align:left">Process B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = 1; //A1 <br> x = b; //A2</td>
<td style="text-align:left">b = 2; //B1 <br> y = a; //B2</td>
</tr>
<tr>
<td style="text-align:left">初始状态：a = b = 0 <br> 处理器允许执行后得到结果：x = y = 0</td>
<td style="text-align:left">(合并行)</td>
</tr>
</tbody>
</table>
<p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：<br><img src="/images/JMM/JMM-3.png" alt=""><br>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操做重排序。</p>
<p>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sparc-TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">X86</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p>
<p>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。</p>
<ul>
<li><p>注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。</p>
</li>
<li><p>注2：上表中的x86包括x64及AMD64。</p>
</li>
<li><p>注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。</p>
</li>
<li><p>注4：数据依赖性后文会专门说明。</p>
</li>
</ul>
<p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td style="text-align:left">StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td style="text-align:left">LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td style="text-align:left">StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的happens-before规则如下：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ul>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。</p>
<p>happens-before与JMM的关系如下图所示：<br><img src="/images/JMM/JMM-4.png" alt=""><br>如上图所示，一个happens-before规则通常对应于多个编译器重排序规则和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;并发编程模型的分类&quot;&gt;&lt;a href=&quot;#并发编程模型的分类&quot; class=&quot;headerlink&quot; title=&quot;并发编程模型的分类&quot;&gt;&lt;/a&gt;并发编程模型的分类&lt;/h3&gt;&lt;p&gt;在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入解析String#intern</title>
    <link href="http://vinoit.me/2016/05/18/java-intern-in-depth-analysis/"/>
    <id>http://vinoit.me/2016/05/18/java-intern-in-depth-analysis/</id>
    <published>2016-05-18T05:24:51.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。</p>
<p>8种基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<p>接下来我们主要来谈一下String#intern方法。</p>
<h3 id="intern-的实现原理"><a href="#intern-的实现原理" class="headerlink" title="intern 的实现原理"></a>intern 的实现原理</h3><p>首先深入看一下它的实现原理。</p>
<h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a canonical representation for the string object.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * A pool of strings, initially empty, is maintained privately by the</div><div class="line"> * class &lt;code&gt;String&lt;/code&gt;.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * When the intern method is invoked, if the pool already contains a</div><div class="line"> * string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by</div><div class="line"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</div><div class="line"> * returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the</div><div class="line"> * pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * It follows that for any two strings &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;,</div><div class="line"> * &lt;code&gt;s.intern()&amp;nbsp;==&amp;nbsp;t.intern()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</div><div class="line"> * if and only if &lt;code&gt;s.equals(t)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * All literal strings and string-valued constant expressions are</div><div class="line"> * interned. String literals are defined in section 3.10.5 of the</div><div class="line"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</div><div class="line"> *          guaranteed to be from a pool of unique strings.</div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>String#intern方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p>
<h4 id="native代码"><a href="#native代码" class="headerlink" title="native代码"></a>native代码</h4><p>在 jdk7后，oracle 接管了 JAVA 的源码后就不对外开放了，根据 jdk 的主要开发人员声明 openJdk7 和 jdk7 使用的是同一分主代码，只是分支代码会有些许的变动。所以可以直接跟踪 openJdk7 的源码来探究 intern 的实现。</p>
<h5 id="native实现代码"><a href="#native实现代码" class="headerlink" title="native实现代码:"></a>native实现代码:</h5><p><code>\openjdk7\jdk\src\share\native\java\lang\String.c</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Java_java_lang_String_intern(JNIEnv *env, jobject <span class="keyword">this</span>)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> JVM_InternString(env, <span class="keyword">this</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\prims\jvm.h</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* java.lang.String</div><div class="line">*/  </div><div class="line"><span class="function">JNIEXPORT jstring JNICALL  </span></div><div class="line"><span class="title">JVM_InternString</span><span class="params">(JNIEnv *env, jstring str)</span>;</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\prims\jvm.cpp</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// String support ///////////////////////////////////////////////////////////////////////////  </span></div><div class="line">JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))  </div><div class="line">  JVMWrapper(<span class="string">"JVM_InternString"</span>);  </div><div class="line">  JvmtiVMObjectAllocEventCollector oam;  </div><div class="line">  <span class="keyword">if</span> (str == NULL) <span class="keyword">return</span> NULL;  </div><div class="line">  oop string = JNIHandles::resolve_non_null(str);  </div><div class="line">  oop result = StringTable::intern(string, CHECK_NULL);</div><div class="line">  <span class="keyword">return</span> (jstring) JNIHandles::make_local(env, result);  </div><div class="line">JVM_END</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">oop StringTable::intern(Handle string_or_null, jchar* name,  </div><div class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;  </div><div class="line">  unsigned <span class="keyword">int</span> hashValue = java_lang_String::hash_string(name, len);  </div><div class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);  </div><div class="line">  oop string = the_table()-&gt;lookup(index, name, len, hashValue);  </div><div class="line">  <span class="comment">// Found  </span></div><div class="line">  <span class="keyword">if</span> (string != NULL) <span class="keyword">return</span> string;  </div><div class="line">  <span class="comment">// Otherwise, add to symbol to table  </span></div><div class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, string_or_null, name, len,  </div><div class="line">                                hashValue, CHECK_NULL);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">oop StringTable::lookup(<span class="keyword">int</span> index, jchar* name,  </div><div class="line">                        <span class="keyword">int</span> len, unsigned <span class="keyword">int</span> hash) &#123;  </div><div class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop&gt;* l = bucket(index); l != NULL; l = l-&gt;next()) &#123;  </div><div class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;  </div><div class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;  </div><div class="line">        <span class="keyword">return</span> l-&gt;literal();  </div><div class="line">      &#125;  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> NULL;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的大体实现结构就是:<br>JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p>
<p>要注意的是，String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
<p>在 jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：</p>
<p><code>-XX:StringTableSize=99991</code></p>
<h3 id="jdk6-和-jdk7-下-intern-的区别"><a href="#jdk6-和-jdk7-下-intern-的区别" class="headerlink" title="jdk6 和 jdk7 下 intern 的区别"></a>jdk6 和 jdk7 下 intern 的区别</h3><p>相信很多 JAVA 程序员都做做类似 <code>String s = new String(&quot;abc&quot;)</code>这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。</p>
<p>来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    s.intern();</div><div class="line">    String s2 = <span class="string">"1"</span>;</div><div class="line">    System.out.println(s == s2);</div><div class="line"></div><div class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    s3.intern();</div><div class="line">    String s4 = <span class="string">"11"</span>;</div><div class="line">    System.out.println(s3 == s4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jdk6 下false false</div><div class="line">jdk7 下false true</div></pre></td></tr></table></figure></p>
<p>具体为什么稍后再解释，然后将<code>s3.intern();</code>语句下调一行，放到<code>String s4 = &quot;11&quot;;</code>后面。将<code>s.intern();</code>放到<code>String s2 = &quot;1&quot;;</code>后面。是什么结果呢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    String s2 = <span class="string">"1"</span>;</div><div class="line">    s.intern();</div><div class="line">    System.out.println(s == s2);</div><div class="line"></div><div class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    String s4 = <span class="string">"11"</span>;</div><div class="line">    s3.intern();</div><div class="line">    System.out.println(s3 == s4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jdk6 下false false</div><div class="line">jdk7 下false false</div></pre></td></tr></table></figure></p>
<h4 id="jdk6中的解释"><a href="#jdk6中的解释" class="headerlink" title="jdk6中的解释"></a>jdk6中的解释</h4><p><img src="/images/java/java-intern-in-depth-analysis-0.png" alt=""><br><code>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</code></p>
<p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern方法也是没有任何关系的。</p>
<h4 id="jdk7中的解释"><a href="#jdk7中的解释" class="headerlink" title="jdk7中的解释"></a>jdk7中的解释</h4><p>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p>
<p>正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。<br><img src="/images/java/java-intern-in-depth-analysis-1.png" alt=""></p>
<ul>
<li>在第一段代码中，先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”);，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的new String(“1”)我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li>
<li>接下来s3.intern();这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li>
<li>最后String s4 = “11”; 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 s3 == s4 是 true。</li>
<li>再看 s 和 s2 对象。 String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</li>
<li>接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。<br><img src="/images/java/java-intern-in-depth-analysis-2.png" alt=""></li>
<li>来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern(); 的顺序是放在String s4 = “11”;后了。这样，首先执行String s4 = “11”;声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern();时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。</li>
<li><p>第二段代码中的 s 和 s2 代码中，s.intern();，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(“1”);的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
</li>
<li><p>将String常量池 从 Perm 区移动到了 Java Heap区</p>
</li>
<li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。<h3 id="使用intern"><a href="#使用intern" class="headerlink" title="使用intern"></a>使用intern</h3><h4 id="intern-正确使用例子"><a href="#intern-正确使用例子" class="headerlink" title="intern 正确使用例子"></a>intern 正确使用例子</h4>接下来我们来看一下一个比较常见的使用String#intern方法的例子。</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">1000</span> * <span class="number">10000</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Integer[] DB_DATA = <span class="keyword">new</span> Integer[<span class="number">10</span>];</div><div class="line">    Random random = <span class="keyword">new</span> Random(<span class="number">10</span> * <span class="number">10000</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DB_DATA.length; i++) &#123;</div><div class="line">        DB_DATA[i] = random.nextInt();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</div><div class="line">        <span class="comment">//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span></div><div class="line">         arr[i] = <span class="keyword">new</span> String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println((System.currentTimeMillis() - t) + <span class="string">"ms"</span>);</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行的参数是：-Xmx2g -Xms2g -Xmn1500M 上述代码是一个演示代码，其中有两条语句不一样，一条是使用 intern，一条是未使用 intern。结果如下图</p>
<p><code>2160ms</code><br><img src="/images/java/java-intern-in-depth-analysis-3.png" alt=""><br><code>826ms</code><br><img src="/images/java/java-intern-in-depth-analysis-4.png" alt=""><br>通过上述结果，我们发现不使用 intern 的代码生成了1000w 个字符串，占用了大约640m 空间。 使用了 intern 的代码生成了1345个字符串，占用总空间 133k 左右。其实通过观察程序中只是用到了10个字符串，所以准确计算后应该是正好相差100w 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。</p>
<p>细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 new String 后，然后又进行 intern 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 intern 占用空间导致 jvm 垃圾回收的时间是要远远大于这点时间的。 毕竟这里使用了1000w次intern 才多出来1秒钟多的时间。</p>
<h4 id="intern-不当使用"><a href="#intern-不当使用" class="headerlink" title="intern 不当使用"></a>intern 不当使用</h4><p>看过了 intern 的使用和 intern 的原理等，我们来看一个不当使用 intern 操作导致的问题。</p>
<p>在使用 fastjson 进行接口读取的时候，我们发现在读取了近70w条数据后，我们的日志打印变的非常缓慢，每打印一次日志用时30ms左右，如果在一个请求中打印2到3条日志以上会发现请求有一倍以上的耗时。在重新启动 jvm 后问题消失。继续读取接口后，问题又重现。接下来我们看一下出现问题的过程。</p>
<h5 id="根据-log4j-打印日志查找问题原因"><a href="#根据-log4j-打印日志查找问题原因" class="headerlink" title="根据 log4j 打印日志查找问题原因"></a>根据 log4j 打印日志查找问题原因</h5><p>在使用<code>log4j#info</code>打印日志的时候时间非常长。所以使用 housemd 软件跟踪 info 方法的耗时堆栈。</p>
<ul>
<li>trace SLF4JLogger.</li>
<li>trace AbstractLoggerWrapper:</li>
<li>trace AsyncLogger<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">org/apache/logging/log4j/core/async/AsyncLogger.actualAsyncLog(RingBufferLogEvent)                sun.misc.Launcher$AppClassLoader@<span class="number">109</span>aca82            <span class="number">1</span>            <span class="number">1</span>ms    org.apache.logging.log4j.core.async.AsyncLogger@<span class="number">19</span>de86bb  </div><div class="line">org/apache/logging/log4j/core/async/AsyncLogger.location(String)                                  sun.misc.Launcher$AppClassLoader@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">30</span>ms    org.apache.logging.log4j.core.async.AsyncLogger@<span class="number">19</span>de86bb  </div><div class="line">org/apache/logging/log4j/core/async/AsyncLogger.log(Marker, String, Level, Message, Throwable)    sun.misc.Launcher$AppClassLoader@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">61</span>ms    org.apache.logging.log4j.core.async.AsyncLogger@<span class="number">19</span>de86bb</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代码出在 <code>AsyncLogger.location</code> 这个方法上. 里边主要是调用了 <code>return Log4jLogEvent.calcLocation(fqcnOfLogger);</code>和<code>Log4jLogEvent.calcLocation()</code></p>
<p><code>Log4jLogEvent.calcLocation()</code>的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StackTraceElement <span class="title">calcLocation</span><span class="params">(<span class="keyword">final</span> String fqcnOfLogger)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (fqcnOfLogger == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">final</span> StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();  </div><div class="line">    <span class="keyword">boolean</span> next = <span class="keyword">false</span>;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> StackTraceElement element : stackTrace) &#123;  </div><div class="line">        <span class="keyword">final</span> String className = element.getClassName();  </div><div class="line">        <span class="keyword">if</span> (next) &#123;  </div><div class="line">            <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </div><div class="line">                <span class="keyword">continue</span>;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> element;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </div><div class="line">            next = <span class="keyword">true</span>;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NOT_AVAIL.equals(className)) &#123;  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过跟踪发现是 <code>Thread.currentThread().getStackTrace();</code> 的问题。</p>
<h5 id="跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern"><a href="#跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern" class="headerlink" title="跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern"></a>跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern</h5><p><code>Thread.currentThread().getStackTrace();native</code>的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;  </div><div class="line">        <span class="comment">// check for getStackTrace permission  </span></div><div class="line">        SecurityManager security = System.getSecurityManager();  </div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;  </div><div class="line">            security.checkPermission(  </div><div class="line">                SecurityConstants.GET_STACK_TRACE_PERMISSION);  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// optimization so we do not call into the vm for threads that  </span></div><div class="line">        <span class="comment">// have not yet started or have terminated  </span></div><div class="line">        <span class="keyword">if</span> (!isAlive()) &#123;  </div><div class="line">            <span class="keyword">return</span> EMPTY_STACK_TRACE;  </div><div class="line">        &#125;        StackTraceElement[][] stackTraceArray = dumpThreads(<span class="keyword">new</span> Thread[] &#123;<span class="keyword">this</span>&#125;);  </div><div class="line">        StackTraceElement[] stackTrace = stackTraceArray[<span class="number">0</span>];  </div><div class="line">        <span class="comment">// a thread that was alive during the previous isAlive call may have  </span></div><div class="line">        <span class="comment">// since terminated, therefore not having a stacktrace.  </span></div><div class="line">        <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;  </div><div class="line">            stackTrace = EMPTY_STACK_TRACE;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> stackTrace;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="comment">// Don't need JVM help for current thread  </span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Exception()).getStackTrace();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</div></pre></td></tr></table></figure></p>
<p>下载 openJdk7的源码查询 jdk 的 native 实现代码，列表如下【这里因为篇幅问题，不详细罗列涉及到的代码，有兴趣的可以根据文件名称和行号查找相关代码】：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\openjdk7\jdk\src\share\native\java\lang\Thread.c</div><div class="line">\openjdk7\hotspot\src\share\vm\prims\jvm.h line:294:</div><div class="line">\openjdk7\hotspot\src\share\vm\prims\jvm.cpp line:4382-4414:</div><div class="line">\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:235-267:</div><div class="line">\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:566-577:</div><div class="line">\openjdk7\hotspot\src\share\vm\classfile\javaClasses.cpp line:1635-[1651,1654,1658]:</div></pre></td></tr></table></figure></p>
<p>完成跟踪了底层的 jvm 源码后发现，是下边的三条代码引发了整个程序的变慢问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">oop classname = StringTable::intern((<span class="keyword">char</span>*) str, CHECK_0);  </div><div class="line">oop methodname = StringTable::intern(method-&gt;name(), CHECK_0);  </div><div class="line">oop filename = StringTable::intern(source, CHECK_0);</div></pre></td></tr></table></figure></p>
<p>这三段代码是获取类名、方法名、和文件名。因为类名、方法名、文件名都是存储在字符串常量池中的，所以每次获取它们都是通过String#intern方法。但没有考虑到的是默认的 StringPool 的长度是1009且不可变的。因此一旦常量池中的字符串达到的一定的规模后，性能会急剧下降。</p>
<h5 id="fastjson-不当使用-String-intern"><a href="#fastjson-不当使用-String-intern" class="headerlink" title="fastjson 不当使用 String#intern"></a>fastjson 不当使用 String#intern</h5><p>导致这个 intern 变慢的原因是因为 fastjson 对String#intern方法的使用不当造成的。跟踪 fastjson 中的实现代码发现，<br><code>com.alibaba.fastjson.parser.JSONScanner#scanFieldSymbol()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ch == <span class="string">'\"'</span>) &#123;</div><div class="line">    bp = index;</div><div class="line">    <span class="keyword">this</span>.ch = ch = buf[bp];</div><div class="line">    strVal = symbolTable.addSymbol(buf, start, index - start - <span class="number">1</span>, hash);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>com.alibaba.fastjson.parser.SymbolTable#addSymbol():</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a new entry from the specified symbol information and next entry reference.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> hash, Entry next)</span></span>&#123;</div><div class="line">    characters = <span class="keyword">new</span> <span class="keyword">char</span>[length];</div><div class="line">    System.arraycopy(ch, offset, characters, <span class="number">0</span>, length);</div><div class="line">    symbol = <span class="keyword">new</span> String(characters).intern();</div><div class="line">    <span class="keyword">this</span>.next = next;</div><div class="line">    <span class="keyword">this</span>.hashCode = hash;</div><div class="line">    <span class="keyword">this</span>.bytes = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>fastjson 中对所有的 json 的 key 使用了 intern 方法，缓存到了字符串常量池中，这样每次读取的时候就会非常快，大大减少时间和空间。而且 json 的 key 通常都是不变的。这个地方没有考虑到大量的 json key 如果是变化的，那就会给字符串常量池带来很大的负担。</p>
<p>这个问题 fastjson 在1.1.24版本中已经将这个漏洞修复了。程序加入了一个最大的缓存大小，超过这个大小后就不会再往字符串常量池中放了。</p>
<p>[1.1.24版本的com.alibaba.fastjson.parser.SymbolTable#addSymbol() Line:113]代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE           = <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (size &gt;= MAX_SIZE) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer, offset, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个问题是70w 数据量时候的引发的，如果是几百万的数据量的话可能就不只是30ms 的问题了。因此在使用系统级提供的String#intern方式一定要慎重！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文大体的描述了 String#intern和字符串常量池的日常使用，jdk 版本的变化和String#intern方法的区别，以及不恰当使用导致的危险等内容，让大家对系统级别的 String#intern有一个比较深入的认识。让我们在使用和接触它的时候能避免出现一些 bug，增强系统的健壮性。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>以下是几个比较关键的几篇博文。感谢！</p>
<ul>
<li>Save Memory by Using String Intern in Java</li>
<li>Java String array: is there a size of method?</li>
<li>Understanding String Table Size in HotSpot</li>
<li>How is Java’s String#intern() method implemented?</li>
<li>JDK7里的String.intern的变化</li>
</ul>
<p>原文地址：<a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">http://tech.meituan.com/in_depth_understanding_string_intern.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="string" scheme="http://vinoit.me/tags/string/"/>
    
      <category term="intern" scheme="http://vinoit.me/tags/intern/"/>
    
  </entry>
  
  <entry>
    <title>java参数传递（值传递还是引用传递）</title>
    <link href="http://vinoit.me/2016/05/18/java-parameters-transfer/"/>
    <id>http://vinoit.me/2016/05/18/java-parameters-transfer/</id>
    <published>2016-05-18T02:36:52.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的参数传递机制一直以来大家都争论不休，究竟是“传值”还是“传址（传引用）”，争论的双方各执一词，互不相让。不但“菜鸟”们一头雾水，一些“老鸟”也只知道结果却说不出所以然来。我相信看过下面的内容后，你就会明白一些。</p>
<p>先看基本类型作为参数传递的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</div><div class="line">    System.out.println(<span class="string">"Before change, n = "</span> + n);</div><div class="line">    changeData(n);</div><div class="line">    System.out.println(<span class="string">"After changeData(n), n = "</span> + n);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</div><div class="line">   n = <span class="number">10</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我想这个例子大家都明白，基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的，输出的结果证明了这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, n = 3</div><div class="line">After changeData(n), n = 3</div></pre></td></tr></table></figure></p>
<p>那么，我们现在来看看对象作为参数传递的例子，这也是大家争论的地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello "</span>);</div><div class="line">          System.out.println(<span class="string">"Before change, sb = "</span> + sb);</div><div class="line">          changeData(sb);</div><div class="line">          System.out.println(<span class="string">"After changeData(n), sb = "</span> + sb);</div><div class="line">    &#125;                                                                      </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</div><div class="line">          strBuf.append(<span class="string">"World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, sb = Hello</div><div class="line">After changeData(n), sb = Hello World!</div></pre></td></tr></table></figure></p>
<p>从结果来看，sb的值被改变了，那么是不是可以说：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。从上面例子的输出结果来看，这样解释是合理。</p>
<p>现在我们对上面的例子稍加改动一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello "</span>);</div><div class="line">          System.out.println(<span class="string">"Before change, sb = "</span> + sb);</div><div class="line">          changeData(sb);</div><div class="line">          System.out.println(<span class="string">"After changeData(n), sb = "</span> + sb);</div><div class="line">    &#125;                                                                                                                                                                                                                     </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</div><div class="line">           strBuf = <span class="keyword">new</span> StringBuffer(<span class="string">"Hi "</span>);</div><div class="line">           strBuf.append(<span class="string">"World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按照上面例子的经验：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。你会认为应该输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, sb = Hello</div><div class="line">After changeData(n), sb = Hi World!</div></pre></td></tr></table></figure></p>
<p>但运行一下这个程序，你会发现结果是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, sb = Hello</div><div class="line">After changeData(n), sb = Hello</div></pre></td></tr></table></figure></p>
<p>这就是让人迷惑的地方，对象作为参数传递时，同样是在方法内改变了对象的值，为什么有的是改变了原对象的值，而有的并没有改变原对象的值呢？这时候究竟是“传值”还是“传引用”呢？</p>
<p>下面就让我们仔细分析一下，来揭开这中间的奥秘吧。</p>
<p>先看Test2这个程序：</p>
<p><code>StringBuffer sb = new StringBuffer(&quot;Hello &quot;);</code></p>
<p>这一句执行完后，就会在内存的堆里生成一个sb对象，请看图1：<br><img src="/images/java/java-parameter-transfer-0.jpg" alt=""><br>如图1所示，sb是一个引用，里面存放的是一个地址“@3a”（这个“@3a”是我举的代表内存地址的例子，你只需知道是个内存地址就行了），而这个地址正是“Hello ”这个字符串在内存中的地址。<br><code>changeData(sb);</code><br>执行这一句后，就把<code>sb</code>传给了<code>changeData</code>方法中的<code>StringBuffer strBuf</code>，由于<code>sb</code>中存放的是地址，所以，<code>strBuf</code>中也将存放相同的地址，请看图2：<br><img src="/images/java/java-parameter-transfer-1.jpg" alt=""><br>此时，<code>sb</code>和<code>strBuf</code>中由于存放的内存地址相同，因此都指向了“Hello”。</p>
<p><code>strBuf.append(&quot;World!&quot;);</code></p>
<p>执行<code>changeData</code>方法中的这一句后，改变了<code>strBuf</code>指向的内存中的值，如下图3所示：<br><img src="/images/java/java-parameter-transfer-2.jpg" alt=""><br>所以，Test2 这个程序最后会输出：</p>
<p><code>After changeData(n), sb = Hello World!</code></p>
<p>再看看Test3这个程序。</p>
<p>在没有执行到<code>changeData</code>方法的<code>strBuf = new StringBuffer(“Hi “);</code>之前，对象在内存中的图和上例中“图2”是一样的，而执行了<code>strBuf = new StringBuffer(“Hi “);</code>之后，则变成了：<br><img src="/images/java/java-parameter-transfer-3.jpg" alt=""><br>此时，<code>strBuf</code>中存放的不再是指向“Hello”的地址，而是指向“Hi ”的地址“@3b” （同样“@3b”是个例子）了，<code>new</code>操作符操作成功后总会在内存中新开辟一块存储区域。</p>
<p><code>strBuf.append(&quot;World!&quot;);</code></p>
<p>而执行完这句后，<br><img src="/images/java/java-parameter-transfer-4.jpg" alt=""><br>通过上图可以看到，由于sb和strBuf中存放地址不一样了，所以虽然strBuf指向的内存中的值改变了，但sb指向的内存中值并不会变，因此也就输出了下面的结果：</p>
<p><code>After changeData(n), sb = Hello</code></p>
<p>因此，你只要按上面的方法去分析，就会发现String对象和基本类型一样，一般情况下作为参数传递，在方法内改变了值，而原对象是不会被改变的。</p>
<p>综上所述，我们就会明白，在Java中对象作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。</p>
<p>你可以试着按上面的画图法分析一下下面例子的结果，看看运行结果与你分析的结果是否一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello "</span>);</div><div class="line">      System.out.println(<span class="string">"Before change, sb = "</span> + sb);</div><div class="line">      changeData(sb);</div><div class="line">      System.out.println(<span class="string">"After changeData(n), sb = "</span> + sb);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</div><div class="line">      StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">"Hi "</span>);</div><div class="line">      strBuf = sb2;</div><div class="line">      sb2.append(<span class="string">"World!"</span>);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提示：</p>
<p>执行完<code>strBuf = sb2；</code>后：<br><img src="/images/java/java-parameter-transfer-5.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的参数传递机制一直以来大家都争论不休，究竟是“传值”还是“传址（传引用）”，争论的双方各执一词，互不相让。不但“菜鸟”们一头雾水，一些“老鸟”也只知道结果却说不出所以然来。我相信看过下面的内容后，你就会明白一些。&lt;/p&gt;
&lt;p&gt;先看基本类型作为参数传递的例子：&lt;b
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="参数传递" scheme="http://vinoit.me/tags/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>java类静态域、块，非静态域、块，构造函数的初始化顺序</title>
    <link href="http://vinoit.me/2016/05/18/java-init-order/"/>
    <id>http://vinoit.me/2016/05/18/java-init-order/</id>
    <published>2016-05-18T02:21:11.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，</p>
<p>构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的<br>结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解。<br>我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序以此是<br>（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。<br>我们也可以通过下面的测试代码来验证这一点：<br>Java代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialOrderTest</span> </span>&#123;               </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;          </div><div class="line">    <span class="comment">// 变量          </span></div><div class="line">    <span class="keyword">public</span> String field = <span class="string">"变量"</span>;                  </div><div class="line">    <span class="comment">// 静态初始化块        </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(staticField);  </div><div class="line">        System.out.println(<span class="string">"静态初始化块"</span>);  </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 初始化块              </span></div><div class="line">    &#123;          </div><div class="line">        System.out.println(field);  </div><div class="line">        System.out.println(<span class="string">"初始化块"</span>);        </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 构造器          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"构造器"</span>);     </div><div class="line">    &#125;                  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">new</span> InitialOrderTest();              </div><div class="line">    &#125;          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上代码，我们会得到如下的输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">静态变量  </div><div class="line">静态初始化块  </div><div class="line">变量  </div><div class="line">初始化块  </div><div class="line">构造器</div></pre></td></tr></table></figure></p>
<p>这与上文中说的完全符合。<br>那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果：<br>Java代码 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;              </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;              </div><div class="line">    <span class="comment">// 变量          </span></div><div class="line">    <span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;                  </div><div class="line">    <span class="comment">// 静态初始化块              </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(p_StaticField);                  </div><div class="line">        System.out.println(<span class="string">"父类--静态初始化块"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 初始化块              </span></div><div class="line">    &#123;          </div><div class="line">        System.out.println(p_Field);          </div><div class="line">        System.out.println(<span class="string">"父类--初始化块"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 构造器          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"父类--构造器"</span>);              </div><div class="line">    &#125;         </div><div class="line">&#125;                  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;              </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;              </div><div class="line">    <span class="comment">// 变量          </span></div><div class="line">    <span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;              </div><div class="line">    <span class="comment">// 静态初始化块              </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(s_StaticField);                  </div><div class="line">        System.out.println(<span class="string">"子类--静态初始化块"</span>);          </div><div class="line">    &#125;          </div><div class="line">    <span class="comment">// 初始化块   </span></div><div class="line">    &#123;          </div><div class="line">        System.out.println(s_Field);          </div><div class="line">        System.out.println(<span class="string">"子类--初始化块"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 构造器          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"子类--构造器"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 程序入口          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                  </div><div class="line">        <span class="keyword">new</span> SubClass();             </div><div class="line">    &#125;          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行一下上面的代码，结果马上呈现在我们的眼前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">父类--静态变量  </div><div class="line">父类--静态初始化块  </div><div class="line">子类--静态变量  </div><div class="line">子类--静态初始化块  </div><div class="line">父类--变量  </div><div class="line">父类--初始化块  </div><div class="line">父类--构造器  </div><div class="line">子类--变量  </div><div class="line">子类--初始化块  </div><div class="line">子类--构造器</div></pre></td></tr></table></figure>
<p>现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，<br>实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。<br>那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？<br>是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。<br>我们以静态变量和静态初始化块为例来进行说明。 同样，我们还是写一个类来进行测试：    </p>
<p>Java代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOrder</span> </span>&#123;          </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestA a = <span class="keyword">new</span> TestA();                       </div><div class="line">    <span class="comment">// 静态初始化块              </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(<span class="string">"静态初始化块"</span>);              </div><div class="line">    &#125;                       </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestB b = <span class="keyword">new</span> TestB();                  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                  </div><div class="line">        <span class="keyword">new</span> TestOrder();              </div><div class="line">    &#125;          </div><div class="line">&#125;                  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;              </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"Test--A"</span>);              </div><div class="line">    &#125;          </div><div class="line">&#125;                  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;              </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"Test--B"</span>);              </div><div class="line">    &#125;          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的代码，会得到如下的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Test--A  </div><div class="line">静态初始化块  </div><div class="line">Test--B</div></pre></td></tr></table></figure></p>
<p>大家可以随意改变变量a、变量b以及静态初始化块的前后位置，就会发现输出结果随着它们在类中出现的前后顺序而改变，<br>这就说明静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。<br>了解了继承情况下类的初始化顺序之后，如何判断最终输出结果就迎刃而解了。  </p>
<p>测试函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticCon</span> </span>&#123;   </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;  </div><div class="line">      <span class="keyword">static</span> &#123;    </div><div class="line">        a = <span class="number">10</span>;  </div><div class="line">          System.out.println(<span class="string">"父类的静态代码块在执行a="</span> + a);   </div><div class="line">    &#125;     </div><div class="line">    &#123;    </div><div class="line">        a = <span class="number">8</span>;  </div><div class="line">          System.out.println(<span class="string">"父类的非静态代码块在执行a="</span> + a);   </div><div class="line">    &#125;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TestStaticCon</span><span class="params">()</span> </span>&#123;   </div><div class="line"></div><div class="line">        <span class="keyword">this</span>(<span class="string">"a在父类带参构造方法中的值："</span> + TestStaticCon.a); <span class="comment">// 调用另外一个构造方法    </span></div><div class="line">        System.out.println(a);    </div><div class="line">        System.out.println(<span class="string">"父类无参构造方法在执行a="</span> + a);   </div><div class="line">    &#125;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TestStaticCon</span><span class="params">(String n)</span> </span>&#123;    </div><div class="line">        System.out.println(n);    </div><div class="line">        System.out.println(a);  </div><div class="line">      &#125;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </div><div class="line">        TestStaticCon tsc = <span class="keyword">null</span>;  </div><div class="line">          System.out.println(<span class="string">"!!!!!!!!!!!!!!!!!!!!!"</span>);    </div><div class="line">        tsc = <span class="keyword">new</span> TestStaticCon();   </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">父类的非静态代码块在执行a=10</div><div class="line">!!!!!!!!!!!!!!!!!!!!!</div><div class="line">父类的非静态代码块在执行a=8</div><div class="line">a在父类带参构造方法中的值：10</div><div class="line">8</div><div class="line">8</div><div class="line">父类无参构造方法在执行a=8</div></pre></td></tr></table></figure></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。且执行顺序为静态代码块——非静态代码块—-构造函数。<br>扩展：静态代码块  与  静态方法：<br>一般情况下,如果有些代码必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的;<br>需要在项目启动的时候就初始化,在不创建对象的情况下,其他程序来调用的时候,需要使用静态方法,这种代码是被动执行的.<br>两者的区别就是:静态代码块是自动执行的;  静态方法是被调用的时候才执行的.  </p>
<p>作用:静态代码块可用来初始化一些项目最常用的变量或对象;静态方法可用作不创建对象也可能需要执行的代码</p>
<h4 id="阿里笔试题"><a href="#阿里笔试题" class="headerlink" title="阿里笔试题"></a>阿里笔试题</h4><p>求下面这段代码的输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test1 t1 = <span class="keyword">new</span> Test1(<span class="string">"t1"</span>);  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test1 t2 = <span class="keyword">new</span> Test1(<span class="string">"t2"</span>);  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = print(<span class="string">"i"</span>);  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">99</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = print(<span class="string">"j"</span>);  </div><div class="line">    &#123;  </div><div class="line">        print(<span class="string">"构造块"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        print(<span class="string">"静态块"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">(String str)</span></span>&#123;  </div><div class="line">        System.out.println((++k)+<span class="string">":"</span>+str+<span class="string">"    i="</span>+i+<span class="string">"    n="</span>+n);  </div><div class="line">        ++i;++n;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(String str)</span></span>&#123;  </div><div class="line">        System.out.println((++k)+<span class="string">":"</span>+str+<span class="string">"    i="</span>+i+<span class="string">"    n="</span>+n);  </div><div class="line">        ++n;  </div><div class="line">        <span class="keyword">return</span> ++i;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// TODO Auto-generated method stub  </span></div><div class="line">        Test1 t = <span class="keyword">new</span> Test1(<span class="string">"init"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">j    i=0    n=0</div><div class="line">构造块    i=1    n=1</div><div class="line">t1    i=2    n=2</div><div class="line">j    i=3    n=3</div><div class="line">构造块    i=4    n=4</div><div class="line">t2    i=5    n=5</div><div class="line">i    i=6    n=6</div><div class="line">静态块    i=7    n=99</div><div class="line">j    i=8    n=100</div><div class="line">构造块    i=9    n=101</div><div class="line">init    i=10    n=102</div></pre></td></tr></table></figure></p>
<p>原文：<a href="http://ini.iteye.com/blog/2007835" target="_blank" rel="external">http://ini.iteye.com/blog/2007835</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h4&gt;&lt;p&gt;面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，&lt;/p&gt;
&lt;p&gt;构造器里可能还有
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 虚拟内存和物理内存的理解</title>
    <link href="http://vinoit.me/2016/05/17/linux-vm-rm/"/>
    <id>http://vinoit.me/2016/05/17/linux-vm-rm/</id>
    <published>2016-05-17T13:59:06.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><ol>
<li>每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。</li>
<li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录。</li>
<li>每个进程已经分配的内存空间，都与对应的磁盘空间映射。<br><img src="/images/linux/linux-vm-rm-0.png" alt=""></li>
</ol>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><ol>
<li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。</li>
<li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li>
<li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录。</li>
<li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。</li>
<li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常。</li>
<li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。<br><img src="/images/linux/linux-vm-rm-1.png" alt=""></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>优点：</p>
<ol>
<li>既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处</li>
<li>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</li>
<li>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</li>
</ol>
<p>另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如<code>.text</code> <code>.data</code>段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如<code>malloc</code>时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<h4 id="补充理解"><a href="#补充理解" class="headerlink" title="补充理解"></a>补充理解</h4><p>虚拟存储器涉及三个概念： 虚拟存储空间，磁盘空间，内存空间<br><img src="/images/linux/linux-vm-rm-2.png" alt=""><br>可以认为虚拟空间都被映射到了磁盘空间中，（事实上也是按需要映射到磁盘空间上，通过mmap），并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。</p>
<p><code>mmap</code>是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过<code>manmap</code>可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这也是一种读写磁盘文件的方法，也是一种进程共享数据的方法 共享内存</p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p>在内核态申请内存比在用户态申请内存要更为直接，它没有采用用户态那种延迟分配内存技术。内核认为一旦有内核函数申请内存，那么就必须立刻满足该申请内存的请求，并且这个请求一定是正确合理的。相反，对于用户态申请内存的请求，内核总是尽量延后分配物理内存，用户进程总是先获得一个虚拟内存区的使用权，最终通过缺页异常获得一块真正的物理内存。</p>
<h4 id="物理内存的内核映射"><a href="#物理内存的内核映射" class="headerlink" title="物理内存的内核映射"></a>物理内存的内核映射</h4><p>IA32架构中内核虚拟地址空间只有1GB大小（从3GB到4GB），因此可以直接将1GB大小的物理内存（即常规内存）映射到内核地址空间，但超出1GB大小的物理内存（即高端内存）就不能映射到内核空间。为此，内核采取了下面的方法使得内核可以使用所有的物理内存。</p>
<p>1). 高端内存不能全部映射到内核空间，也就是说这些物理内存没有对应的线性地址。不过，内核为每个物理页框都分配了对应的页框描述符，所有的页框描述符都保存在mem_map数组中，因此每个页框描述符的线性地址都是固定存在的。内核此时可以使用alloc_pages()和alloc_page()来分配高端内存，因为这些函数返回页框描述符的线性地址。</p>
<p>2). 内核地址空间的后128MB专门用于映射高端内存，否则，没有线性地址的高端内存不能被内核所访问。这些高端内存的内核映射显然是暂时映射的，否则也只能映射128MB的高端内存。当内核需要访问高端内存时就临时在这个区域进行地址映射，使用完毕之后再用来进行其他高端内存的映射。</p>
<p>由于要进行高端内存的内核映射，因此直接能够映射的物理内存大小只有896MB，该值保存在high_memory中。内核地址空间的线性地址区间如下图所示：<br><img src="/images/linux/linux-vm-rm-3.png" alt=""><br>从图中可以看出，内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。</p>
<h4 id="物理内存管理机制"><a href="#物理内存管理机制" class="headerlink" title="物理内存管理机制"></a>物理内存管理机制</h4><p>基于物理内存在内核空间中的映射原理，物理内存的管理方式也有所不同。内核中物理内存的管理机制主要有伙伴算法，slab高速缓存和vmalloc机制。其中伙伴算法和slab高速缓存都在物理内存映射区分配物理内存，而vmalloc机制则在高端内存映射区分配物理内存。</p>
<p><code>伙伴算法</code><br>伙伴算法负责大块连续物理内存的分配和释放，以页框为基本单位。该机制可以避免外部碎片。</p>
<p><code>per-CPU页框高速缓存</code><br>内核经常请求和释放单个页框，该缓存包含预先分配的页框，用于满足本地CPU发出的单一页框请求。</p>
<p><code>slab缓存</code><br>slab缓存负责小块物理内存的分配，并且它也作为高速缓存，主要针对内核中经常分配并释放的对象。</p>
<p><code>vmalloc机制</code><br>vmalloc机制使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大限度的使用高端物理内存。</p>
<h4 id="物理内存的分配"><a href="#物理内存的分配" class="headerlink" title="物理内存的分配"></a>物理内存的分配</h4><p>内核发出内存申请的请求时，根据内核函数调用接口将启用不同的内存分配器。</p>
<h5 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h5><p>分区页框分配器 (zoned page frame allocator) ,处理对连续页框的内存分配请求。分区页框管理器分为两大部分:前端的管理区分配器和伙伴系统，如下图：<br><img src="/images/linux/linux-vm-rm-4.png" alt=""><br>管理区分配器负责搜索一个能满足请求页框块大小的管理区。在每个管理区中,具体的页框分配工作由伙伴系统负责。为了达到更好的系统性能,单个页框的申请工作直接通过per-CPU页框高速缓存完成。</p>
<p>该分配器通过几个函数和宏来请求页框,它们之间的封装关系如下图所示。<br><img src="/images/linux/linux-vm-rm-5.png" alt=""><br>这些函数和宏将核心的分配函数<code>__alloc_pages_nodemask()</code>封装,形成满足不同分配需求的分配函数。其中，<code>alloc_pages()</code>系列函数返回物理内存首页框描述符，<code>__get_free_pages()</code>系列函数返回内存的线性地址。</p>
<h5 id="slab分配器"><a href="#slab分配器" class="headerlink" title="slab分配器"></a>slab分配器</h5><p>slab 分配器最初是为了解决物理内存的内部碎片而提出的，它将内核中常用的数据结构看做对象。slab分配器为每一种对象建立高速缓存。内核对该对象的分配和释放均是在这块高速缓存中操作。一种对象的slab分配器结构图如下：<br><img src="/images/linux/linux-vm-rm-6.png" alt=""><br>可以看到每种对象的高速缓存是由若干个slab组成，每个slab是由若干个页框组成的。虽然slab分配器可以分配比单个页框更小的内存块，但它所需的所有内存都是通过<code>伙伴算法</code>分配的。</p>
<p>slab高速缓存分专用缓存和通用缓存。专用缓存是对特定的对象，比如为内存描述符创建高速缓存。通用缓存则是针对一般情况，适合分配任意大小的物理内存，其接口即为<code>kmalloc()</code>。</p>
<h5 id="非连续内存区的分配"><a href="#非连续内存区的分配" class="headerlink" title="非连续内存区的分配"></a>非连续内存区的分配</h5><p>内核通过<code>vmalloc()</code>来申请非连续的物理内存，若申请成功，该函数返回连续内存区的起始地址，否则，返回<code>NULL</code>。<code>vmalloc()</code>和<code>kmalloc()</code>申请的内存有所不同，<code>kmalloc()</code>所申请内存的线性地址与物理地址都是连续的，而<code>vmalloc()</code>所申请的内存线性地址连续而物理地址则是离散的，两个地址之间通过内核页表进行映射。 <code>vmalloc()</code>的工作方式理解起来很简单：<br>1). 寻找一个新的连续线性地址空间；<br>2). 依次分配一组非连续的页框；<br>3). 为线性地址空间和非连续页框建立映射关系，即修改内核页表；</p>
<p><code>vmalloc()</code>的内存分配原理与用户态的内存分配相似，都是通过连续的虚拟内存来访问离散的物理内存，并且虚拟地址和物理地址之间是通过页表进行连接的，通过这种方式可以有效的使用物理内存。但是应该注意的是，<code>vmalloc()</code>申请物理内存时是立即分配的，因为内核认为这种内存分配请求是正当而且紧急的；相反，用户态有内存请求时，内核总是尽可能的延后，毕竟用户态跟内核态不在一个特权级。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h3&gt;&lt;h4 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h4&gt;&lt;o
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内存" scheme="http://vinoit.me/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》学习整理--cpu加载数据（初阶）</title>
    <link href="http://vinoit.me/2016/05/17/computer-system-roaming/"/>
    <id>http://vinoit.me/2016/05/17/computer-system-roaming/</id>
    <published>2016-05-17T09:58:53.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。</p>
<h4 id="从一条汇编指令开始"><a href="#从一条汇编指令开始" class="headerlink" title="从一条汇编指令开始"></a>从一条汇编指令开始</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movl (%ebp) %edx</div></pre></td></tr></table></figure>
<p><code>%ebp</code> 和 <code>%edx</code>这两个都是寄存器文件，处于CPU中，如图<br><img src="/images/computer-system/computer-system-all.PNG" alt=""><br>每个cpu中都有着有限数量的寄存器在，一个IA32的处理器中包含一组8个存储32位值得寄存器。<br>一般每个寄存器都会存放特定的数据，例如<code>%esp</code>是用来存放栈指针的，<code>%ebp</code>是用来存放帧指针的。</p>
<p><code>movl A B</code>指令是将A的数据移动到B（覆盖B的数据），<code>(%ebp)</code>中括号的作用是取得主存中地址为<code>%ebp</code>的值的数据。也就是说先取得<code>%ebp</code>的值，然后将该值作为一个地址，去内存中找到这个地址，获取数据，然后将这个数据赋给<code>%edx</code>。</p>
<p>现在来看看这个过程具体是什么样的：</p>
<h4 id="获取虚拟地址"><a href="#获取虚拟地址" class="headerlink" title="获取虚拟地址"></a>获取虚拟地址</h4><p>在系统的运行着的每一个进程（程序），它们所接触的都是一个虚拟内存地址，假如系统内存为4G，那么每一个进程在运行时，它都会认为自己拥有着所有的4G内存。假如这些都是物理内存地址，那么每个进程在不经意间都可能会去修改其他进程的数据，造成数据丢失。所以我们从<code>%ebp</code>中获取到了一个虚拟地址。</p>
<h4 id="翻译虚拟地址"><a href="#翻译虚拟地址" class="headerlink" title="翻译虚拟地址"></a>翻译虚拟地址</h4><p>获取到虚拟地址之后，需要将虚拟地址转换为物理地址。这时候用到了页表和TLB，这个时候如果页表命中，则将物理地址返回。如果不命中，将产生缺页异常，需要从磁盘中获取数据，并将数据加载到主存，然后将对应地址记录到页表中。接着翻译机制再从页表中获取物理地址。具体细节以后再整理。</p>
<h4 id="根据物理地址获取数据"><a href="#根据物理地址获取数据" class="headerlink" title="根据物理地址获取数据"></a>根据物理地址获取数据</h4><p>cache中存放着主存中的数据，如果缓存命中，则直接将缓存中的数据返回。如果不命中，则cache从主存中获取值，存放到本地（cache）。cpu再向cache发送一次请求，cache将数据发给cpu。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上是一个很粗糙的cpu加载数据的流程，但是基本上几个核心都提到了，以后整理细节的时候就根据这个流程来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="理解计算机" scheme="http://vinoit.me/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件描述符与打开文件之间的关系</title>
    <link href="http://vinoit.me/2016/05/17/linux-fd-file/"/>
    <id>http://vinoit.me/2016/05/17/linux-fd-file/</id>
    <published>2016-05-17T04:37:06.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。<code>POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。</code>标准文件描述符图如下：<br><img src="/images/linux/linux-fd-file-0.png" alt=""><br>文件描述与打开的文件对应模型如下图：<br><img src="/images/linux/linux-fd-file-1.png" alt=""></p>
<h4 id="文件描述限制"><a href="#文件描述限制" class="headerlink" title="文件描述限制"></a>文件描述限制</h4><p>在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用<code>sysctl -a | grep fs.file-max</code>命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用<code>ulimit -n</code>命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看<a href="http://blog.csdn.net/kumu_linux/article/details/7877770。" target="_blank" rel="external">http://blog.csdn.net/kumu_linux/article/details/7877770。</a></p>
<h4 id="文件描述符合打开文件之间的关系"><a href="#文件描述符合打开文件之间的关系" class="headerlink" title="文件描述符合打开文件之间的关系"></a>文件描述符合打开文件之间的关系</h4><p>每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。</p>
<ol>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ol>
<p>进程级的描述符表的每一条目记录了单个文件描述符的相关信息。</p>
<ul>
<li>控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即<code>close-on-exec</code>标志）</li>
<li>对打开文件句柄的引用</li>
</ul>
<p>内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示：<br>当前文件偏移量（调用<code>read()</code>和<code>write()</code>时更新，或使用<code>lseek()</code>直接修改）</p>
<pre><code>1. 当前文件偏移量（调用`read()`和`write()`时更新，或使用`lseek()`直接修改）
2. 打开文件时所使用的状态标识（即，`open()`的flags参数）
3. 文件访问模式（如调用`open()`时所设置的只读模式、只写模式或读写模式）
4. 与信号驱动相关的设置
5. 对该文件i-node对象的引用
6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限
7. 一个指针，指向该文件所持有的锁列表
8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
</code></pre><p>下图展示了文件描述符、打开的文件句柄以及i-node之间的关系，图中，两个进程拥有诸多打开的文件描述符。<br><img src="/images/linux/linux-fd-file-2.png" alt=""><br>在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用<code>dup()</code>、<code>dup2()</code>、<code>fcntl()</code>或者对同一个文件多次调用了<code>open()</code>函数而形成的。<br>   进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用<code>fork()</code>后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。<br>   此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了<code>open()</code>调用。同一个进程两次打开同一个文件，也会发生类似情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
3. 要获取和修改打开的文件标志（例如：`O_APPEND、O_NONBLOCK`和`O_ASYNC`），可执行`fcntl()`的`F_GETFL`和`F_SETFL`操作，其对作用域的约束与上一条颇为类似。
4. 文件描述符标志（即，`close-on-exec`）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符
</code></pre><p>原文地址：<a href="http://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="external">http://blog.csdn.net/cywosp/article/details/38965239</a></p>
<p>参考<br>[1] <a href="http://blog.chinaunix.net/uid-20633888-id-2747146.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20633888-id-2747146.html</a><br>[2] <a href="http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html" target="_blank" rel="external">http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html</a><br>[3] <a href="http://blog.csdn.net/kumu_linux/article/details/7877770" target="_blank" rel="external">http://blog.csdn.net/kumu_linux/article/details/7877770</a><br>[4] 《Linux/UNIX系统编程手册》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="文件描述符" scheme="http://vinoit.me/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>理解git分支-远程分支</title>
    <link href="http://vinoit.me/2016/05/16/git-branch-remote/"/>
    <id>http://vinoit.me/2016/05/16/git-branch-remote/</id>
    <published>2016-05-16T11:16:26.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
<p>它们以 (remote)/(branch) 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支；但是在服务器上的分支会指向 origin/iss53 的提交。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。</p>
<h4 id="“origin”-并无特殊含义"><a href="#“origin”-并无特殊含义" class="headerlink" title="“origin” 并无特殊含义"></a>“origin” 并无特殊含义</h4><p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。<br><img src="/images/git/remote-branches-1.png" alt=""></p>
<h4 id="克隆之后的服务器与本地仓库"><a href="#克隆之后的服务器与本地仓库" class="headerlink" title="克隆之后的服务器与本地仓库"></a>克隆之后的服务器与本地仓库</h4><p>如果你在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动。<br><img src="/images/git/remote-branches-2.png" alt=""></p>
<h4 id="本地与远程的工作可以分叉"><a href="#本地与远程的工作可以分叉" class="headerlink" title="本地与远程的工作可以分叉"></a>本地与远程的工作可以分叉</h4><p>如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动origin/master 指针指向新的、更新后的位置。<br><img src="/images/git/remote-branches-3.png" alt=""></p>
<h4 id="git-fetch-更新你的远程仓库引用"><a href="#git-fetch-更新你的远程仓库引用" class="headerlink" title="git fetch 更新你的远程仓库引用"></a>git fetch 更新你的远程仓库引用</h4><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为整个 URL 的缩写。<br><img src="/images/git/remote-branches-4.png" alt=""></p>
<h4 id="添加另一个远程仓库"><a href="#添加另一个远程仓库" class="headerlink" title="添加另一个远程仓库"></a>添加另一个远程仓库</h4><p>现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支teamone/master 指向 teamone 的 master 分支。<br><img src="/images/git/remote-branches-5.png" alt=""></p>
<h3 id="远程跟踪分支-teamone-master"><a href="#远程跟踪分支-teamone-master" class="headerlink" title="远程跟踪分支 teamone/master"></a>远程跟踪分支 teamone/master</h3><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git push origin serverfix</div><div class="line">Counting objects: 24, done.</div><div class="line">Delta compression using up to 8 threads.</div><div class="line">Compressing objects: 100% (15/15), done.</div><div class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</div><div class="line">Total 24 (delta 2), reused 0 (delta 0)</div><div class="line">To https://github.com/schacon/simplegit</div><div class="line"> * [new branch]      serverfix -&gt; serverfix</div></pre></td></tr></table></figure></p>
<p>这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分，但是现在可以先把它放在儿。 你也可以运行 git push origin serverfix:serverfix，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的awesomebranch 分支。</p>
<h5 id="如何避免每次输入密码"><a href="#如何避免每次输入密码" class="headerlink" title="如何避免每次输入密码"></a>如何避免每次输入密码</h5><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p>
<p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config –global credential.helper cache 来设置它。</p>
<p>想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。</p>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin</div><div class="line">remote: Counting objects: 7, done.</div><div class="line">remote: Compressing objects: 100% (2/2), done.</div><div class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</div><div class="line">Unpacking objects: 100% (3/3), done.</div><div class="line">From https://github.com/schacon/simplegit</div><div class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</div></pre></td></tr></table></figure></p>
<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix指针。</p>
<p>可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的serverfix 分支上工作，可以将其建立在远程跟踪分支之上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b serverfix origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;serverfix&apos;</div></pre></td></tr></table></figure></p>
<p>这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。</p>
<h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;serverfix&apos;</div></pre></td></tr></table></figure></p>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b sf origin/serverfix</div><div class="line">Branch sf set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;sf&apos;</div></pre></td></tr></table></figure></p>
<p>现在，本地分支 sf 会自动从 origin/serverfix 拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -u origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div></pre></td></tr></table></figure></p>
<p>###　上游快捷方式<br>当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代git merge origin/master。</p>
<p>如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git branch -vv</div><div class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</div><div class="line">  master    1ae2a45 [origin/master] deploying index fix</div><div class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</div><div class="line">  testing   5ea463a trying something new</div></pre></td></tr></table></figure></p>
<p>这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 2 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。</p>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：$ git fetch –all; git branch -vv</p>
<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 –delete 选项的 git push命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin --delete serverfix</div><div class="line">To https://github.com/schacon/simplegit</div><div class="line"> - [deleted]         serverfix</div></pre></td></tr></table></figure></p>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;远程分支&quot;&gt;&lt;a href=&quot;#远程分支&quot; class=&quot;headerlink&quot; title=&quot;远程分支&quot;&gt;&lt;/a&gt;远程分支&lt;/h3&gt;&lt;p&gt;远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获
    
    </summary>
    
      <category term="Git" scheme="http://vinoit.me/categories/Git/"/>
    
    
      <category term="Git" scheme="http://vinoit.me/tags/Git/"/>
    
  </entry>
  
</feed>
