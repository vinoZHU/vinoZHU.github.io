<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>是非之地</title>
  <subtitle>Vino Zhu&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vinoit.me/"/>
  <updated>2016-09-16T13:16:13.000Z</updated>
  <id>http://vinoit.me/</id>
  
  <author>
    <name>Vino Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统启动流程</title>
    <link href="http://vinoit.me/2016/09/16/how-linux-start/"/>
    <id>http://vinoit.me/2016/09/16/how-linux-start/</id>
    <published>2016-09-16T11:40:21.000Z</published>
    <updated>2016-09-16T13:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文在原文地址:<a href="http://www.linux178.com/linux/linuxinit.html的基础上进行了些许修改" target="_blank" rel="external">http://www.linux178.com/linux/linuxinit.html的基础上进行了些许修改</a></p>
</blockquote>
<h4 id="Linux系统启动流程概览"><a href="#Linux系统启动流程概览" class="headerlink" title="Linux系统启动流程概览"></a>Linux系统启动流程概览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST（Power On Self Test/上电自检）--&gt;BootLoader(MBR)--&gt;Kernel(硬件探测、加载驱动、挂载根文件系统、/sbin/init)</div><div class="line">--&gt;init(/etc/inittab:设定默认级别、系统初始化脚本、启动及关闭对应级别的服务、启动终端)</div></pre></td></tr></table></figure>
<h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>计算机电源接通后，CPU默认执行<code>0ffffh:0000h</code>处的指令（8086是这样，386应该类似），而此内存地址应该存放的就是<code>BIOS ROM</code>。系统将有一个对内部各个设备进行检查的过程，这是由一个通常称之为POST（Power On Self Test/上电自检）的程序来完成，这也是BIOS程序的一个功能。完整的自检包括了对CPU、640K基本内存、1M以上的扩展内存、ROM、主板、CMOS存贮器、串并口、显示卡、软硬盘子系统及键盘的测试。在自检过程中若发现问题，系统将给出提示信息或鸣笛警告。</p>
<p>如果没有任何问题，完成自检后BIOS将按照系统CMOS设置中的启动顺序搜寻软、硬盘驱动器及CDROM、网络服务器等有效的启动驱动器 ，读入操作系统引导记录（BootLoader），然后将系统控制权交给引导记录，由引导记录完成系统的启动。如果一直没有找到可启动的设备，那么本次启动宣告失败。</p>
<h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>在上一步中，BIOS找到硬盘的MBR（位于硬盘的0磁道0扇区 大小为512字节，该区域不能被分配给任何分区），然后在MBR中寻找BootLoader（目前比较常用有LILO 和 GRUB，LILO已经不常用，BootLoader在MBR所占446字节，所以必须短小精悍，接下来64字节是分区表信息，最后2字节是用来标明该MBR是否有效），然后把BootLoader加载到内存中开始执行，BootLoader主要功能就是从硬盘找到内核文件，把内核文件加载到内存执行。</p>
<p>MBR的三部分如下:</p>
<ul>
<li>第1-446字节：BootLoader。</li>
<li>第447-510字节：分区表（Partition table）。</li>
<li>第511-512字节：主引导记录签名（0x55和0xAA）。</li>
</ul>
<p>扩充（源于阮一峰的网络日志）：</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。<br>每个主分区的16个字节，由6个部分组成：</p>
<ul>
<li>第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li>
<li>第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li>
<li>第5个字节：主分区类型。</li>
<li>第6-8个字节：主分区最后一个扇区的物理位置。</li>
<li>第9-12字节：该主分区第一个扇区的逻辑地址。</li>
<li>第13-16字节：主分区的扇区总数。</li>
</ul>
<p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。</p>
<p>疑问? 内核文件在哪里？GRUB是怎么找到内核文件？</p>
<p>内核文件（vmlinuz-2.6.18-308.el5）是位于/boot分区下（在我们给硬盘分区的时候都会把/boot单独分区），这时又有疑问了，这时候/都没有被挂载，又如何从硬盘上找到内核文件？<br><img src="/images/linux/how-linux-start-0.png" alt=""></p>
<p>这时看GRUB的配置文件/boot/grub/grub.conf 可以看到 root (hd0,0)，这一行实际上就是指定boot目录所在的位置<br>而kernel /vmlinuz-2.6.18-308.el5 ro root=LABEL=/ 这里指定的是内核文件所在的位置，而前面的/并不是真正的根，而是指的是boot目录所在的位置，那么其全路径为(hd0,0)/vmlinuz-2.6.18-308.el5,而这里的(hd0,0)指的是第1个硬盘的第1个分区，GRUB在识别硬盘的时候都是识别为hd开头的。</p>
<p>总结: GRUB 不是通过文件系统来找内核文件的，因为这时候内核还没有启动所以也不存在什么文件系统，而是直接访问硬盘的第1个硬盘第1个分区（MBR里面存在分区表）的来找到内核文件。</p>
<p>这时候又有个问题 GRUB是怎么识别分区表中这些分区的文件系统的？ 且看/boot/grub目录下的文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@server1 grub]# ll</div><div class="line">总计 257</div><div class="line">-rw-r--r-- 1 root root     63 2013-01-05 device.map</div><div class="line">-rw-r--r-- 1 root root   7584 2013-01-05 e2fs_stage1_5</div><div class="line">-rw-r--r-- 1 root root   7456 2013-01-05 fat_stage1_5</div><div class="line">-rw-r--r-- 1 root root   6720 2013-01-05 ffs_stage1_5</div><div class="line">-rw------- 1 root root    562 2013-01-05 grub.conf</div><div class="line">-rw-r--r-- 1 root root   6720 2013-01-05 iso9660_stage1_5</div><div class="line">-rw-r--r-- 1 root root   8192 2013-01-05 jfs_stage1_5</div><div class="line">lrwxrwxrwx 1 root root     11 2013-01-05 menu.lst -&gt; ./grub.conf</div><div class="line">-rw-r--r-- 1 root root   6880 2013-01-05 minix_stage1_5</div><div class="line">-rw-r--r-- 1 root root   9248 2013-01-05 reiserfs_stage1_5</div><div class="line">-rw-r--r-- 1 root root  55808 2009-03-13 splash.xpm.gz</div><div class="line">-rw-r--r-- 1 root root    512 2013-01-05 stage1</div><div class="line">-rw-r--r-- 1 root root 104988 2013-01-05 stage2</div><div class="line">-rw-r--r-- 1 root root   7072 2013-01-05 ufs2_stage1_5</div><div class="line">-rw-r--r-- 1 root root   6272 2013-01-05 vstafs_stage1_5</div><div class="line">-rw-r--r-- 1 root root   8904 2013-01-05 xfs_stage1_5</div></pre></td></tr></table></figure>
<p>其实GRUB启动是分阶段的：</p>
<p>第1个阶段  BIOS加载MBR里面的GRUB（属于第1阶段的文件），由于只有GRUB只占用446字节所以不能实现太多的功能，所以就有此阶段里面的文件来加载第1.5阶段的文件（/boot/grub下的文件）。</p>
<p>第1.5个阶段 这个阶段里面的就是加载识别文件系统的程序，来识别文件系统，不加载就无法识别文件系统，进而就找不到boot目录，由于GRUB是无法识别LVM，所以你不能把/boot分区设置为LVM，所以必须要把/boot单独分区。</p>
<p>第2个阶段 这里面才是正在的开始寻找内核的过程，然后是启动内核。</p>
<h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>在上一步中，GRUB成功找到内核文件，并把内核加载到内存，同时把/boot/initrd-2.6.18-308.el5.img这个文件也加载进来，这个文件是做什么的呢？</p>
<p>那么首先看看内核在这一步骤里面做的事情：</p>
<ol>
<li>探测硬件</li>
<li>加载驱动</li>
<li>挂载根文件系统</li>
<li>执行第一个程序/sbin/init</li>
</ol>
<p>BIOS检查硬件，而内核是会初始化硬件设备，那么首先会探测硬件（第1步），知道是什么硬件了就该加载硬件驱动程序（第2步），不然是没办法指挥着硬件工作的，关键是内核去哪里找驱动程序（驱动程序是硬盘上，是内核模块.ko存在的）而此时根文件系统还没有挂载上，怎么办？ 那可以②③对调，先挂载根文件系统，然后再加载驱动，那此时又有问题了，我不加载驱动程序又如何驱动着硬盘工作呢？ 这个陷入了是先有蛋还是有先鸡的问题了，这该如何解决？</p>
<p>这时候 这个文件/boot/initrd-2.6.18-308.el5.img（该文件是一个.gz的压缩文件） 就派上用场了，这个文件也是被GRUB加载内存当中，构建成一个虚拟的根文件系统，这个文件里面包含有硬件驱动程序（），这个文件是可以展开如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@server1 boot]# cp initrd-2.6.18-308.el5.img ~</div><div class="line">[root@server1 boot]# cd</div><div class="line">[root@server1 ~]# ls</div><div class="line">initrd-2.6.18-308.el5.img</div><div class="line">[root@server1 ~]# mv initrd-2.6.18-308.el5.img initrd-2.6.18-308.el5.img.gz</div><div class="line">[root@server1 ~]# gzip -d initrd-2.6.18-308.el5.img.gz</div><div class="line">[root@server1 ~]# ls</div><div class="line">initrd-2.6.18-308.el5.img</div><div class="line">[root@server1 ~]# file initrd-2.6.18-308.el5.img</div><div class="line">initrd-2.6.18-308.el5.img: ASCII cpio archive (SVR4 with no CRC) 可以看到此时是一个cpio的归档文件</div><div class="line">[root@server1 ~]# mkdir test</div><div class="line">[root@server1 ~]# mv initrd-2.6.18-308.el5.img  test</div><div class="line">[root@server1 ~]# cd test</div><div class="line">[root@server1 test]# ls</div><div class="line">initrd-2.6.18-308.el5.img</div><div class="line">[root@server1 test]# cpio -id &lt; initrd-2.6.18-308.el5.img  利用cpio来展开该文件</div><div class="line">12111 blocks</div><div class="line">[root@server1 test]# ls</div><div class="line">bin  dev  etc  init  initrd-2.6.18-308.el5.img  lib  proc  sbin  sys  sysroot</div><div class="line">[root@server1 test]# mv initrd-2.6.18-308.el5.img ../</div><div class="line">[root@server1 test]# ls  可以看到这不就是跟真实的根很像吗</div><div class="line">bin  dev  etc  init  lib  proc  sbin  sys  sysroot</div><div class="line">[root@server1 test]# ls lib/    可以看到这目录下包含了ext3.ko的内核模块，该模块就可以驱动着硬盘进行工作了</div><div class="line">ata_piix.ko            dm-mod.ko              ext3.ko                mptbase.ko             scsi_mod.ko</div><div class="line">dm-log.ko              dm-raid45.ko           firmware/              mptscsih.ko            scsi_transport_spi.ko</div><div class="line">dm-mem-cache.ko        dm-region_hash.ko      jbd.ko                 mptspi.ko              sd_mod.ko</div><div class="line">dm-message.ko          ehci-hcd.ko            libata.ko              ohci-hcd.ko            uhci-hcd.ko</div><div class="line">[root@server1 test]#</div></pre></td></tr></table></figure>
<p>至此内核利用虚拟的根文件系统的ext3.ko内核模块，驱动了硬盘，然后挂载了真正的根文件系统，那么此时虚拟的根文件系统是否还有作用，它还可以挂载/proc文件系统等操作。</p>
<p>此阶段中最后一个步骤 由内核来启动第一个程序/sbin/init，启动好之后剩下的工作就有init进程来完成了。</p>
<h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>init进程首先会读取/etc/inittab文件，根据inittab文件中的内容依次执行</p>
<p>设定系统运行的默认级别（id:3:initdefault:）<br>执行系统初始化脚本文件（si::sysinit:/etc/rc.d/rc.sysinit）<br>执行在该运行级别下所启动或关闭对应的服务（l3:3:wait:/etc/rc.d/rc 3）<br>启动6个虚拟终端:</p>
<ul>
<li>l0:0:wait:/etc/rc.d/rc 0</li>
<li>l1:1:wait:/etc/rc.d/rc 1</li>
<li>l2:2:wait:/etc/rc.d/rc 2</li>
<li>l3:3:wait:/etc/rc.d/rc 3</li>
<li>l4:4:wait:/etc/rc.d/rc 4</li>
<li>l5:5:wait:/etc/rc.d/rc 5</li>
<li>l6:6:wait:/etc/rc.d/rc 6</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文在原文地址:&lt;a href=&quot;http://www.linux178.com/linux/linuxinit.html的基础上进行了些许修改&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.linux178
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="Boot" scheme="http://vinoit.me/tags/Boot/"/>
    
      <category term="GRUB" scheme="http://vinoit.me/tags/GRUB/"/>
    
  </entry>
  
  <entry>
    <title>JNI探秘--FileDescriptor、FileInputStream 解惑</title>
    <link href="http://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/"/>
    <id>http://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/</id>
    <published>2016-09-14T01:13:07.000Z</published>
    <updated>2016-09-14T06:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>使用JAVA读取文件时需要用到<code>FileInputStream</code>这个类，最简单的使用方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">            System.out.println(fileInputStream.read());</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>FileInputStream</code>源码中的构造方法一共有3个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            security.checkRead(name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (file.isInvalid()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</div><div class="line">        &#125;</div><div class="line">        fd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">        fd.attach(<span class="keyword">this</span>);</div><div class="line">        path = name;</div><div class="line">        open(name);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            security.checkRead(fdObj);</div><div class="line">        &#125;</div><div class="line">        fd = fdObj;</div><div class="line">        path = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * FileDescriptor is being shared by streams.</div><div class="line">         * Register this stream with FileDescriptor tracker.</div><div class="line">         */</div><div class="line">        fd.attach(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>fd</code>和<code>path</code>定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File Descriptor - handle to the open file */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The path of the referenced file</div><div class="line">   * (null if the stream is created with a file descriptor)</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String path;</div></pre></td></tr></table></figure>
<p>参数为<code>String name</code>或者<code>File file</code>的构造方法都新建了一个<code>fileDescriptor</code>,并赋值给<code>fd</code>，而参数为<code>FileDescriptor fdObj</code>的构造方法直接将<code>fdObj</code>参数赋值给<code>fd</code>。其实从这里可以感觉出<code>FileDescriptor</code>(文件描述符)是JAVA中的文件操作核心。</p>
<h4 id="疑惑一"><a href="#疑惑一" class="headerlink" title="疑惑一"></a>疑惑一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException </span>&#123;</div><div class="line"></div><div class="line">        FileDescriptor fileDescriptor = <span class="keyword">null</span>;</div><div class="line">        FileDescriptor fileDescriptor1 = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">        FileInputStream fileInputStream1 = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">        </div><div class="line">        System.out.println(fileInputStream.getFD().valid());</div><div class="line">        System.out.println(fileInputStream1.getFD().valid());</div><div class="line">        fileDescriptor = fileInputStream.getFD();</div><div class="line">        fileDescriptor1 = fileInputStream1.getFD();</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<p>其中<code>fileDescriptor</code>和<code>fileDescriptor1</code>的值分别为:<br><img src="/images/JNI/FileDescriptor-and-FileInputStream-0.png" alt=""><br>查看<code>FileDescriptor</code>的源码，2个构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  <span class="title">FileDescriptor</span><span class="params">()</span> </span>&#123;</div><div class="line">    fd = -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span>  <span class="title">FileDescriptor</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.fd = fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>FileDescriptor</code>中的<code>fd</code>是一个<code>int</code>类型的值。<code>FileDescriptor</code>源码中只有一个public的构造方法，而且<code>fd</code>的初始值为<code>-1</code>,但是<code>FileInputStream</code>中的<code>fd</code>(FileDescriptor类型)的<code>fd</code>值通过调试看到不为<code>-1</code>（2个fd是包含的关系）。输出<code>true</code>的条件就是<code>fd != -1</code>。</p>
<h4 id="疑惑一解密"><a href="#疑惑一解密" class="headerlink" title="疑惑一解密"></a>疑惑一解密</h4><p>在参数为<code>File file</code>的构造方法的最后调用了一个<code>open</code>方法，初步怀疑在这个方法内改变了<code>fd</code>的内容。通过打断点调试，的确在<code>open</code>方法调用之后<code>fd</code>的值改变了。<code>open</code>方法的最终调用为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>;</div></pre></td></tr></table></figure>
<p>可以看到是一个<code>native</code>方法，对应的JNI方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileInputStream_open</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path)</span> &#123;</div><div class="line">    fileOpen(env, <span class="keyword">this</span>, path, fis_fd, O_RDONLY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>env</code>是JNI的一个对象，<code>this</code>表示调用<code>open</code>方法的<code>FileInputStream</code>对象，<code>path</code>为传进来的参数（文件名）,<code>O_RDONLY</code>表示只读，<code>fis_fd</code>是在JNI中定义的一个变量:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">jfieldID fis_fd; <span class="comment">/* id for jobject 'fd' in java.io.FileInputStream */</span></div><div class="line"></div><div class="line"><span class="comment">/**************************************************************</span></div><div class="line"> * static methods to store field ID's in initializers</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileInputStream_initIDs</span><span class="params">(JNIEnv *env, jclass fdClass)</span> &#123;</div><div class="line">    fis_fd = (*env)-&gt;GetFieldID(env, fdClass, <span class="string">"fd"</span>, <span class="string">"Ljava/io/FileDescriptor;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fis_fd</code>通过<code>Java_java_io_FileInputStream_initIDs</code>方法初始化，该方法对应了<code>FileInputStream</code>如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">        initIDs();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以，在<code>FileInputStream</code>类加载阶段，<code>fis_fd</code>就被初始化了，<code>fid_fd</code>相当于是<code>fd</code>字段的一个内存偏移量。<code>open</code>方法直接调用了<code>fileOpen</code>方法，<code>fileOpen</code>方法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">fileOpen</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path, jfieldID fid, <span class="keyword">int</span> flags)</span></div><div class="line">&#123;</div><div class="line">    WITH_PLATFORM_STRING(env, path, ps) &#123;</div><div class="line">        FD fd;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__) || defined(_ALLBSD_SOURCE)</span></div><div class="line">        <span class="comment">/* Remove trailing slashes, since the kernel won't */</span></div><div class="line">        <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)ps + <span class="built_in">strlen</span>(ps) - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> ((p &gt; ps) &amp;&amp; (*p == <span class="string">'/'</span>))</div><div class="line">            *p-- = <span class="string">'\0'</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        fd = handleOpen(ps, flags, <span class="number">0666</span>);</div><div class="line">        <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</div><div class="line">            SET_FD(<span class="keyword">this</span>, fd, fid);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            throwFileNotFoundException(env, path);</div><div class="line">        &#125;</div><div class="line">    &#125; END_PLATFORM_STRING(env, ps);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>handleOpen</code>函数打开了一个文件句柄（一个数字），相当于和文件建立了联系，并且将返回的句柄赋值给了局部变量<code>fd</code>,然后调用了<code>SET_FD</code>宏:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_FD(this, fd, fid) \</span></div><div class="line">    <span class="meta-keyword">if</span> ((*env)-&gt;GetObjectField(env, (this), (fid)) != NULL) \</div><div class="line">        (*env)-&gt;SetIntField(env, (*env)-&gt;GetObjectField(env, (this), (fid)),IO_fd_fdID, (fd))</div></pre></td></tr></table></figure>
<p>该函数首先判断FileInputStream这个对象的fd属性是不是空，如果不为空，则进行赋值。<code>fd</code>是刚得到的文件句柄，<code>(*env)-&gt;GetObjectField(env, (this), (fid))</code>是<code>FileInputStream</code>对象的<code>fd</code>字段。但是句柄<code>fd</code>是<code>int</code>类型的，而<code>FileInputStream</code>对象的<code>fd</code>字段是<code>FileDescriptor</code>类型的，如何赋值?理所当然，我们需要一个偏移量，一个<code>FileDescriptor</code>中的<code>fd</code>字段的偏移量，也就是<code>IO_fd_fdID</code>的值。<code>IO_fd_fdID</code>是在<code>FileDescriptor</code>对应JNI代码的一个变量，在类加载时期初始化,通过静态代码块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">        initIDs();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对应的<code>native</code>方法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* field id for jint 'fd' in java.io.FileDescriptor */</span></div><div class="line">jfieldID IO_fd_fdID;</div><div class="line"></div><div class="line"><span class="comment">/**************************************************************</span></div><div class="line"> * static methods to store field ID's in initializers</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileDescriptor_initIDs</span><span class="params">(JNIEnv *env, jclass fdClass)</span> &#123;</div><div class="line">    IO_fd_fdID = (*env)-&gt;GetFieldID(env, fdClass, <span class="string">"fd"</span>, <span class="string">"I"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可得，调用<code>open</code>方法之后，<code>FileInputSream</code>对象的<code>fd</code>的值被改变了。</p>
<h4 id="疑惑二"><a href="#疑惑二" class="headerlink" title="疑惑二"></a>疑惑二</h4><p>既然<code>FileDescriptor</code>是文件操作的核心，那么<code>read</code>方法调用又是怎么和它联系起来的？</p>
<h4 id="疑惑二解密"><a href="#疑惑二解密" class="headerlink" title="疑惑二解密"></a>疑惑二解密</h4><p><code>FileInputStream</code>中的<code>read</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> read0();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<p>对应的<code>native</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jint JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileInputStream_read</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span> &#123;</div><div class="line">    <span class="keyword">return</span> readSingle(env, <span class="keyword">this</span>, fis_fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readSingle()</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">jint</span></div><div class="line"><span class="title">readSingle</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jfieldID fid)</span> &#123;</div><div class="line">    jint nread;</div><div class="line">    <span class="keyword">char</span> ret;</div><div class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fid);</div><div class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</div><div class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    nread = IO_Read(fd, &amp;ret, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123; <span class="comment">/* EOF */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123; <span class="comment">/* error */</span></div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Read error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret &amp; <span class="number">0xFF</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然java代码中没有表现出对<code>fd</code>的使用，但是在<code>native</code>代码中的确使用了<code>fd</code>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JAVA中的文件操作最终都是要通过<code>FileDescriptor</code>，在Unix/Linux中的文件描述符就是一个数字，对应了进程打开文件数组的下标，该数组的0,1,2号文件分别表示标准输入、标准输出，标准错误输出。这和JAVA中是一致的，<code>FileDescriptor</code>中的fd为0，1，2时也表示同样的意义。所以以下代码也可以用于输出<code>&#39;A&#39;</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</div><div class="line">        fileOutputStream.write(<span class="string">'A'</span>);</div></pre></td></tr></table></figure>
<p>当我们通过<code>文件名</code>或者<code>文件对象</code>new一个FileInputStream的时候，做了以下步骤：</p>
<ol>
<li><p>如果FileInputStream类尚未加载，则执行initIDs方法，否则这一步直接跳过。</p>
</li>
<li><p>如果FileDescriptor类尚未加载，则执行initIDs方法，否则这一步也直接跳过。</p>
</li>
<li><p>new一个FileDescriptor对象赋给FileInputStream的fd属性。</p>
</li>
<li><p>打开一个文件句柄。</p>
</li>
<li><p>将文件句柄赋给FileDescriptor对象的fd字段。</p>
</li>
</ol>
<p>注：本文JDK版本为1.8</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;使用JAVA读取文件时需要用到&lt;code&gt;FileInputStream&lt;/code&gt;这个类，最简单的使用方式如下:&lt;/p&gt;
&lt;figure
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
      <category term="JNI" scheme="http://vinoit.me/categories/java/JNI/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="JNI" scheme="http://vinoit.me/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程地址空间</title>
    <link href="http://vinoit.me/2016/09/10/linux-kernel-note-process-address-space/"/>
    <id>http://vinoit.me/2016/09/10/linux-kernel-note-process-address-space/</id>
    <published>2016-09-10T05:34:16.000Z</published>
    <updated>2016-09-10T13:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h4><p>进程的地址空间由允许进程使用的全部线性地址组成，在32位系统中为0~3GB，每个进程看到的线性地址集合是不同的。</p>
<p>内核通过线性区的资源（数据结构）来表示线性地址区间，线性区是由起始线性地址，长度和一些访问权限来描述的。线性区的大小为页框的整数倍，起始地址为4096的整数倍。</p>
<p>下图展示了x86 Linux 进程的地址空间组织结构：<br><img src="/images/linux-kernel-note/process-address-space-0.png" alt=""></p>
<ul>
<li>正文段 .text ，这是CPU执行的机器指令部分。通常正文段是共享的，而且是只读的，以防止程序修改其自身的指令。</li>
<li>数据段 .data。数据段包含了程序中需要明确赋初值的变量。</li>
<li>非初始化数据段 bss。bss 起始于 IBM 704汇编语言中的 Block Storage Start 指令的首字母缩写,并且沿用至今。</li>
</ul>
<h4 id="线性区描述符"><a href="#线性区描述符" class="headerlink" title="线性区描述符"></a>线性区描述符</h4><p>进程地址空间中的堆、栈等，就是一个线性区，线性区的结构类型为<code>struct vm_area_struct</code>：<br><a href="http://lxr.free-electrons.com/source/include/linux/mm_types.h#L299" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/mm_types.h#L299</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="number">299</span> <span class="keyword">struct</span> vm_area_struct &#123;</div><div class="line"><span class="number">300</span>         <span class="comment">/* The first cache line has the info for VMA tree walking. */</span></div><div class="line"><span class="number">301</span> </div><div class="line"><span class="number">302</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">/* Our start address within vm_mm. */</span></div><div class="line"><span class="number">303</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">/* The first byte after our end address</span></div><div class="line">304                                            within vm_mm. */</div><div class="line"><span class="number">305</span> </div><div class="line"><span class="number">306</span>         <span class="comment">/* linked list of VM areas per task, sorted by address */</span></div><div class="line"><span class="number">307</span>         <span class="keyword">struct</span> vm_area_struct *vm_next, *vm_prev;</div><div class="line"><span class="number">308</span> </div><div class="line"><span class="number">309</span>         <span class="keyword">struct</span> rb_node vm_rb;</div><div class="line"><span class="number">310</span> </div><div class="line"><span class="number">311</span>         <span class="comment">/*</span></div><div class="line">312          * Largest free memory gap in bytes to the left of this VMA.</div><div class="line">313          * Either between this VMA and vma-&gt;vm_prev, or between one of the</div><div class="line">314          * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</div><div class="line">315          * get_unmapped_area find a free area of the right size.</div><div class="line">316          */</div><div class="line"><span class="number">317</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</div><div class="line"><span class="number">318</span> </div><div class="line"><span class="number">319</span>         <span class="comment">/* Second cache line starts here. */</span></div><div class="line"><span class="number">320</span> </div><div class="line"><span class="number">321</span>         <span class="keyword">struct</span> mm_struct *vm_mm;        <span class="comment">/* The address space we belong to. */</span></div><div class="line"><span class="number">322</span>         <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">/* Access permissions of this VMA. */</span></div><div class="line"><span class="number">323</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;         <span class="comment">/* Flags, see mm.h. */</span></div><div class="line"><span class="number">324</span> </div><div class="line"><span class="number">325</span>         <span class="comment">/*</span></div><div class="line">326          * For areas with an address space and backing store,</div><div class="line">327          * linkage into the address_space-&gt;i_mmap interval tree.</div><div class="line">328          */</div><div class="line"><span class="number">329</span>         <span class="keyword">struct</span> &#123;</div><div class="line"><span class="number">330</span>                 <span class="keyword">struct</span> rb_node rb;</div><div class="line"><span class="number">331</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</div><div class="line"><span class="number">332</span>         &#125; shared;</div><div class="line"><span class="number">333</span> </div><div class="line"><span class="number">334</span>         <span class="comment">/*</span></div><div class="line">335          * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</div><div class="line">336          * list, after a COW of one of the file pages.  A MAP_SHARED vma</div><div class="line">337          * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</div><div class="line">338          * or brk vma (with NULL file) can only be in an anon_vma list.</div><div class="line">339          */</div><div class="line"><span class="number">340</span>         <span class="keyword">struct</span> list_head anon_vma_chain; <span class="comment">/* Serialized by mmap_sem &amp;</span></div><div class="line">341                                           * page_table_lock */</div><div class="line"><span class="number">342</span>         <span class="keyword">struct</span> anon_vma *anon_vma;      <span class="comment">/* Serialized by page_table_lock */</span></div><div class="line"><span class="number">343</span> </div><div class="line"><span class="number">344</span>         <span class="comment">/* Function pointers to deal with this struct. */</span></div><div class="line"><span class="number">345</span>         <span class="keyword">const</span> <span class="keyword">struct</span> vm_operations_struct *vm_ops;</div><div class="line"><span class="number">346</span> </div><div class="line"><span class="number">347</span>         <span class="comment">/* Information about our backing store: */</span></div><div class="line"><span class="number">348</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;         <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></div><div class="line">349                                            units */</div><div class="line"><span class="number">350</span>         <span class="keyword">struct</span> file * vm_file;          <span class="comment">/* File we map to (can be NULL). */</span></div><div class="line"><span class="number">351</span>         <span class="keyword">void</span> * vm_private_data;         <span class="comment">/* was vm_pte (shared mem) */</span></div><div class="line"><span class="number">352</span> </div><div class="line"><span class="number">353</span> <span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></div><div class="line"><span class="number">354</span>         <span class="keyword">struct</span> vm_region *vm_region;    <span class="comment">/* NOMMU mapping region */</span></div><div class="line"><span class="number">355</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">356</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></div><div class="line"><span class="number">357</span>         <span class="keyword">struct</span> mempolicy *vm_policy;    <span class="comment">/* NUMA policy for the VMA */</span></div><div class="line"><span class="number">358</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">359</span>         <span class="keyword">struct</span> vm_userfaultfd_ctx vm_userfaultfd_ctx;</div><div class="line"><span class="number">360</span> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>vm_start</code>:线性区的起始地址</li>
<li><code>vm_end</code>:线性区的结束地址</li>
<li><code>vm_rb</code>:作为红黑树中的一个节点使用</li>
<li><code>vm_mm</code>:指向所在的内存描述符</li>
<li><code>vm_page_prot</code>:线性区中页框的访问权限</li>
<li><code>vm_flags</code>:线性区的标志</li>
<li><code>vm_next, vm_prev</code>:分别指向线性区链表中的下一个和上一个线性区描述符</li>
<li>… …</li>
</ul>
<h4 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h4><p>内存描述符中包含了与进程地址空间有关的所有信息，结构类型为<code>struct mm_struct</code>:<br><a href="http://lxr.free-electrons.com/source/include/linux/mm_types.h#L395" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/mm_types.h#L395</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="number">395</span> <span class="keyword">struct</span> mm_struct &#123;</div><div class="line"><span class="number">396</span>         <span class="keyword">struct</span> vm_area_struct *mmap;            <span class="comment">/* list of VMAs */</span></div><div class="line"><span class="number">397</span>         <span class="keyword">struct</span> rb_root mm_rb;</div><div class="line"><span class="number">398</span>         u32 vmacache_seqnum;                   <span class="comment">/* per-thread vmacache */</span></div><div class="line"><span class="number">399</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></div><div class="line"><span class="number">400</span>         <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span></div><div class="line"><span class="number">401</span>                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</div><div class="line"><span class="number">402</span>                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</div><div class="line"><span class="number">403</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">404</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;                <span class="comment">/* base of mmap area */</span></div><div class="line"><span class="number">405</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_legacy_base;         <span class="comment">/* base of mmap area in bottom-up allocations */</span></div><div class="line"><span class="number">406</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;                <span class="comment">/* size of task vm space */</span></div><div class="line"><span class="number">407</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> highest_vm_end;           <span class="comment">/* highest vma end address */</span></div><div class="line"><span class="number">408</span>         <span class="keyword">pgd_t</span> * pgd;</div><div class="line"><span class="number">409</span>         <span class="keyword">atomic_t</span> mm_users;                      <span class="comment">/* How many users with user space? */</span></div><div class="line"><span class="number">410</span>         <span class="keyword">atomic_t</span> mm_count;                      <span class="comment">/* How many references to "struct mm_struct" (users count as 1) */</span></div><div class="line"><span class="number">411</span>         <span class="keyword">atomic_long_t</span> nr_ptes;                  <span class="comment">/* PTE page table pages */</span></div><div class="line"><span class="number">412</span> <span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></div><div class="line"><span class="number">413</span>         <span class="keyword">atomic_long_t</span> nr_pmds;                  <span class="comment">/* PMD page table pages */</span></div><div class="line"><span class="number">414</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">415</span>         <span class="keyword">int</span> map_count;                          <span class="comment">/* number of VMAs */</span></div><div class="line"><span class="number">416</span> </div><div class="line"><span class="number">417</span>         <span class="keyword">spinlock_t</span> page_table_lock;             <span class="comment">/* Protects page tables and some counters */</span></div><div class="line"><span class="number">418</span>         <span class="keyword">struct</span> rw_semaphore mmap_sem;</div><div class="line"><span class="number">419</span> </div><div class="line"><span class="number">420</span>         <span class="keyword">struct</span> list_head mmlist;                <span class="comment">/* List of maybe swapped mm's.  These are globally strung</span></div><div class="line">421                                                  * together off init_mm.mmlist, and are protected</div><div class="line">422                                                  * by mmlist_lock</div><div class="line">423                                                  */</div><div class="line"><span class="number">424</span> </div><div class="line"><span class="number">425</span> </div><div class="line"><span class="number">426</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;      <span class="comment">/* High-watermark of RSS usage */</span></div><div class="line"><span class="number">427</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;       <span class="comment">/* High-water virtual memory usage */</span></div><div class="line"><span class="number">428</span> </div><div class="line"><span class="number">429</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;         <span class="comment">/* Total pages mapped */</span></div><div class="line"><span class="number">430</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;        <span class="comment">/* Pages that have PG_mlocked set */</span></div><div class="line"><span class="number">431</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm;        <span class="comment">/* Refcount permanently increased */</span></div><div class="line"><span class="number">432</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> data_vm;          <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></div><div class="line"><span class="number">433</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;          <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></div><div class="line"><span class="number">434</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;         <span class="comment">/* VM_STACK */</span></div><div class="line"><span class="number">435</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</div><div class="line"><span class="number">436</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</div><div class="line"><span class="number">437</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</div><div class="line"><span class="number">438</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</div><div class="line"><span class="number">439</span> </div><div class="line"><span class="number">440</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></div><div class="line"><span class="number">441</span> </div><div class="line"><span class="number">442</span>         <span class="comment">/*</span></div><div class="line">443          * Special counters, in some configurations protected by the</div><div class="line">444          * page_table_lock, in other configurations by being atomic.</div><div class="line">445          */</div><div class="line"><span class="number">446</span>         <span class="keyword">struct</span> mm_rss_stat rss_stat;</div><div class="line"><span class="number">447</span> </div><div class="line"><span class="number">448</span>         <span class="keyword">struct</span> linux_binfmt *binfmt;</div><div class="line"><span class="number">449</span> </div><div class="line"><span class="number">450</span>         <span class="keyword">cpumask_var_t</span> cpu_vm_mask_var;</div><div class="line"><span class="number">451</span> </div><div class="line"><span class="number">452</span>         <span class="comment">/* Architecture-specific MM context */</span></div><div class="line"><span class="number">453</span>         <span class="keyword">mm_context_t</span> context;</div><div class="line"><span class="number">454</span> </div><div class="line"><span class="number">455</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></div><div class="line"><span class="number">456</span> </div><div class="line"><span class="number">457</span>         <span class="keyword">struct</span> core_state *core_state; <span class="comment">/* coredumping support */</span></div><div class="line"><span class="number">458</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AIO</span></div><div class="line"><span class="number">459</span>         <span class="keyword">spinlock_t</span>                      ioctx_lock;</div><div class="line"><span class="number">460</span>         <span class="keyword">struct</span> kioctx_table <span class="number">__</span>rcu       *ioctx_table;</div><div class="line"><span class="number">461</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">462</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></div><div class="line"><span class="number">463</span>         <span class="comment">/*</span></div><div class="line">464          * "owner" points to a task that is regarded as the canonical</div><div class="line">465          * user/owner of this mm. All of the following must be true in</div><div class="line">466          * order for it to be changed:</div><div class="line">467          *</div><div class="line">468          * current == mm-&gt;owner</div><div class="line">469          * current-&gt;mm != mm</div><div class="line">470          * new_owner-&gt;mm == mm</div><div class="line">471          * new_owner-&gt;alloc_lock is held</div><div class="line">472          */</div><div class="line"><span class="number">473</span>         <span class="keyword">struct</span> task_struct <span class="number">__</span>rcu *owner;</div><div class="line"><span class="number">474</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">475</span> </div><div class="line"><span class="number">476</span>         <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></div><div class="line"><span class="number">477</span>         <span class="keyword">struct</span> file <span class="number">__</span>rcu *exe_file;</div><div class="line"><span class="number">478</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></div><div class="line"><span class="number">479</span>         <span class="keyword">struct</span> mmu_notifier_mm *mmu_notifier_mm;</div><div class="line"><span class="number">480</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">481</span> <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span></div><div class="line"><span class="number">482</span>         <span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></div><div class="line"><span class="number">483</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">484</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUMASK_OFFSTACK</span></div><div class="line"><span class="number">485</span>         <span class="keyword">struct</span> cpumask cpumask_allocation;</div><div class="line"><span class="number">486</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">487</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></div><div class="line"><span class="number">488</span>         <span class="comment">/*</span></div><div class="line">489          * numa_next_scan is the next time that the PTEs will be marked</div><div class="line">490          * pte_numa. NUMA hinting faults will gather statistics and migrate</div><div class="line">491          * pages to new nodes if necessary.</div><div class="line">492          */</div><div class="line"><span class="number">493</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> numa_next_scan;</div><div class="line"><span class="number">494</span> </div><div class="line"><span class="number">495</span>         <span class="comment">/* Restart point for scanning and setting pte_numa */</span></div><div class="line"><span class="number">496</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> numa_scan_offset;</div><div class="line"><span class="number">497</span> </div><div class="line"><span class="number">498</span>         <span class="comment">/* numa_scan_seq prevents two threads setting pte_numa */</span></div><div class="line"><span class="number">499</span>         <span class="keyword">int</span> numa_scan_seq;</div><div class="line"><span class="number">500</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">501</span> <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NUMA_BALANCING) || defined(CONFIG_COMPACTION)</span></div><div class="line"><span class="number">502</span>         <span class="comment">/*</span></div><div class="line">503          * An operation with batched TLB flushing is going on. Anything that</div><div class="line">504          * can move process memory needs to flush the TLB when moving a</div><div class="line">505          * PROT_NONE or PROT_NUMA mapped page.</div><div class="line">506          */</div><div class="line"><span class="number">507</span>         <span class="keyword">bool</span> tlb_flush_pending;</div><div class="line"><span class="number">508</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">509</span>         <span class="keyword">struct</span> uprobes_state uprobes_state;</div><div class="line"><span class="number">510</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_INTEL_MPX</span></div><div class="line"><span class="number">511</span>         <span class="comment">/* address of the bounds directory */</span></div><div class="line"><span class="number">512</span>         <span class="keyword">void</span> <span class="number">__u</span>ser *bd_addr;</div><div class="line"><span class="number">513</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">514</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HUGETLB_PAGE</span></div><div class="line"><span class="number">515</span>         <span class="keyword">atomic_long_t</span> hugetlb_usage;</div><div class="line"><span class="number">516</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">517</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></div><div class="line"><span class="number">518</span>         <span class="keyword">struct</span> work_struct async_put_work;</div><div class="line"><span class="number">519</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">520</span> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>mmap</code>:线性区描述符链表中的头元素</li>
<li><code>mm_rb</code>:线性区描述符所在红黑树的根</li>
<li><code>get_unmapped_area</code>:在进程地址空间中搜索有效线性地址区间的方法</li>
<li><code>mmap_base</code>:标识第一个分配的匿名线性区或文件内存映射的线性地址</li>
<li><code>task_size</code>:进程地址空间的大小</li>
<li><code>highest_vm_end</code>:能使用的最高线性地址</li>
<li><code>pgd</code>:指向页全局目录</li>
<li><code>mm_users</code>:次使用计数器</li>
<li><code>mm_count</code>:主使用计数器</li>
<li><code>nr_ptes</code>:页表项数量</li>
<li><code>map_count</code>：线性区数量</li>
<li><code>mmlist</code>:链接内存描述符链表中的相邻描述符</li>
<li>… …</li>
</ul>
<h4 id="线性区相关"><a href="#线性区相关" class="headerlink" title="线性区相关"></a>线性区相关</h4><p>进程所拥有的所有线性区通过一个简单地链表链接在一起，链表中的线性区按内存地址升序排列。内核通过进程的内存描述符的<code>mmap</code>字段找到线性区链表的第一个线性区。<br><img src="/images/linux-kernel-note/process-address-space-2.png" alt=""></p>
<p>内核频繁执行的一个操作就是查找包含指定线性地址的的线性区，虽然可以通过遍历链表来查找，但是当线性区数量很庞大时，例如面向对象的数据库，此时的效率会变得非常低效。</p>
<p>Linux2.6把内存描述符存放在红黑树的数据结构中，当插入或删除一个线性区描述符时，内核通过红黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。一般来说，红黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合的时候使用。</p>
<h4 id="内存描述符相关"><a href="#内存描述符相关" class="headerlink" title="内存描述符相关"></a>内存描述符相关</h4><p>进程、内存描述符、线性区描述符、线性地址之间的关系如下:<br><img src="/images/linux-kernel-note/process-address-space-1.png" alt=""></p>
<p>所有内存描述符存放在一个双向链表中，每个描述符中的<code>mmlist</code>字段存放链表中相邻元素的地址。链表的第一个元素是<code>init_mm</code>的<code>mmlist</code>字段，<code>init_mm</code>是初始化阶段进程0所使用的内存描述符。</p>
<p><code>mm_users</code>字段存放共享<code>mm_struct</code>数据结构的轻量级进程（线程）的个数，<code>mm_count</code>字段是内存描述符的主使用器，<code>mm_users</code>的所有使用者在<code>mm_count</code>中只占有一个单位，也就是说多个线程只使得<code>mm_count</code>的值增加了1。假如一个内核线程使用了该内存描述符，则<code>mm_count</code>的值增加1。</p>
<p>对于内核线程来说，因为仅运行在内核态，所以永远不会访问低于<code>TASK_SIZE</code>（3GB）的地址。每个进程的描述符中包含了两种内存描述符指针:<code>mm</code>和<code>active_mm</code>。对于普通进程，两者都指向进程的内存描述符，而内核线程的<code>active_mm</code>指向进程的内存描述符，<code>mm</code>为null。（PS:内核线程使用的全局页表存放在主内存描述符的pgd字段中）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简单地描述了进程地址空间中的一些主要数据结构以及之间的联系，关于源码以及更多细节内容在日后整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程的地址空间&quot;&gt;&lt;a href=&quot;#进程的地址空间&quot; class=&quot;headerlink&quot; title=&quot;进程的地址空间&quot;&gt;&lt;/a&gt;进程的地址空间&lt;/h4&gt;&lt;p&gt;进程的地址空间由允许进程使用的全部线性地址组成，在32位系统中为0~3GB，每个进程看到的线性地址集
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之高端内存映射</title>
    <link href="http://vinoit.me/2016/09/09/linux-kernel-note-high-memory-mapping/"/>
    <id>http://vinoit.me/2016/09/09/linux-kernel-note-high-memory-mapping/</id>
    <published>2016-09-09T11:06:04.000Z</published>
    <updated>2016-09-10T06:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是高端内存"><a href="#什么是高端内存" class="headerlink" title="什么是高端内存"></a>什么是高端内存</h4><p>在32位的系统上，内核使用第3GB~第4GB的线性地址空间，共1GB大小。内核将其中的前896MB与物理内存的0~896MB进行直接映射，即线性映射，将剩余的128M线性地址空间作为访问高于896M的内存的一个窗口。</p>
<p>引入高端内存映射这样一个概念的主要原因就是我们所安装的内存大于1G时，内核的1G线性地址空间无法建立一个完全的直接映射来触及整个物理内存空间，而对于80x86开启PAE的情况下，允许的最大物理内存可达到64G，因此内核将自己的最后128M的线性地址空间腾出来，用以完成对高端内存的暂时性映射。</p>
<p>而在64位的系统上就不存在这样的问题了，因为可用的线性地址空间远大于可安装的内存。下图描述了内核1GB线性地址空间是如何划分的。 </p>
<p><img src="/images/linux-kernel-note/high-memory-mapping-0.png" alt=""></p>
<p>其中PAGE_OFFSET表示内核使用的1GB线性地址的起始处(第3GB)，high_memory往右的部分则表示高端内存，共<code>128M</code>的线性地址。可以用来完成上述映射目的的区域为vmalloc area，Persistent kernel mappings区域和固定映射线性地址空间中的FIX_KMAP区域，这三个区域对应的映射机制分别为<code>非连续内存分配</code>， <code>永久内核映射</code>和 <code>临时内核映射</code>。</p>
<h4 id="永久内核映射"><a href="#永久内核映射" class="headerlink" title="永久内核映射"></a>永久内核映射</h4><p>在内核初始化页表管理机制时，专门用pkmap_page_table这个变量保存了PKMAP_BASE对应的页表项的地址，由pkmap_page_table来维护永久内核映射区的页表项的映射，页表项总数为LAST_PKMAP个。</p>
<p>这里的永久并不是指调用kmap()建立的映射关系会一直持续下去无法解除，而是指在调用kunmap()解除映射之间这种映射会一直存在，这是相对于临时内核映射机制而言的。</p>
<p>需要注意一点的是，当永久内核映射区没有空闲的页表项可供映射时，请求映射的进程会被阻塞，因此永久内核映射请求不能发生在中断和可延迟函数中。</p>
<h4 id="临时内核映射"><a href="#临时内核映射" class="headerlink" title="临时内核映射"></a>临时内核映射</h4><p>临时内核映射和永久内核映射相比，其最大的特点就是不会阻塞请求映射页框的进程，因此临时内核映射请求可以发生在中断和可延迟函数中。系统中的每个CPU都有自己的13个临时内核映射窗口，根据不同的需求（用于内核控制路径），选择不同的窗口来创建映射。</p>
<p>每个CPU的映射窗口集合用<code>enum km_type</code>数据结构表示，该数据结构中的每个符号，如<code>KM_BOUNCE_READ</code>、<code>KM_USER0</code>或<code>KM_PTE0</code>,标识了窗口的线性地址，其实是一个下标。内核根据<code>cpu_id</code>和<code>窗口下标</code>来确定临时映射的地址。</p>
<p>临时内核映射的实现也比永久内核映射要简单，当一个进程申请在某个窗口创建映射，即使这个窗口已经在之前就建立了映射，新的映射也会建立并且覆盖之前的映射，所以说这种映射机制是临时的，并且不会阻塞当前进程。</p>
<h4 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h4><p>非连续内存分配是指将物理地址不连续的页框映射到线性地址连续的线性地址空间，主要应用于大容量的内存分配。采用这种方式分配内存的主要优点是避免了外部碎片，而缺点是必须打乱内核页表，而且访问速度较连续分配的物理页框慢。</p>
<p>非连续内存分配的线性地址空间是从<code>VMALLOC_START</code>到<code>VMALLOC_END</code>，每当内核要用vmalloc类的函数进行非连续内存分配，就会申请一个vm_struct结构来描述对应的vmalloc区，两个vmalloc区之间的间隔至少为一个页框的大小，即PAGE_SIZE。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于内核的线性地址空间有限，因此采取上面介绍的三种方式来映射高端内存。但是每种映射的本质都是通过页表来建立线性地址与物理地址之间的联系。</p>
<p>永久内核映射和临时内核映射，都由内核指定了需要进行映射的页面，也就是说指定了页描述符(页描述符和物理页框之间的关系是固定不可变的)。在永久内核映射中，内核只需要在永久内核映射区找到空闲的，也就是未被映射的线性地址对应的页表项，然后将其分配给page即可，若找不到则将阻塞申请建立映射的进程；而临时内核映射更直接，连进行映射的线性地址窗口都是固定的，若是其已经分配给了某个页框，则直接抢过来用，因此之前的映射就被覆盖了，体现出了临时性。</p>
<p>非连续内存分配，内核不用指定具体的页框,只需指定要申请的内存大小，内核将在非连续内存分配区找到一块相应大小虚拟地址空间，然后再由伙伴系统分配页框，还要通过slab分配器为一些数据结构分配内存，最后再用同样的方式(设置PTE表项)来建立映射。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是高端内存&quot;&gt;&lt;a href=&quot;#什么是高端内存&quot; class=&quot;headerlink&quot; title=&quot;什么是高端内存&quot;&gt;&lt;/a&gt;什么是高端内存&lt;/h4&gt;&lt;p&gt;在32位的系统上，内核使用第3GB~第4GB的线性地址空间，共1GB大小。内核将其中的前896MB与
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核中hlist_head和hlist_node结构解析</title>
    <link href="http://vinoit.me/2016/09/01/linux-kernel-hlist_head-and-hlist_node/"/>
    <id>http://vinoit.me/2016/09/01/linux-kernel-hlist_head-and-hlist_node/</id>
    <published>2016-09-01T07:57:17.000Z</published>
    <updated>2016-09-01T09:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>hlist_head</code>和<code>hlist_node</code>用于散列表，分表表示列表头（数组中的一项）和列表头所在双向链表中的某项，两者结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_head &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *first;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_node &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *next, **pprev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在内核中的普通双向链表基本上都是通过<code>list_head</code>实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> list_head &#123;</div><div class="line">        <span class="keyword">struct</span> list_head *next, *prev;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p><code>list_head</code>很好理解，但是<code>hlist_head</code>和<code>hlist_node</code>为何要这样设计呢？</p>
<p>先看下<code>hlist_head</code>和<code>hlist_node</code>的示意图:</p>
<p><img src="/images/linux/list_head-and-hlist_node-0.png" alt=""></p>
<p><code>hash_table</code>为散列表（数组），其中的元素类型为<code>struct hlist_head</code>。以<code>hlist_head</code>为链表头的链表，其中的节点<code>hash值</code>是相同的（也叫冲突）。<code>first指针</code>指向链表中的节点①，然后节点①的<code>pprev指针</code>指向<code>hlist_head</code>中的<code>first</code>，节点①的<code>next指针</code>指向节点②。以此类推。</p>
<p><code>hash_table</code>的列表头仅存放一个指针,也就是first指针,指向的是对应链表的头结点,没有tail指针也就是指向链表尾节点的指针,这样的考虑是为了节省空间——尤其在<code>hash bucket</code>(数组size)很大的情况下可以节省一半的指针空间。</p>
<p>为什么<code>pprev</code>是一个指向指针的指针呢？按照这个设计，我们如果想要得到尾节点，必须遍历整个链表，可如果是一个指向节点的指针，那么头结点现在的<code>pprev</code>便可以直接指向尾节点，也就是<code>list_head</code>的做法。</p>
<p>对于散列表来说，一般发生冲突的情况并不多（除非hash设计出现了问题），所以一个链表中的元素数量比较有限，遍历的劣势基本可以忽略。</p>
<p>在删除链表头结点的时候，<code>pprev</code>这个设计无需判断删除的节点是否为头结点。如果是普通双向链表的设计，那么删除头结点之后，<code>hlist_head</code>中的<code>first指针</code>需要指向新的头结点。通过下面2个函数来加深理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加节点到链表头</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *first = h-&gt;first;</div><div class="line">    n-&gt;next = first;<span class="comment">//新节点的next指针指向原头结点</span></div><div class="line">    <span class="keyword">if</span> (first)</div><div class="line">        first-&gt;pprev = &amp;n-&gt;next;<span class="comment">//原头结点的pprev指向新节点的next字段</span></div><div class="line">    h-&gt;first = n;<span class="comment">//first指针指向新的节点（更换了头结点）</span></div><div class="line">    n-&gt;pprev = &amp;h-&gt;first; <span class="comment">//此时n是链表的头结点,将它的pprev指向list_head的first字段</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//删除节点</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="number">__</span>hlist_del(<span class="keyword">struct</span> hlist_node *n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *next = n-&gt;next;</div><div class="line">    <span class="keyword">struct</span> hlist_node **pprev = n-&gt;pprev;</div><div class="line">    *pprev = next; <span class="comment">// pprev指向的是前一个节点的next指针,当该节点是头节点时指向 hlist_head的first,两种情况下不论该节点是一般的节点还是头结点都可以通过这个操作删除掉所需删除的节点。</span></div><div class="line">    <span class="keyword">if</span> (next)</div><div class="line">        next-&gt;pprev = pprev;<span class="comment">//使删除节点的后一个节点的pprev指向删除节点的前一个节点的next字段，节点成功删除。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;hlist_head&lt;/code&gt;和&lt;code&gt;hlist_node&lt;/code&gt;用于散列表，分表表示列表头（数组中的一项）和列表头所在双向链表中的某项，两者结构如下:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="源码" scheme="http://vinoit.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之内存管理</title>
    <link href="http://vinoit.me/2016/08/30/linux-kernel-note-memory-manage/"/>
    <id>http://vinoit.me/2016/08/30/linux-kernel-note-memory-manage/</id>
    <published>2016-08-30T12:10:18.000Z</published>
    <updated>2016-09-12T05:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="非一致内存访问（NUMA）"><a href="#非一致内存访问（NUMA）" class="headerlink" title="非一致内存访问（NUMA）"></a>非一致内存访问（NUMA）</h4><p>我们习惯上认为计算机内存是一种均匀、共享的资源。在忽略硬件高速缓存的情况下，我们期望不管内存单元处于何处，也不管CPU处于何处，CPU对内存单元的访问都需要相同的时间。但是，在某些体系结构中并不总是成立。</p>
<p>在NUMA模型中，给定CPU对不同内存单元的访问时间可能不一样。系统的物理内存被划分为几个节点(node)。在一个单独的节点内，任一给定CPU访问页面所需的时间都是相同的。然而，对不同的CPU，这个时间可能就不同。每个节点的物理内存又可以分为几个管理区（zone）。</p>
<p>Linux支持NUMA模型，但是Linux将所有物理内存看作一个节点。在存放节点的链表中，只有一个元素。</p>
<h4 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h4><p>80x86体系结构存在两种硬件约束:</p>
<ul>
<li>ISA总线的DMA处理器只能对RAM的前16M寻址。</li>
<li>在具有大量RAM的现代32位计算机中，因为线性地址空间太小，CPU不能直接访问所有的物理内存。</li>
</ul>
<p>为了应对这两种限制，Linux2.6把每个内存节点的物理内存划分为3个管理区。在80x86 UMA体系结构中的管理区为:</p>
<ul>
<li>ZONE_DMA(包含低于16M的内存页框)</li>
<li>ZONE_NORMAL(包含高于16M低于896M的内存页框)</li>
<li>ZONE_HIGHMEM(包含高于896M的所有内存页框)</li>
</ul>
<p>ZONE_DMA中的页框可以由老式基于ISA的设备通过DMA使用。</p>
<p>ZONE_NORMAL中的页框全部映射到内核使用的第4个GB地址空间，这部分页框的映射方式很简单，例如物理地址为<code>0x10000000</code>,只需要直接加上3GB的地址，得到的线性地址为<code>0xc0000000</code>。</p>
<p>ZONE_HIGHMEM和ZONE_NORMAL都属于“常规”页框，但内核使用的第4个GB地址空间的最后128M才能映射到该部分页框。</p>
<h4 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h4><p>分区页框分配器是一个内核子系统，处理对连续页框组的内存分配请求。这部分内容对于理解Linux的内存管理十分关键，它的主要组成如下:<br><img src="/images/linux-kernel-note/memory-manage-0.png" alt=""></p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>linux内核的伙伴算法最大限度的减少了内存的碎片，其实应该说成是尽自己最大的努力减少了内存的碎片。其思想就是将物理内存分成11个块链表，每个链表包含的是大小为1,2,4,8…512,1024的连续页框块。举例来说要分配256个连续页框，会先到块大小为256的链表中查找空闲块，若有直接返回，若没有，去大小为512的链表中进行查找，将512大小块分为两部分，一部分返回，一部分插入256大小的链表中，若512大小的链表中还没有，到1024大小的链表中查找，取出256大小的块，将剩下的512,256的块分别插入到各个链表中，内存释放的过程则是相反的。</p>
<p>满足以下条件的两个快称为伙伴:</p>
<ul>
<li>两个块具有相同的大小，记作b。</li>
<li>它们的物理地址是连续的。</li>
<li>第一个块的的第一个页框的物理地址是<code>2*b*2^12</code>的倍数。</li>
</ul>
<h4 id="每CPU页框高速缓存（冷热页）"><a href="#每CPU页框高速缓存（冷热页）" class="headerlink" title="每CPU页框高速缓存（冷热页）"></a>每CPU页框高速缓存（冷热页）</h4><p>内核经常请求和释放<code>单个页框</code>，为了提升性能，每个内存管理区定义了一个“每CPU”高速缓存。冷页表示该空闲页已经不再高速缓存中了(一般是指L2 Cache)，热页表示该空闲页仍然在高速缓存中。冷热页是针对于每CPU的，每个zone中，都会针对于所有的CPU初始化一个冷热页的per-cpu-pageset.</p>
<h4 id="分配页框小结"><a href="#分配页框小结" class="headerlink" title="分配页框小结"></a>分配页框小结</h4><p>当内核接收一个分配若干个页框的请求时，如果页框数量为1，则从每CPU页框高速缓存中分配一个页框。如果页框数大于1，则从伙伴系统中分配符合要求的若干个连续页框。其中的大致流程如下：</p>
<ol>
<li>管理区分配器选择一个合适的内存管理区。</li>
<li>如果需要的页框数量为1，则从每CPU页框高速缓存中获取一个空闲的页框。一般情况下获取一个热页，但如果用于DMA等不需要CPU参与的请求，获取一个冷页。</li>
<li>如果数量大于1，则从伙伴系统中选择一个大于0中的最小order链表，然后返回一个块。</li>
</ol>
<p>如果冷热页中无空闲页框，则从伙伴系统中分配一些页框给冷热页机制。</p>
<h4 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h4><p>当我们需要分配一些小对象时，如果还使用页框分配器，那未免太浪费了，无论是从时间上还是空间上。slab分配器用于这些小对象的分配，其大致组成如下:<br><img src="/images/linux-kernel-note/memory-manage-1.png" alt=""><br>高速缓存的大小为2的幂，从32B到131072B共13个级别。对于每种大小都有2个高速缓存：一个适用于ISA DMA分配，另一个适用于常规分配。</p>
<p>高速缓存描述符如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_cache &#123;  </div><div class="line"><span class="comment">/* 1) per-cpu data, touched during every alloc/free */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache *<span class="built_in">array</span>[NR_CPUS];<span class="comment">/*local cache*/</span>  </div><div class="line"><span class="comment">/* 2) Cache tunables. Protected by cache_chain_mutex */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shared;  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size;<span class="comment">/*slab中对象大小*/</span>  </div><div class="line">    u32 reciprocal_buffer_size;<span class="comment">/*slab中对象大小的倒数*/</span>  </div><div class="line"><span class="comment">/* 3) touched by every alloc &amp; free from the backend */</span>  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;     <span class="comment">/* constant flags */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;       <span class="comment">/* # of objs per slab */</span>  </div><div class="line">  </div><div class="line"><span class="comment">/* 4) cache_grow/shrink */</span>  </div><div class="line">    <span class="comment">/* order of pgs per slab (2^n) */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> gfporder;  </div><div class="line">  </div><div class="line">    <span class="comment">/* force GFP flags, e.g. GFP_DMA */</span>  </div><div class="line">    <span class="keyword">gfp_t</span> gfpflags;  </div><div class="line">  </div><div class="line">    <span class="keyword">size_t</span> colour;<span class="comment">/*着色块个数*/</span> <span class="comment">/* cache colouring range */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_off;<span class="comment">/* cache的着色块的单位大小 */</span>    <span class="comment">/* colour offset */</span>  </div><div class="line">    <span class="keyword">struct</span> kmem_cache *slabp_cache;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slab_size;<span class="comment">/*slab管理区大小,包含slab对象和kmem_bufctl_t数组*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dflags;        <span class="comment">/* dynamic flags */</span>  </div><div class="line">  </div><div class="line">    <span class="comment">/* constructor func */</span>  </div><div class="line">    <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *obj);  </div><div class="line">  </div><div class="line"><span class="comment">/* 5) cache creation/removal */</span>  </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  </div><div class="line">    <span class="keyword">struct</span> list_head next;  </div><div class="line">  </div><div class="line"><span class="comment">/* 6) statistics */</span>  </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SLAB  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_active;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_allocations;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> high_mark;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> grown;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reaped;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> errors;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> max_freeable;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_allocs;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_frees;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_overflow;  </div><div class="line">    <span class="keyword">atomic_t</span> allochit;<span class="comment">/*cache命中计数，在分配中更新*/</span>  </div><div class="line">    <span class="keyword">atomic_t</span> allocmiss;<span class="comment">/*cache未命中计数，在分配中更新*/</span>  </div><div class="line">    <span class="keyword">atomic_t</span> freehit;  </div><div class="line">    <span class="keyword">atomic_t</span> freemiss;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * If debugging is enabled, then the allocator can add additional </div><div class="line">     * fields and/or padding to every object. buffer_size contains the total </div><div class="line">     * object size including these internal fields, the following two </div><div class="line">     * variables contain the offset to the user object and its size. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int</span> obj_offset;  </div><div class="line">    <span class="keyword">int</span> obj_size;  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span>  </span></div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * We put nodelists[] at the end of kmem_cache, because we want to size </div><div class="line">     * this array to nr_node_ids slots instead of MAX_NUMNODES </div><div class="line">     * (see kmem_cache_init()) </div><div class="line">     * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache </div><div class="line">     * is statically defined, so we reserve the max number of nodes. </div><div class="line">     */  </div><div class="line">    <span class="keyword">struct</span> kmem_list3 *nodelists[MAX_NUMNODES];  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * Do not add fields after nodelists[] </div><div class="line">     */  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后面的<code>struct kmem_list3</code>结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_list3 &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_partial;<span class="comment">/*slab链表，包含空闲对象和已分配对象的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_full;   <span class="comment">/*slab链表，只包含非空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_free;   <span class="comment">/*slab链表，只包含空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;    <span class="comment">/*高速缓存中空闲对象的个数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;       <span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;       <span class="comment">/*下一个slab使用的颜色*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> list_lock;  </div><div class="line">    <span class="keyword">struct</span> array_cache *shared; <span class="comment">/* shared per node */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache **alien; <span class="comment">/* on other nodes */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;    <span class="comment">/* updated without locking */</span>  </div><div class="line">    <span class="keyword">int</span> free_touched;       <span class="comment">/* updated without locking */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>struct kmem_list3</code>中包含3条slab链表，slab描述符如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> slab &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;  <span class="comment">/*用于将slab链入kmem_list3的链表*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;<span class="comment">/*该slab的着色偏移*/</span>  </div><div class="line">    <span class="keyword">void</span> *s_mem;            <span class="comment">/*指向slab中的第一个对象*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;     <span class="comment">/*已分配出去的对象*/</span>  </div><div class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;     <span class="comment">/*下一个空闲对象的下标*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;  <span class="comment">/*节点标识号*/</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>一个slab中的是同类对象，一个高速缓存中的是相同大小的对象。</strong></p>
<p>一个高速缓存描述符包含3条slab链表：<br><img src="/images/linux-kernel-note/memory-manage-2.png" alt=""></p>
<p>高速缓存描述符中的<code>struct array_cache *array[NR_CPUS];/*local cache*/</code>表示本地高速缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> c &#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> avail;<span class="comment">/*本地高速缓存中可用的空闲对象数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;<span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;<span class="comment">/*一次转入和转出的对象数量*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> touched;   <span class="comment">/*标识本地CPU最近是否被使用*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> lock;  </div><div class="line">    <span class="keyword">void</span> *entry[];  <span class="comment">/*这是一个伪数组，便于对后面用于跟踪空闲对象的指针数组的访问 </span></div><div class="line">             * Must have this definition in here for the proper </div><div class="line">             * alignment of array_cache. Also simplifies accessing </div><div class="line">             * the entries. </div><div class="line">             */  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当我们要求内核给我们分配一个小对象时，是从本地高速缓存中获取的。<strong>本地高速缓存中的对象依次放置在该本地高速缓存描述符的地址后面。</strong></p>
<h4 id="slab分配对象小结"><a href="#slab分配对象小结" class="headerlink" title="slab分配对象小结"></a>slab分配对象小结</h4><p>当我们需要一个小对象时，首先根据该对象大小，选择合适的<strong>高速缓存</strong>(kmem_cache)。然后获取当前CPU id,到对应的<strong>本地高速缓存</strong>(array_cache)中获取对象。如果无空闲对象，则从空闲slab链表或者半空闲slab链表中分配一些slab对象，数量为本地高速缓存描述符中<code>batchcount</code>值。如果slab链表中的对象都已被使用，则从伙伴系统中分配若干个页框作为slab。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文从整体上描述了Linux中的内存管理，并没有涉及到具体源码以及细节问题，更多细节待日后整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;非一致内存访问（NUMA）&quot;&gt;&lt;a href=&quot;#非一致内存访问（NUMA）&quot; class=&quot;headerlink&quot; title=&quot;非一致内存访问（NUMA）&quot;&gt;&lt;/a&gt;非一致内存访问（NUMA）&lt;/h4&gt;&lt;p&gt;我们习惯上认为计算机内存是一种均匀、共享的资源。在忽
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>根据字节码探讨JAVA自增运算符的原理</title>
    <link href="http://vinoit.me/2016/08/29/understand-java-auto-increment-by-bytecode/"/>
    <id>http://vinoit.me/2016/08/29/understand-java-auto-increment-by-bytecode/</id>
    <published>2016-08-29T02:47:24.000Z</published>
    <updated>2016-08-29T03:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        x++;</div><div class="line">        myMethod();</div><div class="line">        System.out.println(x + y + ++x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        y = x++ + ++x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果以上代码的结果你很自信能做对,那么本文或许对你帮助不大,但仍然可以看下java底层的实现.在最后将给出以上代码的结果以及解析.</strong></p>
<h4 id="情况举例"><a href="#情况举例" class="headerlink" title="情况举例"></a>情况举例</h4><p>本文中的例子主要针对以下情况:</p>
<p>①x=y++</p>
<p>②x=++y</p>
<p>③x=x++</p>
<p>④x=++x</p>
<p>a : x,y为形参</p>
<p>b : x,y为成员变量</p>
<p>废话不多说,直接上代码:</p>
<h4 id="代码1-①-b"><a href="#代码1-①-b" class="headerlink" title="代码1(①+b):"></a>代码1(①+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x,y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = y++;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:01</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field y:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #3                  // Field y:I</div><div class="line">         9: putstatic     #4                  // Field x:I</div><div class="line">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #4                  // Field x:I</div><div class="line">        18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:y(值)入操作栈</p>
<p>3:得到y(值)的一个快照y’(值)</p>
<p>(个人认为相当于是将栈顶元素也就是y(值)复制了一份,然后将复制得到的y’(值)入操作栈,现在操作栈中有y(值)和y’(值))</p>
<p>4:常量1入操作栈</p>
<p>5:常量1和y’(值)弹出栈,进行加操作,并将结果s入栈</p>
<p>6:将结果s弹出栈,赋给y(变量)(此时y==1)</p>
<p>9:将y(值)弹出栈,赋给x(变量)(此时x==0)</p>
<p>因为y(值)入操作栈之后没有修改,所以x依旧是0,而y变成了1</p>
<h4 id="代码2-②-b"><a href="#代码2-②-b" class="headerlink" title="代码2(②+b):"></a>代码2(②+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x,y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = ++y;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果11</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field y:I</div><div class="line">         3: iconst_1</div><div class="line">         4: iadd</div><div class="line">         5: dup</div><div class="line">         6: putstatic     #3                  // Field y:I</div><div class="line">         9: putstatic     #4                  // Field x:I</div><div class="line">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #4                  // Field x:I</div><div class="line">        18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:y(值)入操作栈</p>
<p>3:常量1入操作栈</p>
<p>4:常量1和y(值)弹出栈,进行加操作,并将结果s入栈</p>
<p>5:得到栈顶元素也就是s的快照s’,并入操作栈</p>
<p>6:将s’弹出栈,并赋给y(变量)(此时y==1)</p>
<p>9:将s弹出栈,并赋给x(变量)(此时x==1)</p>
<h4 id="代码3-③-b"><a href="#代码3-③-b" class="headerlink" title="代码3(③+b):"></a>代码3(③+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = x++;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:0</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field x:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #3                  // Field x:I</div><div class="line">         9: putstatic     #3                  // Field x:I</div><div class="line">        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #3                  // Field x:I</div><div class="line">        18: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:x(值)入操作栈</p>
<p>3:得到x(值)的快照x’,入操作栈</p>
<p>4:常量1入操作栈</p>
<p>5:常量1和x’弹出操作栈,进行加操作,将结果s入操作栈</p>
<p>6:将s弹出栈,并赋给x(变量)(此时x==1)</p>
<p>9:将x(值)弹出栈,并赋给x(变量)(此时x的值被覆盖,x==0)</p>
<h4 id="代码4-④-b"><a href="#代码4-④-b" class="headerlink" title="代码4(④+b):"></a>代码4(④+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = ++x;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:1</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field x:I</div><div class="line">         3: iconst_1</div><div class="line">         4: iadd</div><div class="line">         5: dup</div><div class="line">         6: putstatic     #3                  // Field x:I</div><div class="line">         9: putstatic     #3                  // Field x:I</div><div class="line">        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #3                  // Field x:I</div><div class="line">        18: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:x(值)入操作栈</p>
<p>3:常量1如入操作栈</p>
<p>4:常量1和x(值)弹出操作栈,进行加操作,并将结果s入操作栈</p>
<p>5:得到栈顶元素s的快照s’,入操作栈</p>
<p>6.将s’弹出操作栈,并赋给x(变量)(此时x==1)</p>
<p>9:将s弹出操作栈,并赋给x(变量)(此时x==1)</p>
<h4 id="代码5-①-a"><a href="#代码5-①-a" class="headerlink" title="代码5(①+a):"></a>代码5(①+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        x = y++;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y); &#125; &#125;</div></pre></td></tr></table></figure>
<p><code>结果:01</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0: iload_1</div><div class="line">         1: iinc          1, 1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: new           #4                  // class java/lang/StringBuilder</div><div class="line">        11: dup</div><div class="line">        12: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">        15: iload_0</div><div class="line">        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        19: ldc           #7                  // String</div><div class="line">        21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">        24: iload_1</div><div class="line">        25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">        34: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:将本地变量区的y(值)入操作栈</p>
<p>1:将本地变量y加1(y==1)</p>
<p>4:将0中的y(值)弹出栈,并赋给本地变量区的x(x==0)</p>
<h4 id="代码6-②-a"><a href="#代码6-②-a" class="headerlink" title="代码6(②+a):"></a>代码6(②+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        x = ++y;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:11</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0: iinc          1, 1</div><div class="line">         3: iload_1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: new           #4                  // class java/lang/StringBuilder</div><div class="line">        11: dup</div><div class="line">        12: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">        15: iload_0</div><div class="line">        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        19: ldc           #7                  // String</div><div class="line">        21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">        24: iload_1</div><div class="line">        25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">        34: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:将本地变量y加1(此时y==1)</p>
<p>3:将本地变量y(值)入操作栈</p>
<p>4:将y(值)弹出操作栈,并赋给x(此时x==1)</p>
<h4 id="代码7-③-a"><a href="#代码7-③-a" class="headerlink" title="代码7(③+a):"></a>代码7(③+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        x = x++;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:0</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: iload_0</div><div class="line">         1: iinc          0, 1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: iload_0</div><div class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        12: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:本地变量x(值)入操作栈</p>
<p>1:本地变量x加1(此时x==1)</p>
<p>4:将x(值)弹出栈,并赋给本地变量x(此时x==0)</p>
<h4 id="代码8-④-a"><a href="#代码8-④-a" class="headerlink" title="代码8(④+a):"></a>代码8(④+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        x = ++x;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:1</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: iinc          0, 1</div><div class="line">         3: iload_0</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: iload_0</div><div class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        12: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:本地变量x加1(此时x==1)</p>
<p>3:本地变量x(值)入操作栈</p>
<p>4:将x(值)弹出操作栈,并赋给x(此时x==1) </p>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><font color="red">事实上i++和++i在底层的实现都是先自增,区别在于返回值.i++返回自增前的值,++i返回自增后的值。</font>



<p>现在来看看一开始那段代码的结果和解析:</p>
<p><code>结果:11</code></p>
<p><strong>myMethod()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #2                  // Field x:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #2                  // Field x:I</div><div class="line">         9: getstatic     #2                  // Field x:I</div><div class="line">        12: iconst_1</div><div class="line">        13: iadd</div><div class="line">        14: dup</div><div class="line">        15: putstatic     #2                  // Field x:I</div><div class="line">        18: iadd</div><div class="line">        19: putstatic     #5                  // Field y:I</div><div class="line">        22: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:变量x(值)入操作栈(栈状态:x0)</p>
<p>3:得到栈顶元素x(值)的快照x’(值),并入操作栈(栈状态:x0-&gt;x0’)</p>
<p>4:常量1入操作栈(栈状态:x0-&gt;x0’-&gt;1)</p>
<p>5:常量1和x’(值)弹出操作栈,进行加操作,将结果s0入操作栈(栈状态:x0-&gt;s0)</p>
<p>6:弹出s0,并赋给x(变量)(栈状态:x0,此时x(变量)==2)</p>
<p>9:将修改后的x(值)入操作栈(栈状态:x0-&gt;x1)</p>
<p>12:常量1入操作栈(栈状态:x0-&gt;x1-&gt;1)</p>
<p>13:常量1和X1(值)弹出操作栈,进行加操作,将结果s1入操作栈(栈状态:x0-&gt;s1)</p>
<p>14:得到栈顶元素s1(值)的快照s1’(值),并入操作栈(栈状态:x0-&gt;s1-&gt;s1’)</p>
<p>15:弹出s1’并赋给x(变量)(栈状态:x0-&gt;s1)</p>
<p>18:s1和x0弹出栈,进行加操作,将结果s2入栈(栈状态:s2)</p>
<p>19:弹出s2,并赋给y(变量) </p>
<p>所以在myMethod之后x的值为经过两次自增后的值,为x+2==3,而y的值为x0+s1,其中x0为最初传进来的值==1,s1是x经过两次自增后的值==3,所以y==4</p>
<p>x==3,y==4</p>
<p>最后输出的结果就是3+4+4==11</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="字节码" scheme="http://vinoit.me/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程调度</title>
    <link href="http://vinoit.me/2016/08/26/linux-kernel-note-process-scheduling/"/>
    <id>http://vinoit.me/2016/08/26/linux-kernel-note-process-scheduling/</id>
    <published>2016-08-26T08:23:54.000Z</published>
    <updated>2016-08-26T13:51:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>传统Unix操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。决定什么时候以怎样的方式选择一个新进程运行的这组规则就是所谓的调度策略（scheduling policy）。</p>
<p>Linux的进程调度是基于分时技术（time-sharing）。允许多个进程“并发”运行就意味着CPU 的时间被粗略地分成“片”，给每个可运行进程分配一片。</p>
<p>当然，单处理器在任何给定的时刻只能运行一个进程。当一个并发执行的进程其时间片或时限（quantum）到期时还没有终止，进程切换就可以发生。分时依赖于定时中断，因此，对进程是透明的。为保证CPU 分时，不需要在程序中插入额外的代码。</p>
<p>在Linux 中，进程的优先级是动态的。调度程序跟踪进程做了些什么，并周期性地调整它们的优先级。在这种方式下，在较长的时间间隔内没有使用CPU的进程，通过动态地增加它们的优先级来提升它们。相应地，对于已经在CPU上运行了较长时间的进程，通过减少它们的优先级来处罚它们。每个进程在创建之初有一个基本的优先级，执行期间调度系统会动态调整它的优先级，交互性高的任务会获得一个高的动态优先级，而交互性低的任务获得一个低的动态优先级。</p>
<h4 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h4><p>传统上把进程分类为“I/O 受限（I/O-bound）”或“CPU受限（CPU-bound）”。前者频繁地使用I/O 设备，并花费很多时间等待I/O操作的完成；而后者是需要大量CPU 时间的数值计算应用程序。</p>
<p>另一种分类法把进程区分为三类:<strong>交互式进程</strong> 、<strong>批处理进程</strong> 、<strong>实时进程</strong>。</p>
<p>交互式进程经常与用户交互，需要花很多时间等待键盘和鼠标操作。典型的交互式程序是命令shel、文本编辑程序、图形应用程序等。批处理程序不必与用户交互，经常在后台运行。因为这些进程不必被很快地相应，因此常受到调度程序的慢待。典型的批处理程序是编译程序、数据库搜索引擎、科学计算等。实时进程有很强的调度需要，他们不会被低优先级的进程阻塞，响应的时间很短。典型的实时程序有视频和音频应用程序、机器人控制程序、从物理传感器上收集数据的程序等。</p>
<p>这2种分类法在一定程度上互相独立。例如一个批处理程序可能是I/O受限型的（如数据库服务器），也可能是CPU受限型的（图像绘制程序）。Linux的调度算法可以明确的区分实时程序，但是没有办法区分交互式程序和批处理程序。Linux根据进程的过去行为，通过特定的算法区分交互式程序和批处理程序。因为交互式程序需要给用户一个良好的体验，所以Linux调度程序对交互式程序比较偏爱。</p>
<h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>交互式程序和批处理程序都叫做<strong>非实时进程（普通进程）</strong>，每个非实时进程都有自己的静态优先级（nice值），<code>值越大优先级越低</code>。。nice值是所有Unix系统的标准化概念，在OS X系统中nice值代表分配给进程的时间片的绝对值，<code>而Linux中代表时间片的比例</code>。通过<code>ps -el</code>命令查看系统中的进程列表，结果中标记<code>NI</code>的一列就是进程对应的nice值。</p>
<p>对于<strong>实时进程</strong>，实时优先级的范围是从1（最低优先级）~ 99（最高优先级），含义与nice值相反。任何实时进程的优先级总高于非实时进程（普通进程）。你可以通过<code>ps -eo stata,uid,pid,ppid,rtprio,time,com</code>查看系统中的进程列表，在<code>RTPRIO</code>列的就是实时优先级，如果显示<code>-</code>，则该进程不是实时进程。</p>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。一般来说，调度策略必须规定一个默认的时间片，但是Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比划分给了进程。这样一来，进程所获得的处理器时间其实是和系统负载密切相关的。nice值作为权重将调整使用比，值越大，使用比越小。Linux中CFS调度器的抢占时机取决于新进程所消耗的使用比。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。</p>
<p>不过，当可运行进程的数量区域无限时，每个进程获得使用比则趋于0，岂不是时间都花在切换进程上了？CFS为此引入了每个进程获得的时间片最小粒度，默认是1ms,也就是每个进程最少能获得1ms的运行时间。</p>
<h4 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h4><p>每个Linux进程都按照以下调度类型被调度：</p>
<ul>
<li><p>SCHED_FIFO<br>先进先出的实时进程。如果没有优先级更高的可运行的实时进程，则当前运行的实时进程想运行多久便运行多久，即使还有其他优先级相同的可运行实时进程</p>
</li>
<li><p>SCHED_RR<br>时间片轮转的实时进程。保证对所有相同优先级的实时进程公平地分配CPU时间。</p>
</li>
<li><p>SCHED_NORMAL<br>普通的分时进程。</p>
</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>早期Linux的调度算法非常简单，在每次进程切换时，内核扫描可运行进程的链表，然后选择“最佳”的进程来运行。这个算法的主要缺点是选择进程所消耗的时间与可运行进程的数量相关。当可运行进程的数量很多时，扫描花费的时间很不可观。</p>
<p>如今Linux采用的算法为“完全公平调度算法”，简称<code>CFS</code>。CFS是一个针对普通进程的调度器，期调度类型为<code>SCHED_NORMAL</code>。在#时间片#中已经讲到，nice值在CFS中被作为进程获得处理器运行比的权重。</p>
<p>CFS使用一个<code>struct sched_entity</code>数据结构来记录进程的调度情况，包括运行时间。进程描述符中的<code>se</code>字段便是该数据类型,<code>se</code>是当前进程的调度实体，该结构部分内容如下:</p>
<p><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.24#L866" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.24#L866</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sched_entity &#123;</div><div class="line">        <span class="keyword">struct</span> load_weight      load;           <span class="comment">/* for load-balancing */</span></div><div class="line">        <span class="keyword">struct</span> rb_node          run_node;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>            on_rq;</div><div class="line"></div><div class="line">        u64                     exec_start;</div><div class="line">        u64                     sum_exec_runtime;</div><div class="line">        u64                     vruntime;</div><div class="line">        u64                     prev_sum_exec_runtime;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>vruntime</code>变量存放进程的虚拟运行时间，CFS使用<code>vruntime</code>来记录一个程序到底运行了多长时间以及它应该再运行多久。可以简单地认为<code>vruntime</code>通过以下公式计算:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vruntime ＝ delta_time / load</div></pre></td></tr></table></figure>
<p>其中<code>delta_time</code>表示该进程以运行的时间，<code>load</code>表示进程对CPU的使用比，和nice值相关。当运行相同时间时，使用比大的进程vruntime更小，表明能获得更多的CPU时间。更新函数通过时钟中断调用。</p>
<p><strong>进程选择</strong></p>
<p>CFS调度算法的核心便是选择具有最小vruntime的进程，CFS使用红黑树来组织可运行进程队列，并且通过红黑树迅速找到最小vruntime的进程。红黑树中的每一个节点的值便是<code>vruntime</code>,越小的<code>vruntime</code>，位置越靠左下，所以只需找到最左下的节点的进程。</p>
<h4 id="调度相关数据结构"><a href="#调度相关数据结构" class="headerlink" title="调度相关数据结构"></a>调度相关数据结构</h4><h5 id="struct-rq"><a href="#struct-rq" class="headerlink" title="struct rq"></a>struct rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rq &#123;</div><div class="line"><span class="number">279</span>         <span class="comment">/* runqueue lock: */</span></div><div class="line"><span class="number">280</span>         <span class="keyword">spinlock_t</span> lock;</div><div class="line"><span class="number">281</span> </div><div class="line"><span class="number">282</span>         <span class="comment">/*</span></div><div class="line">283          * nr_running and cpu_load should be in the same cacheline because</div><div class="line">284          * remote CPUs use both these fields when doing load calculation.</div><div class="line">285          */</div><div class="line"><span class="number">286</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</div><div class="line"><span class="number">287</span>         <span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></div><div class="line"><span class="number">288</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</div><div class="line"><span class="number">289</span>         <span class="keyword">unsigned</span> <span class="keyword">char</span> idle_at_tick;</div><div class="line"><span class="number">290</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ</span></div><div class="line"><span class="number">291</span>         <span class="keyword">unsigned</span> <span class="keyword">char</span> in_nohz_recently;</div><div class="line"><span class="number">292</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">293</span>         <span class="comment">/* capture load from *all* tasks on this cpu: */</span></div><div class="line"><span class="number">294</span>         <span class="keyword">struct</span> load_weight load;</div><div class="line"><span class="number">295</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_load_updates;</div><div class="line"><span class="number">296</span>         u64 nr_switches;</div><div class="line"><span class="number">297</span> </div><div class="line"><span class="number">298</span>         <span class="keyword">struct</span> cfs_rq cfs;</div><div class="line"><span class="number">299</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></div><div class="line"><span class="number">300</span>         <span class="comment">/* list of leaf cfs_rq on this cpu: */</span></div><div class="line"><span class="number">301</span>         <span class="keyword">struct</span> list_head leaf_cfs_rq_list;</div><div class="line"><span class="number">302</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">303</span>         <span class="keyword">struct</span> rt_rq rt;</div><div class="line"><span class="number">304</span> </div><div class="line"><span class="number">305</span>         <span class="comment">/*</span></div><div class="line">306          * This is part of a global counter where only the total sum</div><div class="line">307          * over all CPUs matters. A task can increase this counter on</div><div class="line">308          * one CPU and if it got migrated afterwards it may decrease</div><div class="line">309          * it on another CPU. Always updated under the runqueue lock:</div><div class="line">310          */</div><div class="line"><span class="number">311</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_uninterruptible;</div><div class="line"><span class="number">312</span> </div><div class="line"><span class="number">313</span>         <span class="keyword">struct</span> task_struct *curr, *idle;</div><div class="line"><span class="number">314</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> next_balance;</div><div class="line"><span class="number">315</span>         <span class="keyword">struct</span> mm_struct *prev_mm;</div><div class="line"><span class="number">316</span> </div><div class="line"><span class="number">317</span>         u64 clock, prev_clock_raw;</div><div class="line"><span class="number">318</span>         s64 clock_max_delta;</div><div class="line"><span class="number">319</span> </div><div class="line"><span class="number">320</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> clock_warps, clock_overflows;</div><div class="line"><span class="number">321</span>         u64 idle_clock;</div><div class="line"><span class="number">322</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> clock_deep_idle_events;</div><div class="line"><span class="number">323</span>         u64 tick_timestamp;</div><div class="line"><span class="number">324</span> </div><div class="line"><span class="number">325</span>         <span class="keyword">atomic_t</span> nr_iowait;</div><div class="line"><span class="number">326</span> </div><div class="line"><span class="number">327</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></div><div class="line"><span class="number">328</span>         <span class="keyword">struct</span> sched_domain *sd;</div><div class="line"><span class="number">329</span> </div><div class="line"><span class="number">330</span>         <span class="comment">/* For active balancing */</span></div><div class="line"><span class="number">331</span>         <span class="keyword">int</span> active_balance;</div><div class="line"><span class="number">332</span>         <span class="keyword">int</span> push_cpu;</div><div class="line"><span class="number">333</span>         <span class="comment">/* cpu of this runqueue: */</span></div><div class="line"><span class="number">334</span>         <span class="keyword">int</span> cpu;</div><div class="line"><span class="number">335</span> </div><div class="line"><span class="number">336</span>         <span class="keyword">struct</span> task_struct *migration_thread;</div><div class="line"><span class="number">337</span>         <span class="keyword">struct</span> list_head migration_queue;</div><div class="line"><span class="number">338</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">339</span> </div><div class="line"><span class="number">340</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></div><div class="line"><span class="number">341</span>         <span class="comment">/* latency stats */</span></div><div class="line"><span class="number">342</span>         <span class="keyword">struct</span> sched_info rq_sched_info;</div><div class="line"><span class="number">343</span> </div><div class="line"><span class="number">344</span>         <span class="comment">/* sys_sched_yield() stats */</span></div><div class="line"><span class="number">345</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_exp_empty;</div><div class="line"><span class="number">346</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_act_empty;</div><div class="line"><span class="number">347</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_both_empty;</div><div class="line"><span class="number">348</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_count;</div><div class="line"><span class="number">349</span> </div><div class="line"><span class="number">350</span>         <span class="comment">/* schedule() stats */</span></div><div class="line"><span class="number">351</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_switch;</div><div class="line"><span class="number">352</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_count;</div><div class="line"><span class="number">353</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_goidle;</div><div class="line"><span class="number">354</span> </div><div class="line"><span class="number">355</span>         <span class="comment">/* try_to_wake_up() stats */</span></div><div class="line"><span class="number">356</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> ttwu_count;</div><div class="line"><span class="number">357</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> ttwu_local;</div><div class="line"><span class="number">358</span> </div><div class="line"><span class="number">359</span>         <span class="comment">/* BKL stats */</span></div><div class="line"><span class="number">360</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> bkl_count;</div><div class="line"><span class="number">361</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">362</span>         <span class="keyword">struct</span> lock_class_key rq_lock_key;</div><div class="line"><span class="number">363</span> &#125;;</div></pre></td></tr></table></figure>
<h5 id="struct-cfs-rq"><a href="#struct-cfs-rq" class="headerlink" title="struct cfs_rq"></a>struct cfs_rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cfs_rq &#123;</div><div class="line"><span class="number">232</span>         <span class="keyword">struct</span> load_weight load;</div><div class="line"><span class="number">233</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</div><div class="line"><span class="number">234</span> </div><div class="line"><span class="number">235</span>         u64 exec_clock;</div><div class="line"><span class="number">236</span>         u64 min_vruntime;</div><div class="line"><span class="number">237</span> </div><div class="line"><span class="number">238</span>         <span class="keyword">struct</span> rb_root tasks_timeline;</div><div class="line"><span class="number">239</span>         <span class="keyword">struct</span> rb_node *rb_leftmost;</div><div class="line"><span class="number">240</span>         <span class="keyword">struct</span> rb_node *rb_load_balance_curr;</div><div class="line"><span class="number">241</span>         <span class="comment">/* 'curr' points to currently running entity on this cfs_rq.</span></div><div class="line">242          * It is set to NULL otherwise (i.e when none are currently running).</div><div class="line">243          */</div><div class="line"><span class="number">244</span>         <span class="keyword">struct</span> sched_entity *curr;</div><div class="line"><span class="number">245</span> </div><div class="line"><span class="number">246</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_spread_over;</div><div class="line"><span class="number">247</span> </div><div class="line"><span class="number">248</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></div><div class="line"><span class="number">249</span>         <span class="keyword">struct</span> rq *rq;  <span class="comment">/* cpu runqueue to which this cfs_rq is attached */</span></div><div class="line"><span class="number">250</span> </div><div class="line"><span class="number">251</span>         <span class="comment">/*</span></div><div class="line">252          * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in</div><div class="line">253          * a hierarchy). Non-leaf lrqs hold other higher schedulable entities</div><div class="line">254          * (like users, containers etc.)</div><div class="line">255          *</div><div class="line">256          * leaf_cfs_rq_list ties together list of leaf cfs_rq's in a cpu. This</div><div class="line">257          * list is used during load balance.</div><div class="line">258          */</div><div class="line"><span class="number">259</span>         <span class="keyword">struct</span> list_head leaf_cfs_rq_list;</div><div class="line"><span class="number">260</span>         <span class="keyword">struct</span> task_group *tg;  <span class="comment">/* group that "owns" this runqueue */</span></div><div class="line"><span class="number">261</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">262</span> &#125;;</div></pre></td></tr></table></figure>
<h5 id="struct-rt-rq"><a href="#struct-rt-rq" class="headerlink" title="struct rt_rq"></a>struct rt_rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rt_rq &#123;</div><div class="line"><span class="number">266</span>         <span class="keyword">struct</span> rt_prio_array active;</div><div class="line"><span class="number">267</span>         <span class="keyword">int</span> rt_load_balance_idx;</div><div class="line"><span class="number">268</span>         <span class="keyword">struct</span> list_head *rt_load_balance_head, *rt_load_balance_curr;</div><div class="line"><span class="number">269</span> &#125;;</div></pre></td></tr></table></figure>
<p><code>struct rq</code>为一个运行队列，每个CPU都有一个这样的数据结构，在<code>rq</code>中有<code>struct cfs_rq</code>类型的cfs字段，该字段表示一个CFS调度器的运行队列，<code>rq</code>中的<code>struct rt_rq</code>类型的rt字段表示一个实时进程的运行队列。具体细节日后有时间在整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h4&gt;&lt;p&gt;传统Unix操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux中x86的内联汇编</title>
    <link href="http://vinoit.me/2016/08/24/linux-x86-assembly-inline/"/>
    <id>http://vinoit.me/2016/08/24/linux-x86-assembly-inline/</id>
    <published>2016-08-24T07:45:39.000Z</published>
    <updated>2016-08-24T08:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址:<a href="https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/</a></p>
</blockquote>
<p>如果您是 Linux 内核的开发人员，您会发现自己经常要对与体系结构高度相关的功能进行编码或优化代码路径。您很可能是通过将汇编语言指令插入到 C 语句的中间（又称为内联汇编的一种方法）来执行这些任务的。让我们看一下 Linux 中内联汇编的特定用法。（我们将讨论限制在 IA32 汇编。）</p>
<h4 id="GNU-汇编程序简述"><a href="#GNU-汇编程序简述" class="headerlink" title="GNU 汇编程序简述"></a>GNU 汇编程序简述</h4><p>让我们首先看一下 Linux 中使用的基本汇编程序语法。GCC（用于 Linux 的 GNU C 编译器）使用 AT&amp;T 汇编语法。下面列出了这种语法的一些基本规则。（该列表肯定不完整；只包括了与内联汇编相关的那些规则。）</p>
<p><strong>寄存器命名</strong><br>寄存器名称有 % 前缀。即，如果必须使用 eax，它应该用作 %eax。<br>源操作数和目的操作数的顺序<br>在所有指令中，先是源操作数，然后才是目的操作数。这与将源操作数放在目的操作数之后的 Intel 语法不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov %eax, %ebx, transfers the contents of eax to ebx.</div></pre></td></tr></table></figure>
<p><strong>操作数大小</strong><br>根据操作数是字节 (byte)、字 (word) 还是长型 (long)，指令的后缀可以是 b、w 或 l。这并不是强制性的；GCC 会尝试通过读取操作数来提供相应的后缀。但手工指定后缀可以改善代码的可读性，并可以消除编译器猜测不正确的可能性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movb %al, %bl -- Byte move</div><div class="line">movw %ax, %bx -- Word move</div><div class="line">movl %eax, %ebx -- Longword move</div></pre></td></tr></table></figure>
<p><strong>立即操作数</strong><br>通过使用 $ 指定直接操作数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movl $0xffff, %eax -- will move the value of 0xffff into eax register.</div></pre></td></tr></table></figure></p>
<p><strong>间接内存引用</strong><br>任何对内存的间接引用都是通过使用 ( ) 来完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movb (%esi), %al -- will transfer the byte in the memory pointed by esi into al register</div></pre></td></tr></table></figure>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>GCC 为内联汇编提供特殊结构，它具有以下格式：</p>
<p><strong>GCG 的 “asm” 结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  asm ( assembler template</div><div class="line">    </div><div class="line">: output operands               (optional)</div><div class="line">    </div><div class="line">: input operands                (optional)</div><div class="line">    </div><div class="line">: list of clobbered registers   </div><div class="line">    (optional)</div><div class="line">    </div><div class="line">);</div></pre></td></tr></table></figure>
<p>本例中，汇编程序模板由汇编指令组成。输入操作数是充当指令输入操作数使用的 C 表达式。输出操作数是将对其执行汇编指令输出的 C 表达式。<br>内联汇编的重要性体现在它能够灵活操作，而且可以使其输出通过 C 变量显示出来。因为它具有这种能力，所以 “asm” 可以用作汇编指令和包含它的 C 程序之间的接口。<br>一个非常基本但很重要的区别在于 简单内联汇编只包括指令，而 扩展内联汇编包括操作数。要说明这一点，考虑以下示例：</p>
<p><strong>内联汇编的基本要素</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int a=10, b;</div><div class="line">    asm ("movl %1, %%eax;</div><div class="line">    </div><div class="line">movl %%eax, %0;"</div><div class="line">        :"=r"(b)  /* output */    </div><div class="line">        :"r"(a)       /* input */</div><div class="line">        :"%eax"); /* clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，我们使用汇编指令使 “b” 的值等于 “a”。请注意以下几点：</p>
<ul>
<li>“b” 是输出操作数，由 %0 引用，”a” 是输入操作数，由 %1 引用。</li>
<li>“r” 是操作数的约束，它指定将变量 “a” 和 “b” 存储在寄存器中。请注意，输出操作数约束应该带有一个约束修饰符 “=”，指定它是输出操作数。</li>
<li>要在 “asm” 内使用寄存器 %eax，%eax 的前面应该再加一个 %，换句话说就是 %%eax，因为 “asm” 使用 %0、%1 等来标识变量。任何带有一个 % 的数都看作是输入／输出操作数，而不认为是寄存器。</li>
<li>第三个冒号后的修饰寄存器 %eax 告诉将在 “asm” 中修改 GCC %eax 的值，这样 GCC 就不使用该寄存器存储任何其它的值。</li>
<li>movl %1, %%eax 将 “a” 的值移到 %eax 中， movl %%eax, %0 将 %eax 的内容移到 “b” 中。</li>
<li>因为 “b” 被指定成输出操作数，因此当 “asm” 的执行完成后，它将反映出更新的值。换句话说，对 “asm” 内 “b” 所做的更改将在 “asm” 外反映出来。</li>
</ul>
<p>现在让我们更详细的了解每一项的含义。</p>
<h4 id="汇编程序模板"><a href="#汇编程序模板" class="headerlink" title="汇编程序模板"></a>汇编程序模板</h4><p>汇编程序模板是一组插入到 C 程序中的汇编指令（可以是单个指令，也可以是一组指令）。每条指令都应该由双引号括起，或者整组指令应该由双引号括起。每条指令还应该用一个定界符结尾。有效的定界符为新行 (\n) 和分号 (;)。 ‘\n’ 后可以跟一个 tab(\t) 作为格式化符号，增加 GCC 在汇编文件中生成的指令的可读性。 指令通过数 %0、%1 等来引用 C 表达式（指定为操作数）。</p>
<p>如果希望确保编译器不会在 “asm” 内部优化指令，可以在 “asm” 后使用关键字 “volatile”。如果程序必须与 ANSI C 兼容，则应该使用 <code>__asm__</code> 和 <code>__volatile__</code>，而不是 asm 和 volatile。</p>
<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>C 表达式用作 “asm” 内的汇编指令操作数。在汇编指令通过对 C 程序的 C 表达式进行操作来执行有意义的作业的情况下，操作数是内联汇编的主要特性。</p>
<p>每个操作数都由操作数约束字符串指定，后面跟用括弧括起的 C 表达式，例如：”constraint” (C expression)。操作数约束的主要功能是确定操作数的寻址方式。<br>可以在输入和输出部分中同时使用多个操作数。每个操作数由逗号分隔开。</p>
<p>在汇编程序模板内部，操作数由数字引用。如果总共有 n 个操作数（包括输入和输出），那么第一个输出操作数的编号为 0，逐项递增，最后那个输入操作数的编号为 n -1。总操作数的数目限制在 10，如果机器描述中任何指令模式中的最大操作数数目大于 10，则使用后者作为限制。</p>
<h4 id="修饰寄存器列表"><a href="#修饰寄存器列表" class="headerlink" title="修饰寄存器列表"></a>修饰寄存器列表</h4><p>如果 “asm” 中的指令指的是硬件寄存器，可以告诉 GCC 我们将自己使用和修改它们。这样，GCC 就不会假设它装入到这些寄存器中的值是有效值。通常不需要将输入和输出寄存器列为 clobbered，因为 GCC 知道 “asm” 使用它们（因为它们被明确指定为约束）。不过，如果指令使用任何其它的寄存器，无论是明确的还是隐含的（寄存器不在输入约束列表中出现，也不在输出约束列表中出现），寄存器都必须被指定为修饰列表。修饰寄存器列在第三个冒号之后，其名称被指定为字符串。</p>
<p>至于关键字，如果指令以某些不可预知且不明确的方式修改了内存，则可能将 “memory” 关键字添加到修饰寄存器列表中。这样就告诉 GCC 不要在不同指令之间将内存值高速缓存在寄存器中。</p>
<h4 id="操作数约束"><a href="#操作数约束" class="headerlink" title="操作数约束"></a>操作数约束</h4><p>前面提到过，”asm” 中的每个操作数都应该由操作数约束字符串描述，后面跟用括弧括起的 C 表达式。操作数约束主要是确定指令中操作数的寻址方式。约束也可以指定：</p>
<ul>
<li>是否允许操作数位于寄存器中，以及它可以包括在哪些种类的寄存器中</li>
<li>操作数是否可以是内存引用，以及在这种情况下使用哪些种类的地址</li>
<li>操作数是否可以是立即数</li>
</ul>
<p>约束还要求两个操作数匹配。</p>
<h4 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h4><p>在可用的操作数约束中，只有一小部分是常用的；下面列出了这些约束以及简要描述。有关操作数约束的完整列表，请参考 GCC 和 GAS 手册。</p>
<p><strong>寄存器操作数约束 (r)</strong><br>使用这种约束指定操作数时，它们存储在通用寄存器中。请看下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asm (&quot;movl %%cr3, %0\n&quot; :&quot;=r&quot;(cr3val));</div></pre></td></tr></table></figure>
<p>这里，变量 cr3val 保存在寄存器中，%cr3 的值复制到寄存器上，cr3val 的值从该寄存器更新到内存中。指定 “r” 约束时，GCC 可以将变量 cr3val 保存在任何可用的 GPR 中。要指定寄存器，必须通过使用特定的寄存器约束直接指定寄存器名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">a        eax</div><div class="line">b        ebx</div><div class="line">c        ecx</div><div class="line">d        edx</div><div class="line">S        esi</div><div class="line">D        edi</div><div class="line">I        constant value (0 to 31)</div><div class="line">q,r      dynamically allocated register (see below)</div><div class="line">g        eax, ebx, ecx, edx or variable in memory</div><div class="line">A        eax and edx combined into a 64-bit integer (use long longs)</div></pre></td></tr></table></figure>
<p><strong>内存操作数约束 (m)</strong><br>当操作数位于内存中时，任何对它们执行的操作都将在内存位置中直接发生，这与寄存器约束正好相反，后者先将值存储在要修改的寄存器中，然后将它写回内存位置中。但寄存器约束通常只在对于指令来说它们是绝对必需的，或者它们可以大大提高进程速度时使用。当需要在 “asm” 内部更新 C 变量，而您又确实不希望使用寄存器来保存其值时，使用内存约束最为有效。例如，idtr 的值存储在内存位置 loc 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&quot;sidt %0\n&quot; : :&quot;m&quot;(loc));</div></pre></td></tr></table></figure>
<p><strong>匹配（数字）约束</strong><br>在某些情况下，一个变量既要充当输入操作数，也要充当输出操作数。可以通过使用匹配约束在 “asm” 中指定这种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asm (&quot;incl %0&quot; :&quot;=a&quot;(var):&quot;0&quot;(var));</div></pre></td></tr></table></figure>
<p>在匹配约束的示例中，寄存器 %eax 既用作输入变量，也用作输出变量。将 var 输入读取到 %eax，增加后将更新的 %eax 再次存储在 var 中。这里的 “0” 指定第 0 个输出变量相同的约束。即，它指定 var 的输出实例只应该存储在 %eax 中。该约束可以用于以下情况：</p>
<ul>
<li>输入从变量中读取，或者变量被修改后，修改写回到同一变量中</li>
<li>不需要将输入操作数和输出操作数的实例分开</li>
</ul>
<p>使用匹配约束最重要的意义在于它们可以导致有效地使用可用寄存器。</p>
<h4 id="一般内联汇编用法示例"><a href="#一般内联汇编用法示例" class="headerlink" title="一般内联汇编用法示例"></a>一般内联汇编用法示例</h4><p>以下示例通过各种不同的操作数约束说明了用法。有如此多的约束以至于无法将它们一一列出，这里只列出了最经常使用的那些约束类型。</p>
<p><code>&quot;asm&quot; 和寄存器约束 &quot;r&quot;</code> 让我们先看一下使用寄存器约束 r 的 “asm”。我们的示例显示了 GCC 如何分配寄存器，以及它如何更新输出变量的值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int x = 10, y;</div><div class="line">    </div><div class="line">    asm ("movl %1, %%eax;</div><div class="line">    </div><div class="line"> "movl %%eax, %0;"</div><div class="line">        :"=r"(y)  /* y is output operand */</div><div class="line">        :"r"(x)       /* x is input operand */</div><div class="line">        :"%eax"); /* %eax is clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该例中，x 的值复制为 “asm” 中的 y。x 和 y 都通过存储在寄存器中传递给 “asm”。为该例生成的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $8,%esp</div><div class="line">movl $10,-4(%ebp)    </div><div class="line">movl -4(%ebp),%edx  /* x=10 is stored in %edx */</div><div class="line">#APP    /* asm starts here */   </div><div class="line">movl %edx, %eax     /* x is moved to %eax */</div><div class="line">movl %eax, %edx     /* y is allocated in edx and updated */</div><div class="line">#NO_APP /* asm ends here */</div><div class="line">movl %edx,-8(%ebp)  /* value of y in stack is updated with </div><div class="line">                </div><div class="line"> the value in %edx */</div></pre></td></tr></table></figure>
<p>当使用 “r” 约束时，GCC 在这里可以自由分配任何寄存器。在我们的示例中，它选择 %edx 来存储 x。在读取了 %edx 中 x 的值后，它为 y 也分配了相同的寄存器。</p>
<p>因为 y 是在输出操作数部分中指定的，所以 %edx 中更新的值存储在 -8(%ebp)，堆栈上 y 的位置中。如果 y 是在输入部分中指定的，那么即使它在 y 的临时寄存器存储值 (%edx) 中被更新，堆栈上 y 的值也不会更新。</p>
<p>因为 %eax 是在修饰列表中指定的，GCC 不在任何其它地方使用它来存储数据。</p>
<p>输入 x 和输出 y 都分配在同一个 %edx 寄存器中，假设输入在输出产生之前被消耗。请注意，如果您有许多指令，就不是这种情况了。要确保输入和输出分配到不同的寄存器中，可以指定 &amp; 约束修饰符。下面是添加了约束修饰符的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int x = 10, y;</div><div class="line">    </div><div class="line">    asm (&quot;movl %1, %%eax;</div><div class="line">    </div><div class="line"> &quot;movl %%eax, %0;&quot;</div><div class="line">        :&quot;=&amp;r&quot;(y) /* y is output operand, note the    </div><div class="line">                </div><div class="line"> &amp; constraint modifier. */</div><div class="line">        :&quot;r&quot;(x)       /* x is input operand */</div><div class="line">        :&quot;%eax&quot;); /* %eax is clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是为该示例生成的汇编代码，从中可以明显地看出 x 和 y 存储在 “asm” 中不同的寄存器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $8,%esp</div><div class="line">movl $10,-4(%ebp)</div><div class="line">movl -4(%ebp),%ecx  /* x, the input is in %ecx */</div><div class="line">#APP</div><div class="line">    movl %ecx, %eax</div><div class="line">    movl %eax, %edx     /* y, the output is in %edx */</div><div class="line">#NO_APP</div><div class="line">movl %edx,-8(%ebp)</div></pre></td></tr></table></figure>
<h4 id="特定寄存器约束的使用"><a href="#特定寄存器约束的使用" class="headerlink" title="特定寄存器约束的使用"></a>特定寄存器约束的使用</h4><p>现在让我们看一下如何将个别寄存器作为操作数的约束指定。在下面的示例中，cpuid 指令采用 %eax 寄存器中的输入，然后在四个寄存器中给出输出：%eax、%ebx、%ecx、%edx。对 cpuid 的输入（变量 “op”）传递到 “asm” 的 eax 寄存器中，因为 cpuid 希望它这样做。在输出中使用 a、b、c 和 d 约束，分别收集四个寄存器中的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">asm (&quot;cpuid&quot;</div><div class="line">: &quot;=a&quot; (_eax),</div><div class="line">&quot;=b&quot; (_ebx),</div><div class="line">&quot;=c&quot; (_ecx),</div><div class="line">&quot;=d&quot; (_edx)</div><div class="line">: &quot;a&quot; (op));</div></pre></td></tr></table></figure>
<p>在下面可以看到为它生成的汇编代码（假设 _eax、_ebx 等… 变量都存储在堆栈上）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">movl -20(%ebp),%eax /* store &apos;op&apos; in %eax -- input */</div><div class="line">#APP</div><div class="line">cpuid</div><div class="line">#NO_APP</div><div class="line">movl %eax,-4(%ebp)  /* store %eax in _eax -- output */</div><div class="line">movl %ebx,-8(%ebp)  /* store other registers in</div><div class="line">movl %ecx,-12(%ebp) </div><div class="line"> respective output variables */</div><div class="line">movl %edx,-16(%ebp)</div></pre></td></tr></table></figure>
<p>strcpy 函数可以通过以下方式使用 “S” 和 “D” 约束来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">asm (&quot;cld\n</div><div class="line">    </div><div class="line">rep\n</div><div class="line">    </div><div class="line">movsb&quot;</div><div class="line">    </div><div class="line">: /* no input */</div><div class="line">    </div><div class="line">:&quot;S&quot;(src), &quot;D&quot;(dst), &quot;c&quot;(count));</div></pre></td></tr></table></figure>
<p>通过使用 “S” 约束将源指针 src 放入 %esi 中，使用 “D” 约束将目的指针 dst 放入 %edi 中。因为 rep 前缀需要 count 值，所以将它放入 %ecx 中。</p>
<p>在下面可以看到另一个约束，它使用两个寄存器 %eax 和 %edx 将两个 32 位的值合并在一起，然后生成一个64 位的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define rdtscll(val) \</div><div class="line"> __asm__ __volatile__ (&quot;rdtsc&quot; : &quot;=A&quot; (val))</div><div class="line">The generated assembly looks like this (if val has a 64 bit memory space).</div><div class="line">#APP</div><div class="line">rdtsc</div><div class="line">#NO_APP</div><div class="line">movl %eax,-8(%ebp)  /* As a result of A constraint </div><div class="line">movl %edx,-4(%ebp)  </div><div class="line"> %eax and %edx serve as outputs */</div><div class="line">Note here that the values in %edx:%eax serve as 64 bit output.</div></pre></td></tr></table></figure>
<h4 id="使用匹配约束"><a href="#使用匹配约束" class="headerlink" title="使用匹配约束"></a>使用匹配约束</h4><p>在下面将看到系统调用的代码，它有四个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \</div><div class="line">type name (type1 arg1, type2 arg2, type3 arg3, type4 arg4) \</div><div class="line">&#123; \</div><div class="line">long __res; \</div><div class="line">__asm__ volatile (&quot;int $0x80&quot; \</div><div class="line">: &quot;=a&quot; (__res) \</div><div class="line">: &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1)),&quot;c&quot; ((long)(arg2)), \</div><div class="line">&quot;d&quot; ((long)(arg3)),&quot;S&quot; ((long)(arg4))); \</div><div class="line">__syscall_return(type,__res); \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，通过使用 b、c、d 和 S 约束将系统调用的四个自变量放入 %ebx、%ecx、%edx 和 %esi 中。请注意，在输出中使用了 “=a” 约束，这样，位于 %eax 中的系统调用的返回值就被放入变量 <strong>res 中。通过将匹配约束 “0” 用作输入部分中第一个操作数约束，syscall 号 </strong>NR_##name 被放入 %eax 中，并用作对系统调用的输入。这样，这里的 %eax 既可以用作输入寄存器，又可以用作输出寄存器。没有其它寄存器用于这个目的。另请注意，输入（syscall 号）在产生输出（syscall 的返回值）之前被消耗（使用）。</p>
<h4 id="内存操作数约束的使用"><a href="#内存操作数约束的使用" class="headerlink" title="内存操作数约束的使用"></a>内存操作数约束的使用</h4><p>请考虑下面的原子递减操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__asm__ __volatile__(</div><div class="line">&quot;lock; decl %0&quot;</div><div class="line">:&quot;=m&quot; (counter)</div><div class="line">:&quot;m&quot; (counter));</div></pre></td></tr></table></figure>
<p>为它生成的汇编类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#APP</div><div class="line">    lock</div><div class="line">    decl -24(%ebp) /* counter is modified on its memory location */</div><div class="line">#NO_APP.</div></pre></td></tr></table></figure>
<p>您可能考虑在这里为 counter 使用寄存器约束。如果这样做，counter 的值必须先复制到寄存器，递减，然后对其内存更新。但这样您会无法理解锁定和原子性的全部意图，这些明确显示了使用内存约束的必要性。</p>
<h4 id="使用修饰寄存器"><a href="#使用修饰寄存器" class="headerlink" title="使用修饰寄存器"></a>使用修饰寄存器</h4><p>请考虑内存拷贝的基本实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   asm (&quot;movl $count, %%ecx;</div><div class="line">    </div><div class="line">up: lodsl;  </div><div class="line">    </div><div class="line">stosl;</div><div class="line">    </div><div class="line">loop up;&quot;</div><div class="line">        :           /* no output */</div><div class="line">        :&quot;S&quot;(src), &quot;D&quot;(dst) /* input */</div><div class="line">        :&quot;%ecx&quot;, &quot;%eax&quot; );  /* clobbered list */</div></pre></td></tr></table></figure>
<p>当 lodsl 修改 %eax 时，lodsl 和 stosl 指令隐含地使用它。%ecx 寄存器明确装入 count。但 GCC 在我们通知它以前是不知道这些的，我们是通过将 %eax 和 %ecx 包括在修饰寄存器集中来通知 GCC 的。在完成这一步之前，GCC 假设 %eax 和 %ecx 是自由的，它可能决定将它们用作存储其它的数据。请注意，%esi 和 %edi 由 “asm” 使用，它们不在修饰列表中。这是因为已经声明 “asm” 将在输入操作数列表中使用它们。这里最低限度是，如果在 “asm” 内部使用寄存器（无论是明确还是隐含地），既不出现在输入操作数列表中，也不出现在输出操作数列表中，必须将它列为修饰寄存器。</p>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>总的来说，内联汇编非常巨大，它提供的许多特性我们甚至在这里根本没有涉及到。但如果掌握了本文描述的基本材料，您应该可以开始对自己的内联汇编进行编码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.i
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
      <category term="汇编" scheme="http://vinoit.me/categories/Linux/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="汇编" scheme="http://vinoit.me/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程（三）</title>
    <link href="http://vinoit.me/2016/08/24/linux-kernel-note-process-three/"/>
    <id>http://vinoit.me/2016/08/24/linux-kernel-note-process-three/</id>
    <published>2016-08-24T05:42:48.000Z</published>
    <updated>2016-08-24T15:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。</p>
<h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。</p>
<p>进程恢复执行前必须装入寄存器的一组数据成为硬件上下文（hardware context）。硬件上下文是进程可执行上下文的一个自己，因为可执行上下文包含进程执行时所需要的所有信息。在Linux中，进程硬件上下午的一部分存放在<code>TSS段</code>，而剩余部分存放在<code>内核态堆栈</code>中。</p>
<p>在下面描述中，假定用prev局部变量表示切换出的进程描述符，next表示切换进的进程描述符,<code>这2个局部变量都存放在进程的内核堆栈中</code>。因此，我们把进程切换定义为这样的行为：保存prev硬件上下文，用next硬件上下文代替prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。</p>
<p>早期Linux版本利用80x86体系结构所需提供的硬件支持，并通过far jmp1指令跳到next进程TSS描述符的选择符来执行进程切换。当执行这条指令时，CPU通过自动保存原来的硬件上下文，装入新的硬件上下文来执行硬件上下文切换。但Linux2.6使用软件执行进程切换，原因有：</p>
<p>通过一组mov指令逐步执行切换，这样能较好地控制所装入的数据的合法性，一面被恶意用户伪造。far jmp指令不会有这样的检查。<br>旧方法和新方法所需时间大致相同。<br>进程切换值发生在<code>内核态</code>，在执行进程切换之前，用户态进程使用的所有寄存器内容已保存在内核堆栈上，这也包括ss和esp这对寄存器的内容。</p>
<h4 id="任务状态段"><a href="#任务状态段" class="headerlink" title="任务状态段"></a>任务状态段</h4><p>80x86体系结构包含了一个特殊的段类型，叫任务状态段（Task State Segment，TSS）来存放硬件上下文，尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS，这样做主要有两个理由：</p>
<p>当80x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址。<br>当用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存放在TSS中的I/O许可位图以检查该进程是否有访问端口的权利。<br>更确切的说，当进程在用户态执行in或out指令时，控制单元执行下列操作：</p>
<p>检查eflags寄存器中的2位IOPL字段，如果字段的值为3，控制单元就执行I/O指令。否则，执行下一个检查。<br>访问tr寄存器以确定当前的TSS和相应的I/O许可权位图。<br>检查I/O指令中指定的I/O端口在I/O许可权位图中对应的位，如果该位清，这条指令就执行，否则控制单元产生一个异常。<br>tss_struct结构描述TSS的格式，<code>init_tss数组</code>为系统上每个不同的CPU存放一个TSS。在每次进程切换时，内核都更新TSS的某些字段以便相应的CPU控制单元可以安全地检索到它需要的信息。因此，<code>TSS反映了CPU上当前进程的特权级，但不必为没有在运行的进程保留TSS</code>。</p>
<p>每个TSS有它自己8字节的任务状态段描述符（Task State Segment Descriptor，TSSD）。和其他描述符一样，这个描述符包括指向TSS起始地址的32位Base字段，20位Limit字段。TSSD的S标志位被清0，以表示相应的TSS是<code>系统段</code>的事实。</p>
<p>Type字段被置位11或9以表示这个段实际上是一个TSS。在Intel的原始设计中，<code>系统中的每个进程都应当指向自己的TSS</code>；Type字段的第二个有效位叫Busy位；如果进程正由CPU执行，则该位置1，否则为0。在Linux的设计中，<code>每个CPU只有一个TSS</code>，因此Busy位总是为1.</p>
<p>由Linux创建的TSSD存放在全局描述符表（GDT）中，GDT的基地址存放在每个CPU的gdtr寄存器中。<br><img src="/images/linux-kernel-note/process-three-0.png" alt=""><br>每个CPU的tr寄存器包含相应TSS的TSSD选择符，也包含了两个<code>隐藏的非编程字段</code>：TSSD的Base字段和Limit字段。这样，处理器就能够直接TSS寻址而不需要从GDT中检索TSS地址。</p>
<h4 id="thread字段"><a href="#thread字段" class="headerlink" title="thread字段"></a>thread字段</h4><p>在每次进程切换时，被替换的进程的硬件上下文必须保存在别处。不能像Intel原始设计那样保存在TSS中，因为<code>Linux为每个处理器而不是为每个进程使用TSS</code>。</p>
<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后可以看到，这个数据结构包含的字段涉及大部分CPU寄存器，但不包括eax、ebx等等这些通用寄存器。它们的值保留在内核堆栈中。</p>
<h4 id="执行进程切换"><a href="#执行进程切换" class="headerlink" title="执行进程切换"></a>执行进程切换</h4><p>进程切换可能只发生在精心定义的点：schedule()函数，这个函数在专门整理进程调度的篇幅里讲解。这里，只关注内核如何执行一个进程切换。</p>
<p>进程切换由两步组成：</p>
<ul>
<li>切换页全局目录以安装一个新的地址空间。</li>
<li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</li>
</ul>
<p>第二步由<code>switch_to</code>宏来完成，源码如下:</p>
<p><a href="http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*</span></div><div class="line">  * Context switching is now performed out-of-line in switch_to.S</div><div class="line">  */</div><div class="line"> <span class="keyword">extern</span> <span class="keyword">struct</span> task_struct *<span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *,</div><div class="line">                                        <span class="keyword">struct</span> task_struct *);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev, next, last)                                      											                         \</span></div><div class="line">        do &#123;                                                            \</div><div class="line">                ((last) = __switch_to((prev), (next)));                 			                                                   \</div><div class="line">        &#125; while (0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ASM_GENERIC_SWITCH_TO_H */</span></span></div></pre></td></tr></table></figure>
<p>首先，该宏有三个参数，prev、next和last，prev和next的作用仅是<code>内核堆栈中</code>的局部变量prev和next的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。</p>
<p>在任何进程切换中，涉及到的是三个进程而不是两个。假设内核决定暂停进程A而激活进程B，在schedule()函数中，prev指向A的描述符，而next指向B的进程描述符。switch_to宏一旦使A暂停，A的执行流就被冻结。</p>
<p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。B的内核堆栈中的<code>prev</code>指向B的描述符，<code>next</code>指向other(下一个要调度的进程描述符，目前未知)。</strong></p>
<p>随后，当内核想再次激活A，就必须暂停另一个进程C，因为这通常不是B，因为B有可能被其他进程比如C切换。于是就要用prev指向C而next指向A来执行另一个switch_to宏。当A恢复它执行的流时，就会找到它原来的内核栈，于是prev局部变量还是指向A的描述符而next指向B的描述符。</p>
<p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。C的内核堆栈中的<code>prev</code>指向C的描述符，<code>next</code>指向A的描述符。</strong></p>
<p>所以，<code>代表进程A执行的内核就失去了对C的任何引用</code>。但引用对于完成进程切换是有用的，所以需要保留。</p>
<p>switch_to宏的最后一个参数是输出参数，它表示宏把进程C的描述符地址写在内存的什么位置了，不过，这个是在恢复A执行之后完成的。在进程切换之前，宏把第一个输入参数prev表示的变量存入CPU的eax寄存器。在完成进程切换，A已经恢复执行时，宏把CPU的eax寄存器的内容写入由第三个参数last所指示的A在内存中的位置。因为CPU寄存器不会在切换点发生变化，所以C的描述符地址也存在内存的这个位置。在schedule()执行过程中，last参数指向A的局部变量prev，所以prev被C的地址覆盖。</p>
<h4 id="switch-to-函数"><a href="#switch-to-函数" class="headerlink" title="__switch_to()函数"></a>__switch_to()函数</h4><p><strong>switch_to()函数执行大多数开始于switch_to()宏的进程切换。这个函数作用于prev_p和next_p参数，这两个参数表示前一个进程和新进程。这个函数的调用不同于一般的函数调用。因为</strong>switch_to()从eax和edx取参数prev_p和next_p，而不像大多数函数一样从栈中取参数。</p>
<p><a href="http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *prev_p, <span class="keyword">struct</span> task_struct *next_p)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> thread_struct *prev = &amp;prev_p-&gt;thread,</div><div class="line">                             *next = &amp;next_p-&gt;thread;</div><div class="line">        <span class="keyword">struct</span> fpu *prev_fpu = &amp;prev-&gt;fpu;</div><div class="line">        <span class="keyword">struct</span> fpu *next_fpu = &amp;next-&gt;fpu;</div><div class="line">        <span class="keyword">int</span> cpu = smp_processor_id();</div><div class="line">        <span class="keyword">struct</span> tss_struct *tss = &amp;per_cpu(cpu_tss, cpu);</div><div class="line">        <span class="keyword">fpu_switch_t</span> fpu_switch;</div><div class="line"></div><div class="line">        <span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></div><div class="line"></div><div class="line">        fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Save away %gs. No need to save %fs, as it was saved on the</div><div class="line">         * stack on entry.  No need to save %es and %ds, as those are</div><div class="line">         * always kernel segments while inside the kernel.  Doing this</div><div class="line">         * before setting the new TLS descriptors avoids the situation</div><div class="line">         * where we temporarily have non-reloadable segments in %fs</div><div class="line">         * and %gs.  This could be an issue if the NMI handler ever</div><div class="line">         * used %fs or %gs (it does not today), or if the kernel is</div><div class="line">         * running inside of a hypervisor layer.</div><div class="line">         */</div><div class="line">        lazy_save_gs(prev-&gt;gs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Load the per-thread Thread-Local Storage descriptor.</div><div class="line">         */</div><div class="line">        load_TLS(next, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore IOPL if needed.  In normal use, the flags restore</div><div class="line">         * in the switch assembly will handle this.  But if the kernel</div><div class="line">         * is running virtualized at a non-zero CPL, the popf will</div><div class="line">         * not restore flags, so it must be done in a separate step.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</div><div class="line">                set_iopl_mask(next-&gt;iopl);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Now maybe handle debug registers and/or IO bitmaps</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (unlikely(task_thread_info(prev_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_PREV ||</div><div class="line">                     task_thread_info(next_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_NEXT))</div><div class="line">                <span class="number">__</span>switch_to_xtra(prev_p, next_p, tss);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Leave lazy mode, flushing any hypercalls made here.</div><div class="line">         * This must be done before restoring TLS segments so</div><div class="line">         * the GDT and LDT are properly updated, and must be</div><div class="line">         * done before fpu__restore(), so the TS bit is up</div><div class="line">         * to date.</div><div class="line">         */</div><div class="line">        arch_end_context_switch(next_p);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Reload esp0 and cpu_current_top_of_stack.  This changes</div><div class="line">         * current_thread_info().</div><div class="line">         */</div><div class="line">        load_sp0(tss, next);</div><div class="line">        this_cpu_write(cpu_current_top_of_stack,</div><div class="line">                       (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task_stack_page(next_p) +</div><div class="line">                       THREAD_SIZE);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore %gs if needed (which is common)</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</div><div class="line">                lazy_load_gs(next-&gt;gs);</div><div class="line"></div><div class="line">        switch_fpu_finish(next_fpu, fpu_switch);</div><div class="line"></div><div class="line">        this_cpu_write(current_task, next_p);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> prev_p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数执行步骤如下：</p>
<ul>
<li><p>执行由__unlay_fpu()宏代码产生的代码，以有选择地保存prev_p进程的FPU、MMX以及XMM寄存器的内容。</p>
</li>
<li><p>执行smp_processor_id()宏获得本地CPU的下标，即执行代码当前的CPU。该宏从当前进程的thread_info结构的cpu字段获得下标并保存到cpu局部变量。</p>
</li>
<li><p>把next_p-&gt;thread.esp0装入对应于本地CPU的TSS的esp0字段。其实，任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址拷贝到esp寄存器中。</p>
</li>
<li><p>把next_p进程使用的线程局部存储（TLS）段装载入本地CPU的全局描述符表。</p>
</li>
<li><p>把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中。esi寄存器指向prev_p-&gt;thread结构。</p>
</li>
<li><p>如果fs或gs段寄存器已经被prev_p或next_p进程中的任意一个使用，则将next_p进程的thread_struct描述符中保存的值装入这些寄存器。</p>
</li>
<li><p>用next_p-&gt;thread.debugreg数组内容装载dr0…dr7中的6个调试寄存器。只有在next_p被挂起时正在使用调试寄存器，这种操作才能进行。</p>
</li>
<li><p>如果必要，则更新TSS中的I/O位图。因为进程很少修改I/O权限位图，所以当且仅当一个进程在当前时间片内实际访问I/O端口时，真实的位图才被拷贝到本地CPU的TSS中。进程的定制I/O权限位图被保存在thread_info结构的io_bitmap_ptr字段指向的缓冲区中。当prev_p或者next_p拥有自己定制的I/O权限位图（io_bitmap_ptr不为null）时,TSS的io_bitmap字段被设为0x9000,否则为0x8000。</p>
</li>
<li><p>终止，prev_p参数被拷贝到eax，<code>因为缺省情况下任何C函数的返回值被传给eax寄存器</code>。所以eax的值在调用__switch_to()的过程中被保护起来；这很重要，因为调用该函数时会假定eax总是用来存放将被替换的进程描述符地址。</p>
</li>
<li><p>汇编语言指令ret把栈顶保存的返回地址装入eip程序计数器。不过，__swtich_to()函数时通过简单的跳转被调用的。因此，ret汇编指令在栈中找到标号为1的指令地址，其中标号为1的地址是由switch_to()宏推入堆栈的。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程切换&quot;&gt;&lt;a href=&quot;#进程切换&quot; class=&quot;headerlink&quot; title=&quot;进程切换&quot;&gt;&lt;/a&gt;进程切换&lt;/h3&gt;&lt;p&gt;为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（pro
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Maven常用命令和操作</title>
    <link href="http://vinoit.me/2016/08/19/maven-common-command-and-operation/"/>
    <id>http://vinoit.me/2016/08/19/maven-common-command-and-operation/</id>
    <published>2016-08-19T02:15:15.000Z</published>
    <updated>2016-08-19T08:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Maven-Archetypes"><a href="#Maven-Archetypes" class="headerlink" title="Maven Archetypes"></a>Maven Archetypes</h4><p>Maven archetypes是一个项目模板，可以让Maven按照指定的模板构建出一个项目最基本的文件结构，以及创建一些文件。Maven中有许多项目模板供我们使用，使用方式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate</div></pre></td></tr></table></figure>
<p>执行完上述命令之后，Maven会将当前可用的模板全部列出，我这边是一共列出了1648条。<br><img src="/images/maven/maven-command-and-operation-0.png" alt=""><br>你可以输入一个模板前面的数字或者一个过滤器(按照提示)选择你想要的模板，但这样不怎么方便去找到自己想要的模板。这里有3种解决的办法:</p>
<ol>
<li>你可以将结果导入到一个文本文件中，然后在文件中可以通过关键字查找你所需要的模板信息。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate &gt; archetypes.txt</div></pre></td></tr></table></figure>
</li>
</ol>
<p>2.<code>mvn archetype:create -DgroupId=[your group id] -DartifactId=[your archetype id] -DarchetypeArtifactId=maven-archetype-webapp</code>指定<code>archetypeArtifactId</code>,这样的话就会直接按照所指定的模板构建项目结构。<br>3.<code>mvn archetype:generate -DarchetypeCatalog=internal</code>其中的-DarchetypeCatalog=internal表明使用内置的模板（默认使用中央仓库的模板），这样的话只会列出一些内置的模板，这些内置的模板一般情况下都是能够满足使用的。<br><img src="/images/maven/maven-command-and-operation-1.png" alt=""><br>现在只列出了10条模板，选择第10条模板，然后构建一个webapp的项目结构。<br><img src="/images/maven/maven-command-and-operation-2.png" alt=""><br>按照提示填写一些项目的信息，然后回车，项目结构构建完成，在当前目录下会出现一个以项目名命名的文件夹。<br><img src="/images/maven/maven-command-and-operation-3.png" alt=""></p>
<h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>进入到创建好的项目<code>cd maven-webapp/</code>,执行如下命令:<code>mvn compile</code>。成功之后，在项目根目录会出现一个<code>targer</code>文件夹。因为没有java文件，所以其中的<code>classes</code>文件夹为空。<br><img src="/images/maven/maven-command-and-operation-4.png" alt=""></p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>执行<code>mvn package</code>,<code>target</code>文件夹的内容如下。<br><img src="/images/maven/maven-command-and-operation-5.png" alt=""><br>WAR包解压之后就是一个<code>maven-webapp</code>文件夹。<br><code>maven-archiver</code>文件夹中的<code>pom.properties</code>放了一些项目的基本信息:<br><img src="/images/maven/maven-command-and-operation-6.png" alt=""><br>假如该项目引入了其他依赖，则会将所有需要的JAR包放置在WEB-INF文件夹下的lib文件夹中。</p>
<h4 id="部署到本地仓库"><a href="#部署到本地仓库" class="headerlink" title="部署到本地仓库"></a>部署到本地仓库</h4><p>执行<code>mvn install</code>,在本地仓库中出现了该项目的一个库。<br><img src="/images/maven/maven-command-and-operation-7.png" alt=""><br>如果项目产生的是JAR包，则可以在本地的项目中引入并使用该依赖。</p>
<h4 id="部署到github远程仓库"><a href="#部署到github远程仓库" class="headerlink" title="部署到github远程仓库"></a>部署到github远程仓库</h4><p>首先在Maven的<code>setting.xml</code>中按如下方式配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>github<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>YOUR-GITHUB-USERNAME<span class="tag">&lt;/<span class="name">username</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>YOUR-GITHUB-PASSWORD<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>id</code>可以随意取，在<code>pom.xml</code>中通过该id来引用该信息。<br>在<code>pom.xml</code>中按如下方式配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- github server corresponds to entry in ~/.m2/settings.xml --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">github.global.server</span>&gt;</span>github<span class="tag">&lt;/<span class="name">github.global.server</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>internal.repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Temporary Staging Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;project.build.directory&#125;/mvn-repo<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">altDeploymentRepository</span>&gt;</span>internal.repo::default::file://$&#123;project.build.directory&#125;/mvn-repo<span class="tag">&lt;/<span class="name">altDeploymentRepository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.github<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>site-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- git commit message --&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">message</span>&gt;</span>Maven artifacts for $&#123;project.version&#125;<span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- disable webpage processing --&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">noJekyll</span>&gt;</span>true<span class="tag">&lt;/<span class="name">noJekyll</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- matches distribution management repository url above --&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/mvn-repo<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- remote branch name --&gt;</span></div><div class="line">              <span class="comment">&lt;!-- &lt;branch&gt;refs/heads/master&lt;/branch&gt; --&gt;</span></div><div class="line">              <span class="comment">&lt;!-- If you remove this then the old artifact will be removed and new </span></div><div class="line">               one will replace. But with the merge tag you can just release by changing </div><div class="line">                                                the version --&gt;</div><div class="line">              <span class="tag">&lt;<span class="name">merge</span>&gt;</span>true<span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- github repo name --&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">repositoryName</span>&gt;</span>项目名<span class="tag">&lt;/<span class="name">repositoryName</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- github username --&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">repositoryOwner</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">repositoryOwner</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>site<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上配置中需要修改的地方只有2个地方，github上的项目名称以及你的用户名（注意不是邮箱）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- github repo name --&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">repositoryName</span>&gt;</span>项目名<span class="tag">&lt;/<span class="name">repositoryName</span>&gt;</span></div><div class="line">         <span class="comment">&lt;!-- github username --&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">repositoryOwner</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">repositoryOwner</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后执行<code>mvn clean deploy</code>，在你的<code>target</code>目录下会生成一个名为<code>mvn-repo</code>的文件夹，这就是生成的库，不出意外的话，在你的指定的github项目上的<code>gh-pages</code>分支（默认）会出现一个Maven库。你也可以指定某个分支,比如master:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- remote branch name --&gt;</div><div class="line">             &lt;branch&gt;refs/heads/master&lt;/branch&gt;</div></pre></td></tr></table></figure>
<h4 id="引用github远程仓库的依赖"><a href="#引用github远程仓库的依赖" class="headerlink" title="引用github远程仓库的依赖"></a>引用github远程仓库的依赖</h4><p><code>pom.xml</code>按如下方式配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>不重样即可<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.github.com/用户名/项目名/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这是我在<code>github</code>上的远程仓库，一个小demo。<a href="https://github.com/vinoZHU/my-maven-repo" target="_blank" rel="external">https://github.com/vinoZHU/my-maven-repo</a></p>
<h4 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h4><p>以下常用命令摘自:<a href="http://lychie.github.io/pages/articles/maven/15040920.html" target="_blank" rel="external">http://lychie.github.io/pages/articles/maven/15040920.html</a></p>
<ul>
<li>test  [ 运行测试 ]<br><code>mvn test</code></li>
<li>-e  [ 显示错误详细信息 ]<br><code>mvn -e test</code></li>
<li>site  [ 生成站点文件 ]<br><code>mvn site</code> ( 见 target/site 目录 )</li>
<li>package  [ 打包 ]<br><code>mvn package</code></li>
<li>install  [ 安装到本地仓库 ]<br><code>mvn install</code> ( 见本地仓库 ${groupId}/${artifactId} 目录 )</li>
<li>compile  [ 编译源代码 ]<br><code>mvn compile</code></li>
<li>test-compile  [ 编译测试代码 ]<br><code>mvn test-compile</code></li>
<li>clean  [ 清除目标目录产生的结果 ]<br><code>mvn clean</code></li>
<li>-Dmaven.test.skip  [ 跳过测试 ]<br><code>mvn -Dmaven.test.skip package</code></li>
<li>-Dmaven.test.failure.ignore  [ 忽略测试失败 ]<br><code>mvn -Dmaven.test.failure.ignore package</code></li>
<li>dependency:sources  [ 依赖包源码 ]<br><code>mvn dependency:sources</code></li>
<li>dependency:tree  [ 项目依赖树 ]<br><code>mvn dependency:tree</code></li>
<li>project-info-reports:dependencies  [ 项目依赖报告 ]<br><code>mvn project-info-reports:dependencies</code>( 见 target/site/dependencies.html )</li>
<li>help:effective-pom  [ 查看有效的 pom 配置 ]<br><code>mvn help:effective-pom</code> ( 暴露 super pom )</li>
<li>help:describe  [ 获取插件帮助 ]<br><code>mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull</code></li>
<li>dependency:resolve  [ 已解决的依赖列表 ]<br><code>mvn dependency:resolve</code></li>
<li>idea:idea  [ 转换成 idea 项目 ]<br><code>mvn idea:idea</code></li>
<li>eclipse:eclipse  [ 转换成 eclipse 项目 ]<br><code>mvn eclipse:eclipse</code></li>
<li>archetype:create  [ 创建 java 项目 ]<br><code>mvn archetype:create -DgroupId=org.lychie -DartifactId=myapp</code></li>
<li>archetype:create  [ 创建 web 项目 ]<br><code>mvn archetype:create -DgroupId=org.lychie -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-webapp</code></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要整理了Maven的一些常见操作和命令，未整理的部分日后再补充吧。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>







</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Maven-Archetypes&quot;&gt;&lt;a href=&quot;#Maven-Archetypes&quot; class=&quot;headerlink&quot; title=&quot;Maven Archetypes&quot;&gt;&lt;/a&gt;Maven Archetypes&lt;/h4&gt;&lt;p&gt;Maven archetyp
    
    </summary>
    
      <category term="maven" scheme="http://vinoit.me/categories/maven/"/>
    
    
      <category term="maven" scheme="http://vinoit.me/tags/maven/"/>
    
      <category term="tools" scheme="http://vinoit.me/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>Maven基础教程</title>
    <link href="http://vinoit.me/2016/08/18/maven-tutorial/"/>
    <id>http://vinoit.me/2016/08/18/maven-tutorial/</id>
    <published>2016-08-18T08:47:15.000Z</published>
    <updated>2016-09-14T06:12:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h4><p>Maven最令人印象深刻的也许是它所提供依赖管理，但是Maven的功能远不止这些，Maven是一个java项目构建工具(build tool)。通常来说，一个项目构建工具需要具备以下这些功能甚至更多:</p>
<ul>
<li>在条件允许的情况下能自动生成源代码。</li>
<li>根据源代码能自动生成文档</li>
<li>能编译源代码</li>
<li>对于java项目，要能将编译好的代码打包成JAR包，WAR包等。</li>
<li>能将打包后的文件部署在服务器、仓库或者其他地方。</li>
<li>。。。</li>
</ul>
<p>这些步骤虽然也可以人工手动完成，但是效率比不上构建工具，况且人工出错的概率更大。</p>
<h4 id="Maven总览–核心概念"><a href="#Maven总览–核心概念" class="headerlink" title="Maven总览–核心概念"></a>Maven总览–核心概念</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>Maven最核心的就是一个叫做<code>pom.xml</code>的文件，使用Maven构建项目时所需要的所有信息都包含在该文件中，例如项目的版本号，需要的依赖包等等。当你执行一条<code>mvn *</code>命令时，Maven需要根据<code>pom.xml</code>中的描述来进行操作。</p>
<h5 id="Build-Life-Cycles-Phases-and-Goals"><a href="#Build-Life-Cycles-Phases-and-Goals" class="headerlink" title="Build Life Cycles, Phases and Goals"></a>Build Life Cycles, Phases and Goals</h5><p>Maven的构建过程被分成几个生命周期，一个生命周期又被分为若干个阶段，同时一个阶段中又会有若干个目标(相当于一个特定任务)。一条Maven命令通常为<code>mvn *</code>,其中<code>*</code>的内容为某个生命周期的名字，或者某个阶段的名字，又或者某个目标的名字。这三者在后文会给出具体解释。</p>
<h5 id="Dependencies-and-Repositories"><a href="#Dependencies-and-Repositories" class="headerlink" title="Dependencies and Repositories"></a>Dependencies and Repositories</h5><p>所谓依赖就是项目中需要用到的一些第三方库(JAR files)，如果在本地仓库找不到需要的依赖，Maven会从中央仓库下载到本地仓库。具体内容在后文会涉及到。</p>
<h5 id="Build-Plugins"><a href="#Build-Plugins" class="headerlink" title="Build Plugins"></a>Build Plugins</h5><p>插件的作用是往构建时的阶段（Phases）中增添一些目标(Goals),相当于做一些额外的任务。Maven提供了一些标准插件，同时你也可以实现自己的插件。更多插件相关信息可查看官网，<a href="http://maven.apache.org/plugin-developers/index.html" target="_blank" rel="external">http://maven.apache.org/plugin-developers/index.html</a></p>
<h5 id="Build-Profiles"><a href="#Build-Profiles" class="headerlink" title="Build Profiles"></a>Build Profiles</h5><p>在开发过程中项目可能需要处于不同的环境，这时候<code>pom.xml</code>中的一些配置可能需要修改。<code>Profiles</code>的作用就是当你在<code>pom.xml</code>中声明了一个<code>&lt;profile&gt;&lt;/profile&gt;</code>标签对之后，标签对里面的内容可以用来替换原本的配置值，具体内容在后文会涉及到。</p>
<h4 id="Maven和Ant的区别"><a href="#Maven和Ant的区别" class="headerlink" title="Maven和Ant的区别"></a>Maven和Ant的区别</h4><p>Ant也是Apache的一个构建工具，两者之间的最大区别是:Ant必须要求指定具体动作，细化程度达到如拷贝一个文件之类的操作。而Maven只要告诉它要做什么，具体做法在Maven中已经预先在<code>Phases</code>和<code>Goals</code>中定义过了。Ant强调怎么去做，而Maven则强调做什么。</p>
<h4 id="Maven-pom-xml分析"><a href="#Maven-pom-xml分析" class="headerlink" title="Maven pom.xml分析"></a>Maven pom.xml分析</h4><p>pom是（Project Object Model）的缩写，每个Maven项目都有一个<code>pom.xml</code>与之对应，文件处于项目的根目录。当一个项目含有多个子项目时，主项目和每个子项目都对应一个<code>pom.xml</code>。此时既可以把整个项目一同构建，也可以只根据子项目的<code>pom.xml</code>来单独构建每个子项目。</p>
<p>文件内容描述了该Maven项目的本身信息，需要的依赖（JAR files），应该构建哪些内容，需要的资源等等。以下是一个最简化的<code>pom.xml</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></div><div class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>modelVersion</code>元素指定你所使用的POM模型，4.0.0版本对应Maven 2.x或者3.x版本。</li>
<li><code>groupId</code>元素对于开源项目(e.g.中央仓库的依赖）来说必须是唯一的，因为Maven寻找依赖时必须根据groupId。对于大多数普通使用者来说，groupId和项目包名类似。如果是个网站项目，也可以是网站的域名。这里提一点，假如想让自己的项目变成一个Maven库，以上<code>pom.xml</code>的groupId为<code>com.vino</code>,则在Maven库中的文件目录存在形式为:<code>MAVEN_REPO/com/vino/</code>。</li>
<li><code>artifactId</code>元素包含着项目名。将项目打包时，包名就是该元素内的值。该值中的点号不会变成文件分隔符。假如我有2个项目，groupId都为<code>com.vino</code>, artifactId一个为<code>app1</code>，一个为<code>maven.app2</code>,当我将2个项目部署成本地Maven库时，目录形式为:<code>MAVEN_REPO/com/vino/app1/</code>、<code>MAVEN_REPO/com/vino/maven.app2/</code>。</li>
<li><code>version</code>元素表明当前项目的版本号，相当于在一个项目下面再划分了一个层次。</li>
</ul>
<p>使用上述<code>pom.xml</code>部署成本地Maven库的文件为:<code>MAVEN_REPO/com/vino/maven-app/1.0.0/maven-app-1.0.0.jar</code></p>
<h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><p>只要不是太小的项目，基本上都需要第三方的JAR包。但是这些JAR包一般都是有不同的版本的，如果手动更新、管理这些JAR包，必定又麻烦又费时。Maven内置了依赖管理，只需要在<code>pom.xml</code>中声明，在构建项目时Maven便会将依赖从中央仓库下载到你的本地仓库。如果这些第三方的依赖同时也需要一些其他依赖，Maven会将这些依赖统统下载到你的本地仓库。以下是使用的一个样例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></div><div class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    </div><div class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>项目中需要的每个依赖，都放在一个<code>&lt;dependency&gt;&lt;/dependency&gt;</code>标签对中，并且用<code>groupId</code>,<code>artifactId</code>,<code>version</code>进行描述。下载到本地之后，两个依赖的目录形式为:<code>MAVEN_REPO/junit/junit/4.8.1/</code>、<code>MAVEN_REPO/org/jsoup/jsoup/1.7.1/</code>。目录内容中除了JAR包，还有一个该依赖的<code>pom.xml</code>文件和一些用于校对内容完整性的文件。</p>
<p><strong>将本地JAR包作为依赖</strong><br>有时候某些开源项目没有放在Maven的中央仓库，需要单独下载。这时候需要将下载到本地的JAR包作为一个项目依赖来使用，具体用法如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mydependency<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mydependency<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;/war/WEB-INF/lib/mydependency.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里需要注意的是: <code>groupId</code>和<code>artifactId</code>可以乱填（但一般是依赖的名字），<code>scope</code>必须填<code>system</code>,表明是本系统的文件，<code>version</code>同样可以乱填，<code>systemPath</code>就是JAR包的位置，<code>${basedir}</code>代表<code>pom.xml</code>所在的目录。</p>
<p><strong>快照依赖</strong><br>所谓快照依赖，就是一些仍处于开发状态的依赖。当使用快照依赖时，你不需要经常性地去手动更新版本号来获得最新的依赖。你可以设置一个时间间隔，Maven会自动的每隔一段时间将依赖下载的本地，即使中央仓库的依赖并未更新。但前提是，该依赖的版本号中的大版本号与<code>pom.xml</code>中的对应:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>假如中央仓库的版本号变成了2.0-SNAPSHOT,则Maven不会下载该依赖。</p>
<h4 id="中央仓库与远程仓库的区别"><a href="#中央仓库与远程仓库的区别" class="headerlink" title="中央仓库与远程仓库的区别"></a>中央仓库与远程仓库的区别</h4><p>中央仓库是Maven官方的一个仓库，而远程仓库放在一个其他的服务器上，Maven可以从该服务器下载依赖。github就可以作为一个远程仓库，当我们把开源项目以约定好的的形式放到到github上之后，可以通过如下方式引用:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>your-mvn-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.github.com/yourGitHubId/mvn-repository/master/releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="Maven-Build-Life-Cycles-Phases-and-Goals"><a href="#Maven-Build-Life-Cycles-Phases-and-Goals" class="headerlink" title="Maven Build Life Cycles, Phases and Goals"></a>Maven Build Life Cycles, Phases and Goals</h4><p>生命周期这个概念听上去感觉很模糊，可以把生命周期理解成一个完整的过程。Maven有3种内置的构建生命周期，相当于3种不同功能的过程:</p>
<ol>
<li>default</li>
<li>clean</li>
<li>site </li>
</ol>
<p>3者之间相互独立，分开执行。</p>
<p><code>clean</code>的功能是就是将已生成的资源文件，编译后文件，JAR包，WAR包等清除，使用方法为:<br><code>mvn clean</code>。</p>
<p><code>site</code>的功能是将当前项目的信息整理成一个文档，执行<code>mvn site</code>后，在项目的<code>target</code>目录下会生成一个<code>site</code>文件夹，其中的内容便是项目文档的html文件。</p>
<p><code>default</code>生命周期做的事就是Maven主要功能，无法直接执行<code>mvn default</code>，只能执行它的阶段(Phases)或者目标(Goals)。</p>
<p>它最常用的阶段(Phases)如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Build Phase</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">validate</td>
<td style="text-align:left">验证项目是否无错误，所有的必须的信息都具备了，包括所需要的依赖是否已经下载。</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:left">编译项目源代码</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:left">运行单元测试中的代码，这些测试的代码不应该没被打包或者部署。</td>
</tr>
<tr>
<td style="text-align:center">package</td>
<td style="text-align:left">将编译好的代码打包成某种格式，比如JAR或者WAR等</td>
</tr>
<tr>
<td style="text-align:center">install</td>
<td style="text-align:left">将package后的包安装到本地仓库，可以作为一个依赖来使用</td>
</tr>
<tr>
<td style="text-align:center">deploy</td>
<td style="text-align:left">将最终的包拷贝到远程仓库，供他人使用</td>
</tr>
</tbody>
</table>
<p>当我想使用<code>package</code>，只需在<code>pom.xml</code>目录执行<code>mvn package</code>,这时候在项目的<code>target</code>下会出现一个WAR包（如果是webapp）。但是我都没编译，怎么就可以打包了呢？事实上，当执行某个阶段命令时，该命令所属的生命周期之前的所有阶段步骤都会按照顺序被执行一遍。所以在<code>mvn package</code>被执行时，之前的命令（包括 mvn compile）已经执行过了。</p>
<p>现在构建阶段已经知道了是怎么回事，现在就剩下目标了，目标可以理解为构建阶段中的一个具体任务。比如<code>dependency:copy-dependencies</code>就是一个目标（任务），执行<code>mvn dependency:copy-dependencies</code>时,会在<code>target</code>目录下生成一个<code>dependency</code>文件夹，内容为该项目使用的所有依赖(JAR files)。</p>
<p>关于这三者的完整的信息可以查看官网，<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="external">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>
<h4 id="Maven-Build-Profiles"><a href="#Maven-Build-Profiles" class="headerlink" title="Maven Build Profiles"></a>Maven Build Profiles</h4><p>上面提到过，profile可以简单地认为是一个环境。使用方法很简单，如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></div><div class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">activation</span>&gt;</span>...<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中的<code>activation</code>用来表明当前profile是否正在使用，如果正在使用，则该profile中的元素会覆盖掉原来的值。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是我整理的一些Maven相关的信息，主要是一些基础的原理性的内容。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是Maven&quot;&gt;&lt;a href=&quot;#什么是Maven&quot; class=&quot;headerlink&quot; title=&quot;什么是Maven&quot;&gt;&lt;/a&gt;什么是Maven&lt;/h4&gt;&lt;p&gt;Maven最令人印象深刻的也许是它所提供依赖管理，但是Maven的功能远不止这些，Maven
    
    </summary>
    
      <category term="maven" scheme="http://vinoit.me/categories/maven/"/>
    
    
      <category term="maven" scheme="http://vinoit.me/tags/maven/"/>
    
      <category term="tools" scheme="http://vinoit.me/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程（二）</title>
    <link href="http://vinoit.me/2016/08/16/linux-kernel-note-process-two/"/>
    <id>http://vinoit.me/2016/08/16/linux-kernel-note-process-two/</id>
    <published>2016-08-16T12:31:04.000Z</published>
    <updated>2016-08-18T14:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><p>进程在运行时的所有信息，如进程优先级、地址空间、访问的文件等等，都是通过进程描述符来记录的。内核正是通过进程描述符来对进程进行管理。进程描述符的数据结构是<code>struct task_struct</code>,与进程相关的所有信息都包含在该数据结构中，可想而知该数据结构是十分复杂的。</p>
<p>在<a href="http://lxr.free-electrons.com/source/include/linux/sched.h#L1458" target="_blank" rel="external"><strong>这里</strong></a>可以查看<code>task_struct</code>的完整结构，下图示意性地描述了该数据结构：<br><img src="/images/linux-kernel-note/process-two-0.png" alt=""><br>在这里只讨论进程的某几个属性，其余属性在之后有关其他内容的文章中会逐渐涉及到，内核的学习需要联系的思维。</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>在<a href="http://lxr.free-electrons.com/source/include/linux/sched.h#L207" target="_blank" rel="external"><strong>这里</strong></a>可以查看进程的所有状态，下面是一些常见的状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TASK_RUNNING</td>
<td style="text-align:left">进程正在执行或者进程已经就绪，正在等待cpu时间片的调度。</td>
</tr>
<tr>
<td style="text-align:center">TASK_INTERRUPTIBLE</td>
<td style="text-align:left">进程因为等待一些条件而被挂起（阻塞）时的状态。此时的进程可以被硬中断、资源的释放、信号等事件（这些事件可以认为是等待的条件）唤醒，然后进程就会从该状态（阻塞）迅速转化成为就绪状态TASK_RUNNING。</td>
</tr>
<tr>
<td style="text-align:center">TASK_UNINTERRUPTIBLE</td>
<td style="text-align:left">意义与TASK_INTERRUPTIBLE类似，但是该状态的进程只有当等待的条件为true时才能被唤醒。一般情况下很少用到，但是在一些驱动程序中很有用。特别是对于驱动探测相关的硬件过程很重要，这个探测过程不能被一些其他的东西给中断，否则就会让进程进入不可预测的状态。</td>
</tr>
<tr>
<td style="text-align:center">__TASK_STOPPED</td>
<td style="text-align:left">进程停止执行，当进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后就会进入该状态。</td>
</tr>
<tr>
<td style="text-align:center">__TASK_TRACED</td>
<td style="text-align:left">表示进程被debugger等进程所暂停（<a href="/2016/08/12/how-debugger-work/">ptrac()调用与调试器相关</a>），此时任何一个信号都会让进程进入该状态</td>
</tr>
<tr>
<td style="text-align:center">EXIT_DEAD</td>
<td style="text-align:left">进程的执行被终止，但是其父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程成为僵尸进程</td>
</tr>
<tr>
<td style="text-align:center">EXIT_ZOMBIE</td>
<td style="text-align:left">进程的最终状态，由于父进程进行了wait4()或者waitpid()系统调用，进程被系统删除</td>
</tr>
</tbody>
</table>
<h4 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h4><p>类Unix操作系统通过进程标识符（PID）来标识一个进程(包括轻量级进程) ，每个进程的PID存放在进程描述符的pid字段中。PID是按顺序编号的，新创建的进程通常是前一个进程的PID+1。不过，32位系统的PID值在缺省情况中的上限为32767，64位是4194303，系统管理员可以通过修改<code>/proc/sys/kernel/pid_max</code>来改变这些值。</p>
<p>内核通过管理一个<code>pidmap_array</code>位图来记录当前已使用的PID，因为一个页框的大小为4KB,恰好为32767bit,所以32位体系结构中一个<code>pidmap_array</code>刚好占据一个单独的页。系统会一直保存这些页不被释放。</p>
<h4 id="标识当前进程"><a href="#标识当前进程" class="headerlink" title="标识当前进程"></a>标识当前进程</h4><p>在内核代码中，经常通过current宏来获得当前在CPU上运行的进程描述符指针，例如，current-&gt;pid返回当前正在执行的进程的PID。我们来看下current宏究竟干了什么：</p>
<p>(Linux/arch/tile/include/asm/current.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> current get_current()</span></div></pre></td></tr></table></figure>
<p>(Linux/include/asm-generic/current.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">inline__ <span class="keyword">struct</span> task_struct *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">return</span> current_thread_info()-&gt;task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>current_thread_info()</code>返回一个<code>struct thread_info</code>结构的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> thread_info &#123;</div><div class="line">          <span class="keyword">struct</span> task_struct      *task;          <span class="comment">/* main task structure */</span></div><div class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span>           flags;          <span class="comment">/* low level flags */</span></div><div class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span>           status;         <span class="comment">/* thread-synchronous flags */</span></div><div class="line">          <span class="number">__u</span>32                   cpu;            <span class="comment">/* current CPU */</span></div><div class="line">          <span class="keyword">int</span>                     preempt_count;  <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></div><div class="line">  </div><div class="line">          <span class="keyword">mm_segment_t</span>            addr_limit;     <span class="comment">/* thread address space:</span></div><div class="line">                                                     0-0xBFFFFFFF for user-thread</div><div class="line">                                                     0-0xFFFFFFFF for kernel-thread</div><div class="line">                                                  */</div><div class="line">  </div><div class="line">          <span class="number">__u</span>8                    supervisor_stack[<span class="number">0</span>];</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>返回的<code>thread_info</code>指针就是当前进程描述符中的thread_info字段的指针，而该结构中保存着所属进程的进程描述符指针。<code>为什么不直接把进程描述符指针记录在一个全局变量中？</code>早先的Linux版本的确是这么做的,通过强制引入一个全局静态变量current来标识正在运行进程的描述符。</p>
<p>既然现在是通过<code>thread_info</code>来标识当前进程的，那么如何获得该<code>thread_info</code>的地址呢？</p>
<p>Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区域内，一个是与进程描述符相关的小数据结构thread_info，叫做线程描述符。另一个是内核态的进程堆栈。</p>
<p>内核态的进程堆栈大小通常为8192个字节。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。当几乎没有可用的动态内存空间时，就会很难找到这两个连续页框，因为空闲空间可能存在大量碎片。因此，在80x86体系结构中，在编译时可以设置，以使内核堆栈和线程描述符跨越一个单独的页框。<br><img src="/images/linux-kernel-note/process-two-1.png" alt=""></p>
<p><code>esp</code>寄存器保存着内核态堆栈的栈顶地址，因为内核态堆栈和<code>thread_info</code>处于连续的2个页框，而<code>thread_info</code>处于页框的首地址，只需进行下列的汇编指令就能获得<code>thread_info</code>地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movl $0xffffe000, %ecx</div><div class="line">andl $esp, %ecx</div><div class="line">movl %ecx, p</div></pre></td></tr></table></figure>
<p>其中变量p中的值便是<code>thread_info</code>的地址，而这3条汇编指令其实也就是<code>current_thread_info()</code>函数所做的事。</p>
<p>当进程切换到内核态之后，esp指针便保存内核栈的栈顶地址。内核直接通过寄存器的值，进行少许计算便能获得当前进程描述符，相比较于早先的全局静态变量，效率是明显提升了。</p>
<h4 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h4><p>对于<code>TASK_RUNNING</code>的进程，内核早先把所有的这些进程放到一个进程双向链表中，但是随着进程数量的增加，维护成本会越来越高。调度程序在扫描链表时花费的时间也随之线性上升。Linix2.6中，优先级相同的进程才会放在一个对应优先级的链表中。如果优先级有n个级别，那么就有n个运行队列。在多处理器系统中，每个CPU都有着n个这样的运行队列。</p>
<p>关于运行队列，在之后整理进程调度的文章中会再次涉及到。</p>
<p>对于<code>__TASK_STOPPED</code>、<code>EXIT_DEAD</code>、<code>EXIT_ZOMBIE</code>状态的进程，内核没有建立相应的双向链表。对于这些进程的访问比较简单，或者通过PID，或者通过特定父进程的子进程链表。</p>
<p>对于<code>TASK_INTERRUPTIBLE</code>、<code>TASK_UNINTERRUPTIBLE</code>状态的进程，由于这些进程所等待的条件并不是同一个。而且进程所提供的信息无法满足快速检索的需要，因此有了等待队列。</p>
<p>在这里讨论的等待队列都表示进程在特定事件上的等待。一个等待队列表示一组睡眠的进程，这些进程所等待的条件都是同一个。当条件满足时，内核会唤醒这些进程。然而，当两个或多个进程互斥的访问某个资源时，此时内核必须只能唤醒一个进程，其余的进程需要继续睡眠。</p>
<p>等待队列由双向链表组成，每个等待队列都有一个队列头:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">__</span>wait_queue_head &#123;</div><div class="line">         <span class="keyword">spinlock_t</span>              lock;<span class="comment">//自旋锁</span></div><div class="line">         <span class="keyword">struct</span> list_head        task_list;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>等待队列中的元素:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">__</span>wait_queue &#123;</div><div class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            flags;</div><div class="line">         <span class="keyword">void</span>                    *<span class="keyword">private</span>;<span class="comment">//指向进程描述符</span></div><div class="line">         <span class="keyword">wait_queue_func_t</span>       func;<span class="comment">//唤醒时需要调用的方法</span></div><div class="line">         <span class="keyword">struct</span> list_head        task_list;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p><code>struct list_head</code>在内核中是实现双向链表的关键，在这里不做讨论。</p>
<h4 id="根据PID找到进程描述符"><a href="#根据PID找到进程描述符" class="headerlink" title="根据PID找到进程描述符"></a>根据PID找到进程描述符</h4><p>Linux中有4个pid类型:</p>
<ul>
<li>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。</li>
<li>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。</li>
<li>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。</li>
<li>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。</li>
</ul>
<p>既然每个进程都有一个与之关联的PID，在进程描述符中的pid字段保存着PID值，如果通过遍历进程链表来比较PID值，虽然可行，但是相当低效。那么内核肯定维护着PID与进程描述符之间的某种映射关系。内核可以通过这种关系，快速地根据PID找到对应的进程描述符。</p>
<p>内核是通过hash表来解决这个问题的。在内核初始化的时候会动态地为一个散列表数组分配空间,数组长度和机器内存有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> hlist_head *pid_hash;</div></pre></td></tr></table></figure>
<p>初始化函数为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="number">__</span><span class="function">init <span class="title">pidhash_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>散列表数组的元素类型为 <code>struct hlist_head</code>，看下具体是什么:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_head &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *first;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中包含一个<code>struct hlist_node</code>类型的指针:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_node &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *next, **pprev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>struct hlist_node</code>中包含一个<code>struct hlist_node</code>类型的指针和<code>struct hlist_node*</code>类型的指针。</p>
<p>现在散列表和进程之间还没有建立联系，来看下进程中的<code>pids</code>(不是pid)字段的数据结构:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pid_link</div><div class="line"> &#123;</div><div class="line">         <span class="keyword">struct</span> hlist_node node;</div><div class="line">         <span class="keyword">struct</span> pid *pid;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p>
<p>再看下<code>struct pid</code>是什么东西:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pid</div><div class="line">&#123;</div><div class="line">        <span class="keyword">atomic_t</span> count;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</div><div class="line">        <span class="comment">/* lists of tasks that use this pid */</span></div><div class="line">        <span class="keyword">struct</span> hlist_head tasks[PIDTYPE_MAX];</div><div class="line">        <span class="keyword">struct</span> rcu_head rcu;</div><div class="line">        <span class="keyword">struct</span> upid numbers[<span class="number">1</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的<code>tasks</code>字段，这是一个<code>struct hlist_head</code>类型的数组，长度为pid类型数量，也就是4。</p>
<p>再看下其中的<code>struct upid</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> upid &#123;</div><div class="line">        <span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></div><div class="line">        <span class="keyword">int</span> nr;<span class="comment">//用于计算hsah值</span></div><div class="line">        <span class="keyword">struct</span> pid_namespace *ns;</div><div class="line">        <span class="keyword">struct</span> hlist_node pid_chain;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下图用来帮助理解几者之间的联系:<br><img src="/images/linux-kernel-note/process-two-2.png" alt=""></p>
<ol>
<li>内核初始化期间为pid_hash数组分配好合适的空间。</li>
<li>当创建了一个新的进程之后，内核随之分配一个进程描述符，然后初始化其中的字段。</li>
<li>根据 task_struct-&gt;pids（struct pid_link类型）-&gt;pid-&gt;numbers(struct upid类型)-&gt;nr的值，调用hash函数，取模，然后定位到pid_hash数组中的某一项。</li>
<li>遍历该项的链表，如果其中没有一项的pid与新创建的相同（线程组的所有进程pid相同），则将该进程插入到链表尾。具体做法是将pids字段(struct pid_link类型)中的node插入到链表末尾。</li>
<li>如果存在一项pid与新创建的进程相同，说明是同一线程组的进程。则通过task_struct-&gt;pids（struct pid_link类型）-&gt;pid-&gt;numbers(struct upid类型)-&gt;pid_chain（struct hlist_node类型）,将其链接到已存在项的tasks数组中对应pid类型的链表中去，这样的链表一共有4条。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要讨论了进程描述符中的某几个属性，包括pid,进程状态。还简单介绍了current宏、进程链表以及如何通过pid快速找到对应进程描述符的地址。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>




</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程描述符&quot;&gt;&lt;a href=&quot;#进程描述符&quot; class=&quot;headerlink&quot; title=&quot;进程描述符&quot;&gt;&lt;/a&gt;进程描述符&lt;/h4&gt;&lt;p&gt;进程在运行时的所有信息，如进程优先级、地址空间、访问的文件等等，都是通过进程描述符来记录的。内核正是通过进程描述符来
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程（一）</title>
    <link href="http://vinoit.me/2016/08/15/linux-kernel-note-process-one/"/>
    <id>http://vinoit.me/2016/08/15/linux-kernel-note-process-one/</id>
    <published>2016-08-15T05:56:35.000Z</published>
    <updated>2016-08-18T14:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h4><p>说起进程，真是既熟悉又陌生，感觉知道这个玩意儿，但是又不知该如何说起。按照UTLK中的说法，进程是任何多道程序设计的操作系统中的基本概念，<code>通常把进程定义为程序执行的一个实例</code>,貌似大多数OS教科书也是这么定义的。</p>
<p>从内核的角度来看，进程就是消耗系统资源（内存，CPU时间片等）的一个实体。因为每个进程都会有他的执行代码，内核通过调度，让不同的进程可以在CPU上分时执行代码，同时每个进程也都会占用相应的RAM资源。</p>
<h4 id="进程、轻量级进程、线程"><a href="#进程、轻量级进程、线程" class="headerlink" title="进程、轻量级进程、线程"></a>进程、轻量级进程、线程</h4><p>现代OS基本上都支持多线程应用程序–拥有很多相对独立执行流的用户程序共享应用程序的大部分数据结构，Linux也一样。在这样的系统中，一个进程由由多个用户线程组成，每个线程都代表进程的一个执行流。</p>
<p>Linux使用轻量级进程对多线程应用程序提供更好的支持。两个轻量进程程基本上可以共享一些资源，只要其中一个修改了共享资源，另一个就立即查看这种修改。实现多线程应用程序的一个简单方式就是把轻量级进程与每个线程关联起来。在Linux中，一个线程组基本上就是实现了多线程应用的一组轻量级进程。</p>
<p>下图描述了几者之间的关系：<br><img src="/images/linux-kernel-note/process-one-0.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">进程P0有四条执行流，也就是线程，</div><div class="line">主线程t0是它的第一个线程，与进程P0相关联，</div><div class="line">之后衍生出t1、t2、t3三个线程，这三个线程分别与轻量级进程P1、P2、P3相关联，</div><div class="line">所有的进程、轻量级进程、线程组成了线程组。</div><div class="line">轻量级进程也是进程，只不过它与某进程的某特定线程相关联，而且轻量级进程与原进程之间共享了大部分应用程序的数据结构。</div></pre></td></tr></table></figure></p>
<p>pid是进程标识符，tgid是线程组标识符。</p>
<p>每个进程都有自己的pid,同属于一个线程组的所有进程、轻量级进程有同样的tgid，且其为第一个线程所关联的pid。</p>
<p>上图中的所有轻量级进程和进程的tgid均为a,等同于进程的pid。<br>我们看下两个系统调用的实现，就能发现一些端倪（位于kernel/timer.c）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> current-&gt;tgid;</div><div class="line">  &#125;</div><div class="line"> <span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"> &#123;</div><div class="line">   <span class="keyword">return</span> current-&gt;pid;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从代码里可以清楚的看到，getpid返回的是线程组标识符，gettgid返回的是进程标识符。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要整理了进程的定义以及进程、轻量级进程、线程在Linux中的关系。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程定义&quot;&gt;&lt;a href=&quot;#进程定义&quot; class=&quot;headerlink&quot; title=&quot;进程定义&quot;&gt;&lt;/a&gt;进程定义&lt;/h4&gt;&lt;p&gt;说起进程，真是既熟悉又陌生，感觉知道这个玩意儿，但是又不知该如何说起。按照UTLK中的说法，进程是任何多道程序设计的操作系统
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之分页机制</title>
    <link href="http://vinoit.me/2016/08/14/linux-kernel-note-page-mechanism/"/>
    <id>http://vinoit.me/2016/08/14/linux-kernel-note-page-mechanism/</id>
    <published>2016-08-14T07:07:15.000Z</published>
    <updated>2016-08-18T14:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个逻辑地址经过<a href="/2016/08/13/linux-kernel-note-segment-mechanism/">分段机制</a>转换为一个线性地址之后，便需要分页单元将线性地址转换为实际的物理地址。</p>
<h4 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h4><p>从80386开始，所有的80x86处理器都支持分页。是否开启分页通过设置cr0寄存器的PG标志来决定，当PG为0时，表示不开启分页，此时线性地址呗解释为物理地址。</p>
<p>分页机制管理的对象是固定大小的存储块，称之为页(page)。分页机制把整个线性地址空间及整个物理地址空间都看成由页组成，在线性地址空间中的任何一页，可以映射为物理地址空间中的任何一页（我们把物理空间中的一页叫做一个页面或页框(page frame)）。</p>
<p>80386中每一页的大小都为4KB，每一页的起始地址都能被4K整除（低12位全为0）。因此，80386把4G的线性地址空间，划分为1M个页面。</p>
<p>把线性地址映射到物理地址的数据结构称为页表，页表存放在主存中，由内核进行适当的初始化。</p>
<h5 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h5><p>Intel处理器在处理一个32位的线性地址时，将其分成3部分（按照Little-Endian)：</p>
<ul>
<li>Directory（目录）：最高10位</li>
<li>Table(页表) ：中间10位</li>
<li>Offset(偏移量) ：最低12位</li>
</ul>
<p>线性地址的转换的流程如下：</p>
<ol>
<li>通过高10位定位到页目录中的某一项，获取一个页表。</li>
<li>通过中间10位定位到页表中的某一项，获取到一个页的起始地址</li>
<li>将低12位（偏移量）+ 步骤2中的得到的页起始地址，获得实际的物理地址。</li>
</ol>
<p>其中的页目录地址存放在cr3寄存器中。</p>
<p><img src="/images/linux-kernel-note/page-mechanism-0.png" alt=""></p>
<h5 id="为什么使用二级模式？"><a href="#为什么使用二级模式？" class="headerlink" title="为什么使用二级模式？"></a>为什么使用二级模式？</h5><p>如果使用一级页表，那么整个页表相当于一个拥有1M个元素的大数组，每个页表项占用的大小为4B，所以整个页表的大小为4M。然而每个活动进程都需要一个独立的页表，绝大多数进程都不会马上使用所有的进程地址空间，相比较直接分配一个映射所有地址空间的一级页表，需要时分配页表显然更加效率。二级模式只为进程实际使用的那些虚拟内存区分配页表，既提升了效率，也减少了内存的使用量。（PS：当使用二级页表时，如果为进程的所有虚拟内存区都分配了页表，这时候的内存使用量是增加的）</p>
<h5 id="页目录项结构"><a href="#页目录项结构" class="headerlink" title="页目录项结构"></a>页目录项结构</h5><p><img src="/images/linux-kernel-note/page-mechanism-1.gif" alt=""></p>
<ul>
<li>第31~12位是20位页表地址，由于页表地址的低12位总为0，所以用高20位指出32位页表地址就可以了。因此，一个页目录最多包含1024个页表地址。</li>
<li>第0位是存在位，如果P=1，表示页表地址指向的该页在内存中，如果P=0，表示不在内存中。</li>
<li>第1位是读/写位，第2位是用户/管理员位，这两位为页目录项提供硬件保护。当特权级为3的进程要想访问页面时，需要通过页保护检查，而特权级为0的进程就可以绕过页保护。</li>
<li>第3位是PWT（Page Write-Through）位，表示是否采用写透方式，写透方式就是既写内存（RAM）也写高速缓存,该位为1表示采用写透方式</li>
<li>第4位是PCD（Page Cache Disable）位，表示是否启用高速缓存,该位为1表示启用高速缓存。</li>
<li>第5位是访问位，当对页目录项进行访问时，A位=1。</li>
<li>第7位是Page Size标志，只适用于页目录项。如果置为1，页目录项指的是4MB的页面，请看后面的扩展分页。</li>
<li>第9~11位由操作系统专用，Linux也没有做特殊之用。</li>
</ul>
<h5 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h5><p><img src="/images/linux-kernel-note/page-mechanism-2.gif" alt=""><br>80386的每个页目录项指向一个页表，页表最多含有1024个页面项，每项4个字节，包含页面的起始地址和有关该页面的信息。页面的起始地址也是4K的整数倍，所以页面的低12位也留作它用。<br>第31~12位是20位物理页面地址，除第6位外第0～5位及9~11位的用途和页目录项一样，第6位是页面项独有的，当对涉及的页面进行写操作时，D位被置1。<br>4GB的内存只有一个页目录，它最多有1024个页目录项，每个页目录项又含有1024个页面项，因此，内存一共可以分成1024×1024=1M个页面。由于每个页面为4K个字节，所以，存储器的大小正好最多为4GB。</p>
<h5 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h5><p>扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。在扩展分页的情况下,分页机制把32位线性地址分成两个域：最高10位的目录域和其余22位的偏移量。</p>
<p>扩展分页地址转换过程如下：<br><img src="/images/linux-kernel-note/page-mechanism-3.png" alt=""></p>
<h5 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h5><p>硬件高速缓存中组相连映射是使用最多的，以下是组相连映射的流程图：<br><img src="/images/linux-kernel-note/page-mechanism-4.jpg" alt=""><br><img src="/images/linux-kernel-note/page-mechanism-5.jpg" alt=""></p>
<h5 id="转换后援缓冲器-TLB"><a href="#转换后援缓冲器-TLB" class="headerlink" title="转换后援缓冲器(TLB)"></a>转换后援缓冲器(TLB)</h5><p>因为在获取页地址时需要去慢速访问主存，而TLB缓存了线性地址和物理地址映射的关系，所以直接在SRAM中就可以获取到对应的物理地址，节省了时间。在多处理器系统中，每个CPU都有自己的TLB，叫做本地TLB。</p>
<h4 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h4><p>Linux使用了一个适合32位和64位系统的分页模型。<br><img src="/images/linux-kernel-note/page-mechanism-6.png" alt=""><br>上图的4种页表分别为:</p>
<ul>
<li>页全局目录</li>
<li>页上级目录</li>
<li>页中间目录</li>
<li>页表</li>
</ul>
<p>页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分成五个部分。图中没有显示位数，因为每一部分的大小与具体的计算机体系结构有关。</p>
<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了。从本质上说Linux通过使“页上级目录”位和“页中间目录”位全为0，彻底取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个合适的目录项而实现的。</p>
<p>启用了物理地址扩展的32 位系统使用了三级页表。Linux的页全局目录对应80×86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应80×86的页目录，Linux的页表对应80×86的页表。</p>
<p>最后，64位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从硬件的角度，32位地址被分成了三部份。不管理软件怎么做，最终落实到硬件，也只识别这3部分。</p>
<p>从软件的角度，由于多引入了两部份，也就是说，共有五部份。要让二层架构的硬件认识五部分，在地址划分的时候，将页上级目录和页中间目录的长度设置为0就可以了。</p>
<p>这样，操作系统见到的是五部份，硬件还是按它死板的三部份划分，软硬件又和谐了。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>






</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个逻辑地址经过&lt;a href=&quot;/2016/08/13/linux-kernel-note-segment-mechanism/&quot;&gt;分段机制&lt;/a&gt;转换为一个线性地址之后，便需要分页单元将线性地址转换为实际的物理地址。&lt;/p&gt;
&lt;h4 id=&quot;硬件中的分页&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（六）——final</title>
    <link href="http://vinoit.me/2016/08/14/java-memeory-model-final/"/>
    <id>http://vinoit.me/2016/08/14/java-memeory-model-final/</id>
    <published>2016-08-14T06:38:03.000Z</published>
    <updated>2016-08-14T06:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;                            <span class="comment">//普通变量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                      <span class="comment">//final变量</span></div><div class="line">    <span class="keyword">static</span> FinalExample obj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span> <span class="params">()</span> </span>&#123;     <span class="comment">//构造函数</span></div><div class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></div><div class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span> <span class="params">()</span> </span>&#123;    <span class="comment">//写线程A执行</span></div><div class="line">        obj = <span class="keyword">new</span> FinalExample ();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;       <span class="comment">//读线程B执行</span></div><div class="line">        FinalExample object = obj;       <span class="comment">//读对象引用</span></div><div class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">//读普通域</span></div><div class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">//读final域</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h4 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h4><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p>
<ol>
<li>构造一个FinalExample类型的对象；</li>
<li>把这个对象的引用赋值给引用变量obj。</li>
</ol>
<p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：<br><img src="/images/JMM/JMM-final-0.jpg" alt=""><br>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p>
<h4 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h4><p>读final域的重排序规则如下：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li>
</ul>
<p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。</p>
<p>reader()方法包含三个操作：</p>
<ol>
<li>初次读引用变量obj;</li>
<li>初次读引用变量obj指向对象的普通域j。</li>
<li>初次读引用变量obj指向对象的final域i。</li>
</ol>
<p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：<br><img src="/images/JMM/JMM-final-1.png" alt=""><br>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h4 id="如果final域是引用类型"><a href="#如果final域是引用类型" class="headerlink" title="如果final域是引用类型"></a>如果final域是引用类型</h4><p>上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？</p>
<p>请看下列示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] intArray;                     <span class="comment">//final是引用类型</span></div><div class="line"><span class="keyword">static</span> FinalReferenceExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span> <span class="params">()</span> </span>&#123;        <span class="comment">//构造函数</span></div><div class="line">    intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];              <span class="comment">//1</span></div><div class="line">    intArray[<span class="number">0</span>] = <span class="number">1</span>;                   <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程A执行</span></div><div class="line">    obj = <span class="keyword">new</span> FinalReferenceExample ();  <span class="comment">//3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程B执行</span></div><div class="line">    obj.intArray[<span class="number">0</span>] = <span class="number">2</span>;                 <span class="comment">//4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;              <span class="comment">//读线程C执行</span></div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                    <span class="comment">//5</span></div><div class="line">        <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>];       <span class="comment">//6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：</p>
<ul>
<li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ul>
<p>对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：<br><img src="/images/JMM/JMM-final-2.png" alt=""><br>在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="为什么final引用不能从构造函数内“逸出”"><a href="#为什么final引用不能从构造函数内“逸出”" class="headerlink" title="为什么final引用不能从构造函数内“逸出”"></a>为什么final引用不能从构造函数内“逸出”</h4><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;</div><div class="line"><span class="keyword">static</span> FinalReferenceEscapeExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</div><div class="line">    i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></div><div class="line">    obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;</div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></div><div class="line">        <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：<br><img src="/images/JMM/JMM-final-3.png" alt=""><br>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h4><p>现在我们以x86处理器为例，说明final语义在处理器中的具体实现。</p>
<p>上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<p>由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！</p>
<h4 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（五）——锁</title>
    <link href="http://vinoit.me/2016/08/14/java-memeory-model-lock/"/>
    <id>http://vinoit.me/2016/08/14/java-memeory-model-lock/</id>
    <published>2016-08-14T06:17:18.000Z</published>
    <updated>2016-08-14T06:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="锁的释放-获取建立的happens-before-关系"><a href="#锁的释放-获取建立的happens-before-关系" class="headerlink" title="锁的释放-获取建立的happens before 关系"></a>锁的释放-获取建立的happens before 关系</h4><p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>下面是锁释放-获取的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  <span class="comment">//1</span></div><div class="line">        a++;                             <span class="comment">//2</span></div><div class="line">    &#125;                                    <span class="comment">//3</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  <span class="comment">//4</span></div><div class="line">        <span class="keyword">int</span> i = a;                       <span class="comment">//5</span></div><div class="line">        ……</div><div class="line">    &#125;                                    <span class="comment">//6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens before规则，这个过程包含的happens before 关系可以分为两类：</p>
<ul>
<li>根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li>
<li>根据监视器锁规则，3 happens before 4。<br>根据happens before 的传递性，2 happens before 5。</li>
</ul>
<p>上述happens before 关系的图形化表现形式如下：<br><img src="/images/JMM/JMM-lock-0.png" alt=""></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>上图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p>
<h4 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h4><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如下：<br><img src="/images/JMM/JMM-lock-1.png" alt=""><br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图：<br><img src="/images/JMM/JMM-lock-2.png" alt=""><br>对比锁释放-获取的内存语义与volatile写-读的内存语义，可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p>
<p>下面对锁释放和锁获取的内存语义做个总结：</p>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h4 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h4><p>本文将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();         <span class="comment">//获取锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        a++;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();        <span class="comment">//获取锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = a;</div><div class="line">        ……</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p>
<p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。 下面是ReentrantLock的类图（仅画出与本文相关的部分）：<br><img src="/images/JMM/JMM-lock-3.png" alt=""><br>ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。</p>
<p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : lock()</div><div class="line">FairSync : lock()</div><div class="line">AbstractQueuedSynchronizer : acquire(int arg)</div><div class="line">ReentrantLock : tryAcquire(int acquires)</div></pre></td></tr></table></figure></p>
<p>在第4步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();   <span class="comment">//获取锁的开始，首先读volatile变量state</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p>
<p>在使用公平锁时，解锁方法unlock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : unlock()</div><div class="line">AbstractQueuedSynchronizer : release(int arg)</div><div class="line">Sync : tryRelease(int releases)</div></pre></td></tr></table></figure></p>
<p>在第3步真正开始释放锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);           <span class="comment">//释放锁的最后，写volatile变量state</span></div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源代码我们可以看出，在释放锁的最后写volatile变量state。</p>
<p>公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</p>
<p>现在我们分析非公平锁的内存语义的实现。</p>
<p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p>
<p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : lock()</div><div class="line">NonfairSync : lock()</div><div class="line">AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</div></pre></td></tr></table></figure></p>
<p>在第3步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法以原子操作的方式更新state变量，本文把java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p>
<p>这里我们分别从编译器和处理器的角度来分析,CAS如何同时具有volatile读和volatile写的内存语义。</p>
<p>前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p>
<p>下面我们来分析在常见的intel x86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的。</p>
<p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></div><div class="line">                                              <span class="keyword">int</span> expected,</div><div class="line">                                              <span class="keyword">int</span> x);</div></pre></td></tr></table></figure>
<p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：<code>unsafe.cpp</code>，<code>atomic.cpp</code>和<code>atomicwindowsx86.inline.hpp</code>。这个本地方法的最终实现在openjdk的如下位置：<code>openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp</code>（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Adding a lock prefix to an instruction on MP machine</div><div class="line">// VC++ doesn't like the lock prefix to be on a single line</div><div class="line">// so we can't insert a label after the lock prefix.</div><div class="line">// By emitting a lock prefix, we can define a label after it.</div><div class="line">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</div><div class="line">                       __asm je L0      \</div><div class="line">                       __asm _emit 0xF0 \</div><div class="line">                       __asm L0:</div><div class="line"></div><div class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</div><div class="line">  // alternative for InterlockedCompareExchange</div><div class="line">  int mp = os::is_MP();</div><div class="line">  __asm &#123;</div><div class="line">    mov edx, dest</div><div class="line">    mov ecx, exchange_value</div><div class="line">    mov eax, compare_value</div><div class="line">    LOCK_IF_MP(mp)</div><div class="line">    cmpxchg dword ptr [edx], ecx</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
<p>intel的手册对lock前缀的说明如下：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<p>经过上面的这些分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。</p>
<p>现在对公平锁和非公平锁的内存语义做个总结：</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读这个volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新这个volatile变量,这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用volatile变量的写-读所具有的内存语义。</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ol>
<h4 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h4><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：<br><img src="/images/JMM/JMM-lock-4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;锁的释放-获取建立的happens-before-关系&quot;&gt;&lt;a href=&quot;#锁的释放-获取建立的happens-before-关系&quot; class=&quot;headerlink&quot; title=&quot;锁的释放-获取建立的happens before 关系&quot;&gt;&lt;/a&gt;锁的释放-
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之分段机制</title>
    <link href="http://vinoit.me/2016/08/13/linux-kernel-note-segment-mechanism/"/>
    <id>http://vinoit.me/2016/08/13/linux-kernel-note-segment-mechanism/</id>
    <published>2016-08-13T07:59:27.000Z</published>
    <updated>2016-08-18T14:19:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要有分段机制？"><a href="#为什么要有分段机制？" class="headerlink" title="为什么要有分段机制？"></a>为什么要有分段机制？</h4><ul>
<li><p>在8086处理器诞生之前，内存寻址方式就是直接访问物理地址,也就是所谓的实模式。8086处理器为了寻址1M的内存空间，把地址总线扩展到了20位。但是，ALU的宽度<code>只有16位</code>，也就是说，ALU不能计算20位的地址。为了解决这个问题，从而引入了分段机制。<br>为了支持分段，8086处理器设置了四个段寄存器：CS, DS, SS, ES.每个段寄存器都是16位的，都包含着相应段的基址，访存指令中的地址也是16位的。但是，在送入地址总线之前，CPU先把它与某个段寄存器内的值按以下方式相加：<br><code>实际物理地址 = （段寄存器地址 &lt;&lt; 4） + （指令访存地址）</code></p>
</li>
<li><p>80286处理器的地址总线为24位，寻址空间达16M，同时引入了保护模式（指令给出的地址不对应实际的物理地址）</p>
</li>
<li><p>80386处理器是一个32位处理器，ALU和地址总线都是32位的，寻址空间达 4G。它可以不通过分段机制，直接访问4G的内存空间。然而为了兼容前代的处理器，它必须同时支持实模式和保护模式。所以，80386在段寄存器的基础上构筑保护模式，并且保留16位的段寄存器。</p>
</li>
<li><p>从80386之后的处理器，架构基本相似，统称为IA32（32 Bit Intel Architecture）。</p>
</li>
</ul>
<h4 id="IA32架构下的内存寻址"><a href="#IA32架构下的内存寻址" class="headerlink" title="IA32架构下的内存寻址"></a>IA32架构下的内存寻址</h4><h5 id="IA32的三类地址"><a href="#IA32的三类地址" class="headerlink" title="IA32的三类地址"></a>IA32的三类地址</h5><ul>
<li>逻辑地址:<br>机器语言指令用这类地址指定一个操作数的地址或一条指令的地址，最原始的地址就是逻辑地址。</li>
<li>线性地址：<br>将逻辑地址经过分段机制转换之后，便得到了线性地址,每个线性地址都由一个段基址和段内偏移量组成。</li>
<li>物理地址：<br>线性地址经过分页单元的处理之后得到一个实际物理地址，也就是内存单元的实际地址，用于芯片级内存单元寻址。</li>
</ul>
<h5 id="MMU地址转化过程"><a href="#MMU地址转化过程" class="headerlink" title="MMU地址转化过程"></a>MMU地址转化过程</h5><p>以上3类地址是通过MMU（内存管理单元）来进行转换。其中MMU处理时包含2个过程，分段和分页。在这里简单的说明下具体过程：</p>
<blockquote>
<p>当一条机器指令给出一个地址时，这时候的地址便是逻辑地址。</p>
<p>为了得到线性地址，需要从相应的段寄存器中取出16位的段标识符（段选择符），通过这个段标识符可以得到一个段基址。然后将得到的段基址与指令中的地址相加，从而得到一个线性地址。</p>
<p>有了线性地址之后，再通过分页单元得到实际的物理地址。</p>
</blockquote>
<h5 id="IA32的段寄存器"><a href="#IA32的段寄存器" class="headerlink" title="IA32的段寄存器"></a>IA32的段寄存器</h5><p>IA32中有六个16位段寄存器：CS, DS, SS, ES，FS, GS.跟8086的段寄存器不同的是，这些寄存器存放的不再是某个段的基地址，而是某个段的选择符（Selector）。</p>
<h4 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h4><h5 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a>段选择符和段寄存器</h5><p>段寄存器的唯一目的就是存放段选择符，段选择符是一个16位长的字段：<br><img src="/images/linux-kernel-note/segment-mechanism-0.jpg" alt=""></p>
<p>第01位表示的是请求者的特权，第2位是表指示器，用于指定所使用的描述符表。3~15位是一个索引号，定位到描述符表中的某一项段描述符。</p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符说白了就是用来描述段的特征，段描述表放在全局描述符表（GDT）或者局部描述符表（LDT），每个段描述符为8个字节大小。GDT的地址和大小存放在寄存器gdtr中，LDT的地址和大小存放在寄存器ldtr中。</p>
<p>有几种不同类型的段以及它们对应的段描述符，下面列出了Linux中广泛采用的类型：</p>
<p><strong>代码段描述符</strong></p>
<p>表示这个段描述符代表一个代码段，它可以放在GDT或LDT中。该描述符置S标志为1，并且为非系统段。</p>
<p><strong>数据段描述符</strong></p>
<p>表示这个段描述符代表一个数据段，它可以放在GDT或LDT中。该描述符置S标志为1，栈段是通过数据段实现的。</p>
<p><strong>任务状态段描述符（TSSD）</strong></p>
<p>表示这个段描述符代表一个任务状态段（Task State Segment，TSS），也就是说这个段用于保存处理器寄存器的内容。它只能出现在GDT中。根据相应的进程是否正在CPU上运行，其Type字段的值分别为11或9。这个描述符的S标志被置为0。</p>
<p><strong>局部描述符表描述符（LDTD）</strong></p>
<p>这个表示段描述符代表一个包含LDT的段，他置出现在GDT中。相应的Type字段的值为2，S标志被置为0。</p>
<p>下图为段描述符的字段表示：<br><img src="/images/linux-kernel-note/segment-mechanism-1.png" alt=""></p>
<p>相应字段的意义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Base</td>
<td style="text-align:left">包含段的首字节的线性地址</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:left">粒度标志，如果为0，则段大小以字节为单位，否则以4096字节的倍数计算</td>
</tr>
<tr>
<td style="text-align:center">Limit</td>
<td style="text-align:left">存放段最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在一个字节到1MB之间变化，否则，将在4KB到4GB之间变化</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:left">系统标志，如果被置为0，则这是一个系统段，否则为普通的代码段或者数据段</td>
</tr>
<tr>
<td style="text-align:center">Type</td>
<td style="text-align:left">描述了段的类型特征和它的存取权限</td>
</tr>
<tr>
<td style="text-align:center">DPL</td>
<td style="text-align:left">描述符特权等级字段，用于限制这个段的存取。它表示为访问这个段而要求的CPU最小的优先级，因此DPL设置为0的段只能当CPL为0时，也就是内核态才可以访问。DPL设为3则堆任何CPL值都是可访问的</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:left">Segment-Present标志，等于0表示段当前不在主存中。Linux总是把此标志设为1，因为Linux从来不把整个段交换到磁盘上去</td>
</tr>
<tr>
<td style="text-align:center">D或B</td>
<td style="text-align:left">称为D或B标志，取决于是代码段还是数据段，D和B的含义在两种情况下有区别，如果段偏移量的地址是32位长，就基本上把它设置为1，如果偏移量是16位长，则清零</td>
</tr>
<tr>
<td style="text-align:center">AVL</td>
<td style="text-align:left">可以由操作系统使用，但是被Linux忽略</td>
</tr>
</tbody>
</table>
<p>当指令给出一个地址后，硬件的处理顺序如下：</p>
<ol>
<li>根据指令类型选择好段选择符，检查段选择符的TI字段，决定使用GDT还是LDT，再从gftr寄存器或者ldtr寄存器中获得描述符表的地址。</li>
<li>使用段选择符的索引号，定位到段描述符，<code>描述符地址 = 索引号 * 8 + gdtr(ldtr)中的地址</code>。</li>
<li>将段描述符中的Base值与给出的地址相加，从而得到线性地址。</li>
<li>将线性地址通过分页单元换换成物理地址。</li>
</ol>
<p>其中的段描述符地址，在寄存器内容不变的情况下会保存在一个与段寄存器相关的不可编程寄存器中，相当于缓存了这个地址，于是就可以省去前面2个步骤。</p>
<h4 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h4><p> Linux的段式管理，事实上只是“哄骗”了一下硬件而已。从2.2版开始，Linux让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。但内核中也用到LDT，那只是在VM86模式中运行Wine，因为就是说在Linux上模拟运行Winodws软件或DOS软件的程序时才使用。</p>
<p> 在内核源码<code>include/asm-i386/segment.h</code>中定义了如下宏:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_CS        14</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_DS        15</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_BASE        12</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_CS                (GDT_ENTRY_KERNEL_BASE + 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_DS                (GDT_ENTRY_KERNEL_BASE + 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)</span></div></pre></td></tr></table></figure>
<p> 把其中的宏替换成数值，则为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS 115      [00000000 1110  0  11]（用户代码段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS 123      [00000000 1111  0  11]（用户数据段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS 96     [00000000 1100  0  00]（内核代码段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS 104    [00000000 1101  0  00]（内核数据段）</span></div></pre></td></tr></table></figure>
<p> 方括号后是这四个段选择符的16位二制表示，它们的索引号和T1字段值也可以算出来了：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__USER_CS             index= 14   T1=0</div><div class="line">__USER_DS             index= 15   T1=0</div><div class="line">__KERNEL_CS           index= 12   T1=0</div><div class="line">__KERNEL_DS           index= 13   T1=0</div></pre></td></tr></table></figure>
<p> T1均为0，则表示都使用了GDT，再来看初始化GDT的内容中相应的12-15项(arch/i386/head.S)：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.quad <span class="number">0x00cf9a000000ffff</span>        <span class="comment">/* 0x60 kernel 4GB code at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cf92000000ffff</span>        <span class="comment">/* 0x68 kernel 4GB data at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cffa000000ffff</span>        <span class="comment">/* 0x73 user 4GB code at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cff2000000ffff</span>        <span class="comment">/* 0x7b user 4GB data at 0x00000000 */</span></div></pre></td></tr></table></figure>
<p>按照前面段描述符表中的描述，可以把它们展开，发现其16-31位全为0，即四个段的基地址全为0。</p>
<p>这样，给定一个段内偏移地址，按照前面转换公式，0 + 段内偏移，转换为线性地址，可以得出重要的结论，<strong>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>分段机制的存在主要是为了兼容前代处理器，而Linux巧妙的避开了硬件的死套路，有时候软硬件的结合的确很和谐。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么要有分段机制？&quot;&gt;&lt;a href=&quot;#为什么要有分段机制？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有分段机制？&quot;&gt;&lt;/a&gt;为什么要有分段机制？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在8086处理器诞生之前，内存寻址方式就是直接访问物理地址
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（四）——volatile</title>
    <link href="http://vinoit.me/2016/08/13/java-memeory-model-volatile/"/>
    <id>http://vinoit.me/2016/08/13/java-memeory-model-volatile/</id>
    <published>2016-08-13T06:18:13.000Z</published>
    <updated>2016-08-13T06:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h4><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>;  <span class="comment">//使用volatile声明64位的long型变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">        vl = l;   <span class="comment">//单个volatile变量的写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</div><div class="line">        vl++;    <span class="comment">//复合（多个）volatile变量的读/写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vl;   <span class="comment">//单个volatile变量的读</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> vl = <span class="number">0L</span>;               <span class="comment">// 64位的long型普通变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;     <span class="comment">//对单个的普通 变量的写用同一个监视器同步</span></div><div class="line">        vl = l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">//普通方法调用</span></div><div class="line">        <span class="keyword">long</span> temp = get();           <span class="comment">//调用已同步的读方法</span></div><div class="line">        temp += <span class="number">1L</span>;                  <span class="comment">//普通写操作</span></div><div class="line">        set(temp);                   <span class="comment">//调用已同步的写方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="comment">//对单个的普通变量的读用同一个监视器同步</span></div><div class="line">        <span class="keyword">return</span> vl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</p>
<p>简而言之，volatile变量自身具有下列特性：</p>
<ul>
<li>可见性: 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
<h4 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens before关系"></a>volatile写-读建立的happens before关系</h4><p>上面讲的是volatile变量自身的特性，对程序员来说，volatile对线程的内存可见性的影响比volatile自身的特性更为重要，也更需要我们去关注。</p>
<p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。</p>
<p>从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。</p>
<p>请看下面使用volatile变量的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></div><div class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></div><div class="line">            ……</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据volatile规则，2 happens before 3。</li>
<li>根据happens before 的传递性规则，1 happens before 4。</li>
</ol>
<p>上述happens before 关系的图形化表现形式如下：<br><img src="/images/JMM/JMM-volatile-0.png" alt=""><br>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
<h4 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h4><p>volatile写的内存语义如下：</p>
<p><code>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</code></p>
<p>以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图：<br><img src="/images/JMM/JMM-volatile-1.png" alt=""></p>
<p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p>
<p>volatile读的内存语义如下：</p>
<p><code>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</code></p>
<p>下面是线程B读同一个volatile变量后，共享变量的状态示意图：<br><img src="/images/JMM/JMM-volatile-2.png" alt=""></p>
<p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把volatile写和volatile读这两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p>下面对volatile写和volatile读的内存语义做个总结：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<p>volatile内存语义的实现</p>
<p>下面，让我们来看看JMM如何实现volatile写/读的内存语义。</p>
<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：</p>
<table border="1px"><tr><td>是否能重排序</td><td colspan="3">第二个操作</td></tr><tr><td>第一个操作</td><td>普通读/写</td><td>volatile读</td><td>volatile写</td></tr><tr><td>普通读/写</td><td>&nbsp;</td><td>&nbsp;</td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td>&nbsp;</td><td>NO</td><td>NO</td></tr></table>

<p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上表我们可以看出：</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：<br><img src="/images/JMM/JMM-volatile-3.png" alt=""></p>
<p>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：<br><img src="/images/JMM/JMM-volatile-4.png" alt=""></p>
<p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = v1;           <span class="comment">//第一个volatile读</span></div><div class="line">        <span class="keyword">int</span> j = v2;           <span class="comment">// 第二个volatile读</span></div><div class="line">        a = i + j;            <span class="comment">//普通写</span></div><div class="line">        v1 = i + <span class="number">1</span>;          <span class="comment">// 第一个volatile写</span></div><div class="line">        v2 = j * <span class="number">2</span>;          <span class="comment">//第二个 volatile写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    …                    <span class="comment">//其他方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：<br><img src="/images/JMM/JMM-volatile-5.png" alt=""></p>
<p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器常常会在这里插入一个StoreLoad屏障。</p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以x86处理器为例，上图中除最后的StoreLoad屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的volatile读和写，在 x86处理器平台可以优化成：<br><img src="/images/JMM/JMM-volatile-6.png" alt=""><br>前文提到过，x86处理器仅会对写-读操作做重排序。X86不会对读-读，读-写和写-写操作做重排序，因此在x86处理器中会省略掉这三种操作类型对应的内存屏障。在x86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在x86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p>
<h4 id="JSR-133为什么要增强volatile的内存语义"><a href="#JSR-133为什么要增强volatile的内存语义" class="headerlink" title="JSR-133为什么要增强volatile的内存语义"></a>JSR-133为什么要增强volatile的内存语义</h4><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：<br><img src="/images/JMM/JMM-volatile-7.png" alt=""><br>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;volatile的特性&quot;&gt;&lt;a href=&quot;#volatile的特性&quot; class=&quot;headerlink&quot; title=&quot;volatile的特性&quot;&gt;&lt;/a&gt;volatile的特性&lt;/h4&gt;&lt;p&gt;当我们声明共享变量为volatile后，对这个变量的读/写将会很特别
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（三）——顺序一致性</title>
    <link href="http://vinoit.me/2016/08/13/java-memeory-model-sequential-consistency/"/>
    <id>http://vinoit.me/2016/08/13/java-memeory-model-sequential-consistency/</id>
    <published>2016-08-13T05:59:55.000Z</published>
    <updated>2016-08-13T06:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h4><p>当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义如下：</p>
<ul>
<li>在一个线程中写一个变量</li>
<li>在另一个线程读同一个变量</li>
<li>而且写和读没有通过同步来排序</li>
</ul>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p>
<p><code>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。</code></p>
<h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>不管程序是否同步,所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>顺序一致性内存模型为程序员提供的视图如下：<br><img src="/images/JMM/JMM-sequential-consistency-0.png" alt=""></p>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<p>假设有两个线程A和B并发执行。其中A线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p>
<p>假设这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：<br><img src="/images/JMM/JMM-sequential-consistency-1.png" alt=""><br>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：<br><img src="/images/JMM/JMM-sequential-consistency-2.png" alt=""><br>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>下面我们对前面的示例程序ReorderExample用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    a = <span class="number">1</span>;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (flag) &#123;</div><div class="line">        <span class="keyword">int</span> i = a;</div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：<br><img src="/images/JMM/JMM-sequential-consistency-3.png" alt=""></p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到JMM在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
<h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在JMM中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ol>
<p>第3个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和I/O设备执行内存的读/写。下面让我们通过一个示意图来说明总线的工作机制：<br><img src="/images/JMM/JMM-sequential-consistency-4.png" alt=""></p>
<p>如上图所示，假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其它两个处理器则要等待处理器A的总线事务完成后才能开始再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<p>在一些32位的处理器上，如果要求对64位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性。当JVM在这种处理器上运行时，会把一个64位long/ double型变量的读/写操作拆分为两个32位的读/写操作来执行。这两个32位的读/写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的读/写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：<br><img src="/images/JMM/JMM-sequential-consistency-5.png" alt=""></p>
<p>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时处理器B中64位的读操作被拆分为两个32位的读操作，且这两个32位的读操作被分配到同一个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半“的无效值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据竞争与顺序一致性保证&quot;&gt;&lt;a href=&quot;#数据竞争与顺序一致性保证&quot; class=&quot;headerlink&quot; title=&quot;数据竞争与顺序一致性保证&quot;&gt;&lt;/a&gt;数据竞争与顺序一致性保证&lt;/h4&gt;&lt;p&gt;当程序未正确同步时，就会存在数据竞争。java内存模型规范对
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
</feed>
