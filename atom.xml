<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>是非之地</title>
  <subtitle>Vino Zhu&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vinoit.me/"/>
  <updated>2016-08-15T06:51:54.000Z</updated>
  <id>http://vinoit.me/</id>
  
  <author>
    <name>Vino Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux内核笔记之进程（一）</title>
    <link href="http://vinoit.me/2016/08/15/linux-kernel-note-process-one/"/>
    <id>http://vinoit.me/2016/08/15/linux-kernel-note-process-one/</id>
    <published>2016-08-15T05:56:35.000Z</published>
    <updated>2016-08-15T06:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h4><p>说起进程，真是既熟悉又陌生，感觉知道这个玩意儿，但是又不知该如何说起。按照UTLK中的说法，进程是任何多道程序设计的操作系统中的基本概念，<code>通常把进程定义为程序执行的一个实例</code>,貌似大多数OS教科书也是这么定义的。</p>
<p>从内核的角度来看，进程就是消耗系统资源（内存，CPU时间片等）的一个实体。因为每个进程都会有他的执行代码，内核通过调度，让不同的进程可以在CPU上分时执行代码，同时每个进程也都会占用相应的RAM资源。</p>
<h4 id="进程、轻量级进程、线程"><a href="#进程、轻量级进程、线程" class="headerlink" title="进程、轻量级进程、线程"></a>进程、轻量级进程、线程</h4><p>现代OS基本上都支持多线程应用程序–拥有很多相对独立执行流的用户程序共享应用程序的大部分数据结构，Linux也一样。在这样的系统中，一个进程由由多个用户线程组成，每个线程都代表进程的一个执行流。</p>
<p>Linux使用轻量级进程对多线程应用程序提供更好的支持。两个轻量进程程基本上可以共享一些资源，只要其中一个修改了共享资源，另一个就立即查看这种修改。实现多线程应用程序的一个简单方式就是把轻量级进程与每个线程关联起来。在Linux中，一个线程组基本上就是实现了多线程应用的一组轻量级进程。</p>
<p>下图描述了几者之间的关系：<br><img src="/images/linux-kernel-note/process-one-0.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">进程P0有四条执行流，也就是线程，</div><div class="line">主线程t0是它的第一个线程，与进程P0相关联，</div><div class="line">之后衍生出t1、t2、t3三个线程，这三个线程分别与轻量级进程P1、P2、P3相关联，</div><div class="line">所有的进程、轻量级进程、线程组成了线程组。</div><div class="line">轻量级进程也是进程，只不过它与某进程的某特定线程相关联，而且轻量级进程与原进程之间共享了大部分应用程序的数据结构。</div></pre></td></tr></table></figure></p>
<p>pid是进程标识符，tgid是线程组标识符。</p>
<p>每个进程都有自己的pid,同属于一个线程组的所有进程、轻量级进程有同样的tgid，且其为第一个线程所关联的pid。</p>
<p>上图中的所有轻量级进程和进程的tgid均为a,等同于进程的pid。<br>我们看下两个系统调用的实现，就能发现一些端倪（位于kernel/timer.c）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> current-&gt;tgid;</div><div class="line">  &#125;</div><div class="line"> <span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"> &#123;</div><div class="line">   <span class="keyword">return</span> current-&gt;pid;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从代码里可以清楚的看到，getpid返回的是线程组标识符，gettgid返回的是进程标识符。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要整理了进程的定义以及进程、轻量级进程、线程在Linux中的关系。</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程定义&quot;&gt;&lt;a href=&quot;#进程定义&quot; class=&quot;headerlink&quot; title=&quot;进程定义&quot;&gt;&lt;/a&gt;进程定义&lt;/h4&gt;&lt;p&gt;说起进程，真是既熟悉又陌生，感觉知道这个玩意儿，但是又不知该如何说起。按照UTLK中的说法，进程是任何多道程序设计的操作系统
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之分页机制</title>
    <link href="http://vinoit.me/2016/08/14/linux-kernel-note-page-mechanism/"/>
    <id>http://vinoit.me/2016/08/14/linux-kernel-note-page-mechanism/</id>
    <published>2016-08-14T07:07:15.000Z</published>
    <updated>2016-08-14T09:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个逻辑地址经过<a href="/2016/08/13/linux-kernel-note-segment-mechanism/">分段机制</a>转换为一个线性地址之后，便需要分页单元将线性地址转换为实际的物理地址。</p>
<h4 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h4><p>从80386开始，所有的80x86处理器都支持分页。是否开启分页通过设置cr0寄存器的PG标志来决定，当PG为0时，表示不开启分页，此时线性地址呗解释为物理地址。</p>
<p>分页机制管理的对象是固定大小的存储块，称之为页(page)。分页机制把整个线性地址空间及整个物理地址空间都看成由页组成，在线性地址空间中的任何一页，可以映射为物理地址空间中的任何一页（我们把物理空间中的一页叫做一个页面或页框(page frame)）。</p>
<p>80386中每一页的大小都为4KB，每一页的起始地址都能被4K整除（低12位全为0）。因此，80386把4G的线性地址空间，划分为1M个页面。</p>
<p>把线性地址映射到物理地址的数据结构称为页表，页表存放在主存中，由内核进行适当的初始化。</p>
<h5 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h5><p>Intel处理器在处理一个32位的线性地址时，将其分成3部分（按照Little-Endian)：</p>
<ul>
<li>Directory（目录）：最高10位</li>
<li>Table(页表) ：中间10位</li>
<li>Offset(偏移量) ：最低12位</li>
</ul>
<p>线性地址的转换的流程如下：</p>
<ol>
<li>通过高10位定位到页目录中的某一项，获取一个页表。</li>
<li>通过中间10位定位到页表中的某一项，获取到一个页的起始地址</li>
<li>将低12位（偏移量）+ 步骤2中的得到的页起始地址，获得实际的物理地址。</li>
</ol>
<p>其中的页目录地址存放在cr3寄存器中。</p>
<p><img src="/images/linux-kernel-note/page-mechanism-0.png" alt=""></p>
<h5 id="为什么使用二级模式？"><a href="#为什么使用二级模式？" class="headerlink" title="为什么使用二级模式？"></a>为什么使用二级模式？</h5><p>如果使用一级页表，那么整个页表相当于一个拥有1M个元素的大数组，每个页表项占用的大小为4B，所以整个页表的大小为4M。然而每个活动进程都需要一个独立的页表，绝大多数进程都不会马上使用所有的进程地址空间，相比较直接分配一个映射所有地址空间的一级页表，需要时分配页表显然更加效率。二级模式只为进程实际使用的那些虚拟内存区分配页表，既提升了效率，也减少了内存的使用量。（PS：当使用二级页表时，如果为进程的所有虚拟内存区都分配了页表，这时候的内存使用量是增加的）</p>
<h5 id="页目录项结构"><a href="#页目录项结构" class="headerlink" title="页目录项结构"></a>页目录项结构</h5><p><img src="/images/linux-kernel-note/page-mechanism-1.gif" alt=""></p>
<ul>
<li>第31~12位是20位页表地址，由于页表地址的低12位总为0，所以用高20位指出32位页表地址就可以了。因此，一个页目录最多包含1024个页表地址。</li>
<li>第0位是存在位，如果P=1，表示页表地址指向的该页在内存中，如果P=0，表示不在内存中。</li>
<li>第1位是读/写位，第2位是用户/管理员位，这两位为页目录项提供硬件保护。当特权级为3的进程要想访问页面时，需要通过页保护检查，而特权级为0的进程就可以绕过页保护。</li>
<li>第3位是PWT（Page Write-Through）位，表示是否采用写透方式，写透方式就是既写内存（RAM）也写高速缓存,该位为1表示采用写透方式</li>
<li>第4位是PCD（Page Cache Disable）位，表示是否启用高速缓存,该位为1表示启用高速缓存。</li>
<li>第5位是访问位，当对页目录项进行访问时，A位=1。</li>
<li>第7位是Page Size标志，只适用于页目录项。如果置为1，页目录项指的是4MB的页面，请看后面的扩展分页。</li>
<li>第9~11位由操作系统专用，Linux也没有做特殊之用。</li>
</ul>
<h5 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h5><p><img src="/images/linux-kernel-note/page-mechanism-2.gif" alt=""><br>80386的每个页目录项指向一个页表，页表最多含有1024个页面项，每项4个字节，包含页面的起始地址和有关该页面的信息。页面的起始地址也是4K的整数倍，所以页面的低12位也留作它用。<br>第31~12位是20位物理页面地址，除第6位外第0～5位及9~11位的用途和页目录项一样，第6位是页面项独有的，当对涉及的页面进行写操作时，D位被置1。<br>4GB的内存只有一个页目录，它最多有1024个页目录项，每个页目录项又含有1024个页面项，因此，内存一共可以分成1024×1024=1M个页面。由于每个页面为4K个字节，所以，存储器的大小正好最多为4GB。</p>
<h5 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h5><p>扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。在扩展分页的情况下,分页机制把32位线性地址分成两个域：最高10位的目录域和其余22位的偏移量。</p>
<p>扩展分页地址转换过程如下：<br><img src="/images/linux-kernel-note/page-mechanism-3.png" alt=""></p>
<h5 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h5><p>硬件高速缓存中组相连映射是使用最多的，以下是组相连映射的流程图：<br><img src="/images/linux-kernel-note/page-mechanism-4.jpg" alt=""><br><img src="/images/linux-kernel-note/page-mechanism-5.jpg" alt=""></p>
<h5 id="转换后援缓冲器-TLB"><a href="#转换后援缓冲器-TLB" class="headerlink" title="转换后援缓冲器(TLB)"></a>转换后援缓冲器(TLB)</h5><p>因为在获取页地址时需要去慢速访问主存，而TLB缓存了线性地址和物理地址映射的关系，所以直接在SRAM中就可以获取到对应的物理地址，节省了时间。在多处理器系统中，每个CPU都有自己的TLB，叫做本地TLB。</p>
<h4 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h4><p>Linux使用了一个适合32位和64位系统的分页模型。<br><img src="/images/linux-kernel-note/page-mechanism-6.png" alt=""><br>上图的4种页表分别为:</p>
<ul>
<li>页全局目录</li>
<li>页上级目录</li>
<li>页中间目录</li>
<li>页表</li>
</ul>
<p>页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分成五个部分。图中没有显示位数，因为每一部分的大小与具体的计算机体系结构有关。</p>
<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了。从本质上说Linux通过使“页上级目录”位和“页中间目录”位全为0，彻底取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个合适的目录项而实现的。</p>
<p>启用了物理地址扩展的32 位系统使用了三级页表。Linux的页全局目录对应80×86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应80×86的页目录，Linux的页表对应80×86的页表。</p>
<p>最后，64位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从硬件的角度，32位地址被分成了三部份。不管理软件怎么做，最终落实到硬件，也只识别这3部分。</p>
<p>从软件的角度，由于多引入了两部份，也就是说，共有五部份。要让二层架构的硬件认识五部分，在地址划分的时候，将页上级目录和页中间目录的长度设置为0就可以了。</p>
<p>这样，操作系统见到的是五部份，硬件还是按它死板的三部份划分，软硬件又和谐了。</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>






]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个逻辑地址经过&lt;a href=&quot;/2016/08/13/linux-kernel-note-segment-mechanism/&quot;&gt;分段机制&lt;/a&gt;转换为一个线性地址之后，便需要分页单元将线性地址转换为实际的物理地址。&lt;/p&gt;
&lt;h4 id=&quot;硬件中的分页&quot;&gt;&lt;a hre
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（六）——final</title>
    <link href="http://vinoit.me/2016/08/14/java-memeory-model-final/"/>
    <id>http://vinoit.me/2016/08/14/java-memeory-model-final/</id>
    <published>2016-08-14T06:38:03.000Z</published>
    <updated>2016-08-14T06:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;                            <span class="comment">//普通变量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                      <span class="comment">//final变量</span></div><div class="line">    <span class="keyword">static</span> FinalExample obj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span> <span class="params">()</span> </span>&#123;     <span class="comment">//构造函数</span></div><div class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></div><div class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span> <span class="params">()</span> </span>&#123;    <span class="comment">//写线程A执行</span></div><div class="line">        obj = <span class="keyword">new</span> FinalExample ();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;       <span class="comment">//读线程B执行</span></div><div class="line">        FinalExample object = obj;       <span class="comment">//读对象引用</span></div><div class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">//读普通域</span></div><div class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">//读final域</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h4 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h4><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p>
<ol>
<li>构造一个FinalExample类型的对象；</li>
<li>把这个对象的引用赋值给引用变量obj。</li>
</ol>
<p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：<br><img src="/images/JMM/JMM-final-0.jpg" alt=""><br>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p>
<h4 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h4><p>读final域的重排序规则如下：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li>
</ul>
<p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。</p>
<p>reader()方法包含三个操作：</p>
<ol>
<li>初次读引用变量obj;</li>
<li>初次读引用变量obj指向对象的普通域j。</li>
<li>初次读引用变量obj指向对象的final域i。</li>
</ol>
<p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：<br><img src="/images/JMM/JMM-final-1.png" alt=""><br>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h4 id="如果final域是引用类型"><a href="#如果final域是引用类型" class="headerlink" title="如果final域是引用类型"></a>如果final域是引用类型</h4><p>上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？</p>
<p>请看下列示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] intArray;                     <span class="comment">//final是引用类型</span></div><div class="line"><span class="keyword">static</span> FinalReferenceExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span> <span class="params">()</span> </span>&#123;        <span class="comment">//构造函数</span></div><div class="line">    intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];              <span class="comment">//1</span></div><div class="line">    intArray[<span class="number">0</span>] = <span class="number">1</span>;                   <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程A执行</span></div><div class="line">    obj = <span class="keyword">new</span> FinalReferenceExample ();  <span class="comment">//3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程B执行</span></div><div class="line">    obj.intArray[<span class="number">0</span>] = <span class="number">2</span>;                 <span class="comment">//4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;              <span class="comment">//读线程C执行</span></div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                    <span class="comment">//5</span></div><div class="line">        <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>];       <span class="comment">//6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：</p>
<ul>
<li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ul>
<p>对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：<br><img src="/images/JMM/JMM-final-2.png" alt=""><br>在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="为什么final引用不能从构造函数内“逸出”"><a href="#为什么final引用不能从构造函数内“逸出”" class="headerlink" title="为什么final引用不能从构造函数内“逸出”"></a>为什么final引用不能从构造函数内“逸出”</h4><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;</div><div class="line"><span class="keyword">static</span> FinalReferenceEscapeExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</div><div class="line">    i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></div><div class="line">    obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;</div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></div><div class="line">        <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：<br><img src="/images/JMM/JMM-final-3.png" alt=""><br>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h4><p>现在我们以x86处理器为例，说明final语义在处理器中的具体实现。</p>
<p>上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<p>由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！</p>
<h4 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（五）——锁</title>
    <link href="http://vinoit.me/2016/08/14/java-memeory-model-lock/"/>
    <id>http://vinoit.me/2016/08/14/java-memeory-model-lock/</id>
    <published>2016-08-14T06:17:18.000Z</published>
    <updated>2016-08-14T06:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="锁的释放-获取建立的happens-before-关系"><a href="#锁的释放-获取建立的happens-before-关系" class="headerlink" title="锁的释放-获取建立的happens before 关系"></a>锁的释放-获取建立的happens before 关系</h4><p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>下面是锁释放-获取的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  <span class="comment">//1</span></div><div class="line">        a++;                             <span class="comment">//2</span></div><div class="line">    &#125;                                    <span class="comment">//3</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  <span class="comment">//4</span></div><div class="line">        <span class="keyword">int</span> i = a;                       <span class="comment">//5</span></div><div class="line">        ……</div><div class="line">    &#125;                                    <span class="comment">//6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens before规则，这个过程包含的happens before 关系可以分为两类：</p>
<ul>
<li>根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li>
<li>根据监视器锁规则，3 happens before 4。<br>根据happens before 的传递性，2 happens before 5。</li>
</ul>
<p>上述happens before 关系的图形化表现形式如下：<br><img src="/images/JMM/JMM-lock-0.png" alt=""></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>上图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p>
<h4 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h4><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如下：<br><img src="/images/JMM/JMM-lock-1.png" alt=""><br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图：<br><img src="/images/JMM/JMM-lock-2.png" alt=""><br>对比锁释放-获取的内存语义与volatile写-读的内存语义，可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p>
<p>下面对锁释放和锁获取的内存语义做个总结：</p>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h4 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h4><p>本文将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();         <span class="comment">//获取锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        a++;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();        <span class="comment">//获取锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = a;</div><div class="line">        ……</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p>
<p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。 下面是ReentrantLock的类图（仅画出与本文相关的部分）：<br><img src="/images/JMM/JMM-lock-3.png" alt=""><br>ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。</p>
<p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : lock()</div><div class="line">FairSync : lock()</div><div class="line">AbstractQueuedSynchronizer : acquire(int arg)</div><div class="line">ReentrantLock : tryAcquire(int acquires)</div></pre></td></tr></table></figure></p>
<p>在第4步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();   <span class="comment">//获取锁的开始，首先读volatile变量state</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p>
<p>在使用公平锁时，解锁方法unlock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : unlock()</div><div class="line">AbstractQueuedSynchronizer : release(int arg)</div><div class="line">Sync : tryRelease(int releases)</div></pre></td></tr></table></figure></p>
<p>在第3步真正开始释放锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);           <span class="comment">//释放锁的最后，写volatile变量state</span></div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源代码我们可以看出，在释放锁的最后写volatile变量state。</p>
<p>公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</p>
<p>现在我们分析非公平锁的内存语义的实现。</p>
<p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p>
<p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : lock()</div><div class="line">NonfairSync : lock()</div><div class="line">AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</div></pre></td></tr></table></figure></p>
<p>在第3步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法以原子操作的方式更新state变量，本文把java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p>
<p>这里我们分别从编译器和处理器的角度来分析,CAS如何同时具有volatile读和volatile写的内存语义。</p>
<p>前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p>
<p>下面我们来分析在常见的intel x86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的。</p>
<p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></div><div class="line">                                              <span class="keyword">int</span> expected,</div><div class="line">                                              <span class="keyword">int</span> x);</div></pre></td></tr></table></figure>
<p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：<code>unsafe.cpp</code>，<code>atomic.cpp</code>和<code>atomicwindowsx86.inline.hpp</code>。这个本地方法的最终实现在openjdk的如下位置：<code>openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp</code>（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Adding a lock prefix to an instruction on MP machine</div><div class="line">// VC++ doesn't like the lock prefix to be on a single line</div><div class="line">// so we can't insert a label after the lock prefix.</div><div class="line">// By emitting a lock prefix, we can define a label after it.</div><div class="line">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</div><div class="line">                       __asm je L0      \</div><div class="line">                       __asm _emit 0xF0 \</div><div class="line">                       __asm L0:</div><div class="line"></div><div class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</div><div class="line">  // alternative for InterlockedCompareExchange</div><div class="line">  int mp = os::is_MP();</div><div class="line">  __asm &#123;</div><div class="line">    mov edx, dest</div><div class="line">    mov ecx, exchange_value</div><div class="line">    mov eax, compare_value</div><div class="line">    LOCK_IF_MP(mp)</div><div class="line">    cmpxchg dword ptr [edx], ecx</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
<p>intel的手册对lock前缀的说明如下：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<p>经过上面的这些分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。</p>
<p>现在对公平锁和非公平锁的内存语义做个总结：</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读这个volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新这个volatile变量,这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用volatile变量的写-读所具有的内存语义。</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ol>
<h4 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h4><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：<br><img src="/images/JMM/JMM-lock-4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;锁的释放-获取建立的happens-before-关系&quot;&gt;&lt;a href=&quot;#锁的释放-获取建立的happens-before-关系&quot; class=&quot;headerlink&quot; title=&quot;锁的释放-获取建立的happens before 关系&quot;&gt;&lt;/a&gt;锁的释放-
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之分段机制</title>
    <link href="http://vinoit.me/2016/08/13/linux-kernel-note-segment-mechanism/"/>
    <id>http://vinoit.me/2016/08/13/linux-kernel-note-segment-mechanism/</id>
    <published>2016-08-13T07:59:27.000Z</published>
    <updated>2016-08-13T12:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要有分段机制？"><a href="#为什么要有分段机制？" class="headerlink" title="为什么要有分段机制？"></a>为什么要有分段机制？</h4><ul>
<li><p>在8086处理器诞生之前，内存寻址方式就是直接访问物理地址,也就是所谓的实模式。8086处理器为了寻址1M的内存空间，把地址总线扩展到了20位。但是，ALU的宽度<code>只有16位</code>，也就是说，ALU不能计算20位的地址。为了解决这个问题，从而引入了分段机制。<br>为了支持分段，8086处理器设置了四个段寄存器：CS, DS, SS, ES.每个段寄存器都是16位的，都包含着相应段的基址，访存指令中的地址也是16位的。但是，在送入地址总线之前，CPU先把它与某个段寄存器内的值按以下方式相加：<br><code>实际物理地址 = （段寄存器地址 &lt;&lt; 4） + （指令访存地址）</code></p>
</li>
<li><p>80286处理器的地址总线为24位，寻址空间达16M，同时引入了保护模式（指令给出的地址不对应实际的物理地址）</p>
</li>
<li><p>80386处理器是一个32位处理器，ALU和地址总线都是32位的，寻址空间达 4G。它可以不通过分段机制，直接访问4G的内存空间。然而为了兼容前代的处理器，它必须同时支持实模式和保护模式。所以，80386在段寄存器的基础上构筑保护模式，并且保留16位的段寄存器。</p>
</li>
<li><p>从80386之后的处理器，架构基本相似，统称为IA32（32 Bit Intel Architecture）。</p>
</li>
</ul>
<h4 id="IA32架构下的内存寻址"><a href="#IA32架构下的内存寻址" class="headerlink" title="IA32架构下的内存寻址"></a>IA32架构下的内存寻址</h4><h5 id="IA32的三类地址"><a href="#IA32的三类地址" class="headerlink" title="IA32的三类地址"></a>IA32的三类地址</h5><ul>
<li>逻辑地址:<br>机器语言指令用这类地址指定一个操作数的地址或一条指令的地址，最原始的地址就是逻辑地址。</li>
<li>线性地址：<br>将逻辑地址经过分段机制转换之后，便得到了线性地址,每个线性地址都由一个段基址和段内偏移量组成。</li>
<li>物理地址：<br>线性地址经过分页单元的处理之后得到一个实际物理地址，也就是内存单元的实际地址，用于芯片级内存单元寻址。</li>
</ul>
<h5 id="MMU地址转化过程"><a href="#MMU地址转化过程" class="headerlink" title="MMU地址转化过程"></a>MMU地址转化过程</h5><p>以上3类地址是通过MMU（内存管理单元）来进行转换。其中MMU处理时包含2个过程，分段和分页。在这里简单的说明下具体过程：</p>
<blockquote>
<p>当一条机器指令给出一个地址时，这时候的地址便是逻辑地址。</p>
<p>为了得到线性地址，需要从相应的段寄存器中取出16位的段标识符（段选择符），通过这个段标识符可以得到一个段基址。然后将得到的段基址与指令中的地址相加，从而得到一个线性地址。</p>
<p>有了线性地址之后，再通过分页单元得到实际的物理地址。</p>
</blockquote>
<h5 id="IA32的段寄存器"><a href="#IA32的段寄存器" class="headerlink" title="IA32的段寄存器"></a>IA32的段寄存器</h5><p>IA32中有六个16位段寄存器：CS, DS, SS, ES，FS, GS.跟8086的段寄存器不同的是，这些寄存器存放的不再是某个段的基地址，而是某个段的选择符（Selector）。</p>
<h4 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h4><h5 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a>段选择符和段寄存器</h5><p>段寄存器的唯一目的就是存放段选择符，段选择符是一个16位长的字段：<br><img src="/images/linux-kernel-note/segment-mechanism-0.jpg" alt=""></p>
<p>第01位表示的是请求者的特权，第2位是表指示器，用于指定所使用的描述符表。3~15位是一个索引号，定位到描述符表中的某一项段描述符。</p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符说白了就是用来描述段的特征，段描述表放在全局描述符表（GDT）或者局部描述符表（LDT），每个段描述符为8个字节大小。GDT的地址和大小存放在寄存器gdtr中，LDT的地址和大小存放在寄存器ldtr中。</p>
<p>有几种不同类型的段以及它们对应的段描述符，下面列出了Linux中广泛采用的类型：</p>
<p><strong>代码段描述符</strong></p>
<p>表示这个段描述符代表一个代码段，它可以放在GDT或LDT中。该描述符置S标志为1，并且为非系统段。</p>
<p><strong>数据段描述符</strong></p>
<p>表示这个段描述符代表一个数据段，它可以放在GDT或LDT中。该描述符置S标志为1，栈段是通过数据段实现的。</p>
<p><strong>任务状态段描述符（TSSD）</strong></p>
<p>表示这个段描述符代表一个任务状态段（Task State Segment，TSS），也就是说这个段用于保存处理器寄存器的内容。它只能出现在GDT中。根据相应的进程是否正在CPU上运行，其Type字段的值分别为11或9。这个描述符的S标志被置为0。</p>
<p><strong>局部描述符表描述符（LDTD）</strong></p>
<p>这个表示段描述符代表一个包含LDT的段，他置出现在GDT中。相应的Type字段的值为2，S标志被置为0。</p>
<p>下图为段描述符的字段表示：<br><img src="/images/linux-kernel-note/segment-mechanism-1.png" alt=""></p>
<p>相应字段的意义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Base</td>
<td style="text-align:left">包含段的首字节的线性地址</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:left">粒度标志，如果为0，则段大小以字节为单位，否则以4096字节的倍数计算</td>
</tr>
<tr>
<td style="text-align:center">Limit</td>
<td style="text-align:left">存放段最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在一个字节到1MB之间变化，否则，将在4KB到4GB之间变化</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:left">系统标志，如果被置为0，则这是一个系统段，否则为普通的代码段或者数据段</td>
</tr>
<tr>
<td style="text-align:center">Type</td>
<td style="text-align:left">描述了段的类型特征和它的存取权限</td>
</tr>
<tr>
<td style="text-align:center">DPL</td>
<td style="text-align:left">描述符特权等级字段，用于限制这个段的存取。它表示为访问这个段而要求的CPU最小的优先级，因此DPL设置为0的段只能当CPL为0时，也就是内核态才可以访问。DPL设为3则堆任何CPL值都是可访问的</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:left">Segment-Present标志，等于0表示段当前不在主存中。Linux总是把此标志设为1，因为Linux从来不把整个段交换到磁盘上去</td>
</tr>
<tr>
<td style="text-align:center">D或B</td>
<td style="text-align:left">称为D或B标志，取决于是代码段还是数据段，D和B的含义在两种情况下有区别，如果段偏移量的地址是32位长，就基本上把它设置为1，如果偏移量是16位长，则清零</td>
</tr>
<tr>
<td style="text-align:center">AVL</td>
<td style="text-align:left">可以由操作系统使用，但是被Linux忽略</td>
</tr>
</tbody>
</table>
<p>当指令给出一个地址后，硬件的处理顺序如下：</p>
<ol>
<li>根据指令类型选择好段选择符，检查段选择符的TI字段，决定使用GDT还是LDT，再从gftr寄存器或者ldtr寄存器中获得描述符表的地址。</li>
<li>使用段选择符的索引号，定位到段描述符，<code>描述符地址 = 索引号 * 8 + gdtr(ldtr)中的地址</code>。</li>
<li>将段描述符中的Base值与给出的地址相加，从而得到线性地址。</li>
<li>将线性地址通过分页单元换换成物理地址。</li>
</ol>
<p>其中的段描述符地址，在寄存器内容不变的情况下会保存在一个与段寄存器相关的不可编程寄存器中，相当于缓存了这个地址，于是就可以省去前面2个步骤。</p>
<h4 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h4><p> Linux的段式管理，事实上只是“哄骗”了一下硬件而已。从2.2版开始，Linux让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。但内核中也用到LDT，那只是在VM86模式中运行Wine，因为就是说在Linux上模拟运行Winodws软件或DOS软件的程序时才使用。</p>
<p> 在内核源码<code>include/asm-i386/segment.h</code>中定义了如下宏:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_CS        14</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_DS        15</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_BASE        12</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_CS                (GDT_ENTRY_KERNEL_BASE + 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_DS                (GDT_ENTRY_KERNEL_BASE + 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)</span></div></pre></td></tr></table></figure>
<p> 把其中的宏替换成数值，则为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS 115      [00000000 1110  0  11]（用户代码段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS 123      [00000000 1111  0  11]（用户数据段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS 96     [00000000 1100  0  00]（内核代码段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS 104    [00000000 1101  0  00]（内核数据段）</span></div></pre></td></tr></table></figure>
<p> 方括号后是这四个段选择符的16位二制表示，它们的索引号和T1字段值也可以算出来了：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__USER_CS             index= 14   T1=0</div><div class="line">__USER_DS             index= 15   T1=0</div><div class="line">__KERNEL_CS           index= 12   T1=0</div><div class="line">__KERNEL_DS           index= 13   T1=0</div></pre></td></tr></table></figure>
<p> T1均为0，则表示都使用了GDT，再来看初始化GDT的内容中相应的12-15项(arch/i386/head.S)：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.quad <span class="number">0x00cf9a000000ffff</span>        <span class="comment">/* 0x60 kernel 4GB code at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cf92000000ffff</span>        <span class="comment">/* 0x68 kernel 4GB data at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cffa000000ffff</span>        <span class="comment">/* 0x73 user 4GB code at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cff2000000ffff</span>        <span class="comment">/* 0x7b user 4GB data at 0x00000000 */</span></div></pre></td></tr></table></figure>
<p>按照前面段描述符表中的描述，可以把它们展开，发现其16-31位全为0，即四个段的基地址全为0。</p>
<p>这样，给定一个段内偏移地址，按照前面转换公式，0 + 段内偏移，转换为线性地址，可以得出重要的结论，<strong>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>分段机制的存在主要是为了兼容前代处理器，而Linux巧妙的避开了硬件的死套路，有时候软硬件的结合的确很和谐。</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么要有分段机制？&quot;&gt;&lt;a href=&quot;#为什么要有分段机制？&quot; class=&quot;headerlink&quot; title=&quot;为什么要有分段机制？&quot;&gt;&lt;/a&gt;为什么要有分段机制？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在8086处理器诞生之前，内存寻址方式就是直接访问物理地址
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（四）——volatile</title>
    <link href="http://vinoit.me/2016/08/13/java-memeory-model-volatile/"/>
    <id>http://vinoit.me/2016/08/13/java-memeory-model-volatile/</id>
    <published>2016-08-13T06:18:13.000Z</published>
    <updated>2016-08-13T06:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h4><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>;  <span class="comment">//使用volatile声明64位的long型变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">        vl = l;   <span class="comment">//单个volatile变量的写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</div><div class="line">        vl++;    <span class="comment">//复合（多个）volatile变量的读/写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vl;   <span class="comment">//单个volatile变量的读</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> vl = <span class="number">0L</span>;               <span class="comment">// 64位的long型普通变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;     <span class="comment">//对单个的普通 变量的写用同一个监视器同步</span></div><div class="line">        vl = l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">//普通方法调用</span></div><div class="line">        <span class="keyword">long</span> temp = get();           <span class="comment">//调用已同步的读方法</span></div><div class="line">        temp += <span class="number">1L</span>;                  <span class="comment">//普通写操作</span></div><div class="line">        set(temp);                   <span class="comment">//调用已同步的写方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="comment">//对单个的普通变量的读用同一个监视器同步</span></div><div class="line">        <span class="keyword">return</span> vl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</p>
<p>简而言之，volatile变量自身具有下列特性：</p>
<ul>
<li>可见性: 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
<h4 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens before关系"></a>volatile写-读建立的happens before关系</h4><p>上面讲的是volatile变量自身的特性，对程序员来说，volatile对线程的内存可见性的影响比volatile自身的特性更为重要，也更需要我们去关注。</p>
<p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。</p>
<p>从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。</p>
<p>请看下面使用volatile变量的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></div><div class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></div><div class="line">            ……</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据volatile规则，2 happens before 3。</li>
<li>根据happens before 的传递性规则，1 happens before 4。</li>
</ol>
<p>上述happens before 关系的图形化表现形式如下：<br><img src="/images/JMM/JMM-volatile-0.png" alt=""><br>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
<h4 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h4><p>volatile写的内存语义如下：</p>
<p><code>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</code></p>
<p>以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图：<br><img src="/images/JMM/JMM-volatile-1.png" alt=""></p>
<p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p>
<p>volatile读的内存语义如下：</p>
<p><code>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</code></p>
<p>下面是线程B读同一个volatile变量后，共享变量的状态示意图：<br><img src="/images/JMM/JMM-volatile-2.png" alt=""></p>
<p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把volatile写和volatile读这两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p>下面对volatile写和volatile读的内存语义做个总结：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<p>volatile内存语义的实现</p>
<p>下面，让我们来看看JMM如何实现volatile写/读的内存语义。</p>
<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：</p>
<table border="1px"><tr><td>是否能重排序</td><td colspan="3">第二个操作</td></tr><tr><td>第一个操作</td><td>普通读/写</td><td>volatile读</td><td>volatile写</td></tr><tr><td>普通读/写</td><td>&nbsp;</td><td>&nbsp;</td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td>&nbsp;</td><td>NO</td><td>NO</td></tr></table>

<p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上表我们可以看出：</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：<br><img src="/images/JMM/JMM-volatile-3.png" alt=""></p>
<p>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：<br><img src="/images/JMM/JMM-volatile-4.png" alt=""></p>
<p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = v1;           <span class="comment">//第一个volatile读</span></div><div class="line">        <span class="keyword">int</span> j = v2;           <span class="comment">// 第二个volatile读</span></div><div class="line">        a = i + j;            <span class="comment">//普通写</span></div><div class="line">        v1 = i + <span class="number">1</span>;          <span class="comment">// 第一个volatile写</span></div><div class="line">        v2 = j * <span class="number">2</span>;          <span class="comment">//第二个 volatile写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    …                    <span class="comment">//其他方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：<br><img src="/images/JMM/JMM-volatile-5.png" alt=""></p>
<p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器常常会在这里插入一个StoreLoad屏障。</p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以x86处理器为例，上图中除最后的StoreLoad屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的volatile读和写，在 x86处理器平台可以优化成：<br><img src="/images/JMM/JMM-volatile-6.png" alt=""><br>前文提到过，x86处理器仅会对写-读操作做重排序。X86不会对读-读，读-写和写-写操作做重排序，因此在x86处理器中会省略掉这三种操作类型对应的内存屏障。在x86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在x86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p>
<h4 id="JSR-133为什么要增强volatile的内存语义"><a href="#JSR-133为什么要增强volatile的内存语义" class="headerlink" title="JSR-133为什么要增强volatile的内存语义"></a>JSR-133为什么要增强volatile的内存语义</h4><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：<br><img src="/images/JMM/JMM-volatile-7.png" alt=""><br>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;volatile的特性&quot;&gt;&lt;a href=&quot;#volatile的特性&quot; class=&quot;headerlink&quot; title=&quot;volatile的特性&quot;&gt;&lt;/a&gt;volatile的特性&lt;/h4&gt;&lt;p&gt;当我们声明共享变量为volatile后，对这个变量的读/写将会很特别
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（三）——顺序一致性</title>
    <link href="http://vinoit.me/2016/08/13/java-memeory-model-sequential-consistency/"/>
    <id>http://vinoit.me/2016/08/13/java-memeory-model-sequential-consistency/</id>
    <published>2016-08-13T05:59:55.000Z</published>
    <updated>2016-08-13T06:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h4><p>当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义如下：</p>
<ul>
<li>在一个线程中写一个变量</li>
<li>在另一个线程读同一个变量</li>
<li>而且写和读没有通过同步来排序</li>
</ul>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p>
<p><code>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。</code></p>
<h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>不管程序是否同步,所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>顺序一致性内存模型为程序员提供的视图如下：<br><img src="/images/JMM/JMM-sequential-consistency-0.png" alt=""></p>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<p>假设有两个线程A和B并发执行。其中A线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p>
<p>假设这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：<br><img src="/images/JMM/JMM-sequential-consistency-1.png" alt=""><br>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：<br><img src="/images/JMM/JMM-sequential-consistency-2.png" alt=""><br>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>下面我们对前面的示例程序ReorderExample用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    a = <span class="number">1</span>;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (flag) &#123;</div><div class="line">        <span class="keyword">int</span> i = a;</div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：<br><img src="/images/JMM/JMM-sequential-consistency-3.png" alt=""></p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到JMM在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
<h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在JMM中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ol>
<p>第3个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和I/O设备执行内存的读/写。下面让我们通过一个示意图来说明总线的工作机制：<br><img src="/images/JMM/JMM-sequential-consistency-4.png" alt=""></p>
<p>如上图所示，假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其它两个处理器则要等待处理器A的总线事务完成后才能开始再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<p>在一些32位的处理器上，如果要求对64位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性。当JVM在这种处理器上运行时，会把一个64位long/ double型变量的读/写操作拆分为两个32位的读/写操作来执行。这两个32位的读/写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的读/写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：<br><img src="/images/JMM/JMM-sequential-consistency-5.png" alt=""></p>
<p>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时处理器B中64位的读操作被拆分为两个32位的读操作，且这两个32位的读操作被分配到同一个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半“的无效值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据竞争与顺序一致性保证&quot;&gt;&lt;a href=&quot;#数据竞争与顺序一致性保证&quot; class=&quot;headerlink&quot; title=&quot;数据竞争与顺序一致性保证&quot;&gt;&lt;/a&gt;数据竞争与顺序一致性保证&lt;/h4&gt;&lt;p&gt;当程序未正确同步时，就会存在数据竞争。java内存模型规范对
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>调试器基本工作原理</title>
    <link href="http://vinoit.me/2016/08/12/how-debugger-work/"/>
    <id>http://vinoit.me/2016/08/12/how-debugger-work/</id>
    <published>2016-08-12T08:34:29.000Z</published>
    <updated>2016-08-13T12:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。</p>
<h4 id="ptrace-系统调用"><a href="#ptrace-系统调用" class="headerlink" title="ptrace()系统调用"></a>ptrace()系统调用</h4><p>Linux下的调试器实现的主要组成部分就是<code>ptrace()</code>,这是一个功能众多且相当复杂的工具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。其中这2个进程是父子进程的关系，调试的进程是父进程，被调试的则是子进程。</p>
<p>OS X下<code>ptrace()</code>的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">int</span> request, <span class="keyword">pid_t</span> pid, <span class="keyword">caddr_t</span> addr, <span class="keyword">int</span> data)</span></span>;</div></pre></td></tr></table></figure>
<p>其中man手册如此描述参数：</p>
<p><code>The request argument specifies what operation is being performed; the
meaning of the rest of the arguments depends on the operation, but except for one special case noted below,  all ptrace() calls are made by the tracing process, and the pid argument specifies the process ID of the traced process.</code></p>
<p>也就是说<code>request</code>参数表示操作的类型，其他3个参数在不同的操作下意义可能不同，<code>pid</code>永远指向<strong>被调试</strong>的进程。<br><code>request</code>可以有以下值：</p>
<ul>
<li>PT_TRACE_ME</li>
<li>PT_DENY_ATTACH</li>
<li>PT_CONTINUE</li>
<li>PT_STEP</li>
<li>PT_KILL</li>
<li>PT_ATTACH</li>
<li>PT_ATTACHEXC</li>
<li>PT_DETACH </li>
</ul>
<p>某些值由父进程使用，某些则由子进程使用，比如<code>PT_TRACE_ME</code>由子进程调用，从命名上也可以看出来(追踪我)。其中的具体含义可以查看man手册，此处就不多解释了。</p>
<h4 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h4><p>从高层设计来说，我们要写一个程序，它产生一个子进程用来执行一个用户指定的命令，而父进程跟踪这个子进程。首先，main函数是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> child_pid;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Expected a program name as argument\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    child_pid = fork();</div><div class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</div><div class="line">        run_target(argv[<span class="number">1</span>]);<span class="comment">//子进程执行需要被追踪的指令</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</div><div class="line">        run_debugger(child_pid);<span class="comment">//父进程追踪子进程</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        perror(<span class="string">"fork"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>run_target(char arg)</code>函数的核心内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ptrace(PT_TRACE_ME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">execl(arg, arg, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>首先执行ptrace系统调用，request值为PT_TRACE_ME，表明进程期待被父进程追踪，这时候一旦调用了<code>execl()</code>,进程被停止运行，然后接收到一个SIGTRAP信号，并等待父进程的操作。</p>
<p>父进程<code>run_debugger()</code>函数的核心内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wait(&amp;wait_status);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (WIFSTOPPED(wait_status)) &#123;</div><div class="line">        <span class="comment">/* Make the child execute another instruction */</span></div><div class="line">        <span class="keyword">if</span> (ptrace(PT_STEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">            perror(<span class="string">"ptrace"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></div><div class="line">        wait(&amp;wait_status);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>循环外面的<code>wait()</code>调用阻塞父进程，直到有子进程停止运行。此时执行while循环的内容，如果子进程由于发送的信号而停止运行，WIFSTOPPED就返回true。循环内的代码就做了2件事，首先调用<code>ptrace()</code>,request值为PT_STEP，使得pid为child_pid的进程单步执行下一条指令。然后再次调用<code>wait()</code>,阻塞等待子进程停止。依次循环，直到子进程结束。</p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>在调试的时候我们可以在期望的地方打上断点，程序运行到断点处自动停止运行。这在Linux中是通过中断机制来实现的，将断点处的指令用<code>int 3</code>来替代，int指令可以产生一个中断，后面的数字是中断号，每个中断号都对应一个处理例程，3号例程专门用来处理调试时的断点。</p>
<p>要在被调试进程中的某个目标地址上设定一个断点，调试器需要做下面两件事情：</p>
<ol>
<li><p>保存目标地址上的数据</p>
</li>
<li><p>将目标地址上的第一个字节替换为int 3指令</p>
</li>
</ol>
<p>然后，当调试器向操作系统请求开始运行进程时，进程最终一定会碰到int 3指令。此时进程停止，操作系统将发送一个信号。这时就是调试器(父进程)再次出马的时候了，接收到一个其子进程（或被跟踪进程）停止的信号，然后调试器要做下面几件事：</p>
<ol>
<li><p>在目标地址上用原来的指令替换掉int 3</p>
</li>
<li><p>将被跟踪进程中的指令指针向后递减1。这么做是必须的，因为现在指令指针指向的是已经执行过的int 3之后的下一条指令。</p>
</li>
<li><p>由于进程此时仍然是停止的，用户可以同被调试进程进行某种形式的交互。这里调试器可以让你查看变量的值，检查调用栈等等。</p>
</li>
<li><p>当用户希望进程继续运行时，调试器负责将断点再次加到目标地址上（由于在第一步中断点已经被移除了），除非用户希望取消断点。</p>
</li>
</ol>
<h4 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h4><p>当你在某些函数的入口处设置断点时，调试器如何知道该在哪里停止目标进程的运行呢？当你希望查看一个变量的值时，调试器又是如何找到它并展示给你呢？答案就是——调试信息。</p>
<p><strong>调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码<code>一起存储</code>。</strong>许多年以来，针对不同的平台和可执行文件，人们发明了许多这样的编码格式。其中一种最重要的格式就是DWARF，作为Linux以及其他类Unix平台上的ELF可执行文件的调试信息格式，如今的DWARF可以说是无处不在。</p>
<p>通过下面的C代码构建一个名为traceprog2的可执行文件来做下实验:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">int</span> my_arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> my_local = my_arg + <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; my_local; ++i)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    do_stuff(<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过objdump –h导出ELF可执行文件中的段头信息，我们注意到其中有几个段的名字是以.debug_打头的，这些就是DWARF格式的调试段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">26</span> .debug_aranges <span class="number">00000020</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001037</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">27</span> .debug_pubnames <span class="number">00000028</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001057</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">28</span> .debug_info   <span class="number">000000</span>cc  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">0000107f</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">29</span> .debug_abbrev <span class="number">0000008</span>a  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">0000114b</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">30</span> .debug_line   <span class="number">0000006b</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">000011</span>d5</div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">31</span> .debug_frame  <span class="number">00000044</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001240</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">32</span> .debug_str    <span class="number">000000</span>ae  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001284</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">33</span> .debug_loc    <span class="number">00000058</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001332</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div></pre></td></tr></table></figure>
<p>每行的第一个数字表示每个段的大小，而最后一个数字表示距离ELF文件开始处的偏移量。调试器就是利用这个信息来从可执行文件中读取相关的段信息，从而找到可执行程序和源代码之间的关系。</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。&lt;/p&gt;
&lt;h4 id=&quot;ptrace-系统调用&quot;&gt;&lt;a href=&quot;#ptrace-系统调用&quot; class=&quot;h
    
    </summary>
    
      <category term="理解计算机" scheme="http://vinoit.me/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>java实现的订单号生成工具类</title>
    <link href="http://vinoit.me/2016/07/05/java-ordernum-generate/"/>
    <id>http://vinoit.me/2016/07/05/java-ordernum-generate/</id>
    <published>2016-07-05T03:31:05.000Z</published>
    <updated>2016-08-13T12:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一个自己在项目里写的订单号生成工具类，不当之处望各位指出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.project.utils;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Vino on 16/5/7.</div><div class="line"> * 订单生成规则:</div><div class="line"> * 正常情况下:年(2位)+月(2位)+日(2位)+秒(5位)+循环自增值(3位)+随机码(2位)共16位</div><div class="line"> * 非正常情况下:年(2位)+月(2位)+日(2位)+秒(5位)+随机码(5位)共16位</div><div class="line"> * 注:非正常情况在同时开启1W个线程的情况下并未发生</div><div class="line"> * 业务编码(1位)：自营、通用件、全车件待定</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNumGen</span> </span>&#123;</div><div class="line">    <span class="comment">//循环自增上限,超出则从初始值开始</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxLoop = <span class="number">999</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initNum  = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger atomicInteger;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: DCL获取单例atomicInteger</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger <span class="title">getAtomicInteger</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (atomicInteger == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (OrderNumGen.class) &#123;</div><div class="line">                <span class="keyword">if</span> (atomicInteger == <span class="keyword">null</span>)</div><div class="line">                    atomicInteger = <span class="keyword">new</span> AtomicInteger(initNum);<span class="comment">//初始值为100</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> atomicInteger;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: 订单号生成</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取单例</span></div><div class="line">        AtomicInteger atomicInteger = getAtomicInteger();</div><div class="line">        <span class="comment">//原子性自增并返回自增前的值</span></div><div class="line">        <span class="keyword">int</span> nextValue = atomicInteger.getAndIncrement();</div><div class="line">        <span class="comment">//若循环次数已超过上限</span></div><div class="line">        <span class="keyword">if</span> (nextValue &gt; maxLoop) &#123;</div><div class="line">            <span class="comment">//CAS更新值成功</span></div><div class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(nextValue + <span class="number">1</span>, initNum)) &#123;</div><div class="line">                atomicInteger.getAndIncrement();</div><div class="line">                <span class="keyword">return</span> getNextNormally(initNum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">//CAS更新值失败</span></div><div class="line">                <span class="comment">//重新获取</span></div><div class="line">                nextValue = atomicInteger.getAndIncrement();</div><div class="line">                <span class="keyword">if</span> (nextValue &lt;= maxLoop)</div><div class="line">                    <span class="keyword">return</span> getNextNormally(nextValue);</div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//非正常情况下</span></div><div class="line">                    <span class="keyword">return</span> getNextUnNormally();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getNextNormally(nextValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getNextNormally</span><span class="params">(<span class="keyword">int</span> nextValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> randomNum=(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>)+<span class="number">10</span>;<span class="comment">//2位随机码</span></div><div class="line">        <span class="keyword">return</span> Long.valueOf(getDateNum()+nextValue+randomNum);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getNextUnNormally</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>)(Math.random()*<span class="number">90000</span>)+<span class="number">10000</span>;<span class="comment">//5位随机码</span></div><div class="line">        <span class="keyword">return</span> Long.valueOf(getDateNum()+randomNum);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: 获取订单号中的时间部分</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateNum</span><span class="params">()</span></span>&#123;</div><div class="line">        Date date = <span class="keyword">new</span> Date();</div><div class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyMMddHHmmss"</span>);</div><div class="line">        String sTime = simpleDateFormat.format(date);</div><div class="line">        Integer nSecond = Integer.valueOf(sTime.substring(<span class="number">6</span>,<span class="number">8</span>)) * <span class="number">60</span> * <span class="number">60</span> +Integer.valueOf(sTime.substring(<span class="number">8</span>,<span class="number">10</span>)) * <span class="number">60</span></div><div class="line">                + Integer.valueOf(sTime.substring(<span class="number">10</span>,<span class="number">12</span>));</div><div class="line">        String sSecond = String.valueOf(nSecond);</div><div class="line">        <span class="keyword">if</span>(sSecond.length() &lt; <span class="number">5</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>,j = sSecond.length(); i &gt; j; i--)&#123;</div><div class="line">                sSecond = <span class="string">"0"</span> + sSecond;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sTime.substring(<span class="number">0</span>,<span class="number">6</span>)+sSecond;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一个自己在项目里写的订单号生成工具类，不当之处望各位指出。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="订单生成" scheme="http://vinoit.me/tags/%E8%AE%A2%E5%8D%95%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux slab机制中的colouroff</title>
    <link href="http://vinoit.me/2016/06/29/linux-slab-colour/"/>
    <id>http://vinoit.me/2016/06/29/linux-slab-colour/</id>
    <published>2016-06-29T10:52:25.000Z</published>
    <updated>2016-08-13T12:25:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="slab简介"><a href="#slab简介" class="headerlink" title="slab简介"></a>slab简介</h4><p>slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。</p>
<h4 id="slab数据结构"><a href="#slab数据结构" class="headerlink" title="slab数据结构"></a>slab数据结构</h4><p>用于描述和管理cache的数据结构是struct kmem_cache，在struct kmem_cache中有一个struct kmem_list3*nodelists[<code>MAX_NUMNODES</code>]，<br>每个nodelists中都有着3条slab双向链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_list3 &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_partial; <span class="comment">/*slab链表，包含空闲对象和已分配对象的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_full;   <span class="comment">/*slab链表，只包含非空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_free;   <span class="comment">/*slab链表，只包含空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;    <span class="comment">/*高速缓存中空闲对象的个数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;       <span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;       <span class="comment">/*下一个slab使用的颜色*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> list_lock;  </div><div class="line">    <span class="keyword">struct</span> array_cache *shared; <span class="comment">/* shared per node */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache **alien; <span class="comment">/* on other nodes */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;    <span class="comment">/* updated without locking */</span>  </div><div class="line">    <span class="keyword">int</span> free_touched;       <span class="comment">/* updated without locking */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>（其中的<code>MAX_NUMNODES</code>在UMA机制中为1，Linux把物理内存划分为三个层次来管理：存储节点（Node）、管理区（Zone）和页面（Page）。UMA对应一致存储结构，它只需要一个Node就可以描述当前系统中的物理内存）。</p>
<p>每个slab由一个或多个页框组成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> slab &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;  <span class="comment">/*用于将slab链入kmem_list3的链表*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;<span class="comment">/*该slab的着色偏移*/</span>  </div><div class="line">    <span class="keyword">void</span> *s_mem;            <span class="comment">/*指向slab中的第一个对象*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;     <span class="comment">/*已分配出去的对象*/</span>  </div><div class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;     <span class="comment">/*下一个空闲对象的下标*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;  <span class="comment">/*节点标识号*/</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>其中的colouroff代表的是什么呢？</strong></p>
<h4 id="为什么要colouroff"><a href="#为什么要colouroff" class="headerlink" title="为什么要colouroff?"></a>为什么要colouroff?</h4><p>比如cache line 32 字节,  字节0-31一次从内存写入/读取, 字节32-63一次从内存写入/读取…..</p>
<p>另外cache对应到内存位置不是任意的</p>
<p>Cache 地址0 对应到 内存地址0 , 32 ,64 ….</p>
<p>Cache 地址1 对应到 内存地址1 , 33 ,65 ….</p>
<p>…</p>
<p>一个slab大小肯定是整数页,所以起始地址末12位为零, 即都于cache0 对应.</p>
<p>然后2个slab的每一个obj大小一样, 所以2个slab每个obj都对应相同的cache line.</p>
<p>这样2个位置相同的obj都要频繁访问,比较容易使cache来回刷新,效率降低.</p>
<p>着色就是在第二个slab的起始位置空一个cache line出来, 这样2个slab每个obj对应的cache错开一个, 这样2个位置相同的obj即使频繁访问,也不会用一个相同cache line.</p>
<h4 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h4><p>一个L1 DATA CACHE相当于一块小的内存，<code>我们假设它为16K大</code>，它会与一般物理内存交互。<br>它和内存交互一般一次传输16个字节(32个字节),也就是:  </p>
<p>CACHE 字节0-15一次写到/读取物理内存 ，字节16-31一次写到/读取物理内存.32-47 … …  </p>
<p>这些一次被传输的字节被称为cache line。  </p>
<p><strong>注意!!!这里的cache line中的cache指的是cpu中的L1 DATA CACHE ,而不是slab算法中的结构cache,这两个容易混淆。下面提到的cache都是指L1 DATA CACHE,而不是slab算法中的结构cache</strong>  </p>
<hr>
<h4 id="cache-line对齐和colouroff"><a href="#cache-line对齐和colouroff" class="headerlink" title="cache line对齐和colouroff"></a>cache line对齐和colouroff</h4><p>另外，cache写到物理内存的位置不是任意的，<br>我们假定内存为64K,那么cache地址0的数值只能和物理内存的地址0, 16K, 32K交互；cache地址1的数值只能和物理内存的地址1, 16K+1, 32K+1交互<br>。。。 。。。cache地址16K-1的数值只能和物理内存的地址6K-1, 16K+16K-1, 32K+16K -1交互  </p>
<p>这说明了两点:  </p>
<p>(1)假设对象A的一个字段长为16个字节，如果它放在物理地址 0-15,那么它将和cache的第一个cache line 交互，如果放在物理地址 8-23,那么<br>如果CPU要访问这个字段，必须将第一个和第二个cache line 都读入，才能获得这个字段的信息，显然这样速度慢，所以一般字段需要<code>cache line对齐</code>，<br>在这里就是16个字节对齐。  </p>
<p>(2)关于colouroff  </p>
<p>一般一个对象某些字段访问频繁些。<br>假定一个cache(这个cache指slab的cache,不是上面提到CPU的L1 DATA CACHE)占用5个页面也就是20K.<br>假定其中对象大小为32个字节，前16个字节访问频繁许多。  </p>
<p>假定对象A起始于物理地址0，对象C起始于31,对象B起始于物理地址16K,那么对象A，对象B的前16个字节都和第一个cache line 交互，后16个字节都和第二个cache line 交互<br>对象C前16个字节与第3个cache交互。  </p>
<p>我们假定内核访问A后就访问B,再访问A,交错进行，并且前16个字节次数都是50次，后16个为10次。C也是。  </p>
<p>这样第一个cache line 要交互100次，第二个20次，一共120次。  </p>
<p>如果让对象B向后移动16个字节，也就是对象B的前16个字节与第二个cache line 交互，后16个与第3个交互。<br>那么第一个为2次，因为只有开头结尾2次要与内存交互，其它每次都在L1 DATACACHE 中写就可以了。第2个cache line为20次左右(后面的只须在CACHE中读写),第3个cache line为20次，<br>3个line一共才41次，你不妨仔细模拟一下。  </p>
<p>所以进行错位能降低CACHE的交互次数，从而提高CPU处理速度能力。  </p>
<p>这个错位(也就是上面的16个字节)就是colouroff.</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;slab简介&quot;&gt;&lt;a href=&quot;#slab简介&quot; class=&quot;headerlink&quot; title=&quot;slab简介&quot;&gt;&lt;/a&gt;slab简介&lt;/h4&gt;&lt;p&gt;slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的冷热页机制概述</title>
    <link href="http://vinoit.me/2016/06/28/linux-cold-hot-page/"/>
    <id>http://vinoit.me/2016/06/28/linux-cold-hot-page/</id>
    <published>2016-06-28T11:01:36.000Z</published>
    <updated>2016-08-13T12:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是冷热页？"><a href="#什么是冷热页？" class="headerlink" title="什么是冷热页？"></a>什么是冷热页？</h4><p>在Linux Kernel的物理内存管理的<a href="/2016/06/28/linux-buddy-system/">Buddy System</a>中，引入了冷热页的概念。冷页表示该空闲页已经不再高速缓存中了(一般是指L2 Cache)，热页表示该空闲页仍然在高速缓存中。冷热页是针对于每CPU的，每个zone中，都会针对于所有的CPU初始化一个冷热页的per-cpu-pageset.</p>
<h4 id="为什么要有冷热页？"><a href="#为什么要有冷热页？" class="headerlink" title="为什么要有冷热页？"></a>为什么要有冷热页？</h4><p>作用有3点：</p>
<ul>
<li><p>Buddy Allocator在分配order为0的空闲页的时候，如果分配一个热页，那么由于该页已经存在于L2 Cache中了。CPU写访问的时候，不需要先把内存中的内容读到Cache中，然后再写。如果分配一个冷页，说明该页不在L2 Cache中。一般情况下，尽可能用热页，是容易理解的。什么时候用冷页呢？While allocating a physical page frame, there is a bit specifying whether we would like a hot or a cold page (that is, a page likely to be in the CPU cache, or a page not likely to be there). If the page will be used by the CPU, a hot page will be faster. If the page will be used for device <code>DMA</code> the CPU cache would be invalidated anyway, and a cold page does not waste precious cache contents.<br>简单翻译一下：当内核分配<code>一个</code>物理页框时，有一些规范来约束我们是分配热页还是冷页。当页框是CPU使用的，则分配热页。当页框是DMA设备使用的，则分配冷页。因为DMA设备不会用到CPU高速缓存，所以没必要使用热页。</p>
</li>
<li><p>Buddy System在给某个进程分配某个zone中空闲页的时候，首先需要用自旋锁锁住该zone,然后分配页。这样，如果多个CPU上的进程同时进行分配页，便会竞争。引入了per-cpu-set后，当多个CPU上的进程同时分配页的时候，竞争便不会发生，提高了效率。另外当释放单个页面时，空闲页面首先放回到per-cpu-pageset中，以减少zone中自旋锁的使用。当页面缓存中的页面数量超过阀值时，再将页面放回到伙伴系统中。</p>
</li>
<li><p>使用每CPU冷热页还有一个好处是，能保证某个页一直黏在1个CPU上，这有助于提高Cache的命中率。</p>
</li>
</ul>
<h4 id="冷热页的数据结构"><a href="#冷热页的数据结构" class="headerlink" title="冷热页的数据结构"></a>冷热页的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> per_cpu_pages &#123;</div><div class="line">        <span class="keyword">int</span> count;              <span class="comment">// number of pages in the list</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> high;               <span class="comment">// high watermark, emptying needed</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> batch;              <span class="comment">// chunk size for buddy add/remove</span></div><div class="line"></div><div class="line">         <span class="comment">// Lists of pages, one per migrate type stored on the pcp-lists</span></div><div class="line">         每个CPU在每个zone上都有MIGRATE_PCPTYPES个冷热页链表（根据迁移类型划分）</div><div class="line">         <span class="keyword">struct</span> list_head lists[MIGRATE_PCPTYPES];</div><div class="line"></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>在Linux中，对于UMA的架构，冷热页是在一条链表上进行管理。热页在前，冷页在后。CPU每释放一个order为0的页，如果per-cpu-pageset中的页数少于其指定的阈值，便会将释放的页插入到冷热页链表的开始处。这样，之前插入的热页便会随着其后热页源源不断的插入向后移动，其页由热变冷的几率便大大增加。</p>
<h4 id="怎样分配冷热页"><a href="#怎样分配冷热页" class="headerlink" title="怎样分配冷热页"></a>怎样分配冷热页</h4><p>在分配order为0页的时候(冷热页机制只处理单页分配的情况)，先找到合适的zone,然后根据需要的<code>migratetype</code>类型定位冷热页链表（每个zone，对于每个cpu,有3条冷热页链表，对应于：MIGRATE_UNMOVABLE、MIGRATE_RECLAIMABLE、MIGRATE_MOVABLE）。若需要热页，则从链表头取下一页（此页最“热”）；若需要冷页，则从链表尾取下一页（此页最“冷”）。</p>
<p>分配函数（关键部分已添加注释）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Really, prep_compound_page() should be called from __rmqueue_bulk().  But</div><div class="line"> * we cheat by calling it from here, in the order &gt; 0 path.  Saves a branch</div><div class="line"> * or two.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span></div><div class="line"><span class="keyword">struct</span> page *<span class="title">buffered_rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></div><div class="line">            <span class="keyword">struct</span> zone *zone, <span class="keyword">int</span> order, <span class="keyword">gfp_t</span> gfp_flags,</div><div class="line">            <span class="keyword">int</span> migratetype)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">    <span class="keyword">struct</span> page *page;</div><div class="line">    <span class="comment">//分配标志是__GFP_COLD才分配冷页</span></div><div class="line">    <span class="keyword">int</span> cold = !!(gfp_flags &amp; <span class="number">__</span>GFP_COLD);</div><div class="line"></div><div class="line">again:</div><div class="line">    <span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">struct</span> per_cpu_pages *pcp;</div><div class="line">        <span class="keyword">struct</span> list_head *<span class="built_in">list</span>;</div><div class="line"></div><div class="line">        local_irq_save(flags);</div><div class="line">        pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</div><div class="line">        <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</div><div class="line">        <span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</div><div class="line">          <span class="comment">//如果缺少页，则从Buddy System中分配。</span></div><div class="line">            pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</div><div class="line">                    pcp-&gt;batch, <span class="built_in">list</span>,</div><div class="line">                    migratetype, cold);</div><div class="line">            <span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</div><div class="line">                <span class="keyword">goto</span> failed;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cold)</div><div class="line">        <span class="comment">//分配冷页时，从链表尾部分配，list为链表头，list-&gt;prev表示链表尾</span></div><div class="line">            page = list_entry(<span class="built_in">list</span>-&gt;prev, <span class="keyword">struct</span> page, lru);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="comment">//分配热页时，从链表头分配</span></div><div class="line">            page = list_entry(<span class="built_in">list</span>-&gt;next, <span class="keyword">struct</span> page, lru);</div><div class="line">       <span class="comment">//分配完一个页框后从冷热页链表中删去该页</span></div><div class="line">        list_del(&amp;page-&gt;lru);</div><div class="line">        pcp-&gt;count--;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果order!=0(页框数&gt;1)，则不从冷热页链表中分配</span></div><div class="line">        <span class="keyword">if</span> (unlikely(gfp_flags &amp; <span class="number">__</span>GFP_NOFAIL)) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * __GFP_NOFAIL is not to be used in new code.</div><div class="line">             *</div><div class="line">             * All __GFP_NOFAIL callers should be fixed so that they</div><div class="line">             * properly detect and handle allocation failures.</div><div class="line">             *</div><div class="line">             * We most definitely don't want callers attempting to</div><div class="line">             * allocate greater than order-1 page units with</div><div class="line">             * __GFP_NOFAIL.</div><div class="line">             */</div><div class="line">            WARN_ON_ONCE(order &gt; <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        spin_lock_irqsave(&amp;zone-&gt;lock, flags);</div><div class="line">        page = <span class="number">__</span>rmqueue(zone, order, migratetype);</div><div class="line">        spin_unlock(&amp;zone-&gt;lock);</div><div class="line">        <span class="keyword">if</span> (!page)</div><div class="line">            <span class="keyword">goto</span> failed;</div><div class="line">        <span class="number">__</span>mod_zone_page_state(zone, NR_FREE_PAGES, -(<span class="number">1</span> &lt;&lt; order));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="number">__</span>count_zone_vm_events(PGALLOC, zone, <span class="number">1</span> &lt;&lt; order);</div><div class="line">    zone_statistics(preferred_zone, zone, gfp_flags);</div><div class="line">    local_irq_restore(flags);</div><div class="line"></div><div class="line">    VM_BUG_ON(bad_range(zone, page));</div><div class="line">    <span class="keyword">if</span> (prep_new_page(page, order, gfp_flags))</div><div class="line">        <span class="keyword">goto</span> again;</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line"></div><div class="line">failed:</div><div class="line">    local_irq_restore(flags);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linuxarm-%E4%B8%AD%E7%9A%84%E5%86%B7%E7%83%AD%E9%A1%B5/" target="_blank" rel="external">认识Linux/ARM 中的冷热页</a></li>
<li>Linux源码</li>
</ul>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是冷热页？&quot;&gt;&lt;a href=&quot;#什么是冷热页？&quot; class=&quot;headerlink&quot; title=&quot;什么是冷热页？&quot;&gt;&lt;/a&gt;什么是冷热页？&lt;/h4&gt;&lt;p&gt;在Linux Kernel的物理内存管理的&lt;a href=&quot;/2016/06/28/linux-bu
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的Buddy System</title>
    <link href="http://vinoit.me/2016/06/28/linux-buddy-system/"/>
    <id>http://vinoit.me/2016/06/28/linux-buddy-system/</id>
    <published>2016-06-28T02:49:31.000Z</published>
    <updated>2016-08-13T12:27:01.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Buddy-System"><a href="#什么是Buddy-System" class="headerlink" title="什么是Buddy System?"></a>什么是Buddy System?</h4><p>Buddy System是Linux Kernel 进行物理内存页管理的一个子系统。在Buddy System中，管理的一个基本单位是block，每一个block有若干个连续的物理页组成，物理页的个数为2^n，这个n在buddy system中被称为order。<code>相同order的block，挂载一条双向链表上。</code>当某个block空闲时，只要发现对应的伙伴也是空闲的，就和伙伴组成一个页数为2^（n+1）的block，挂载在order为(n+1)的双向链表上，换句话说一个页数为2^n的block，是由两个页数为2^（n-1）的伙伴block组成的。因此，一个block的伙伴肯定是和这个block在 <strong>物理地址上是连续</strong> 的。在Linux中，order的默认的取值范围是[0,10]。</p>
<p>linux中用<code>struct zone</code>来描述一个内存管理区(<em>ZONE_DMA:0~16MB  ZONE_NORMAL:16MB~896MB  ZONE_HIGHMEM:896MB~end</em>)<br>其中的struct free_area中的<code>每一个元素</code>表示的是由相同order的block构成的<code>双向链表</code>。free_area[i]表示该free_area处的链表的order为i。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> zone &#123;  </div><div class="line">    ...  </div><div class="line">         ...      </div><div class="line">    <span class="keyword">struct</span> free_area    free_area[MAX_ORDER];  </div><div class="line">    ...  </div><div class="line">    ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> free_area &#123;  </div><div class="line">  <span class="comment">//每个free_area内有MIGRATE_TYPES个双向链表，根据迁移类型划分()*迁移类型请查看文末*）。</span></div><div class="line">  <span class="comment">//free_list和struct page中的lru相连</span></div><div class="line">    <span class="keyword">struct</span> list_head    free_list[MIGRATE_TYPES];  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_free;  <span class="comment">//空闲块数量</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在buddy system中，存入一个页会进行一次伙伴整合的迭代操作，直到不能再合并为止。那么，如何查找某个block的伙伴呢？在Linux中，一个block的伙伴信息记录在该block的<code>第一个物理页</code>的<code>struct page</code>上。也就是说，假若一个页在伙伴系统中，page-&gt;private的值为n,则后面连续的2^(n-1)个页面就在buddy system中。一个页面在buddy System中，就代表了该页是空闲的，可以被分配。</p>
<h4 id="查找伙伴"><a href="#查找伙伴" class="headerlink" title="查找伙伴"></a>查找伙伴</h4><p>内核代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mm/page_alloc.c</div><div class="line">		buddy_idx = <span class="number">__f</span>ind_buddy_index(page_idx, order);</div><div class="line">		buddy = page + (buddy_idx - page_idx);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></div><div class="line"><span class="number">__f</span>ind_buddy_index(<span class="keyword">unsigned</span> <span class="keyword">long</span> page_idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> page_idx ^ (<span class="number">1</span> &lt;&lt; order);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找一个页数为2^n的block的伙伴计算方法是buddy_index=page_index^(1&lt;&lt;n)(此处的^表示异或)，buddy_index 表示伙伴块首页的页索引，page_index是该block首页的页索引，n代表order。</p>
<p>举例：<br><img src="/images/linux/linux-buddy-system-2.png" alt=""></p>
<p><img src="/images/linux/linux-buddy-system-3.png" alt=""></p>
<h4 id="从buddy-System中分配页"><a href="#从buddy-System中分配页" class="headerlink" title="从buddy System中分配页"></a>从buddy System中分配页</h4><p>buddy System用来管理空闲的物理内存，接受进程的内存页申请。Linux提供给用户进程申请内存的接口函数中包含两个参数：一个是<code>GFP_***</code>，另一个是<code>order</code>。前者表示分配标志信息，从标志中可以知道进程要从哪个zone中申请物理内存，并在内存紧缺的情况下指导内存何时回收内存；后者表示需要分配2^order个连续的物理页。<br>buddy system根据参数order，在要求的zone中查找对应的链表。若该order的双向链表非空，则把该双向链表上的第一个block从buddy system中脱链，同时更新该双向链表上的block的数量，完成内存分配。若该order的双向链表为空，则查找order+1的双向链表，如果order+1的双向链表为空，则查找order+2的双向链表，直到查找到。假设查找到了第n个双向链表(n&gt;order)，由于查找到的连续物理内存页的数量大于order，因此将该block一分为二，将后半部分block挂载到2^(n-1)的双向链表上，将前半部分再一分为二，将前半部分的后半部分挂载到2^(n-2)的双向链表上，将前半部分的前半部分再一分为二。。。直到与请求的order相等为止。</p>
<h4 id="释放页到buddy-System"><a href="#释放页到buddy-System" class="headerlink" title="释放页到buddy System"></a>释放页到buddy System</h4><p>当非空闲的页被进程释放后，需要把页放回到伙伴系统中。由于block是作为一个整体被申请的，因此其释放也是以block为单位。若该block有2^n个连续的物理页，在释放的时候，根据buddy_index = page_index^(1&lt;&lt;n)查找该block的order为n的伙伴。若查找到伙伴，则将两个order为n的block合并为一个order为n+1的block。同时再查找order为n+1 block的伙伴，若找到则两个order为n+1的block继续合并…直到其不能合并为止，插入到最终order的双向链表的最前端。释放的迭代过程是分配页的逆过程.</p>
<h4 id="linux中的迁移类型"><a href="#linux中的迁移类型" class="headerlink" title="linux中的迁移类型"></a>linux中的迁移类型</h4><p>在2.6.24之前的内核版本中，free_area结构中只有一个free_list数组，而从2.6.24开始，free_area结构中存有MIGRATE_TYPES个free_list,这些数组是根据页框的移动性来划分的，为什么要进行这样的划分呢?实际上也是为了减少碎片而提出的，我们考虑下面的情况：</p>
<p><img src="/images/linux/linux-buddy-system-0.png" alt=""><br>图中一共有32个页，只分配出了4个页框，但是能够分配的最大连续内存也只有8个页框(因为伙伴系统分配出去的内存必须是2的整数次幂个页框)，内核解决这种问题的办法就是将不同类型的页进行分组。分配出去的页面可分为三种类型：</p>
<ul>
<li>不可移动页(Non-movable pages)：这类页在内存当中有固定的位置，不能移动。内核的核心分配的内存大多属于这种类型</li>
<li>可回收页(Reclaimable pages)：这类页不能直接移动，但可以删除，其内容页可以从其他地方重新生成，例如，映射自文件的数据属于这种类型，针对这种页，内核有专门的页面回收处理</li>
<li>可移动页:这类页可以随意移动，用户空间应用程序所用到的页属于该类别。它们通过页表来映射，如果他们复制到新的位置，页表项也会相应的更新，应用程序不会注意到任何改变。</li>
</ul>
<p>假如上图中大部分页都是可移动页，而分配出去的四个页都是不可移动页，由于不可移动页插在了其他类型页的中间，就导致了无法从原本空闲的连续内存区中分配较大的内存块。考虑下图的情况:<br><img src="/images/linux/linux-buddy-system-1.png" alt=""></p>
<p>将可回收页和不可移动页分开，这样虽然在不可移动页的区域当中无法分配大块的连续内存，但是可回收页的区域却没有受其影响，可以分配大块的连续内存。</p>
<p><code>内核对于迁移类型的定义如下:</code></p>
<mmzone.h>

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_UNMOVABLE     0  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_RECLAIMABLE   1  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_MOVABLE       2  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_PCPTYPES      3 <span class="comment">/* the number of types on the pcp lists */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_RESERVE       3  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_ISOLATE       4 <span class="comment">/* can't allocate from here */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_TYPES         5</span></div></pre></td></tr></table></figure>
<p>前三种类型已经介绍过</p>
<p><code>MIGRATE_PCPTYPES</code>是per_cpu_pageset，即用来表示每CPU页框高速缓存的数据结构中的链表的迁移类型数目</p>
<p><code>MIGRATE_RESERVE</code>是在前三种的列表中都没用可满足分配的内存块时，就可以从MIGRATE_RESERVE分配</p>
<p><code>MIGRATE_ISOLATE</code>用于跨越NUMA节点移动物理内存页，在大型系统上，它有益于将物理内存页移动到接近于是用该页最频繁地CPU</p>
<p><code>MIGRATE_TYPES</code>表示迁移类型的数目<br>当一个指定的迁移类型所对应的链表中没有空闲块时，将会按以下定义的顺序到其他迁移类型的链表中寻找</p>
<p>参考：</p>
<ul>
<li><a href="http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/" target="_blank" rel="external">认识Linux物理内存管理系统–Buddy System</a></li>
<li><a href="http://blog.csdn.net/vanbreaker/article/details/7605367" target="_blank" rel="external">Linux伙伴系统(一)–伙伴系统的概述</a></li>
<li><a href="http://rick_stone.leanote.com/post/%E5%86%85%E5%AD%98%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%9F%A5%E6%89%BE%E4%BC%99%E4%BC%B4" target="_blank" rel="external">内存伙伴系统之查找伙伴算法</a></li>
</ul>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

</mmzone.h>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是Buddy-System&quot;&gt;&lt;a href=&quot;#什么是Buddy-System&quot; class=&quot;headerlink&quot; title=&quot;什么是Buddy System?&quot;&gt;&lt;/a&gt;什么是Buddy System?&lt;/h4&gt;&lt;p&gt;Buddy System是Lin
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内存管理" scheme="http://vinoit.me/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>当···时发生了什么？</title>
    <link href="http://vinoit.me/2016/06/13/what-happens-when/"/>
    <id>http://vinoit.me/2016/06/13/what-happens-when/</id>
    <published>2016-06-13T03:23:25.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>当你在浏览器中输入 google.com 并且按下回车之后发生了什么？</strong></p>
<h4 id="按下”g”键"><a href="#按下”g”键" class="headerlink" title="按下”g”键"></a>按下”g”键</h4><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 <code>&quot;google.com&quot;</code>，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 <code>&quot;google.com&quot;</code> 建议给你。</p>
<h4 id="回车键按下"><a href="#回车键按下" class="headerlink" title="回车键按下"></a>回车键按下</h4><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>
<h5 id="USB键盘："><a href="#USB键盘：" class="headerlink" title="USB键盘："></a>USB键盘：</h5><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压<br>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内<br>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供<br>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包<br>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）<br>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p>
<h5 id="虚拟键盘（触屏设备）："><a href="#虚拟键盘（触屏设备）：" class="headerlink" title="虚拟键盘（触屏设备）："></a>虚拟键盘（触屏设备）：</h5><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标<br>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮<br>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息<br>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p>
<h4 id="产生中断-非USB键盘"><a href="#产生中断-非USB键盘" class="headerlink" title="产生中断[非USB键盘]"></a>产生中断[非USB键盘]</h4><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>
<h4 id="Windows-一个-WM-KEYDOWN-消息被发往应用程序"><a href="#Windows-一个-WM-KEYDOWN-消息被发往应用程序" class="headerlink" title="(Windows)一个 WM_KEYDOWN 消息被发往应用程序"></a>(Windows)一个 WM_KEYDOWN 消息被发往应用程序</h4><p>HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>
<p>Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>
<p>Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p>
<p>当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p>
<h4 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 KeyDown NSEvent被发往应用程序</h4><p>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p>
<h4 id="GNU-Linux-Xorg-服务器监听键码值"><a href="#GNU-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU/Linux)Xorg 服务器监听键码值"></a>(GNU/Linux)Xorg 服务器监听键码值</h4><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>
<h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>浏览器通过 URL 能够知道下面的信息：</p>
<blockquote>
<ul>
<li>Protocol “http”<br>使用HTTP协议</li>
<li>Resource “/“<br>请求的资源是主页(index)</li>
</ul>
</blockquote>
<h4 id="输入的是-URL-还是搜索的关键字？"><a href="#输入的是-URL-还是搜索的关键字？" class="headerlink" title="输入的是 URL 还是搜索的关键字？"></a>输入的是 URL 还是搜索的关键字？</h4><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>
<h4 id="检查-HSTS-列表···"><a href="#检查-HSTS-列表···" class="headerlink" title="检查 HSTS 列表···"></a>检查 HSTS 列表···</h4><p>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站<br>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</p>
<h4 id="转换非-ASCII-的-Unicode-字符"><a href="#转换非-ASCII-的-Unicode-字符" class="headerlink" title="转换非 ASCII 的 Unicode 字符"></a>转换非 ASCII 的 Unicode 字符</h4><p>浏览器检查输入是否含有不是 <code>a-z， A-Z，0-9， -</code> 或者 <code>.</code> 的字符<br>这里主机名是 <code>google.com</code>，所以没有非ASCII的字符，如果有的话，浏览器会对主机名部分使用 Punycode 编码</p>
<h4 id="DNS-查询···"><a href="#DNS-查询···" class="headerlink" title="DNS 查询···"></a>DNS 查询···</h4><ul>
<li>浏览器检查域名是否在缓存当中</li>
<li>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询</li>
<li><code>gethostbyname</code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同</li>
<li>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li>
<li>查询本地 DNS 服务器</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li>
</ul>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>要想发送 ARP 广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>
<ul>
<li><p>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC<br>如果缓存没有命中：</p>
</li>
<li><p>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</p>
</li>
<li>查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层 ARP 请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ARP Request:</div><div class="line"></div><div class="line">Sender MAC: interface:mac:address:here</div><div class="line">Sender IP: interface.ip.goes.here</div><div class="line">Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)</div><div class="line">Target IP: target.ip.goes.here</div></pre></td></tr></table></figure>
<p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<p>直连：</p>
<ul>
<li><p>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。<br>集线器：</p>
</li>
<li><p>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。<br>交换机：</p>
</li>
<li><p>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</p>
</li>
<li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li>
<li>如果路由器也“连接”在其中，它会返回一个 ARP Reply</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ARP Reply:</div><div class="line"></div><div class="line">Sender MAC: target:mac:address:here</div><div class="line">Sender IP: target.ip.goes.here</div><div class="line">Target MAC: interface:mac:address:here</div><div class="line">Target IP: interface.ip.goes.here</div></pre></td></tr></table></figure>
<p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>
<ul>
<li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li>
<li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li>
</ul>
<h4 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h4><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET 和 SOCK_STREAM 。</p>
<ul>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。</li>
<li><p>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。<br>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>
</li>
<li><p>以太网</p>
</li>
<li>WiFi</li>
<li>蜂窝数据网络<br>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。</li>
</ul>
<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>
<ul>
<li><p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</p>
</li>
<li><p><em>服务器端接收到 SYN 包，如果它可以建立连接：</em></p>
<ul>
<li>服务器端选择它自己的初始序列号</li>
<li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li>
<li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li>
</ul>
</li>
<li><em>客户端通过发送下面一个封包来确认这次连接：</em><ul>
<li>自己的序列号+1</li>
<li>接收端 ACK+1</li>
<li>设置 ACK 位</li>
</ul>
</li>
<li><em>数据通过下面的方式传输：</em><ul>
<li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li>
<li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li>
</ul>
</li>
<li><em>关闭连接时：</em><ul>
<li>要关闭连接的一方发送一个 FIN 包</li>
<li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li>
<li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li>
</ul>
</li>
</ul>
<h4 id="UDP-数据包"><a href="#UDP-数据包" class="headerlink" title="UDP 数据包"></a>UDP 数据包</h4><h4 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h4><ul>
<li>客户端发送一个 <code>Client hello</code> 消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。</li>
<li>服务器端向客户端返回一个 <code>Server hello</code> 消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li>
<li>客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li>
<li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li>
<li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li>
<li>服务器端生成自己的 <code>hash</code> 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li>
<li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li>
</ul>
<h4 id="TCP-数据包"><a href="#TCP-数据包" class="headerlink" title="TCP 数据包"></a>TCP 数据包</h4><h4 id="HTTP-协议···"><a href="#HTTP-协议···" class="headerlink" title="HTTP 协议···"></a>HTTP 协议···</h4><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>
<p>如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求:</p>
<p><code>GET / HTTP/1.1
Host: google.com
[其他头部]</code></p>
<p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合<code>HTTP</code>协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反<code>HTTP</code>协议标准的bug，同时浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 GET 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。</p>
<p>HTTP/1.1 定义了“关闭连接”的选项 <code>&quot;close&quot;</code>，发送者使用这个选项指示这次连接在响应结束之后会断开:</p>
<p><code>Connection:close</code><br>不支持持久连接的<code>HTTP/1.1</code> 必须在每条消息中都包含 <code>&quot;close&quot;</code> 选项。</p>
<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>
<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>
<p><code>200 OK
[响应头部]</code></p>
<p>然后是一个换行，接下来有效载荷(payload)，也就是<code>www.google.com</code>的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。</p>
<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>
<p><code>304 Not Modified
[响应头部]</code></p>
<p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>
<p>在解析完 HTM L之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code>会变成 <code>GET /$(相对www.google.com的URL) HTTP/1.1</code>。</p>
<p>如果HTML引入了 <code>www.google.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code>头部会变成另外的域名。</p>
<h4 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h4><p>HTTPD(HTTP Daemon)在服务器端处理请求/相应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li><p>HTTPD 接收请求</p>
</li>
<li><p><em>服务器把请求拆分为以下几个参数：</em></p>
<ul>
<li>HTTP 请求方法(GET, POST, HEAD, PUT 和 DELETE)。在访问 Google 这种情况下，使用的是 GET 方法</li>
<li>域名：google.com</li>
<li>请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</li>
</ul>
</li>
<li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p>
</li>
<li><p>服务器验证 google.com 接受 GET 方法</p>
</li>
<li><p>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p>
</li>
<li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p>
</li>
<li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p>
</li>
<li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</p>
</li>
</ul>
<h4 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h4><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>
<ul>
<li>解析 HTML，CSS，JS</li>
<li>渲染——构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li>
</ul>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>
<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>
<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>
<ul>
<li>一个地址栏</li>
<li>后退和前进按钮</li>
<li>书签选项</li>
<li>刷新和停止按钮</li>
<li>主页按钮</li>
</ul>
<h5 id="浏览器高层架构"><a href="#浏览器高层架构" class="headerlink" title="浏览器高层架构"></a>浏览器高层架构</h5><p>组成浏览器的组件有：</p>
<ul>
<li>用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li>
<li>浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作</li>
<li>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li>
<li>网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li>
<li>UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li>
<li>Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码</li>
<li>数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li>
</ul>
<h4 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h4><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>
<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>
<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>
<h5 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h5><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>
<ul>
<li>语言本身的“宽容”特性</li>
<li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li>
<li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li>
</ul>
<p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
<h5 id="解析结束之后"><a href="#解析结束之后" class="headerlink" title="解析结束之后"></a>解析结束之后</h5><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>
<p>此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。</p>
<p>注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。</p>
<p>执行同步 Javascript 代码。</p>
<h4 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h4><p>根据 CSS词法和句法 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容<br>每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象<br>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</p>
<h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><ul>
<li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li>
<li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度</li>
<li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li>
<li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li>
<li>使用上面的计算结果构建每个节点的坐标</li>
<li>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code>或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/" target="_blank" rel="external">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work" target="_blank" rel="external">http://www.w3.org/Style/CSS/current-work</a></li>
<li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li>
<li>页面上的每个层都被分配了纹理(?)</li>
<li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制</li>
<li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li>
<li>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li>
</ul>
<h4 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h4><ul>
<li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li>
<li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li>
</ul>
<h4 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h4><p><strong>后期渲染与用户引发的处理</strong></p>
<p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<p><strong>原文地址：<a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">https://github.com/skyline75489/what-happens-when-zh_CN</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;当你在浏览器中输入 google.com 并且按下回车之后发生了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;按下”g”键&quot;&gt;&lt;a href=&quot;#按下”g”键&quot; class=&quot;headerlink&quot; title=&quot;按下”g”键&quot;&gt;&lt;/a&gt;按下”g”键&lt;/
    
    </summary>
    
      <category term="理解计算机" scheme="http://vinoit.me/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理解计算机" scheme="http://vinoit.me/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM中class文件结构--实例讲解</title>
    <link href="http://vinoit.me/2016/05/23/java-classfile-structure-example/"/>
    <id>http://vinoit.me/2016/05/23/java-classfile-structure-example/</id>
    <published>2016-05-23T05:25:43.000Z</published>
    <updated>2016-08-13T12:30:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过一个简单的例子来讲解class文件结构,<strong>某些具体结构概念和信息需结合我之前的两篇博文<a href="/2016/05/22/java-classfile-structure-concept/">《理解JVM中class文件结构–概念部分》</a>，<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a></strong>，建议可以通过上面的两篇博文先了解这方面的一些知识再看本文。<br>java代码（jdk7）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> testInt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        testInt = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应class文件(十六进制)：<br><img src="/images/jvm/java-classfile-structure-example-0.PNG" alt=""><br>接下来的顺序和class文件结构顺序一致</p>
<h4 id="u4-magic"><a href="#u4-magic" class="headerlink" title="u4 magic;"></a><code>u4 magic;</code></h4><p>文件位置<code>0x0-0x3</code>为魔数 CA FE BA BE ,固定不变。</p>
<h4 id="u2-minor-version"><a href="#u2-minor-version" class="headerlink" title="u2 minor_version;"></a><code>u2 minor_version;</code></h4><p>文件位置<code>0x4-0x5</code>为副版本号，值为0x0000。</p>
<h4 id="u2-major-version"><a href="#u2-major-version" class="headerlink" title="u2 major_version;"></a><code>u2 major_version;</code></h4><p>文件位置<code>0x6-0x7</code>为主版本号，值为0x0033。</p>
<h4 id="u2-constant-pool-count"><a href="#u2-constant-pool-count" class="headerlink" title="u2 constant_pool_count;"></a><code>u2 constant_pool_count;</code></h4><p>文件位置<code>0x8-0x9</code>为常量池计数器，值为0x0015，十进制为21。</p>
<h4 id="反编译后的常量池信息"><a href="#反编译后的常量池信息" class="headerlink" title="反编译后的常量池信息"></a>反编译后的常量池信息</h4><p>此时通过<code>javap -v</code> 命令反编译class文件，查看常量池信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #4.#17         //  java/lang/Object."&lt;init&gt;":()V</div><div class="line">   #2 = Fieldref           #3.#18         //  pac1/TestClass.testInt:I</div><div class="line">   #3 = Class              #19            //  pac1/TestClass</div><div class="line">   #4 = Class              #20            //  java/lang/Object</div><div class="line">   #5 = Utf8               testInt</div><div class="line">   #6 = Utf8               I</div><div class="line">   #7 = Utf8               &lt;init&gt;</div><div class="line">   #8 = Utf8               ()V</div><div class="line">   #9 = Utf8               Code</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               LocalVariableTable</div><div class="line">  #12 = Utf8               this</div><div class="line">  #13 = Utf8               Lpac1/TestClass;</div><div class="line">  #14 = Utf8               test</div><div class="line">  #15 = Utf8               SourceFile</div><div class="line">  #16 = Utf8               TestClass.java</div><div class="line">  #17 = NameAndType        #7:#8          //  "&lt;init&gt;":()V</div><div class="line">  #18 = NameAndType        #5:#6          //  testInt:I</div><div class="line">  #19 = Utf8               pac1/TestClass</div><div class="line">  #20 = Utf8               java/lang/Object</div></pre></td></tr></table></figure></p>
<p>常量池中一共有20项，这也证明了<code>u2 constant_pool_count</code>的值为常量池项目数+1。<br>在class文件中各项之间<code>没有任何填充</code>或<code>对齐</code>作为各项间的分隔符号，紧接着的便是常量池项。</p>
<h4 id="cp-info-constant-pool-constant-pool-count-1"><a href="#cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="cp_info constant_pool[constant_pool_count-1];"></a><code>cp_info constant_pool[constant_pool_count-1];</code></h4><h5 id="常量池项1"><a href="#常量池项1" class="headerlink" title="常量池项1"></a>常量池项1</h5><p><strong>通过常量池项1来学习常量池</strong></p>
<p>通过常量池项的通用格式可知，文件位置<code>0x10</code>为常量池项的tagbyte,值为0x0A,查看常量池的 tag 项说明可知常量池项1类型为CONSTANT_Methodref。</p>
<p>接着通过查看CONSTANT_Methodref_info 结构具体信息，文件位置<code>0x11-0x12</code>为CONSTANT_Methodref的class_index,为常量池项中某一项的索引，类型必须是CONSTANT_Class。值为0x0004,指向常量池项4，通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_Class类型的。</p>
<p>文件位置<code>0x13-0x14</code>为CONSTANT_Methodref的name_and_type_index，同样指向常量池中的一项，类型必须是CONSTANT_NameAndType。值为0x0011,指向常量池项17，通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_NameAndType类型的。</p>
<p><strong>在这里把和常量池项1有关的所有常量池项（1-&gt; 4,17 -&gt; 20,7,8）都讲一下</strong></p>
<h6 id="常量池项4"><a href="#常量池项4" class="headerlink" title="常量池项4"></a>常量池项4</h6><p>常量池项4在文件的开始位置是<code>0x17</code>，属于常量池项4的tagbyte,值为0x07,是CONSTANT_Class类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_Class_info 结构具体信息，文件位置<code>0x18-0x19</code>为CONSTANT_Class的 name_index，指向常量池中的某一项，类型必须是CONSTANT_Utf8，表示字符串常量的值。值为0x0014,指向常量池项20，通过查看上面反编译后的常量池信息，可以看到常量池项20是CONSTANT_Utf8类型的。</p>
<h6 id="常量池项20"><a href="#常量池项20" class="headerlink" title="常量池项20"></a>常量池项20</h6><p>常量池项20在文件的开始位置是<code>0xbf</code>,属于常量池项20的tagbyte,值为0x01,是CONSTANT_Utf8类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_Utf8_info 结构具体信息，文件位置<code>0xc0-0xc1</code>为CONSTANT_Utf8的length，表示字符串常量的长度，值为0x0010,长度为16个字节。</p>
<p>文件位置<code>0xc2-0xd1</code>为具体内容，通过ascii码转换之后的值便是<code>java/lang/Object</code>,和反编译后的常量池信息一致。</p>
<h6 id="常量池项17"><a href="#常量池项17" class="headerlink" title="常量池项17"></a>常量池项17</h6><p>常量池项17在文件的开始位置是<code>0xa4</code>,属于常量池项17的tagbyte,值为0x0c,是CONSTANT_NameAndType类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_NameAndType_info 结构具体信息，文件位置<code>0xa5-0xa6</code>为CONSTANT_NameAndType的name_index，指向常量池项的某一项，类型必须为CONSTANT_Utf8，表示字符串常量的值。值为0x0007,指向常量池项7。通过查看上面反编译后的常量池信息，可以看到常量池项7是CONSTANT_Utf8类型的。</p>
<p>文件位置<code>0xa7-0xa8</code>为CONSTANT_NameAndType的descriptor_index，指向常量池项的某一项，类型必须为CONSTANT_Utf8，表示字符串常量的值。此字符串为方法描述符，具体可参考《JVM规范》。此处的值为0x0008,指向常量池项8。通过查看上面反编译后的常量池信息，可以看到常量池项8是CONSTANT_Utf8类型的。</p>
<h6 id="常量池项7和8"><a href="#常量池项7和8" class="headerlink" title="常量池项7和8"></a>常量池项7和8</h6><p>常量池项7和8均为CONSTANT_Utf8类型的,分析方法和常量池项20一样。</p>
<h6 id="常量池项1总结"><a href="#常量池项1总结" class="headerlink" title="常量池项1总结"></a>常量池项1总结</h6><p>常量池项1是CONSTANT_Methodref类型，表示一个方法的应用。通过查看上面反编译后的常量池信息，可以发现此方法为java/lang/Object.”<init>“:()V，但其中涉及到对其他多个常量池项的引用。一个方法是由类名和方法名决定的，所以分别引用了CONSTANT_Class和CONSTANT_NameAndType，其中CONSTANT_NameAndType表示一个方法名。然后CONSTANT_Class和CONSTANT_NameAndType又分别需要字符串信息来描述，所以又引用了CONSTANT_Utf8类型的项。</init></p>
<p><strong>其他常量池项可以按照这个方式来分析。</strong></p>
<h4 id="u2-access-flags"><a href="#u2-access-flags" class="headerlink" title="u2 access_flags"></a><code>u2 access_flags</code></h4><p>文件位置<code>0xd2-0xd3</code>表示的是access_flags，值为0x0021,通过查看access_flags的取值范围和相应含义表，得知该值的含义是ACC_PUBLIC（可以被包的类外访问。）和ACC_SUPER（当用到 invokespecial 指令时，需要特殊处理的父类方法。）和反编译之后的文件中的<code>flags: ACC_PUBLIC, ACC_SUPER</code>一致。其中invokespecial指令调用了<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>。</p>
<h4 id="u2-this-class"><a href="#u2-this-class" class="headerlink" title="u2 this_class"></a><code>u2 this_class</code></h4><p>文件位置<code>0xd4-0xd5</code>表示的是u2 this_class，为本类的引用，指向常量池中的某一项，类型必须为CONSTANT_Class。值为0x0003,表示指向常量池项3。通过查看上面反编译后的常量池信息，可以看到常量池项3是CONSTANT_Class类型的,最终值为pac1/TestClass。</p>
<h4 id="u2-super-class"><a href="#u2-super-class" class="headerlink" title="u2 super_class"></a><code>u2 super_class</code></h4><p>文件位置<code>0xd6-0xd7</code>表示的是u2 super_class，为父类的引用，指向常量池中的某一项，类型必须为CONSTANT_Class。值为0x0004,表示指向常量池项4。通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_Class类型的,最终值为java/lang/Object,Object是所有类的父类。</p>
<h4 id="u2-interfaces-count"><a href="#u2-interfaces-count" class="headerlink" title="u2 interfaces_count"></a><code>u2 interfaces_count</code></h4><p>文件位置<code>0xd8-0xd9</code>表示的是u2 interfaces_count，为接口计数器。值为0x0000,表示没有实现任何接口。所以接下来便不会有<code>u2 interfaces[interfaces_count]</code>（接口表）的字节信息。</p>
<h4 id="u2-fields-count"><a href="#u2-fields-count" class="headerlink" title="u2 fields_count"></a><code>u2 fields_count</code></h4><p>文件位置<code>0xda-0xdb</code>表示的是u2 fields_count，为字段计数器。值为0x0001,表示有一个字段。</p>
<h4 id="field-info-fields-fields-count"><a href="#field-info-fields-fields-count" class="headerlink" title="field_info fields[fields_count]"></a><code>field_info fields[fields_count]</code></h4><p>接下来便是表示字段信息的字节，文件位置<code>0xdc-0xdd</code>表示的是字段的access_flags，值为0x0000。查看字段 access_flags 标记列表及其含义表后发现没有含义是用0x0000表示的。因为源代码中字段前面没有任何修饰符，表示默认访问权限。access_flags 是一种掩码标志，0x0000表示没有一个是命中的。</p>
<p>文件位置<code>0xde-0xdf</code>表示的是字段信息的name_index,指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为字段名。值为0x0005,指向常量池项5，通过查看上面反编译后的常量池信息，可以看到常量池项5是CONSTANT_Utf8类型的,最终值为testInt，和源代码的字段名一致。</p>
<p>文件位置<code>0xe0-0xe1</code>表示的是字段信息的descriptor_index,指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为字段名。值为0x0006,指向常量池项6，通过查看上面反编译后的常量池信息，可以看到常量池项6是CONSTANT_Utf8类型的,最终值为I,表示int类型。更多基本类型字符解释可查看<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>中的字段基本类型字符解释表。</p>
<p>文件位置<code>0xe2-0xe3</code>表示的是字段信息的attributes_count，此处指为0。如果字段前面用了final或者字段被注解修饰等，则值便不为0，接下来便是各个属性的描述字节。具体属性信息可参看《JVM规范》。</p>
<h4 id="u2-methods-count"><a href="#u2-methods-count" class="headerlink" title="u2 methods_count"></a><code>u2 methods_count</code></h4><p>文件位置<code>0xe4-0xe5</code>表示的是u2 methods_count，为方法计数器。值为0x0002,表示有2个方法。</p>
<h4 id="method-info-methods-methods-count"><a href="#method-info-methods-methods-count" class="headerlink" title="method_info methods[methods_count]"></a><code>method_info methods[methods_count]</code></h4><p>文件位置<code>0xe6-0xe7</code>表示的是第一个方法的access_flags,值为0x0001,通过查看方法 access_flags 标记列表及其含义表可知，该方法为ACC_PUBLIC（public，方法可以从包外访问）。</p>
<p>文件位置<code>0xe8-0xe9</code>表示的是第一个方法的name_index，指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为方法名。值为0x0007,指向常量池项7，通过查看上面反编译后的常量池信息，可以看到常量池项7是CONSTANT_Utf8类型的,最终值为<code>&lt;init&gt;</code>。</p>
<p>文件位置<code>0xea-0xeb</code>表示的是第一个方法的descriptor_index，指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为方法名。值为0x0008,指向常量池项8，通过查看上面反编译后的常量池信息，可以看到常量池项8是CONSTANT_Utf8类型的,最终值为<code>()V</code>。</p>
<p>文件位置<code>0xec-0xed</code>表示的是第一个方法的attributes_count,为方法属性计数器。值为0x0001,表明有一个属性。</p>
<p>接下来的是表示属性信息的字节，<code>查看属性的通用格式后</code>，文件位置<code>0xee-0xef</code>表示的是第一个方法中属性信息的attribute_name_index，为属性名索引，指向常量池中的某一项，必须是CONSTANT_Utf8类型的。值为0x0009,指向常量池项9，通过查看上面反编译后的常量池信息，可以看到常量池项9是CONSTANT_Utf8类型的,最终值为<code>Code</code>。Code属性的属性名固定为“Code”。</p>
<p>文件位置<code>0xf0-0xf3</code>表示属性信息的attribute_length，值为0x0000002f,说明当前属性的长度为47，不包括开始的6个字节（attribute_name_index 和 attribute_length所占用的长度）。</p>
<p>文件位置<code>0xf4-0xf5</code>表示属性信息的max_stack，为操作数栈的最大深度值，jvm运行时根据该值分配栈帧。此处值为0x0001,说明此方法调用时分配的最大栈帧为1个字节。</p>
<p>文件位置<code>0xf6-0xf7</code>表示属性信息的max_locals，为局部变量表最大存储空间，单位是slot。此处值为0x0001,说明此方法局部变量的最大存储空间为1个字节。</p>
<p>文件位置<code>0xf8-0xfb</code>表示属性信息的code_length，为具体的字节码长度。此处值为0x00000005,说明此方法具体字节码长度为5个字节。接下来的5个字节的内容就是具体的字节码。</p>
<p><strong>剩下的一些属性信息可以按照这个方法，对照属性表来分析。</strong></p>
<h4 id="u2-attributes-count-amp-attribute-info-attributes-attributes-count"><a href="#u2-attributes-count-amp-attribute-info-attributes-attributes-count" class="headerlink" title="u2 attributes_count &amp; attribute_info attributes[attributes_count]"></a><code>u2 attributes_count</code> &amp; <code>attribute_info attributes[attributes_count]</code></h4><p>u2 attributes_count 和 attribute_info attributes[attributes_count] 和方法里的属性分析原理一样。</p>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过一个简单的例子来讲解class文件结构,&lt;strong&gt;某些具体结构概念和信息需结合我之前的两篇博文&lt;a href=&quot;/2016/05/22/java-classfile-structure-concept/&quot;&gt;《理解JVM中class文件结构–概念部分》&lt;/a&gt;，
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM中class文件结构--具体结构信息</title>
    <link href="http://vinoit.me/2016/05/22/java-classfile-structure-detail/"/>
    <id>http://vinoit.me/2016/05/22/java-classfile-structure-detail/</id>
    <published>2016-05-22T06:21:30.000Z</published>
    <updated>2016-08-13T12:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述的是class结构的具体信息，排版顺序按照class结构。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h5><p>所有的常量池项都具有如下通用格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cp_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u1 info[];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="常量池的-tag-项说明"><a href="#常量池的-tag-项说明" class="headerlink" title="常量池的 tag 项说明"></a>常量池的 tag 项说明</h5><table>
<thead>
<tr>
<th style="text-align:left">常量类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Class</td>
<td>7</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Fieldref</td>
<td>9</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Methodref</td>
<td>10</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InterfaceMethodref</td>
<td>11</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_String</td>
<td>8</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Integer</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Float</td>
<td>4</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Long</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Double</td>
<td>6</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_NameAndType</td>
<td>12</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Utf8</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodHandle</td>
<td>15</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodType</td>
<td>16</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InvokeDynamic</td>
<td>18</td>
</tr>
</tbody>
</table>
<h5 id="CONSTANT-Class-info-结构"><a href="#CONSTANT-Class-info-结构" class="headerlink" title="CONSTANT_Class_info 结构"></a>CONSTANT_Class_info 结构</h5><p>CONSTANT_Class_info 结构用于表示类或接口，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Class_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-Fieldref-info-结构"><a href="#CONSTANT-Fieldref-info-结构" class="headerlink" title="CONSTANT_Fieldref_info 结构"></a>CONSTANT_Fieldref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Fieldref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Methodref-info-结构"><a href="#CONSTANT-Methodref-info-结构" class="headerlink" title="CONSTANT_Methodref_info 结构"></a>CONSTANT_Methodref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Methodref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-InterfaceMethodref-info-结构"><a href="#CONSTANT-InterfaceMethodref-info-结构" class="headerlink" title="CONSTANT_InterfaceMethodref_info 结构"></a>CONSTANT_InterfaceMethodref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_InterfaceMethodref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-String-info-结构"><a href="#CONSTANT-String-info-结构" class="headerlink" title="CONSTANT_String_info 结构"></a>CONSTANT_String_info 结构</h5><p>CONSTANT_String_info 用于表示 java.lang.String 类型的常量对象，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_String_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 string_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-Integer-info-结构"><a href="#CONSTANT-Integer-info-结构" class="headerlink" title="CONSTANT_Integer_info  结构"></a>CONSTANT_Integer_info  结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Integer_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Float-info-结构"><a href="#CONSTANT-Float-info-结构" class="headerlink" title="CONSTANT_Float_info 结构"></a>CONSTANT_Float_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Float_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Long-info-结构"><a href="#CONSTANT-Long-info-结构" class="headerlink" title="CONSTANT_Long_info 结构"></a>CONSTANT_Long_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Long_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 high_bytes;</div><div class="line">    u4 low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Double-info-结构"><a href="#CONSTANT-Double-info-结构" class="headerlink" title="CONSTANT_Double_info 结构"></a>CONSTANT_Double_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Double_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 high_bytes;</div><div class="line">    u4 low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-NameAndType-info-结构"><a href="#CONSTANT-NameAndType-info-结构" class="headerlink" title="CONSTANT_NameAndType_info 结构"></a>CONSTANT_NameAndType_info 结构</h5><p>CONSTANT_NameAndType_info 结构用于表示字段或方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CONSTANT_NameAndType_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 name_index; //name_index 项的值必须是对常量池的有效索引， 常量池在该索引处的项必须是</div><div class="line">    CONSTANT_Utf8_info（ §4.4.7）结构，这个结构要么表示特殊的方法名&lt;init&gt;，要么表示一个有效</div><div class="line">    的字段或方法的非限定名（ Unqualified Name）。</div><div class="line"></div><div class="line">    u2 descriptor_index;//descriptor_index 项的值必须是对常量池的有效索引， 常量池在该索引</div><div class="line">    处的项必须是CONSTANT_Utf8_info结构。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法描述符具体格式可参考《JVM规范》。</p>
<h5 id="CONSTANT-Utf8-info-结构"><a href="#CONSTANT-Utf8-info-结构" class="headerlink" title="CONSTANT_Utf8_info 结构"></a>CONSTANT_Utf8_info 结构</h5><p>CONSTANT_Utf8_info 结构用于表示字符串常量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Utf8_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 length;</div><div class="line">    u1 bytes[length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-MethodHandle-info-结构"><a href="#CONSTANT-MethodHandle-info-结构" class="headerlink" title="CONSTANT_MethodHandle_info 结构"></a>CONSTANT_MethodHandle_info 结构</h5><p>CONSTANT_MethodHandle_info 结构用于表示方法句柄，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CONSTANT_MethodHandle_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u1 reference_kind;//reference_kind 项的值必须在 1 至 9 之间（包括 1 和 9），它决定了方法句柄的类型。</div><div class="line">    方法句柄类型的值表示方法句柄的字节码行为。</div><div class="line"></div><div class="line">    u2 reference_index;//reference_index 项的值必须是对常量池的有效索引。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-MethodType-info-结构"><a href="#CONSTANT-MethodType-info-结构" class="headerlink" title="CONSTANT_MethodType_info 结构"></a>CONSTANT_MethodType_info 结构</h5><p>CONSTANT_MethodType_info 结构用于表示方法类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_MethodType_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-InvokeDynamic-info-结构"><a href="#CONSTANT-InvokeDynamic-info-结构" class="headerlink" title="CONSTANT_InvokeDynamic_info 结构"></a>CONSTANT_InvokeDynamic_info 结构</h5><p>CONSTANT_InvokeDynamic_info 用于表示 invokedynamic 指令所使用到的引导方法<br>（ Bootstrap Method）、 引导方法使用到动态调用名称（ Dynamic Invocation Name）、 参<br>数和请求返回类型、以及可以选择性的附加被称为静态参数（ Static Arguments） 的常量序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_InvokeDynamic_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 bootstrap_method_attr_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="access-flags的取值范围和相应含义表"><a href="#access-flags的取值范围和相应含义表" class="headerlink" title="access_flags的取值范围和相应含义表"></a>access_flags的取值范围和相应含义表</h4><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>可以被包的类外访问。</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>不允许有子类。</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td>0x0020</td>
<td>当用到 invokespecial 指令时，需要特殊处理的父类方法。</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识定义的是接口而不是类。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td>不能被实例化。</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识并非 Java 源码生成的代码。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识注解类型</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td>标识枚举类型</td>
</tr>
</tbody>
</table>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>field_info 结构格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">field_info &#123;</div><div class="line">    u2 access_flags;</div><div class="line">    u2 name_index;</div><div class="line">    u2 descriptor_index;</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="字段-access-flags-标记列表及其含义"><a href="#字段-access-flags-标记列表及其含义" class="headerlink" title="字段 access_flags 标记列表及其含义"></a>字段 access_flags 标记列表及其含义</h5><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，表示字段可以从任何包访问。</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，表示字段仅能该类自身调用。</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，表示字段可以被子类调用。</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td>0x0008</td>
<td>static，表示静态字段。</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>final，表示字段定义后值无法修改</td>
</tr>
<tr>
<td style="text-align:left">ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile，表示字段是易变的。</td>
</tr>
<tr>
<td style="text-align:left">ACC_TRANSIENT</td>
<td>0x0080</td>
<td>transient，表示字段不会被序列</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>表示字段由编译器自动产生。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td>enum，表示字段为枚举类型</td>
</tr>
</tbody>
</table>
<h5 id="基本类型字符解释表"><a href="#基本类型字符解释表" class="headerlink" title="基本类型字符解释表"></a>基本类型字符解释表</h5><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">B</td>
<td>byte</td>
<td>有符号字节型数</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td>char</td>
<td>Unicode 字符， UTF-16 编码</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td>int</td>
<td>整型数</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td>long</td>
<td>长整数</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td>short</td>
<td>有符号短整数</td>
</tr>
<tr>
<td style="text-align:left">Z</td>
<td>boolean</td>
<td>布尔值 true/false</td>
</tr>
<tr>
<td style="text-align:left">L Classname;</td>
<td>reference</td>
<td>一个名为<classname>的实例</classname></td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td>reference</td>
<td>一个一维数组</td>
</tr>
</tbody>
</table>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>method_info 结构格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">method_info &#123;</div><div class="line">    u2 access_flags;</div><div class="line">    u2 name_index;</div><div class="line">    u2 descriptor_index;</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="方法-access-flags-标记列表及其含义"><a href="#方法-access-flags-标记列表及其含义" class="headerlink" title="方法 access_flags 标记列表及其含义"></a>方法 access_flags 标记列表及其含义</h5><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类中访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>final，方法不能被重写（覆盖）</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>synchronized，方法由管程同步</td>
</tr>
<tr>
<td style="text-align:left">ACC_BRIDGE</td>
<td>0x0040</td>
<td>bridge，方法由编译器产生</td>
</tr>
<tr>
<td style="text-align:left">ACC_VARARGS</td>
<td>0x0080</td>
<td>表示方法带有变长参数</td>
</tr>
<tr>
<td style="text-align:left">ACC_NATIVE</td>
<td>0x0100</td>
<td>native，方法引用非 java 语言的本地方法</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td>abstract，方法没有具体实现</td>
</tr>
<tr>
<td style="text-align:left">ACC_STRICT</td>
<td>0x0800</td>
<td>strictfp，方法使用 FP-strict 浮点格式</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>方法在源文件中不出现，由编译器产生</td>
</tr>
</tbody>
</table>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。<br>关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。</p>
<h5 id="属性的通用格式如下："><a href="#属性的通用格式如下：" class="headerlink" title="属性的通用格式如下："></a>属性的通用格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute_info &#123;</div><div class="line">    u2 attribute_name_index;   //属性名索引</div><div class="line">    u4 attribute_length;       //属性长度</div><div class="line">    u1 info[attribute_length]; //属性的具体内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h5><p>ConstantValue 属性表示一个常量字段的值。位于 field_info结构的属性表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ConstantValue_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 constantvalue_index;//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是long型的，在常量池中便是CONSTANT_Long）</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Deprecated-属性"><a href="#Deprecated-属性" class="headerlink" title="Deprecated 属性"></a>Deprecated 属性</h5><p>Deprecated 属性是在 JDK 1.1 为了支持注释中的关键词@deprecated 而引入的。<br>Deprecated 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Deprecated_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Code-属性"><a href="#Code-属性" class="headerlink" title="Code 属性"></a>Code 属性</h5><p>Code 属性的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“</div><div class="line">    u4 attribute_length; //属性值长度，为整个属性表长度-6</div><div class="line">    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值分配栈帧</div><div class="line">    u2 max_locals;  //局部变量表最大存储空间，单位是slot</div><div class="line">    u4 code_length; // 字节码指令的个数</div><div class="line">    u1 code[code_length]; // 具体的字节码指令</div><div class="line">    u2 exception_table_length; //异常的个数</div><div class="line">    &#123;   u2 start_pc;</div><div class="line">        u2 end_pc;</div><div class="line">        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。</div><div class="line">        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理</div><div class="line">    &#125; exception_table[exception_table_length]; //具体的异常内容</div><div class="line">    u2 attributes_count;     //属性的个数</div><div class="line">    attribute_info attributes[attributes_count]; //具体的属性内容</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>其中slot为局部变量中的最小单位。boolean、 byte、 char、 short、 float、 reference和 returnAddress 等小于等于32位的用一个slot表示，double,long这些大于32位的用2个slot表示</li>
</ul>
<h5 id="InnerClasses-属性"><a href="#InnerClasses-属性" class="headerlink" title="InnerClasses 属性"></a>InnerClasses 属性</h5><p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个<br>CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的<br>ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。<br>InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的,位于 ClassFile结构的属性表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">InnerClasses_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_classes;</div><div class="line">    &#123;   u2 inner_class_info_index;</div><div class="line">        u2 outer_class_info_index;</div><div class="line">        u2 inner_name_index;</div><div class="line">        u2 inner_class_access_flags;</div><div class="line">    &#125; classes[number_of_classes];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LineNumberTable-属性"><a href="#LineNumberTable-属性" class="headerlink" title="LineNumberTable 属性"></a>LineNumberTable 属性</h5><p>LineNumberTable 属性是可选变长属性，位于 Code结构的属性表。它被调试<br>器用于确定源文件中行号表示的内容在 Java 虚拟机的 code[]数组中对应的部分。在 Code 属性<br>的属性表中， LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable<br>属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件<br>的行一一对应。<br>LineNumberTable 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LineNumberTable_attribute &#123;</div><div class="line">    u2 attribute_name_index;//属性名称在常量池的索引，指向一个 CONSTANT_Utf8_info结构。</div><div class="line">    u4 attribute_length;//属性长度</div><div class="line">    u2 line_number_table_length;//线性表长度</div><div class="line">    &#123;   u2 start_pc;</div><div class="line">        u2 line_number;</div><div class="line">      &#125; line_number_table[line_number_table_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LocalVariableTable-属性"><a href="#LocalVariableTable-属性" class="headerlink" title="LocalVariableTable 属性"></a>LocalVariableTable 属性</h5><p>LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调<br>试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，<br>LocalVariableTable 属性可以按照任意顺序出现。 Code 属性中的每个局部变量最多只能有一<br>个 LocalVariableTable 属性。<br>LocalVariableTable 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LocalVariableTable_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 local_variable_table_length</div><div class="line">    &#123; u2 start_pc;</div><div class="line">      u2 length;</div><div class="line">      u2 name_index;</div><div class="line">      u2 descriptor_index;</div><div class="line">      u2 index;</div><div class="line">    &#125; local_variable_table[local_variable_table_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h5><p>Signature 属性是可选的定长属性，位于 ClassFile， field_info<br>或 method_info结构的属性表中。在 Java 语言中，任何类、 接口、 初始化方法或成<br>员的泛型签名如果包含了类型变量（ Type Variables） 或参数化类型（ Parameterized<br>Types），则 Signature 属性会为它记录泛型签名信息。<br>Signature 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Signature_attribute &#123;</div><div class="line">    u2 attribute_name_index;//属性名称在常量池中的索引，指向一个 CONSTANT_Utf8_info结构。</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 signature_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>slot是虚拟机未局部变量分配内存使用的最小单位。对于byte/char/float/int/short/boolean/returnAddress等长度不超过32位的局部变量，每个占用1个Slot；对于long和double这两种64位的数据类型则需要2个Slot来存放。</li>
<li>实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。</li>
<li>max_locals，不是所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。</li>
<li>虚拟机规范限制严格方法不允许超过65535个字节码，否则拒绝编译。</li>
</ul>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文描述的是class结构的具体信息，排版顺序按照class结构。&lt;/p&gt;
&lt;h4 id=&quot;常量池&quot;&gt;&lt;a href=&quot;#常量池&quot; class=&quot;headerlink&quot; title=&quot;常量池&quot;&gt;&lt;/a&gt;常量池&lt;/h4&gt;&lt;h5 id=&quot;通用格式&quot;&gt;&lt;a href=&quot;#通用格式
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM中class文件结构--概念部分</title>
    <link href="http://vinoit.me/2016/05/22/java-classfile-structure-concept/"/>
    <id>http://vinoit.me/2016/05/22/java-classfile-structure-concept/</id>
    <published>2016-05-22T05:38:49.000Z</published>
    <updated>2016-08-13T12:30:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是class文件"><a href="#什么是class文件" class="headerlink" title="什么是class文件"></a>什么是class文件</h4><p>java源代码（后缀名是.java）经过编译器编译之后会生成class文件（后缀名是.class），每一个 Class 文件都对应着唯一一个类或接口的定义信息，但是相对地， 类或接口并不一定都得定义在文件里，我们只是通俗地将任意一个有效的类或接口所应当满足的格式称为“ Class 文件格式”， 即使它不一定以磁盘文件的形式存在。</p>
<p>每个 Class 文件都是由 8 字节为单位的字节流组成，所有的 16 位、 32 位和 64 位长度的数据将被构造成 2 个、 4 个和 8 个 8 字节单位来表示。多字节数据项总是按照 <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">Big-Endian</a>的顺序进行存储。<br>JVM规范还定义了一组私有数据类型来表示 Class 文件的内容，它们包括 <code>u1， u2 和 u4</code>，分别代表了 <code>1、 2 和 4</code>个字节的无符号。</p>
<p>为了避免与类的字段、 类的实例等概念产生混淆， 在此把用于描述类结构格式的内容定义为<code>项</code>（ Item）。在 Class 文件中，各项按照<code>严格顺序连续存放</code>的， 它们之间没有任何填充或对齐作为各项间的分隔符号。</p>
<p><code>表</code>（ Table） 是由任意数量的可变长度的<code>项</code>组成，用于表示Class 文件内容的一系列复合结构。</p>
<h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>每一个 Class 文件对应于一个如下所示的 ClassFile 结构体：</p>
<p>ClassFile :<br>    <code>u4 magic;</code><br>    <strong>魔数值固定为 0xCAFEBABE,不会改变，唯一作用是确定这个文件是否为一个能被虚拟机所接受的 Class 文件。</strong><br>    <code>u2 minor_version;</code><strong>副版本号</strong><br>    <code>u2 major_version;</code><strong>主版本号</strong><br>    <strong>主副版本号共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m。一个 Java 虚拟机实例只能支持特定范围内的主版本号。</strong><br>    <code>u2 constant_pool_count;</code><br>    <strong>常量池计数器，constant_pool_count 的值等于 constant_pool 表中的成员数加 1。constant_pool 表的索引值只有在大于 0 且小于 constant_pool_count 时才会被认为是有效的。（0表示不引用常量池的任一项）</strong><br>    <code>cp_info constant_pool[constant_pool_count-1];</code><br>    <strong>常量池，constant_pool 是一种表结构， 它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，  称为“ tagbyte”。常量池的索引范围是 1 至 constant_pool_count−1。（索引1表示第一个常量项）具体结构信息可查看我的另<br>    一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 access_flags;</code><br>    <strong>访问标志， access_flags 是一种掩码标志， 用于表示某个类或者接口的访问权限及基础属性。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 this_class;</code><br>    <strong>类索引， this_class 的值必须是对 constant_pool 表中项目的一个有效索引值。constant_pool 表在这个索引处的项必须为 CONSTANT_Class_info 类型常量。</strong><br>    <code>u2 super_class;</code><br>    <strong>父类索引，对于类来说， super_class 的值必须为 0 或者是对 constant_pool 表中项目的一个有效索引值。 如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为 CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。</strong><br>    <code>u2 interfaces_count;</code><br>    <strong>接口计数器， interfaces_count 的值表示当前类或接口的直接父接口数量。</strong><br>    <code>u2 interfaces[interfaces_count];</code><br>    <strong>接口表， interfaces[]数组中的每个成员的值必须是一个对 constant_pool 表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 类型常量,成员所表示的接口顺序和对应的源代码中给定的接口顺序（ 从左至右）<br>    一样。</strong><br>    <code>u2 fields_count;</code><br>    <strong>字段计数器， fields_count 的值表示当前 Class 文件 fields[]数组的成员个数。</strong><br>    <code>field_info fields[fields_count];</code><br>    <strong>字段表， fields[]数组中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述。fields[]数组描述当前类或接口声明的所有字段，但<em>不包括</em>从父类或父接口继承的部分。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 methods_count;</code><br>    <strong>方法计数器， methods_count 的值表示当前 Class 文件 methods[]数组的成员个数。</strong><br>    <code>method_info methods[methods_count];</code><br>    <strong>方法表， methods[]数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。methods[]数组只描述当前类或接口中声明的方法，<code>不包括</code>从父类或父接口继承的方法。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 attributes_count;</code><br>    <strong>属性计数器， attributes_count 的值表示当前 Class 文件 attributes 表的成员个数。attributes 表中每一项都是一个attribute_info 结构的数据项。</strong><br>    <code>attribute_info attributes[attributes_count];</code><br>    <strong>属性表，和字段表、方法表中属性表中的内容<em>有所区别</em>。（某些属性只能用于class,某些属性只能用于字段或者方法，例如ConstantValue 属性用于字段，Code 属性用于方法）具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong></p>
<p><code>以下是JVM规范SE7中的原文：</code><br>JVM规范里， Class 文件结构中的 attributes 表的项包括下列定义的属性：InnerClasses、EnclosingMethod、Synthetic 、Signature、SourceFile，SourceDebugExtension、 Deprecated、 RuntimeVisibleAnnotations、 RuntimeInvisibleAnnotations以及BootstrapMethods属性。对于支持 Class 文件格式版本号为 49.0 或更高的 Java虚拟机实现，必须正确识别并读取 attributes表中的Signature、 RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。<br>对于支持 Class 文件格式版本号为 51.0 或更高的Java 虚拟机实现，必须正确识别并读取 attributes 表中的BootstrapMethods属性。<br>本规范要求任一 Java 虚拟机实现可以自动忽略Class文件的 attributes 表中的若干（ 甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响 Class 文件的语义，只能提供附加的描述信息。<br><code>概括一下：虚拟机可以忽视某些属性，不同版本的虚拟机实例中所需的属性有所区别，你也可以实现自己的属性，但是只能作为附加信息，不能对原语义做出修改。</code></p>
<p>以上结构便是整个class文件，建议和我的另两篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>以及<a href="/2016/05/23/java-classfile-structure-example/">《理解JVM中class文件结构–实例讲解》</a>结合的来看。</p>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是class文件&quot;&gt;&lt;a href=&quot;#什么是class文件&quot; class=&quot;headerlink&quot; title=&quot;什么是class文件&quot;&gt;&lt;/a&gt;什么是class文件&lt;/h4&gt;&lt;p&gt;java源代码（后缀名是.java）经过编译器编译之后会生成class文件（
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（二）——重排序</title>
    <link href="http://vinoit.me/2016/05/21/java-memeory-model-reorder/"/>
    <id>http://vinoit.me/2016/05/21/java-memeory-model-reorder/</id>
    <published>2016-05-21T08:37:49.000Z</published>
    <updated>2016-08-10T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td style="text-align:left">写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td style="text-align:left">读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">//A</span></div><div class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">//B</span></div><div class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">//C</span></div></pre></td></tr></table></figure></p>
<p>上面三个操作的数据依赖关系如下图所示：<br><img src="/images/JMM/JMM-reorder-0.png" alt=""><br>如上图所示，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。下图是该程序的两种执行顺序：<br><img src="/images/JMM/JMM-reorder-1.png" alt=""><br>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h4 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h4><p>根据happens- before的程序顺序规则，上面计算圆的面积的示例代码存在三个happens- before关系：</p>
<p>1.A happens- before B；<br>2.B happens- before C；<br>3.A happens- before C；<br>这里的第3个happens- before关系，是根据happens- before的传递性推导出来的。</p>
<p>这里A happens- before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。</p>
<h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">            a = <span class="number">1</span>;                   <span class="comment">//1</span></div><div class="line">            flag = <span class="keyword">true</span>;             <span class="comment">//2</span></div><div class="line">      &#125;</div><div class="line">      <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i =  a * a;        <span class="comment">//4</span></div><div class="line">            ……</div><div class="line">          &#125;</div><div class="line">      &#125;       </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入？</p>
<p><code>答案是：不一定能看到。</code></p>
<p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图：<br><img src="/images/JMM/JMM-reorder-2.png" alt=""><br>如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！</p>
<p><code>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</code></p>
<p>下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作3和操作4重排序后，程序的执行时序图：<br><img src="/images/JMM/JMM-reorder-2.png" alt=""><br>在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据依赖性&quot;&gt;&lt;a href=&quot;#数据依赖性&quot; class=&quot;headerlink&quot; title=&quot;数据依赖性&quot;&gt;&lt;/a&gt;数据依赖性&lt;/h4&gt;&lt;p&gt;如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型
    
    </summary>
    
      <category term="JMM" scheme="http://vinoit.me/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://vinoit.me/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存分配的原理--molloc/brk/mmap</title>
    <link href="http://vinoit.me/2016/05/20/linux-memory-alloc/"/>
    <id>http://vinoit.me/2016/05/20/linux-memory-alloc/</id>
    <published>2016-05-20T14:06:51.000Z</published>
    <updated>2016-08-13T12:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配的原理__进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<h4 id="如何查看进程发生缺页中断的次数？"><a href="#如何查看进程发生缺页中断的次数？" class="headerlink" title="如何查看进程发生缺页中断的次数？"></a>如何查看进程发生缺页中断的次数？</h4><p>用<code>ps -o majflt,minflt -C program</code>命令查看。</p>
<p>majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。这两个数值表示一个进程自启动以来所发生的缺页中断的次数。</p>
<p>发生缺页中断后，执行了那些操作？</p>
<h4 id="当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作："><a href="#当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：" class="headerlink" title="当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作："></a>当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：</h4><ol>
<li><p>检查要访问的虚拟地址是否合法</p>
</li>
<li><p>查找/分配一个物理页</p>
</li>
<li><p>填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）</p>
</li>
<li><p>建立映射关系（虚拟地址到物理地址）</p>
</li>
</ol>
<p>重新执行发生缺页中断的那条指令</p>
<p>如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。</p>
<h4 id="内存分配原理"><a href="#内存分配原理" class="headerlink" title="内存分配原理"></a>内存分配原理</h4><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<ul>
<li><p>brk是将数据段(.data)的最高地址指针_edata往高地址推；</p>
</li>
<li><p>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
</li>
</ul>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p>
<h5 id="下面以一个例子来说明内存分配的原理："><a href="#下面以一个例子来说明内存分配的原理：" class="headerlink" title="下面以一个例子来说明内存分配的原理："></a>下面以一个例子来说明内存分配的原理：</h5><p>情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：<br><img src="/images/linux/linux-memory-alloc-0.jpg" alt=""><br>1.进程启动的时候，其（虚拟）内存空间的初始布局如图1-(1)所示。</p>
<p>其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。</p>
<p><code>_edata</code>指针（glibc里面定义）指向数据段的最高地址。</p>
<p>2.进程调用<code>A=malloc(30K)</code>以后，内存空间如图1-(2)：</p>
<p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p>
<p>你可能会问：只要把<code>_edata+30K</code>就完成内存分配了？</p>
<p>事实是这样的，<code>_edata+30K</code>只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</p>
<p>3.进程调用<code>B=malloc(40K)</code>以后，内存空间如图1-(3)。</p>
<p>情况二、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：<br><img src="/images/linux/linux-memory-alloc-1.jpg" alt=""></p>
<p>4.进程调用<code>C=malloc(200K)</code>以后，内存空间如图2-(4)：</p>
<p>默认情况下，malloc函数分配内存，如果请求内存大于128K（可由<code>M_MMAP_THRESHOLD</code>选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</p>
<p>这样子做主要是因为::<br>brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p>
<p>5.进程调用<code>D=malloc(100K)</code>以后，内存空间如图2-(5)；</p>
<p>6.进程调用<code>free(C</code>)以后，C对应的虚拟内存和物理内存一起释放如图2-(6)。<br><img src="/images/linux/linux-memory-alloc-2.jpg" alt=""></p>
<p>7.进程调用free(B)以后，如图3-(7)所示：</p>
<p>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？</p>
<p>当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。</p>
<p>8.进程调用free(D)以后，如图3-(8)所示：</p>
<p>B和D连接起来，变成一块140K的空闲内存。</p>
<p>9.默认情况下：</p>
<p>当最高地址空间的空闲内存超过128K（可由<code>M_TRIM_THRESHOLD</code>选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图3-(9)所示。</p>
<hr>
<h4 id="mmap-样例"><a href="#mmap-样例" class="headerlink" title="mmap 样例"></a>mmap 样例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,l;</div><div class="line">	<span class="keyword">char</span> *mp;</div><div class="line">	mp = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">1000000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</div><div class="line">	*mp = <span class="string">'A'</span>;</div><div class="line">	munmap(mp, <span class="number">1000000</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,l;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">char</span> *mp;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/tmp/mmap"</span>, O_CREAT|O_RDWR, <span class="number">00777</span>);</div><div class="line">	lseek(fd, <span class="number">100</span>, SEEK_SET);</div><div class="line">	write(fd, <span class="string">""</span>, <span class="number">1</span>);</div><div class="line">	mp = <span class="built_in">malloc</span>(<span class="number">1000000</span>);</div><div class="line">	mp = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">100</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">	i = *mp;</div><div class="line">	*mp = <span class="string">'A'</span>;</div><div class="line">	munmap(mp, <span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配的原理__进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。&lt;/p&gt;
&lt;h4 id=&quot;如何查看进程发生缺页中断的次数？&quot;&gt;&lt;a href=&quot;#如何查看进程发生缺页中断的次数？&quot; class=&quot;headerlink&quot; title=&quot;如
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内存分配" scheme="http://vinoit.me/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>理解JVM加载class原理--class加载的时机</title>
    <link href="http://vinoit.me/2016/05/19/when-jvm-load-class/"/>
    <id>http://vinoit.me/2016/05/19/when-jvm-load-class/</id>
    <published>2016-05-19T11:00:58.000Z</published>
    <updated>2016-08-13T12:25:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java的动态性"><a href="#java的动态性" class="headerlink" title="java的动态性"></a>java的动态性</h3><p>Java 语言是一种具有动态性的解释型编程语言，当指定程序运行的时候， Java 虚拟机就将编译生成的 . class 文件按照需求和一定的规则加载进内存，并组织成为一个完整的 Java 应用程序。 Java 语言把每个单独的类 Class 和接口 Implements 编译成单独的一个 . class 文件，这些文件对于 Java 运行环境来说就是一个个可以动态加载的单元。正是因为 Java 的这种特性，我们可以在不重新编译其它代码的情况下，只编译需要修改的单元，并把修改文件编译后的 . class 文件放到 Java 的路径当中， 等到下次该 Java 虚拟机器重新激活时，这个逻辑上的 Java 应用程序就会因为加载了新修改的 .class 文件，自己的功能也做了更新，这就是 Java 的动态性。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（using）、和卸载（Unloading）七个阶段。其中验证、准备和解析三个部分统称为连接（Linking），这七个阶段的发生顺序如下图所示：<br> <img src="/images/jvm/when-jvm-load-class-0.PNG" alt=""><br> 如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始。</p>
<p>类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>Java虚拟机规范没有强制性约束在什么时候开始类加载过程，但是对于初始化阶段，虚拟机规范则严格规定了有且只有四种情况必需立即对类进行“初始化”（而加载、验证、准备阶段则必需在此之前开始），这四种情况归类如下：<br>1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时、以及调用一个类的静态方法的时候。<br>2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要触发父类的初始化。<br>4.当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的类），虚拟机会先初始化这个类。</p>
<p>对于这四种触发类进行初始化的场景，在java虚拟机规范中限定了“有且只有”这四种场景会触发。这四种场景的行为称为对类的<code>主动引用</code>，除此以外的所有引用类的方式都不会触发类的初始化，称为<code>被动引用</code>。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>下面通过三个实例来说明被动引用：</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p> 父类SuperClass.java<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子类SubClass.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(SubClass.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure></p>
<p>由结果可以看出只输出了“SuperClass init！”，没有输出“SubClass init！”。这是因为对于静态字段，只有直接定义该字段的类才会被初始化，因此当我们通过子类来引用父类中定义的静态字段时，只会触发父类的初始化，而不会触发子类的初始化。</p>
<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>父类SuperClass.java如上一个示例一样<br>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">      SuperClass[] scs = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>输出结果为空</code><br>没有输出“SuperClass init！”说明没有触发类com.chenzhou.classloading.SuperClass的初始化阶段，但是这段代码会触发“[Lcom.chenzhou.classloading.SuperClass”类的初始化阶段。这个类是由虚拟机自动生成的，该创建动作由newarray触发。<code>从这里可以看出，对象的数组在java里面是一个单独的类型。</code></p>
<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>常量类ConstClass.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          System.out.println(ConstClass.HELLOWORLD);  </div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>输出：hello world</code><br>上面的示例代码运行后也没有输出“SuperClass init！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，<code>但是在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中</code>，对于常量ConstClass.HELLOWORLD的引用实际上都被转化为NotInitialization类对自身常量池的引用了。实际上NotInitialization的Class文件之中已经不存在ConstClass类的符号引用入口了。</p>
<h3 id="接口加载与类加载的区别"><a href="#接口加载与类加载的区别" class="headerlink" title="接口加载与类加载的区别"></a>接口加载与类加载的区别</h3><p>接口的加载过程与类加载的区别在于当类在初始化时要求其父类都已经初始化过了，但是一个接口在初始化时，并不要求其父类都完成了初始化，只有在真正用到父类接口的时候（如引用父接口的常量）才会初始化。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          <span class="keyword">new</span> SubClass();</div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line">SubClass init!</div></pre></td></tr></table></figure></p>
<p>如果此时的父类是一个接口，则只输出<code>SubClass init!</code>。</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>

]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java的动态性&quot;&gt;&lt;a href=&quot;#java的动态性&quot; class=&quot;headerlink&quot; title=&quot;java的动态性&quot;&gt;&lt;/a&gt;java的动态性&lt;/h3&gt;&lt;p&gt;Java 语言是一种具有动态性的解释型编程语言，当指定程序运行的时候， Java 虚拟机就将
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型及垃圾收集策略解析</title>
    <link href="http://vinoit.me/2016/05/19/jvm-gc-tactics/"/>
    <id>http://vinoit.me/2016/05/19/jvm-gc-tactics/</id>
    <published>2016-05-19T05:26:25.000Z</published>
    <updated>2016-08-13T12:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。</p>
<p>这五个区域既然是存储空间，那么为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。</p>
<p>这个垃圾收集者就是平常我们所说的“垃圾收集器”，那么垃圾收集器在何时清扫内存？清扫哪些数据？这就是接下来我们要解决的问题。</p>
<p>程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，也就是每条线程都拥有这三块区域，而且会随着线程的创建而创建，线程的结束而销毁。那么，垃圾收集器在何时清扫这三块区域的问题就解决了。</p>
<p>此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，方法的结束而出栈，并且每个栈帧中的本地变量表都是在类被加载的时候就确定的。因此以上三个区域的垃圾收集工作具有确定性，垃圾收集器能够清楚地知道何时清扫这三块区域中的哪些数据。</p>
<p>然而，堆和方法区中的内存清理工作就没那么容易了。<br>堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。</p>
<p>堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。</p>
<p>方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。<br>因此，堆和方法区的内存回收具有不确定性。</p>
<h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><p>JVM堆一般又可以分为以下三部分：<br><img src="/images/jvm/jvm-gc-tactics-0.jpg" alt=""></p>
<ul>
<li>Perm</li>
</ul>
<p>Perm代主要保存class,method,filed对象，这部门的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p>
<ul>
<li>Tenured</li>
</ul>
<p>Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p>
<ul>
<li>Young</li>
</ul>
<p>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Young区间变满的时候，minor GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p>
<h4 id="Sizing-the-Generations"><a href="#Sizing-the-Generations" class="headerlink" title="Sizing the Generations"></a>Sizing the Generations</h4><p>JVM提供了相应的参数来对内存大小进行配置。正如上面描述，JVM中堆被分为了3个大的区间，同时JVM也提供了一些选项对Young,Tenured的大小进行控制。<br><img src="/images/jvm/jvm-gc-tactics-1.jpg" alt=""></p>
<ul>
<li>Total Heap</li>
</ul>
<p><code>-Xms:</code>指定了JVM初始启动以后初始化内存</p>
<p><code>-Xmx：</code>指定JVM堆得最大内存，在JVM启动以后，会分配<code>-Xmx</code>参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存</p>
<p><code>-Xmx -Xms</code>之差就是三个Virtual空间的大小</p>
<ul>
<li>Young Generation</li>
</ul>
<p><code>-XX:NewRatio=8</code>意味着tenured 和 young的比值8：1，这样eden+2*survivor=1/9</p>
<p>堆内存</p>
<p><code>-XX:SurvivorRatio=32</code>意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.</p>
<p><code>-Xmn</code> 参数设置了年轻代的大小</p>
<ul>
<li>Perm Generation</li>
</ul>
<p><code>-XX:PermSize=16M -XX:MaxPermSize=64M</code></p>
<p>Thread Stack</p>
<p><code>-XX:Xss=128K</code></p>
<h4 id="堆栈分离的好处"><a href="#堆栈分离的好处" class="headerlink" title="堆栈分离的好处"></a>堆栈分离的好处</h4><p>如果从JAVA内存模型的角度去理解面向对象的设计，我们就会发现对象它完美的表示了堆和栈，对象的数据放在堆中，而我们编写的那些方法一般都是运行在栈中，因此面向对象的设计是一种非常完美的设计方式，它完美的统一了数据存储和运行。</p>
<h3 id="JAVA垃圾收集器"><a href="#JAVA垃圾收集器" class="headerlink" title="JAVA垃圾收集器"></a>JAVA垃圾收集器</h3><h4 id="常见的垃圾收集策略"><a href="#常见的垃圾收集策略" class="headerlink" title="常见的垃圾收集策略"></a>常见的垃圾收集策略</h4><p><img src="/images/jvm/jvm-gc-tactics-2.jpg" alt=""></p>
<p>所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面得不可到达主要是指应用程序已经没有内存块的引用了，而在JAVA中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。</p>
<h5 id="Reference-Counting-引用计数）"><a href="#Reference-Counting-引用计数）" class="headerlink" title="Reference Counting(引用计数）"></a>Reference Counting(引用计数）</h5><p>  引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。</p>
<p><code>优点：</code><br>简单，直接，不需要暂停整个应用<br><code>缺点：</code><br>1.需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作，比如每次将对象赋值给新的引用，或者者对象的引用超出了作用域等。<br>2.不能处理循环引用的问题</p>
<h5 id="跟踪收集器"><a href="#跟踪收集器" class="headerlink" title="跟踪收集器"></a>跟踪收集器</h5><p>跟踪收集器首先要暂停整个应用程序，然后开始从根对象扫描整个堆，判断扫描的对象是否有对象引用，这里面有三个问题需要搞清楚：<br><img src="/images/jvm/jvm-gc-tactics-3.jpg" alt=""><br>1．如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了分代收集，在新生代收集的时候minor gc只需要扫描新生代，而不需要扫描老生代。</p>
<p>2．JVM采用了分代收集以后，minor gc只扫描新生代，但是minor gc怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，卡片标记将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆。具体如下图：<br>3．GC在收集一个对象的时候会判断是否有引用指向对象，在JAVA中的引用主要有四种：Strong reference,Soft reference,Weak reference,Phantom reference.</p>
<ul>
<li>Strong Reference</li>
</ul>
<p>强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      Object referent = <span class="keyword">new</span> Object();  </div><div class="line">      Object strongReference = referent;  </div><div class="line">      referent = <span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNotNull(strongReference);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Soft Reference</li>
</ul>
<p>软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      String  str =  <span class="string">"test"</span>;  </div><div class="line">      SoftReference&lt;String&gt; softreference = <span class="keyword">new</span> SoftReference&lt;String&gt;(str);  </div><div class="line">      str=<span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNotNull(softreference.get());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Weak reference</li>
</ul>
<p>弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      String  str =  <span class="string">"test"</span>;  </div><div class="line">      WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);  </div><div class="line">      str=<span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNull(weakReference.get());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Phantom reference</li>
</ul>
<h6 id="Mark-Sweep-Collector-标记-清除收集器）"><a href="#Mark-Sweep-Collector-标记-清除收集器）" class="headerlink" title="Mark-Sweep Collector(标记-清除收集器）"></a>Mark-Sweep Collector(标记-清除收集器）</h6><p>标记清除收集器最早由Lisp的发明人于1960年提出，标记清除收集器停止所有的工作，从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。</p>
<p><code>优点：</code><br>1.解决循环引用的问题<br>2.不需要编译器的配合，从而就不执行额外的指令<br><code>缺点：</code><br>1.每个活跃的对象都要进行扫描，收集暂停的时间比较长。</p>
<h6 id="Copying-Collector-复制收集器）"><a href="#Copying-Collector-复制收集器）" class="headerlink" title="Copying Collector(复制收集器）"></a>Copying Collector(复制收集器）</h6><p>复制收集器将内存分为两块一样大小空间，某一个时刻，只有一个空间处于活跃的状态，当活跃的空间满的时候，GC就会将活跃的对象复制到未使用的空间中去，原来不活跃的空间就变为了活跃的空间。复制收集器具体过程可以参考下图：<br><img src="/images/jvm/jvm-gc-tactics-4.jpg" alt=""><br><code>优点：</code><br>1.只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间<br><code>缺点：</code><br>1.需要额外的空间消耗，某一个时刻，总是有一块内存处于未使用状态<br>2.复制对象需要一定的开销</p>
<h6 id="Mark-Compact-Collector-标记-整理收集器）"><a href="#Mark-Compact-Collector-标记-整理收集器）" class="headerlink" title="Mark-Compact Collector(标记-整理收集器）"></a>Mark-Compact Collector(标记-整理收集器）</h6><p>标记整理收集器汲取了标记清除和复制收集器的优点，它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的的对象复制到堆得底部。标记整理收集器的过程示意图请参考下图：Mark-compact策略极大的减少了内存碎片，并且不需要像Copy Collector一样需要两倍的空间。<br><img src="/images/jvm/jvm-gc-tactics-5.jpg" alt=""></p>
<h4 id="JVM的垃圾收集策略"><a href="#JVM的垃圾收集策略" class="headerlink" title="JVM的垃圾收集策略"></a>JVM的垃圾收集策略</h4><p>GC的执行时要耗费一定的CPU资源和时间的，因此在JDK1.2以后，JVM引入了分代收集的策略，其中对新生代采用<code>&quot;Copying Collector&quot;</code>策略，而对老生代采用了<code>“Mark-Compact&quot;</code>的策略。其中新生代的垃圾收集器命名为<code>“minor gc”</code>，老生代的GC命名为<code>&quot;Full Gc</code> 或者<code>Major GC&quot;</code>.其中用<code>System.gc()</code>强制执行的是<code>Full Gc</code>.</p>
<h5 id="新生代垃圾收集"><a href="#新生代垃圾收集" class="headerlink" title="新生代垃圾收集"></a>新生代垃圾收集</h5><p>在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。</p>
<p>通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。</p>
<p>但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。</p>
<h5 id="什么是分配担保？"><a href="#什么是分配担保？" class="headerlink" title="什么是分配担保？"></a>什么是分配担保？</h5><p>当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发MinorGC，对该区域的废弃对象进行回收。但如果MinorGC过后只有少量对象被回收，仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。</p>
<h5 id="老年代垃圾收集"><a href="#老年代垃圾收集" class="headerlink" title="老年代垃圾收集"></a>老年代垃圾收集</h5><p>老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。</p>
<h5 id="方法区垃圾收集"><a href="#方法区垃圾收集" class="headerlink" title="方法区垃圾收集"></a>方法区垃圾收集</h5><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p>
<p>加载该类的ClassLoader已经被回收。</p>
<p>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading</code>查看类的加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<font color="Darkorange">尊重他人劳动,转载请在正文明显处注明原文地址。</font>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h3&gt;&lt;p&gt;Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。
    
    </summary>
    
      <category term="jvm" scheme="http://vinoit.me/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://vinoit.me/tags/jvm/"/>
    
      <category term="GC" scheme="http://vinoit.me/tags/GC/"/>
    
  </entry>
  
</feed>
