<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>下定青年的个人博客</title>
  <subtitle>VinoZhu&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vinoit.me/"/>
  <updated>2016-11-13T12:49:11.000Z</updated>
  <id>http://vinoit.me/</id>
  
  <author>
    <name>Vino Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单字符串匹配算法--KMP、BM 和 Sunday</title>
    <link href="http://vinoit.me/2016/11/13/single-string-match-KMP-BM-Sunday/"/>
    <id>http://vinoit.me/2016/11/13/single-string-match-KMP-BM-Sunday/</id>
    <published>2016-11-13T11:19:51.000Z</published>
    <updated>2016-11-13T12:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>字符串匹配(查找)算法是一类重要的字符串算法，给定一个长度为n的字符串text（文本串），要求找出text中是否存在另一个长度为m的字符串pattern（模式串）。如果使用蛮力法，那么时间复杂度为O(m*n)，只有在长度较短的场景下才能勉强使用。</p>
<p>本文涉及的3种算法，KMP、BM、Sunday，都是目前比较主流的单字符串匹配算法。所谓单字符串匹配，就是在一个文本串中找一个模式串，多字符串匹配便是一个文本串中找多个模式串，多字符串匹配算法中主流的有ac自动机。</p>
<p>这3种单字符串匹配算法的具体说明在这里就不详细展开了，网络上有很多图文并茂的教程，在这里只提一下每个算法中最核心的几点，并分别给出java实现的算法。</p>
<p><strong>一些名称</strong></p>
<ul>
<li>text:文本串</li>
<li>pattern:模式串</li>
<li>i为文本串中当前比较字符的下标</li>
<li>j为模式串中当前比较字符的下标</li>
</ul>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>KMP算法是对蛮力法的改进，在蛮力法中，i和j都是一步一步往后移的，这就会做大量无用的循环判断。在KMP中，通过提前计算出一个next数组。从左到右匹配时，当模式串中的某个字符匹配失败了，取出next数组中对应下标的值，这个值就是j的下一个值。考虑以下情况：<br><img src="/images/algorithm/KMP-BM-Sunday-0.png" alt=""><br>此时pattern中的最后一个字符匹配失败，如果是蛮力法，那么pattern会向后移动一位。但是仔细观察pattern，就会发现有更好的移动方案：<br><img src="/images/algorithm/KMP-BM-Sunday-1.png" alt=""><br>在pattern移动到此位置之前的所有移动都属于无用功，这正是KMP中的正确做法。</p>
<p><strong>KMP中的一些概念</strong></p>
<ul>
<li>前缀：指除了最后一个字符以外，一个字符串的全部头部组合；</li>
<li>后缀：指除了第一个字符以外，一个字符串的全部尾部组合；</li>
<li><p>最大前后缀匹配：”前缀”和”后缀”的最长的共有元素的长度；</p>
<p>  “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</p>
<p>  “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p>
</li>
</ul>
<p>KMP中的next数组便是用来存放这个最大前后缀匹配的情况。对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<br><img src="/images/algorithm/KMP-BM-Sunday-2.png" alt=""></p>
<p><strong>java实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">package singleStrMatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> KMP &#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//模式串下标</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>;<span class="comment">//最大前后缀匹配中前缀的下一个下标（最大前后缀匹配的长度）</span></div><div class="line">        <span class="keyword">int</span> len = pattern.length();</div><div class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &lt; len - <span class="number">1</span>) &#123;<span class="comment">//j为计算当前next值的前一个下标</span></div><div class="line">            <span class="comment">//k == -1表示0～j的字符串中没有前后缀匹配</span></div><div class="line">            <span class="comment">//如果pattern.charAt(k) == pattern.charAt(j)，最大前后缀匹配长度加1</span></div><div class="line">            <span class="keyword">if</span> (k == <span class="number">-1</span> || pattern.charAt(k) == pattern.charAt(j)) &#123;</div><div class="line"></div><div class="line">                j++;</div><div class="line">                k++;</div><div class="line">                next[j] = k;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">//此时不存在前后缀匹配。若k&gt;1,则p[0 ～ k-1]字符串和p[j-k ～ j-1]字符串相等。</span></div><div class="line"></div><div class="line">                k = next[k];<span class="comment">//（前缀中最大前后缀匹配）的前缀的下一个下标</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(String text, String pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> slen = text.length();</div><div class="line">        <span class="keyword">int</span> plen = pattern.length();</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] next = getNext(pattern);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; slen &amp;&amp; j &lt; plen) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (text.charAt(i) == pattern.charAt(j)) &#123;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (next[j] == <span class="number">-1</span>) &#123;</div><div class="line">                    i++;</div><div class="line">                    j = <span class="number">0</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    j = next[j];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == plen) &#123;</div><div class="line">                <span class="keyword">return</span> i - j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        String text = <span class="string">"HERE IS A SIMPLE EXAMPLE"</span>;</div><div class="line">        String pattern = <span class="string">"EXAMPLE"</span>;</div><div class="line">        System.out.println(<span class="string">"字符串匹配的位置为:"</span> + kmp(text, pattern));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h4><p>KMP算法其实并不是效率最高的字符串匹配算法，实际应用的并不多，各种文本编辑器的“查找(CTRL F)”功能大多采用的是BM算法(Boyer Moore)。BM算法效率更高，更容易理解,BM算法往往比KMP算法快上3－5倍。</p>
<p>BM算法从尾部开始比较，如果匹配失败，此时存在2种规则：</p>
<ol>
<li>坏字符规则</li>
</ol>
<ul>
<li>后移位数 = 坏字符的位置 - 模式串中的上一次出现位置值</li>
</ul>
<p>假如在模式串中未出现，则为-1</p>
<p>假定文本串为”HERE IS A SIMPLE EXAMPLE”，模式串为”EXAMPLE”。</p>
<p>首先，”字符串”与”搜索词”头部对齐，从<code>尾部</code>开始比较。<br><img src="/images/algorithm/KMP-BM-Sunday-3.png" alt=""><br>S就是坏字符,移动<code>6-(-1)</code>。</p>
<p>依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在搜索词”EXAMPLE”之中。所以，将搜索词后移两位，两个”P”对齐。<br><img src="/images/algorithm/KMP-BM-Sunday-4.png" alt=""><br>移动<code>6-4</code>。<br><img src="/images/algorithm/KMP-BM-Sunday-5.png" alt=""></p>
<ol>
<li>好后缀规则</li>
</ol>
<ul>
<li>后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置</li>
</ul>
<p>同样，未出现则为-1</p>
<p><img src="/images/algorithm/KMP-BM-Sunday-6.png" alt=""><br>这个规则有三个注意点：</p>
<ul>
<li>“好后缀”的位置以最后一个字符为准。假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5（从0开始计算）。
　　</li>
<li>如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）。
　　</li>
<li>如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，请问这时”好后缀”的上一次出现位置是什么？回答是，此时采用的好后缀是”B”，它的上一次出现位置是头部，即第0位。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”。</li>
</ul>
<p>回到上图，此时，所有的”好后缀”（MPLE、PLE、LE、E）之中，只有”E”在”EXAMPLE”还出现在头部，所以后移 6 - 0 = 6位。<br><img src="/images/algorithm/KMP-BM-Sunday-7.png" alt=""><br>那什么时候用坏字符规则，什么时候用好后缀规则呢？Boyer-Moore算法的基本思想是，每次后移这两个规则之中的较大值。因为模式串已经确定了，所以可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。</p>
<p><strong>java实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> singleStrMatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BM</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CARD_CHAR_SET = <span class="number">256</span>;<span class="comment">// 字符集规模</span></div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param text 主串</div><div class="line">     * @param pattern 模式串</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMatchIndex</span><span class="params">(String text, String pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] BC = BuildBC(pattern); <span class="comment">// 坏字符表</span></div><div class="line">        <span class="keyword">int</span>[] GS = BuildGS(pattern); <span class="comment">// 好后缀表</span></div><div class="line"></div><div class="line">        <span class="comment">// 查找匹配</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 模式串相对于主串的起始位置（初始时与主串左对齐）</span></div><div class="line">        <span class="keyword">while</span> (text.length() - pattern.length() &gt;= i) &#123; <span class="comment">// 在到达最右端前，不断右移模式串</span></div><div class="line">            <span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; <span class="comment">// 从模式串最末尾的字符开始</span></div><div class="line">            <span class="keyword">while</span> (pattern.charAt(j) == text.charAt(i + j))</div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> &gt; --j) <span class="comment">// 自右向左比较</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span> (<span class="number">0</span> &gt; j) <span class="comment">// 若最大匹配后缀 == 整个模式串（说明已经完全匹配）</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                i += MAX(GS[j], j - BC[text.charAt(i + j)]);<span class="comment">// 在位移量BC和GS之间选择大者，相应地移动模式串</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 构造Bad Charactor Shift表BC[] - 坏字符表</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BuildBC(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span>[] BC = <span class="keyword">new</span> <span class="keyword">int</span>[CARD_CHAR_SET]; <span class="comment">// 初始化坏字符表</span></div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CARD_CHAR_SET; j++)</div><div class="line">            BC[j] = -<span class="number">1</span>; <span class="comment">// 首先假设该字符没有在P中出现</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pattern.length(); j++) <span class="comment">// 自左向右迭代：更新各字符的BC[]值</span></div><div class="line">            BC[pattern.charAt(j)] = j;</div><div class="line">        <span class="keyword">return</span> BC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 构造Good Suffix Shift表GS[] - 好后缀表</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BuildGS(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span> m = pattern.length();</div><div class="line">        <span class="keyword">int</span>[] SS = ComputeSuffixSize(pattern); <span class="comment">// 计算各字符对应的最长匹配后缀长度</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] GS = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">// Good Suffix Index</span></div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</div><div class="line">            GS[j] = m;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= -<span class="number">1</span>; j--)</div><div class="line">            <span class="keyword">if</span> (-<span class="number">1</span> == j || j + <span class="number">1</span> == SS[j]) <span class="comment">// 若定义SS[-1] = 0，则可统一为：if (j+1 == SS[j])</span></div><div class="line">                <span class="keyword">for</span> (; i &lt; m - j - <span class="number">1</span>; i++)</div><div class="line">                    <span class="keyword">if</span> (GS[i] == m)</div><div class="line">                        GS[i] = m - j - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++)</div><div class="line">            GS[m - SS[j] - <span class="number">1</span>] = m - j - <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> GS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 计算P的各前缀与P的各后缀的最大匹配长度</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ComputeSuffixSize(String pattern) &#123;</div><div class="line">        <span class="keyword">int</span> m = pattern.length();</div><div class="line">        <span class="keyword">int</span>[] SS = <span class="keyword">new</span> <span class="keyword">int</span>[m];<span class="comment">// Suffix Size Table</span></div><div class="line">        <span class="keyword">int</span> s, t; <span class="comment">// 子串P[s+1, ..., t]与后缀P[m+s-t, ..., m-1]匹配</span></div><div class="line">        <span class="keyword">int</span> j; <span class="comment">// 当前字符的位置</span></div><div class="line"></div><div class="line">        SS[m - <span class="number">1</span>] = m; <span class="comment">// 对最后一个字符而言，与之匹配的最长后缀就是整个P串</span></div><div class="line"></div><div class="line">        s = m - <span class="number">1</span>; <span class="comment">// 从倒数第二个字符起，自右向左扫描P，依次计算出SS[]其余各项</span></div><div class="line">        t = m - <span class="number">2</span>;</div><div class="line">        <span class="keyword">for</span> (j = m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> ((j &gt; s) &amp;&amp; (j - s &gt; SS[(m - <span class="number">1</span> - t) + j]))</div><div class="line">                SS[j] = SS[(m - <span class="number">1</span> - t) + j];</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                t = j; <span class="comment">// 与后缀匹配之子串的终点，就是当前字符</span></div><div class="line">                s = MIN(s, j); <span class="comment">// 与后缀匹配之子串的起点</span></div><div class="line">                <span class="keyword">while</span> ((<span class="number">0</span> &lt;= s) &amp;&amp; (pattern.charAt(s) == pattern.charAt((m - <span class="number">1</span> - t) + s)))</div><div class="line">                    s--;</div><div class="line">                SS[j] = t - s;<span class="comment">// 与后缀匹配之最长子串的长度</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> SS;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (a &gt; b) ? a : b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (a &lt; b) ? a : b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String text = <span class="string">"HERE IS A SIMPLE EXAMPLE"</span>;</div><div class="line">        String pattern = <span class="string">"EXAMPLE"</span>;</div><div class="line">        System.out.println(<span class="string">"字符串匹配的位置为: "</span> + getMatchIndex(text, pattern));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h4><p>Sunday算法的思想和BM算法中的坏字符思想非常类似。差别只是在于Sunday算法在匹配失败之后，是取文本串中当前和模式串对应的部分后面一个位置的字符来做坏字符匹配。</p>
<p>Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。</p>
<ul>
<li>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；</li>
<li>否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。</li>
</ul>
<p>下面举个例子说明下Sunday算法。假定现在要在主串”substring searching”中查找模式串”search”。</p>
<ul>
<li><p>刚开始时，把模式串与文主串左边对齐：<br><img src="/images/algorithm/KMP-BM-Sunday-8.png" alt=""></p>
</li>
<li><p>结果发现在第2个字符处发现不匹配，不匹配时关注主串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：<br><img src="/images/algorithm/KMP-BM-Sunday-9.png" alt=""></p>
</li>
<li><p>结果第一个字符就不匹配，再看主串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（m - 3 = 6 - 3 = r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：<br><img src="/images/algorithm/KMP-BM-Sunday-10.png" alt=""></p>
</li>
<li><p>匹配成功<br>  和BM一样，Sunday也需要提前计算出一个表来获取移动的长度。</p>
</li>
</ul>
<p><strong>java实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> singleStrMatch;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/11/13.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sunday</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 统计pattern每个字符出现的位置 -1为没有出现在模式字符串中</div><div class="line">     * <span class="doctag">@since</span>: 1.0.0</div><div class="line">     * <span class="doctag">@param</span> pattern</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map <span class="title">calculateCharsTable</span><span class="params">(String pattern)</span> </span>&#123;</div><div class="line">        Map badTables = <span class="keyword">new</span> HashMap();</div><div class="line">        <span class="comment">// 从右到左遍历，也可以从左到右（0，plen-1)，只不过右边重复的字符会覆盖之前的index</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = pattern.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (!badTables.containsKey(pattern.charAt(j))) &#123;</div><div class="line">                <span class="comment">// 模式字符串最右边出现的位置</span></div><div class="line">                badTables.put(pattern.charAt(j), j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> badTables;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * sunday 算法</div><div class="line">     * <span class="doctag">@since</span>: 1.0.0</div><div class="line">     * <span class="doctag">@param</span> text</div><div class="line">     * <span class="doctag">@param</span> pattern</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sundaySerarch</span><span class="params">(String text, String pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span> || text.isEmpty() || pattern == <span class="keyword">null</span> || pattern.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> tlen = text.length();</div><div class="line">        <span class="keyword">int</span> plen = pattern.length();</div><div class="line">        <span class="keyword">if</span> (tlen &lt; plen) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> maxCount = tlen - plen;</div><div class="line">        Map badCharsTable = calculateCharsTable(pattern);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">while</span> (i &lt;= maxCount) &#123;</div><div class="line">            j = <span class="number">0</span>;</div><div class="line">            <span class="comment">//子串比较</span></div><div class="line">            <span class="keyword">while</span> ( j&lt; plen &amp;&amp; text.charAt(i + j) == pattern.charAt(j))&#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//全部匹配</span></div><div class="line">            <span class="keyword">if</span> (j == plen) &#123;</div><div class="line">                <span class="comment">//System.out.println(text + "=================&gt;found:" + pattern + ",i=" + i);</span></div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//有字符不匹配</span></div><div class="line">            i += plen;</div><div class="line">            <span class="keyword">if</span> (i &lt; tlen) &#123;</div><div class="line">                <span class="comment">// 从下一个字符（bad char）处查找出现的位置</span></div><div class="line">                Integer badCharFound = (Integer) badCharsTable.get(text.charAt(i));</div><div class="line">                <span class="keyword">if</span> (badCharFound == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 没有在模式串中找到</span></div><div class="line">                    badCharFound = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                i -= badCharFound;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// not found</span></div><div class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        <span class="comment">//System.out.println(text + "=================&gt;not found:" + pattern);</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String text = <span class="string">"HERE IS A SIMPLE EXAMPLE"</span>;</div><div class="line">        String pattern = <span class="string">"EXAMPLE"</span>;</div><div class="line">        System.out.println(<span class="string">"字符串匹配的位置为:"</span> + sundaySerarch(text,pattern));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>3种算法的效率和时间复杂度可参照此文：<a href="http://www.voidcn.com/blog/cy_cai/article/p-6305505.html" target="_blank" rel="external">http://www.voidcn.com/blog/cy_cai/article/p-6305505.html</a></p>
<ul>
<li>BM比KMP查找效率好2-6倍。</li>
<li>随着搜索字符增长，BM与KMP查找效率比差距越来越大。</li>
<li>Sunday比BM查找效率又稍微好点。</li>
<li>随着搜索字符增长，BM和Sunday效率越来越突出。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/q547550831/article/details/51860017" target="_blank" rel="external">http://blog.csdn.net/q547550831/article/details/51860017</a></li>
<li><a href="http://www.youzhixu.com/reading/HgSWfRL#toc--0" target="_blank" rel="external">http://www.youzhixu.com/reading/HgSWfRL#toc--0</a></li>
<li><a href="http://blog.csdn.net/zdp072/article/details/13168605" target="_blank" rel="external">http://blog.csdn.net/zdp072/article/details/13168605</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;字符串匹配(查找)算法是一类重要的字符串算法，给定一个长度为n的字符串text（文本串），要求找出text中是否存在另一个长度为m的字符串p
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://vinoit.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="字符串匹配" scheme="http://vinoit.me/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="BM" scheme="http://vinoit.me/tags/BM/"/>
    
      <category term="KMP" scheme="http://vinoit.me/tags/KMP/"/>
    
      <category term="Sunday" scheme="http://vinoit.me/tags/Sunday/"/>
    
  </entry>
  
  <entry>
    <title>《程序员的自我修养-链接、装载与库》学习笔记</title>
    <link href="http://vinoit.me/2016/11/09/programmer-self-culture-link-load-and-lib-notes/"/>
    <id>http://vinoit.me/2016/11/09/programmer-self-culture-link-load-and-lib-notes/</id>
    <published>2016-11-09T09:51:54.000Z</published>
    <updated>2016-11-09T10:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>正所谓圆越大，圆外圈的空白越大。你当前学习的知识很大程度上是由之前的某个知识引出的，我就是这种情况下开始看这本书的。书的内容没有涉及到很细节，但是对于这方面知识体系的建立很有帮助，让你对程序运行的背后机制有了深一层的了解，值得推荐。该文是一个学习笔记，转载自<a href="http://noalgo.info/582.html" target="_blank" rel="external">程序的编译、链接与装载</a>。</p>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>许多IDE和编译器将编译和链接的过程合并在一起，称为构建（Build），使用起来非常方便。但只有深入理解其中的机制，才能看清许多问题的本质，正确解决问题。</p>
<p>一般的编译过程可以分解为4个步骤，预处理，编译，汇编和链接：</p>
<ul>
<li>预编译：处理源代码中的以”#”开始的预编译指令，如”#include”、”#define”等。</li>
<li>编译：把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后产生相应的汇编代码文件，是程序构建的核心部分，也是最复杂的部分之一。</li>
<li>汇编：将汇编代码根据指令对照表转变成机器可以执行的指令，一个汇编语句一般对应一条机器指令。</li>
<li>链接：将多个目标文件综合起来形成一个可执行文件。</li>
</ul>
<p>而对于第2步，编译由编译器完成器，编译器是将高级语言翻译成机器语言的一个工具，其具体步骤包括：</p>
<ul>
<li>词法分析：将源代码程序输入扫描器，将源代码字符序列分割成一系列记号（Token）。</li>
<li>语法分析：对产生的记号使用上下文无关语法进行语法分析，产生语法树。</li>
<li>语义分析：进行静态语义分析，通常包括声明和类型的匹配，类型的转换。</li>
<li>中间语言生成：使用源代码优化器将语法树转换成中间代码并进行源码级的优化。</li>
<li>目标代码生成：使用代码生成器将中间代码转成依赖于具体机器的目标机器代码。</li>
<li>目标代码优化：使用目标代码优化器对目标代码进行优化，比如选择合适的寻址方式、使用位移替代乘法、删除多余指令等。</li>
</ul>
<p>如果一个源代码文件中有变量或函数等符号定义在其他模块，那么编译后得到的目标代码中，该符号的地址并没有确定下来，因为编译器不知道到哪里去找这些符号，事实上这些变量和函数的最终地址要在链接的时候才能确定。现代的编译器只是将一个源代码编译成一个未链接的目标文件，最终由链接器将这些目标文件链接起来形成可执行文件。</p>
<h4 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h4><p>编译器编译源代码后生成的文件称为目标文件，事实上，目标文件是按照可执行文件的格式存储的，二者结构只是稍有不同。Linux下的目标文件和可执行文件可以看成一种类型的文件，统称为ELF文件，一般有以下几类：</p>
<ul>
<li>可重定位文件：如.o文件，包含代码和数据，可以被链接成可执行文件或共享目标文件，静态链接库属于这一类。</li>
<li>可执行文件：如/bin/bash文件，包含了可以直接执行的程序，一般没有扩展名。</li>
<li>共享目标文件：如.so文件，包含代码和数据，可以跟其他可重定位文件和共享目标文件链接产生新的目标文件，也可以跟可执行文件结合作为进程映像的一部分。</li>
</ul>
<p>目标文件由许多段组成，其中主要的段包括：</p>
<ul>
<li>代码段（.text）：保存编译后得到的指令数据。</li>
<li>数据段（.data）：保存已经初始化的全局静态变量和局部静态变量。</li>
<li>只读数据段（.rodata）：保存只读变量和字符串常量，有些编译器会把字符串常量放到”.data”段。</li>
<li>BSS段（.bss）：保存未初始化的全局变量和局部静态变量。</li>
</ul>
<p>除了这几个常用的段之外，ELF可能包含其他的段，保存与程序相关的信息，如：</p>
<ul>
<li>.comment 编译器版本信息</li>
<li>.debug 调试信息</li>
<li>.dynamic 动态链接信息</li>
<li>.hash 符号哈希表</li>
<li>.line 调试时的行号表，源代码行号与编译后指令的对应表</li>
<li>.note 额外的比编译器信息</li>
<li>.strtab String Table，字符串表，存储用到的各种字符串</li>
<li>.symtab Symbol Table，符号表</li>
<li>.shstrtab Section String Table，段名表</li>
<li>.plt 动态链接跳转表</li>
<li>.got 动态链接全局入口表</li>
<li>.init 程序初始化代码段</li>
<li>.fini 程序终结代码段<br>ELF目标文件的总体结构如下图所示，其中省去了一些繁琐的结果，把最终的提出出来。</li>
</ul>
<p><img src="/images/programmer-self-culture/link-load-and-lib-0.png" alt=""><br>以下选取较为重要的进行介绍。<br>ELF文件头（ELF Header）：保存描述整个文件的基本属性，如ELF魔数、文件机器字节长度、数据存储格式等。</p>
<p>段表（Section Header Table）：保存各个段的基本属性，是除了文件头之最重要的结构。节选样例内容如下：<br><img src="/images/programmer-self-culture/link-load-and-lib-1.png" alt=""><br>其表示的意义为，下标为1的段是.text段，类型是程序段（PROGBITS包括代码段和数据段），加载地址为0，在文件中的偏移量是0×34，长度为0x5b，项的长度为0（表示该段不包含固定大小的项），标志AX表示该段要分配空间及可以被执行，链接信息的两个0没有意义（不是与链接相关的段），最后的4表示段地址对齐为2^4=16字节。</p>
<p>重定位表：链接器在处理目标文件的时候，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些绝对地址的引用位置，这些重定位信息记录在重定位表里。每个需要重定位的代码段或数据段都会有一个相应的重定位表，如.rel.text是针对”.text”段的重定位表，”.rel.data”是针对”.data”段的重定位表。</p>
<p>字符串表：ELF文件中用到很多字符串，如段名、变量名，因为字符串的长度不固定，用固定的结构来表示它比较困难，一般把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。一般字符串表在ELF中以段的形式保存，常见的有.strtab（字符串表，String Table）和.shstrtab（段表字符串表，Section Header String Table），前者保存如符号名字等普通字符串，后者保存如段名等段表中用到的字符串。</p>
<p>符号表：函数和变量统称为符号，其名称称为符号名。链接过程中关键的部分就是符号的管理，每一个目标文件都会有一个相应的符号表，记录了目标文件用到的所有符号，每个符号有一个对应的符号值，一般为符号的地址。一个样例如下：<br><img src="/images/programmer-self-culture/link-load-and-lib-2.png" alt=""><br>其意义如下：下标为13的符号的符号值为0x1b，大小为64字节，类型为函数，绑定信息为全局符号，VIS可以忽略，Ndx表示其所在段的下标为1（通过上一个样例可知，该段为.text段），符号名称为main。如果Ndx下标一项为UND（undefine），则表示该符号在其他模块定义，以后需要重定位。</p>
<p>调试信息：目标文件里可能保存有调试信息，如在GCC编译时加上”-g”参数，会生成许多以”.debug”开头的段。</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>几个目标文件进行链接时，每个目标文件都有其自身的代码段、数据段等，链接器需要将它们各个段的合并到输出文件中，具体有两种合并方法：</p>
<ul>
<li>按序叠加：将输入的目标文件按照次序叠加起来。</li>
<li>相似段合并：将相同性质的段合并到一起，比如将所有输入文件的”.text”合并到输出文件的”.text”段，接着是”.data”段、”.bss”段等。</li>
</ul>
<p>第一种方法会产生很多零散的段，而且每个段有一定的地址和空间对齐要求，会造成内存空间大量的内部碎片。所以现在的链接器空间分配基本采用第二种方法，而且一般采用一种称为两部链接的方法：</p>
<ol>
<li><p>空间与地址分配。扫描所有输入的目标文件，获得他们各个段的长度、属性和位置，收集它们符号表中所有的符号定义和符号引用，统一放到一个全局符号表中。此时，链接器可以获得所有输入目标文件的段长度，将他们合并，计算出输出文件中各个段合并后的长度与位置并建立映射关系。</p>
</li>
<li><p>符号解析与重定位。使用上面收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。<br>经过第一步后，输入文件中的各个段在链接后的虚拟地址已经确定了，链接器开始计算各个符号的虚拟地址。各个符号在段内的相对地址是固定的，链接器只需要给他们加上一个偏移量，调整到正确的虚拟地址即可。</p>
</li>
</ol>
<p>ELF中每个需要重定位的段都有一个对应的重定位表，也称为重定位段。重定位表中每个需要重定位的地方叫一个重定位入口，包含：</p>
<ul>
<li><p>重定位入口的偏移：对于可重定位文件来说，偏移指该重定位入口所要修正的位置的第一个字节相对于该段的起始偏移。</p>
</li>
<li><p>重定位入口的类型和符号：低8位表示重定位入口的类型，高24位表示重定位入口的符号在符号表的下标。</p>
</li>
</ul>
<p>不同的处理器指令对于地址的格式和方式都不一样，对于每一个重定位入口，根据其重定位类型使用对应的指令修正方式修改其指令地址，完成重定位过程。</p>
<h4 id="可执行文件的装载"><a href="#可执行文件的装载" class="headerlink" title="可执行文件的装载"></a>可执行文件的装载</h4><p>32位硬件平台上进程的虚拟地址空间的地址为0到2^32-1：0×00000000~0xFFFFFFFF，即通常说的4GB虚拟空间大小。在Linux操作系统下，4GB被划分成两部分，操作系统本身占用了0xC00000000到0xFFFFFFFF共1GB的空间，剩下的从0×00000000到0xBFFFFFFFF共3GB的空间留给进程使用。</p>
<p>可执行文件只有被装载到内存以后才能运行，最简单的办法是把所有的指令和数据全部装入内存，但这可能需要大量的内存，为了更有效地利用内存，根据程序运行的局部性原理，我们可以把程序中最常用的部分驻留内存，将不太常用的数据放在磁盘中，即动态装入。</p>
<p>现在大部分操作系统采用的是页映射的方法进行程序装载。页映射并不是一下把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令按照”页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。目前一般的页大小为4K=4096字节。装载管理器负责控制程序的装载问题，当运行到的某条指令不在内存的时候，会将该指令所在的页装载到内存中的一个地方，然后继续程序的运行。如果内存中已经没有位置，装载管理器会根据一定的算法放弃某个正在使用的页，并用新的页来替代，然后程序可以继续运行。</p>
<p>可执行文件中包含代码段、数据段、BSS段等一系列的段，其中很多段都要映射进进程的虚拟地址空间。当段的数量增加时，会产生空间浪费问题。因为ELF文件被映射时是以系统的页长度为单位进行的，一个段映射的长度应为页长度的整数倍，如果不是，那么多余部分也将占用一个页，从而产生内存浪费。</p>
<p>实际上操作系统并不关心可执行文件各个段所包含的实际内容，它只关心一些跟装载有关的问题，最主要的是段的权限（可读、可写、可执行）。ELF中，段的权限组合可以分成三类：</p>
<ul>
<li>以代码段为代表的权限为可读可执行的段。</li>
<li>以数据段和BSS段为代表的权限为可读可写的段。</li>
<li>以只读数据段为代表的权限为只读的段。</li>
</ul>
<p>于是，对于相同权限的段，可以把它们合并到一起当做一个段进行映射，这样可以把原先的多个段当做一个整体进行映射，明显地减少页面内部碎片，节省内存空间。这个称为”Segment”，表示一个或多个属性类似的”Section”，可以认为”Section”是链接时的概念，”Segment”是装载时的概念。链接器会把属性相似的”Section”放在一起，然后系统会按照这些”Section”组成的”Segment”来映射并装载可执行文件。</p>
<p>进程的虚拟地址空间中除了被用来映射可执行文件的各个”Segment”之外，还有包括栈（Stack）和堆（Heap）的空间，一个进程中的栈和堆在也是以虚拟内存区域（VMA, Virtual Memrory Area）的形式存在。操作系统通过给进程空间划分出一个个的VMA来管理进程的虚拟空间，基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA，一个进程基本可以分为如下几种VMA区域：</p>
<ul>
<li>代码VMA，权限只读，可执行，有映像文件。</li>
<li>数据VMA，权限可读写，可执行，有映像文件。</li>
<li>堆VMA，权限可读写，可执行，无映像文件，匿名，可向上扩展。</li>
<li>栈VMA，权限可读写，不可执行，无映像文件，匿名，可向下扩展。</li>
</ul>
<p>其常见的分布情况如下图所示：<br><img src="/images/programmer-self-culture/link-load-and-lib-3.png" alt=""></p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>静态链接允许不同程序开发者相对独立地开发和测试自己的程序模块，促进程序开发的效率，但其也有相应的缺点：</p>
<ul>
<li><p>浪费内存和磁盘空间。在多进程操作系统下，每个程序内部都保留了公用的库函数及其他数量可观的库函数及辅助数据结构，浪费大量空间。</p>
</li>
<li><p>程序开发和发布困难。一个程序如果使用了很多第三方的静态库，那么程序中一旦有任何库的更新，整个程序就要重新链接并重新发布给客户，非常不方便。</p>
</li>
</ul>
<p>动态链接可以解决空间浪费和更新困难的问题，其不对那些组成程序的目标文件进行链接，而是等到程序运行时才进行链接。使用了动态链接之后，当我们运行一个程序时，系统会首先加载该程序依赖的其他的目标文件，如果其他目标文件还有依赖，系统会按照同样方法将它们全部加载到内存。当所需要的所有目标文件加载完毕之后，如果依赖关系满足，系统开始进行链接工作，包括符号解析及地址重定位等。完成之后，系统把控制权交回给原程序，程序开始运行。此时如果运行第二个程序，它依赖于一个已经加载过的目标文件，则系统不需要重新加载目标文件，而只要将它们连接起来即可。</p>
<p>动态链接可以解决共享的目标文件存在多个副本浪费磁盘和内存空间的问题，因为同一个目标文件在内存中只保存一份。另外，当一个程序所依赖的库升级之后，只需要将简单地用新的库将旧的覆盖掉，无需将所有的程序再重新链接一遍，当程序下次运行时，新版本的库会被自动加载到内存并链接起来，程序仍然可以正常运行，并且完成了升级过程。</p>
<p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，那就是可执行文件本身。但是对于动态链接来说，除了可执行文件本身，还有它所依赖的共享目标文件，此时，它们都是被操作系统用同样的方法映射进进程的虚拟地址空间，只是它们占用的虚拟地址和长度不同。另外，动态链接器也和普通共享对象一样被映射到进程的地址空间。系统开始运行程序之前，会把控制权交给动态链接器，由它完成所有的动态链接工作，然后再把控制权交回给程序，程序就开始执行。</p>
<h5 id="装载时重定位"><a href="#装载时重定位" class="headerlink" title="装载时重定位"></a>装载时重定位</h5><p>动态链接的共享对象在被装载时，其在进程虚拟地址空间的位置是不确定的，为了使共享对象能够在任意地址装载，可以参考静态链接时的重定位（Link Time Relocation）思想，在链接时对所有的绝对地址的引用不做重定位，把这一步推迟到装载时再完成。一旦模块装载完毕，其地址就确定了，即目标地址确定，系统就对程序中所有的绝对地址引用进行重定位。这种装载时重定位（Load Time Relocation）又称为基址重置（Rebasing）。</p>
<p>但是动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位之后对于每个进程来讲是不同的。当然，动态链接库中的可修改的数据部分对于不同的进程来说有多个副本，所以它们可以采用装载时重定位的方法来解决。</p>
<h5 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h5><p>装载时重定位导致指令部分无法在多个进程之间共享，失去了动态链接节省内存的一大优势。为了程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，可以把指令中那些需要改变的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变了，而数据部分可以在每个进程中拥有一个副本。这种方案称为地址无关代码（PIC, Position-independent Code）技术。<br>我们把共享对象模块中的地址引用按照是否扩模块分成模块内部引用和模块外部引用，按照不用的引用方式分成指令引用和数据引用，然后把得到的4种情况分别进行处理：</p>
<ul>
<li><p>模块内部调用或跳转。因为被调用的函数和调用者处于同一个模块，相对位置固定，而现代的系统对于模块内部的跳转、函数调用可以采用相对地址调用或者给予寄存器的相对调用，所以这种指令不需要重定位，其是地址无关的。</p>
</li>
<li><p>模块内部数据访问。显然指令不能包含数据的绝对地址，那么只有进行相对寻址。因为一个模块前面一半是若干个页的代码，然后是若干个也的数据，这些页之间的相对位置是固定的，即任何一条指令与它所需要访问的模块颞部数据之间的相对位置是固定的，那么只需要相对当前指令加上固定的偏移量就可以访问模块内部数据了。现代的体系结构中，数据的相对寻址往往没有相对当前指令地址（PC）的寻址方式，ELF中使用了巧妙的办法获取当前的PC值，然后再加上一个偏移量达到访问相应变量的目的。</p>
</li>
<li><p>模块间数据访问。模块间的数据访问目标地址要等到装载时才能确定，这些变量的地址跟模块的装载地址相关。ELF在数据段里建立一个指向这些变量的指针数组，称为全局偏移表（GOT, Global Offset Table），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。当指令需要一个其他模块的变量时，程序会先找到GOT，然后根据GOT中变量对应的项找到该变量的目标地址。每个变量对应一个4字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT的各个项，以确保每个指针所指向的地址都正确。由于GOT本身放在数据段，它可以在被模块装载时修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
</li>
<li><p>模块间调用、跳转。采用上述类似的方法，不同的是，GOT中相应保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。调用一个函数时，先得到当前指令地址PC，然后加上一个偏移得到函数地址在GOT中的偏移，然后进行间接调用。<br>于是，四种地址引用方式在理论上都实现了地址无关性。</p>
</li>
</ul>
<h4 id="数据段地址无关性"><a href="#数据段地址无关性" class="headerlink" title="数据段地址无关性"></a>数据段地址无关性</h4><p>以上的方法能够保证共享对象中代码部分地址无关，但数据部分并不是地址无关的，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span>* p = &amp;a;</div></pre></td></tr></table></figure>
<p>指针p的地址是绝对地址，指向变量a，但a的地址会随着共享对象的装载地址改变而变。</p>
<p>数据段在每个进程都有一份独立的副本，并不担心被进程改变，于是可以选择装载时重定位的方法来解决数据段中绝对地址引用的问题。对于共享对象来说，如果数据段中有绝对地址的引用，那么编译器和链接器会产生一个重定位表，这个表中包含了”R_386_RELATIVE”类型的重定位入口来解决上述问题。当动态链接器装载共享对象时，如果发现共享对象上有这样的重定位入口，就会对该共享对象进行重定位。</p>
<p>其实对代码段也可以使用装载时重定位而不是地址无关代码的方法，它有以下特点：</p>
<ul>
<li>代码段不是地址无关，不能被多个进程共享，失去了节省内存的有点。</li>
<li>运行速度比地址无关代码的共享对象块，因为它省去了地址无关代码中每次访问全局数据和函数时都要做一次计算当前地址以及间接地址寻址的过程。</li>
</ul>
<h5 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h5><p>动态链接下可执行文件的装载与静态链接下基本一样，首先操作系统会读取可执行文件的头部，检查文件的合法性，然后从头部中的”Program Header”中读取每个”Segment”的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置，这些步骤跟前面的静态链接情况下的装载基本无异。在静态链接情况下，操作系统接着就可以把控制权交给可执行文件的入口地址，然后程序开始执行。但在动态链接情况下，操作系统会先启动一个动态链接器，动态链接器得到控制权后，开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成以后，动态链接器会将控制权转交到可执行文件的入口地址，程序开始正式执行。</p>
<p>动态链接涉及到的段主要如下：</p>
<ul>
<li><p>“.interp”段。在Linux中，操作系统在对可执行文件进行加载时，会寻找装载该可执行文件需要的相应的动态链接器，即”.interp”段指定的路径的共享对象。</p>
</li>
<li><p>“.dynamic”段。动态链接ELF中最重要的结构，保存了动态链接器需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。”.dynamic”段保存的信息类似于ELF文件头，只是ELF文件头保存的是静态链接相关的内容，这里换成动态链接所使用的相应信息。</p>
</li>
<li><p>动态符号表。ELF中专门保存符号信息的段为”.dynsym”。类似于”.symtab”，但”.dynsym”只保存与动态链接相关的符号，而”.symtab”则保存了所有的符号，包括”.synsyms”中的符号。同样地，动态符号表也需要一些辅助的表，如保存符号名的字符串表，静态链接时叫符号字符串表”.strtab”，在这里就是动态符号字符串表”.dynstr”（Dynamic String Table）。为了加快动态链接下程序符号查找的过程，往往还有扶着的符号哈希表”.hash”。动态链接符号表的结构与静态链接的符号表几乎一样，可以简单地将导入函数看做是对其他目标文件函数的引用，把导出函数看做是在本目标文件定义的函数即可。</p>
</li>
<li><p>动态链接重定位表。动态链接下，可执行文件一旦依赖于其他共享对象，它的代码或数据中就会有对于导入符号的引用，这些导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。如果共享对象不是以PIC编译的，那么它需要在装载是被重定位；如果它是PIC编译的，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，其绝对地址被分离出来成了GOT，而GOT是数据段的一部分，需要重定位。</p>
<p>  装载时重定位跟静态链接中的目标文件重定位十分相似。静态链接中，目标文件里包含专门用于重定位信息的重定位表，如”.rel.txt”表示代码段的重定位表，”.rel.data”表示数据段的重定位表。类似地，动态链接中，重定位表分别为”.rel.dyn”和”.rel.plt”，前者是对数据引用的修正，修正的位置位于”.got”以及数据段，后者是对于函数引用的修正，修正的位置位于”.got.plt”。</p>
</li>
</ul>
<h5 id="动态链接的步骤"><a href="#动态链接的步骤" class="headerlink" title="动态链接的步骤"></a>动态链接的步骤</h5><p>动态链接的步骤基本上分为3步：启动动态链接器本身，然后是装载所有需要的共享对象，最后是重定位和初始化。</p>
<ol>
<li><p>动态链接器自举。普通共享对象文件的重定位工作由动态链接器完成，动态链接器本身本身不可以依赖于其他共享对象，其重定位工作由其自身完成，这需要动态链接器在启动时有一段非常精巧的代码可以完成这项艰巨的工作而同时不能用到全局和静态变量，甚至不能调用函数，这种具有一定限制的启动代码称为自举（Bootstrap）。</p>
</li>
<li><p>动态链接器获得控制权后，自举代码开始执行。自举代码首先找到自己的GOT，而GOT的第一个入口即是”.dynamic”段的偏移地址，由此找到了动态链接器本身的”.dynamic”段。通过”.dynamic”的信息，自举代码可以获得动态链接器本身的重定位表和符号表，从而得到动态链接器本身的重定位入口，先将他们全部重定位，然后动态链接器代码可以使用自己的全局变量和静态变量。</p>
</li>
<li><p>装载共享对象。自举完成后，动态链接器将可执行文件盒链接器本身的符号表合并到一个全局符号表中，然后开始寻找可执行文件依赖的共享对象。通过”.dynamic”段中类型的入口是DT_NEEDED的项，链接器可以列出可执行文件所依赖的所有共享对象，将他们的名字放入一个装载集合中。然后从集合中取出一个共享对象的名字，找到相应的文件后打开，读取相应的ELF文件头”.dynamic”段，然后将它相应的代码段和数据段映射到进程空间。如果这个ELF共享对象还依赖其他共享对象，则将所依赖的共享对象的名字放入装载集合中。如此循环把所有依赖对象都装载进内存为止。如果把依赖关系看做一个图的话，装载过程就是图的遍历过程，可以使用广度优先或深度优先搜索的顺序进行编译。</p>
<p> 重定位和初始化。上述步骤完成后，链接器开始重新遍历可执行文件和每个共享对象的重定位表，将他们的GOT/PLT中的每个需要重定位的位置进行修正。因为此时动态链接器已经拥有了进程的全局符号表，所以这个修正过程比较容易，和前面的地址重定位原理基本相同。</p>
<p> 重定位完成后，如果共享对象有”.init”段，那么动态链接器会执行”.init”段的代码，用来实现共享对象特有的初始化过程，比如共享对象中C++的全局/静态对象的构造。相应地，如果有”.finit”段，当进程退出时会执行”.finit”段中的代码，比如类似的C++全局对象的析构。而进程的可执行文件本身的的”.init”和”.finit”段不是由动态链接器执行，而是有运行库的初始化部分代码负责执行。</p>
</li>
</ol>
<p>重定位和初始化后，准备工作宣告完成，所需要的共享对象也都已经装载并且链接完成，这是动态链接器就如释重负，将进程的控制权交给程序的入口并开始执行。</p>
<h5 id="显式运行时链接"><a href="#显式运行时链接" class="headerlink" title="显式运行时链接"></a>显式运行时链接</h5><p>动态链接还有一种更加灵活的模块加载方式，称为显式运行时链接（Explicit Run-time Linking），也叫运行时加载。就是让程序自己在运行时控制加载指定的模块，并且可以在不需要该模块时将其卸载。一般的共享对象不需要进行任何修改就可以进行运行时加载，称为动态装载库（Dynamic Loading Library）。动态库的装载通过以下一系列的动态链接器API完成：</p>
<ul>
<li>dlopen：打开一个动态库，加载到进程的地址空间，完成初始化过程。</li>
<li>dysm：通过指定的动态库句柄找到制定的符号的地址。</li>
<li>dlerror：每次调用dlopen()、dlsym()或dlclose()以后，可以调用dlerror()来判断上一次调用是否成功。</li>
<li>dlclose：将一个已经加载的模块卸载。系统会维持一个加载引用计数器，每次使用dlopen()加载时，计数器加一；每次使用dlclose()卸载时，计数器减一。当计数器减到0时，模块才真正地卸载。</li>
</ul>
<p>下面是一个简单的例子，这个程序将数学库模块用运行时加载的方法加载到进程中，然后获取sin()函数符号地址，调用sin()并且返回结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">void</span> *handle;</div><div class="line">	<span class="keyword">double</span> (*func)(<span class="keyword">double</span>);</div><div class="line">	<span class="keyword">char</span> *error;</div><div class="line">	</div><div class="line">	handle = dlopen(argv[<span class="number">1</span>], RTLD_NOW);</div><div class="line">	<span class="keyword">if</span> (handle == <span class="literal">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Open library %s error: %s\n"</span>, argv[<span class="number">1</span>], dlerror());</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	func = dlsym(handle, <span class="string">"sin"</span>);</div><div class="line">	<span class="keyword">if</span> ( (error = dlerror()) != <span class="literal">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Symbol sin not found: %s\n"</span>, error);</div><div class="line">		<span class="keyword">goto</span> exit_runso;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%f\n"</span>, func(<span class="number">3.1415926</span>/<span class="number">2</span>));</div><div class="line">	</div><div class="line">	exit_runso:</div><div class="line">	dlclose(handle);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$gcc -o RunSoSimple RunSoSimple.c -ldl</div><div class="line">$./RunSoSimple /lib/libm-2.6.1.so</div><div class="line">1.000000</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正所谓圆越大，圆外圈的空白越大。你当前学习的知识很大程度上是由之前的某个知识引出的，我就是这种情况下开始看这本书的。书的内容没有涉及到很细节，但是对于这方面知识体系的建立很有帮助，让你对程序运行的背后机制有了深一层的了解，值得推荐。该文是一个学习笔记，转载自&lt;a href=
    
    </summary>
    
      <category term="程序员的自我修养" scheme="http://vinoit.me/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="装载" scheme="http://vinoit.me/tags/%E8%A3%85%E8%BD%BD/"/>
    
      <category term="链接" scheme="http://vinoit.me/tags/%E9%93%BE%E6%8E%A5/"/>
    
      <category term="库" scheme="http://vinoit.me/tags/%E5%BA%93/"/>
    
      <category term="程序员的自我修养" scheme="http://vinoit.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>位图法以及相关应用</title>
    <link href="http://vinoit.me/2016/11/09/bitmap/"/>
    <id>http://vinoit.me/2016/11/09/bitmap/</id>
    <published>2016-11-09T01:53:56.000Z</published>
    <updated>2016-11-09T03:06:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>位图（bitmap）是一种非常常用的结构，在索引，数据压缩等方面有广泛应用。例如在ext2文件系统中的索引节点位图，linux内核中的pid位图等。正因为位图运算在空间方面的优越性，很多语言都有直接对它的支持。如在C++的STL库中就有一个bitset容器。而在Java中，在java.util包下也有一个BitSet类用来实现位图运算。在位图中，每一位只有0或1，一般情况下就表示存在或者不存在。下图为所有位都为0的位图,其存储空间为2字节：<br><img src="/images/data-structure/bitmap-0.png" alt="位图"></p>
<h4 id="c语言实现"><a href="#c语言实现" class="headerlink" title="c语言实现"></a>c语言实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_BITS sizeof(int)</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5 <span class="comment">// 2^5=32</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1f <span class="comment">//掩码</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024*1024*1024 <span class="comment">//max number</span></span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> bitmap[MAX / INT_BITS];<span class="comment">//位图数组</span></div><div class="line"> </div><div class="line"><span class="comment">/*</span></div><div class="line"> </div><div class="line">* 设置第i位为1(先找到i所在的int元素，再设置对应的位)</div><div class="line"> </div><div class="line">* i &gt;&gt; SHIFT 相当于 i / (2 ^ SHIFT)，结果为所在int的下标</div><div class="line"> </div><div class="line">* i&amp;MASK相当于取i的最后5位，结果为所在int的对应位</div><div class="line"> </div><div class="line">*/</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line"> </div><div class="line">	bitmap[i &gt;&gt; SHIFT] |= <span class="number">1</span> &lt;&lt; (i &amp; MASK);</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//获取第i位</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line"> </div><div class="line">	<span class="keyword">return</span> bitmap[i &gt;&gt; SHIFT] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; MASK));</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//清除第i位（置0）</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line"> </div><div class="line">	<span class="keyword">return</span> bitmap[i &gt;&gt; SHIFT] &amp; ~(<span class="number">1</span> &lt;&lt; (i &amp; MASK));</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>判断是否重复（存在）、去重</p>
<p>  给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。</p>
<p>  解决方法：申请512M的内存一个bit位代表一个unsigned int值读入40亿个数，设置相应的bit位读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
</li>
<li><p>排序</p>
<p>  假设无重复数据，则位图法排序只需将存入位图的数据依次输出，便得到了排序后的数据。</p>
</li>
<li><p>存储数据（压缩）</p>
<p>  压缩和判重很多时候都是组合使用的。</p>
<ul>
<li>在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数？</li>
<li>给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</li>
</ul>
</li>
<li><p>搜索</p>
<p>  设计搜索剪枝时，需要保存已经搜索过的历史信息，有些情况下，可以使用位图减小历史信息数据所占空间。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>位图适用于数据规模大，但数据状态少的情况。同时位图在存在以下一些不足：</p>
<ul>
<li>存储离散数据利用率低 Bitmap申请空间时要根据最大的数来决定申请的空间大小，如果数据是离散的，那空间的利用率就会非常低。</li>
<li>不适合多状态 一个bit只能表示两种状态，如果要表示更多的状态，就需要更多的状态位来实现。如果一个数字需要多个状态位来表示的话，Bitmap的优越性也会大打折扣，而且复杂度却在增加。</li>
<li>可读性差 将数据抽象为bit不利于理解，尤其是用多个bit位来表示一个数时。</li>
<li>性能一般 需要维护额外的逻辑，计算速度会受到一定的影响。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;位图（bitmap）是一种非常常用的结构，在索引，数据压缩等方面有广泛应用。例如在ext2文件系统中的索引节点位图，linux内核中的pid
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://vinoit.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://vinoit.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://vinoit.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位图" scheme="http://vinoit.me/tags/%E4%BD%8D%E5%9B%BE/"/>
    
      <category term="压缩" scheme="http://vinoit.me/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://vinoit.me/2016/11/07/heap/"/>
    <id>http://vinoit.me/2016/11/07/heap/</id>
    <published>2016-11-07T07:42:09.000Z</published>
    <updated>2016-11-09T00:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="堆介绍"><a href="#堆介绍" class="headerlink" title="堆介绍"></a>堆介绍</h4><p>堆（也叫优先队列），是一棵完全二叉树，它的特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。堆可以用数组来存储，但为了和完全二叉树的性质对应，数组的0号元素不存储节点，0号元素可以用来记录堆的节点数量。由于是完全二叉树，假定<code>i</code>是其中某个节点，可定义如下操作：</p>
<ul>
<li>PARENT(i) = i/2</li>
<li>LEFT(i) = 2*i</li>
<li>RIGHT(i) = 2*i+1</li>
</ul>
<p>大顶堆以及数组存储：<br><img src="/images/data-structure/heap-0.png" alt=""></p>
<h4 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h4><p>对于大顶堆，如果父节点的值小于某个子节点，那么这个堆的性质就需要恢复，过程如下：<br><img src="/images/data-structure/heap-1.png" alt=""><br>这里的前提是i的左右孩子都是堆（在建堆的时候是自下而上的），然后在A[i]、A[LEFT(i)]、A[RIGHT(i)]中选择一个最大的，如果A[i]最大，则堆的性质没有被破坏，否则A[i]和某个孩子交换位置，然后使交换位置后的子节点重复上述过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//n为堆的容量大小 </span></div><div class="line">  <span class="keyword">int</span> left = LEFT(i);</div><div class="line">  <span class="keyword">int</span> right = RIGHT(i);</div><div class="line">  <span class="keyword">int</span> max = i;<span class="comment">//max记录最大节点的下标</span></div><div class="line">  <span class="keyword">if</span>(left &lt;= n)&#123;</div><div class="line">  		max = A[left] &gt; A[max] ? left : max;</div><div class="line">  &#125;      </div><div class="line">  <span class="keyword">if</span>(right &lt;= n) &#123;</div><div class="line">  		max = A[right] &gt; A[max] ? right : max;</div><div class="line">  &#125;    </div><div class="line">  <span class="keyword">if</span>(max != i)&#123;</div><div class="line">    swap(A, max, i);</div><div class="line">    maxHeapify(A, max, n);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>给定一个数组A，n=A.length,其子数组A[(n/2)+1..n]中的元素都是堆这颗完全二叉树的叶子节点，可以利用这个性质,先找到堆的最后一个非叶子节点（即为第n/2个节点），然后从该节点开始，从后往前逐个调整每个子树，使之称为堆，最终整个数组便是一个堆。来将这个数组转换成一个大顶堆，以下是一个示意图：<br><img src="/images/data-structure/heap-2.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i = n/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;</div><div class="line">    maxHeapify(A, i, n);<span class="comment">//依次向上维护堆的性质</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>给定一个数组A,使用堆排序的步骤如下：</p>
<ol>
<li>建堆</li>
<li>n:=heap-size,swap(A[1],A[n])</li>
<li>heap-size–</li>
<li>heapify(A,1,heap-size)//维护堆</li>
<li>if(heap-size&gt;0) goto (2)</li>
</ol>
<p>示意图：<br><img src="/images/data-structure/heap-3.png" alt=""><br><img src="/images/data-structure/heap-4.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	buildMaxHeap(A,n);</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</div><div class="line">		swap(A[<span class="number">1</span>],A[i]);</div><div class="line">		n--;</div><div class="line">		maxHeapify(A,<span class="number">1</span>,n);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>堆当作优先队列使用时，每个元素都有一个key，常见操作如下：</p>
<ul>
<li>insert(A,x):将元素x插入到队列中</li>
<li>maximum（A):返回最大key所在的元素</li>
<li>extract-max(A):返回并删除最大key所在的元素</li>
<li>increase-key(A,x,k):将元素x的key增加为k，假设k大于x</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapMaximun</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//error</span></div><div class="line">	<span class="keyword">return</span> A[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">heapExtractMax</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//error</span></div><div class="line">	<span class="keyword">int</span> max = A[<span class="number">1</span>];</div><div class="line">	A[<span class="number">1</span>] = A[n];</div><div class="line">	n--;</div><div class="line">	maxHeapify(A,<span class="number">1</span>,n);</div><div class="line">	<span class="keyword">return</span> max;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapIncreaseKey</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(key &lt; A[i]) error;</div><div class="line">	A[i] = key;</div><div class="line">	<span class="keyword">while</span>(i &gt; <span class="number">1</span> &amp;&amp; A[PARENT(i)] &lt; A[i])&#123;</div><div class="line">		swap(A[i],A[PARENT(i)]);</div><div class="line">		i = PARENT(i);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapInsert</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	A[++n] = x;</div><div class="line">	<span class="keyword">while</span>(n &gt; <span class="number">1</span> &amp;&amp; A[n] &gt; A[PARENT(n)])&#123;</div><div class="line">		swap(A[n],A[PARENT(n)]);</div><div class="line">		n = PARENT(n);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h4><ul>
<li><p>堆的最常见应用是堆排序，时间复杂度为O(N lg N)。如果是从小到大排序，用大顶堆；从大到小排序，用小顶堆。</p>
</li>
<li><p>在O(n lg k)时间内，将k个排序表合并成一个排序表，n为所有有序表中元素个数。</p>
</li>
<li><p>一个文件中包含了1亿个随机整数，如何快速的找到最大(小)的100万个数字?（时间复杂度：O（n lg k））</p>
<p>  【解析】取前100 万个整数，构造成了一棵数组方式存储的具有小顶堆，然后接着依次取下一个整数，如果它大于最小元素亦即堆顶元素，则将其赋予堆顶元素，然后用Heapify调整整个堆，如此下去，则最后留在堆中的100万个整数即为所求 100万个数字。该方法可大大节约内存。</p>
</li>
</ul>
<p>参考：</p>
<ul>
<li>《算法导论》</li>
</ul>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> 



</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;堆介绍&quot;&gt;&lt;a href=&quot;#堆介绍&quot; class=&quot;headerlink&quot; title=&quot;堆介绍&quot;&gt;&lt;/a&gt;堆介绍&lt;/h4&gt;&lt;p&gt;堆（也叫优先队列），是一棵完全二叉树，它的特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。堆可以用数组来存储，
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://vinoit.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://vinoit.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://vinoit.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="http://vinoit.me/tags/%E5%A0%86/"/>
    
      <category term="排序" scheme="http://vinoit.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Trie树介绍及实现（传统&amp;双数组）</title>
    <link href="http://vinoit.me/2016/11/02/trie-tree/"/>
    <id>http://vinoit.me/2016/11/02/trie-tree/</id>
    <published>2016-11-02T01:13:54.000Z</published>
    <updated>2016-11-09T00:47:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文属于一个整理性质，参考了几篇较好的文章，在文末给出参考链接。</p>
<h4 id="什么是Trie树"><a href="#什么是Trie树" class="headerlink" title="什么是Trie树"></a>什么是Trie树</h4><p>Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，<code>查询效率比较高</code>。</p>
<p>Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p>
<p>它有3个基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p>其结构大致如下：<br><img src="/images/data-structure/trie-tree-0.png" alt=""></p>
<h4 id="Trie树的传统实现"><a href="#Trie树的传统实现" class="headerlink" title="Trie树的传统实现"></a>Trie树的传统实现</h4><p>传统的实现方式中，每个节点都包含着一个指针数组，用于指向子节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">  <span class="keyword">bool</span> endOfWord;<span class="comment">//是否为单词的结尾</span></div><div class="line">  <span class="keyword">char</span> ch;</div><div class="line">  <span class="keyword">struct</span> Node* child[MAX_NUM]; <span class="comment">//26-tree-&gt;a, b ,c, .....z</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为可能有多个字符串拥有相同的前缀，所以用一个<code>bool</code>的字段来表示该字母是否为一个字符串的结尾。插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第i 次循环找到前i 个字母所对应的子树，然后进行相应的操作。其实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 26</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">  <span class="keyword">bool</span> endOfWord;<span class="comment">//是否为单词的结尾</span></div><div class="line">  <span class="keyword">char</span> ch;</div><div class="line">  <span class="keyword">struct</span> Node* child[MAX_NUM]; <span class="comment">//26-tree-&gt;a, b ,c, .....z</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> Node* ROOT; <span class="comment">//tree root</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">struct</span> Node* <span class="title">createNewNode</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">  <span class="comment">// create a new node</span></div><div class="line">  <span class="keyword">struct</span> Node *new_node = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</div><div class="line">  new_node-&gt;ch = ch;</div><div class="line">  new_node-&gt;endOfWord == <span class="literal">false</span>;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_NUM; i++)</div><div class="line">    new_node-&gt;child[i] = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">return</span> new_node;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialization</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//intiazation: creat an empty tree, with only a ROOT</span></div><div class="line">ROOT = createNewNode(<span class="string">' '</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">charToindex</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123; <span class="comment">//a "char" maps to an index&lt;br&gt;</span></div><div class="line"><span class="keyword">return</span> ch - <span class="string">'a'</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> chars[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">  <span class="keyword">struct</span> Node* ptr = ROOT;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(i &lt; len) &#123;</div><div class="line">   <span class="keyword">if</span>(ptr-&gt;child[charToindex(chars[i])] == <span class="literal">NULL</span>) &#123;</div><div class="line">   <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  ptr = ptr-&gt;child[charToindex(chars[i])];</div><div class="line">  i++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (i == len) &amp;&amp; (ptr-&gt;endOfWord == <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> chars[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">  <span class="keyword">struct</span> Node* ptr = ROOT;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">   <span class="keyword">if</span>(ptr-&gt;child[charToindex(chars[i])] == <span class="literal">NULL</span>) &#123;</div><div class="line">    ptr-&gt;child[charToindex(chars[i])] = createNewNode(chars[i]);</div><div class="line">  &#125;</div><div class="line">  ptr = ptr-&gt;child[charToindex(chars[i])];</div><div class="line">&#125;</div><div class="line">  ptr-&gt;endOfWord = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>trie树的检索，插入，删除都很快，但是它占用了很大的内存空间，而且空间的复杂度是基于节点的个数和字符的个数。如果是纯单词，而且兼顾大小写的话，每个节点就要分配52*4的内存空间，耗费很大。</p>
<h4 id="Trie树的双数组实现"><a href="#Trie树的双数组实现" class="headerlink" title="Trie树的双数组实现"></a>Trie树的双数组实现</h4><p>该实现基本上是按照该文的算法：<a href="http://blog.csdn.net/zzran/article/details/8462002" target="_blank" rel="external">http://blog.csdn.net/zzran/article/details/8462002</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleArrayTrie</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="keyword">char</span> END_CHAR = <span class="string">'#'</span>;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LEN = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">int</span> Base[]  = <span class="keyword">new</span> <span class="keyword">int</span> [DEFAULT_LEN];</div><div class="line">	<span class="keyword">int</span> Check[] = <span class="keyword">new</span> <span class="keyword">int</span> [DEFAULT_LEN];</div><div class="line">	<span class="keyword">char</span> Tail[] = <span class="keyword">new</span> <span class="keyword">char</span> [DEFAULT_LEN];</div><div class="line">	<span class="keyword">int</span> Pos = <span class="number">1</span>;<span class="comment">//TAIL数组下一个可用下标</span></div><div class="line">	<span class="comment">//用于将字符转换为索引</span></div><div class="line">	Map&lt;Character ,Integer&gt; CharMap = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</div><div class="line">	<span class="comment">//用于将索引转换为字符</span></div><div class="line">	ArrayList&lt;Character&gt; CharList = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DoubleArrayTrie</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">	<span class="comment">//一系列初始化</span></div><div class="line">		Base[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"></div><div class="line">		CharMap.put(END_CHAR,<span class="number">1</span>);</div><div class="line">		CharList.add(END_CHAR);</div><div class="line">		CharList.add(END_CHAR);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="comment">//a对应2，z对应27</span></div><div class="line">		&#123;</div><div class="line">			CharMap.put((<span class="keyword">char</span>)(<span class="string">'a'</span>+i),CharMap.size()+<span class="number">1</span>);</div><div class="line">			CharList.add((<span class="keyword">char</span>)(<span class="string">'a'</span>+i));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Extend_Array</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		Base = Arrays.copyOf(Base, Base.length*<span class="number">2</span>);</div><div class="line">		Check = Arrays.copyOf(Check, Check.length*<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Extend_Tail</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		Tail = Arrays.copyOf(Tail, Tail.length*<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">GetCharCode</span><span class="params">(<span class="keyword">char</span> c)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (!CharMap.containsKey(c))</div><div class="line">		&#123;</div><div class="line">			CharMap.put(c,CharMap.size()+<span class="number">1</span>);</div><div class="line">			CharList.add(c);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> CharMap.get(c);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">CopyToTailArray</span><span class="params">(String s,<span class="keyword">int</span> p)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> _Pos = Pos;</div><div class="line">		<span class="keyword">while</span>(s.length()-p+<span class="number">1</span> &gt; Tail.length-Pos)</div><div class="line">		&#123;</div><div class="line">			Extend_Tail();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=p; i&lt;s.length();++i)</div><div class="line">		&#123;</div><div class="line">			Tail[_Pos] = s.charAt(i);</div><div class="line">			_Pos++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> _Pos;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">x_check</span><span class="params">(Integer []set)</span><span class="comment">//获得一个可行的最小base，set中的每一个下标都要是空闲的</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; ; ++i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;set.length;++j)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> cur_p = i+set[j];</div><div class="line">				<span class="keyword">if</span>(cur_p&gt;= Base.length) Extend_Array();</div><div class="line">				<span class="keyword">if</span>(Base[cur_p]!= <span class="number">0</span> || Check[cur_p]!= <span class="number">0</span>)<span class="comment">//必须是空闲未使用的</span></div><div class="line">				&#123;</div><div class="line">					flag = <span class="keyword">false</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (flag) <span class="keyword">return</span> i;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">GetChildList</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//p为父状态</span></span></div><div class="line">	&#123;</div><div class="line">		ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=CharMap.size();++i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(Base[p]+i &gt;= Check.length) <span class="keyword">break</span>;</div><div class="line">			<span class="keyword">if</span>(Check[Base[p]+i] == p)</div><div class="line">			&#123;</div><div class="line">				ret.add(i);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">TailContainString</span><span class="params">(<span class="keyword">int</span> start,String s2)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.length();++i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(s2.charAt(i) != Tail[i+start]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">TailMatchString</span><span class="params">(<span class="keyword">int</span> start,String s2)</span></span></div><div class="line">	&#123;</div><div class="line">		s2 += END_CHAR;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.length();++i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(s2.charAt(i) != Tail[i+start]) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span></div><div class="line">	&#123;</div><div class="line">		s += END_CHAR;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> pre_p = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> cur_p;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//获取状态位置</span></div><div class="line">			cur_p = Base[pre_p]+GetCharCode(s.charAt(i));</div><div class="line">			<span class="comment">//如果长度超过现有，拓展数组</span></div><div class="line">			<span class="keyword">if</span> (cur_p &gt;= Base.length) Extend_Array();</div><div class="line"></div><div class="line">			<span class="comment">//空闲状态</span></div><div class="line">			<span class="keyword">if</span>(Base[cur_p] == <span class="number">0</span> &amp;&amp; Check[cur_p] == <span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				Base[cur_p] = -Pos;<span class="comment">//pos是TAIL数组的下标</span></div><div class="line">				Check[cur_p] = pre_p;<span class="comment">//CHECK中为对应的父状态</span></div><div class="line">				Pos = CopyToTailArray(s,i+<span class="number">1</span>);<span class="comment">//将尾串直接存储到TAIL数组，并更新pos</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;<span class="keyword">else</span></div><div class="line">			<span class="comment">//已存在状态</span></div><div class="line">			<span class="keyword">if</span>(Base[cur_p] &gt; <span class="number">0</span> &amp;&amp; Check[cur_p] == pre_p)</div><div class="line">			&#123;</div><div class="line">				pre_p = cur_p;<span class="comment">//更新pre_p,切换到下一个状态</span></div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;<span class="keyword">else</span></div><div class="line">			<span class="comment">//冲突 1：遇到 Base[cur_p]小于0的，即遇到一个被压缩存到Tail中的字符串</span></div><div class="line">			<span class="keyword">if</span>(Base[cur_p] &lt; <span class="number">0</span> &amp;&amp; Check[cur_p] == pre_p)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> head = -Base[cur_p];<span class="comment">//head为TAIL数组的下标</span></div><div class="line"></div><div class="line">				<span class="keyword">if</span>(s.charAt(i+<span class="number">1</span>)== END_CHAR &amp;&amp; Tail[head]==END_CHAR)	<span class="comment">//插入重复字符串</span></div><div class="line">				&#123;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="comment">//公共字母的情况，因为上一个判断已经排除了结束符，所以一定是2个都不是结束符</span></div><div class="line">				<span class="keyword">if</span> (Tail[head] == s.charAt(i+<span class="number">1</span>))</div><div class="line">				&#123;</div><div class="line">					<span class="comment">//因为和TAIL数组中的尾串字母重复，则这两个字母需要提取出来共用一个状态，需要一个新的base</span></div><div class="line">					<span class="keyword">int</span> avail_base = x_check(<span class="keyword">new</span> Integer[]&#123;GetCharCode(s.charAt(i+<span class="number">1</span>))&#125;);</div><div class="line">					Base[cur_p] = avail_base;<span class="comment">//更新当前状态的base</span></div><div class="line"></div><div class="line">					<span class="comment">//修改CHECK数组和BASE数组</span></div><div class="line">					Check[avail_base+GetCharCode(s.charAt(i+<span class="number">1</span>))] = cur_p;</div><div class="line">					<span class="comment">//论文中是将数组的字符串左移，这边是将下标右移，节省了几步操作</span></div><div class="line">					Base[avail_base+GetCharCode(s.charAt(i+<span class="number">1</span>))] = -(head+<span class="number">1</span>);</div><div class="line">					pre_p = cur_p;</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span></div><div class="line">				&#123;</div><div class="line">					<span class="comment">//2个字母不相同的情况，可能有一个为结束符。同时需要将这个两个不同的字符给提取出来，</span></div><div class="line">					<span class="comment">//分配到两个不同的状态，也就是不同的index，需要新的base</span></div><div class="line">					<span class="keyword">int</span> avail_base ;</div><div class="line">					avail_base = x_check(<span class="keyword">new</span> Integer[]&#123;GetCharCode(s.charAt(i+<span class="number">1</span>)),GetCharCode(Tail[head])&#125;);</div><div class="line"></div><div class="line">					Base[cur_p] = avail_base;<span class="comment">//更新base</span></div><div class="line"></div><div class="line">					<span class="comment">//修改新的CHECK数组的值为cur_p(父状态)</span></div><div class="line">					Check[avail_base+GetCharCode(Tail[head])] = cur_p;</div><div class="line">					Check[avail_base+GetCharCode(s.charAt(i+<span class="number">1</span>))] = cur_p;</div><div class="line"></div><div class="line">					<span class="comment">//Tail 为END_FLAG 的情况</span></div><div class="line">					<span class="keyword">if</span>(Tail[head] == END_CHAR)</div><div class="line">						Base[avail_base+GetCharCode(Tail[head])] = <span class="number">0</span>;</div><div class="line">					<span class="keyword">else</span><span class="comment">//修改为TAIL数组在剩余尾串的下标</span></div><div class="line">						Base[avail_base+GetCharCode(Tail[head])] = -(head+<span class="number">1</span>);</div><div class="line">					<span class="keyword">if</span>(s.charAt(i+<span class="number">1</span>) == END_CHAR)</div><div class="line">						Base[avail_base+GetCharCode(s.charAt(i+<span class="number">1</span>))] = <span class="number">0</span>;</div><div class="line">					<span class="keyword">else</span></div><div class="line">						Base[avail_base+GetCharCode(s.charAt(i+<span class="number">1</span>))] = -Pos;</div><div class="line"></div><div class="line">					Pos = CopyToTailArray(s,i+<span class="number">2</span>);<span class="comment">//插入串的剩余部分插入到TAIL数组中</span></div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;<span class="keyword">else</span></div><div class="line">			<span class="comment">//冲突2：当前结点已经被占用，需要调整pre的base，然后将之前的数据迁移到新的base</span></div><div class="line">			<span class="keyword">if</span>(Check[cur_p] != pre_p)</div><div class="line">			&#123;</div><div class="line">				ArrayList&lt;Integer&gt; list = GetChildList(pre_p);<span class="comment">//获取所有子状态</span></div><div class="line">				<span class="keyword">int</span> origin_base = Base[pre_p];<span class="comment">//保存原来的base</span></div><div class="line">				list.add(GetCharCode(s.charAt(i)));</div><div class="line">				<span class="comment">//新base</span></div><div class="line">				<span class="keyword">int</span> avail_base = x_check(list.toArray(<span class="keyword">new</span> Integer[list.size()]));</div><div class="line">				list.remove(list.size()-<span class="number">1</span>);</div><div class="line">				<span class="comment">//更新base</span></div><div class="line">				Base[pre_p] = avail_base;</div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;list.size(); ++j)</div><div class="line">				&#123;</div><div class="line">					<span class="comment">//迁移数据</span></div><div class="line">					<span class="keyword">int</span> tmp1 = origin_base + list.get(j);</div><div class="line">					<span class="keyword">int</span> tmp2 = avail_base + list.get(j);</div><div class="line">					Base[tmp2] = Base[tmp1];</div><div class="line">					Check[tmp2] = Check[tmp1];</div><div class="line"></div><div class="line">					<span class="comment">//有后续</span></div><div class="line">					<span class="keyword">if</span>(Base[tmp1] &gt; <span class="number">0</span>)</div><div class="line">					&#123;</div><div class="line">						ArrayList&lt;Integer&gt; subsequence = GetChildList(tmp1);</div><div class="line">						<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;subsequence.size(); ++k)</div><div class="line">						&#123;</div><div class="line">							Check[Base[tmp1]+subsequence.get(k)] = tmp2;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					<span class="comment">//将之前的数组槽置为空闲</span></div><div class="line">					Base[tmp1] = <span class="number">0</span>;</div><div class="line">					Check[tmp1] = <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="comment">//更新新的cur_p</span></div><div class="line">				cur_p = Base[pre_p]+GetCharCode(s.charAt(i));</div><div class="line"></div><div class="line">				<span class="keyword">if</span>(s.charAt(i) == END_CHAR)</div><div class="line">					Base[cur_p] = <span class="number">0</span>;</div><div class="line">				<span class="keyword">else</span></div><div class="line">					Base[cur_p] = -Pos;</div><div class="line">				Check[cur_p] = pre_p;</div><div class="line">				Pos = CopyToTailArray(s,i+<span class="number">1</span>);<span class="comment">//同样，将插入串剩余的部分插入TAIL数组</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Exists</span><span class="params">(String word)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> pre_p = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> cur_p = <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();++i)</div><div class="line">		&#123;</div><div class="line">			cur_p = Base[pre_p]+GetCharCode(word.charAt(i));</div><div class="line">			<span class="keyword">if</span>(Check[cur_p] != pre_p) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			<span class="keyword">if</span>(Base[cur_p] &lt; <span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(TailMatchString(-Base[cur_p],word.substring(i+<span class="number">1</span>)))</div><div class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">			pre_p = cur_p;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(Check[Base[cur_p]+GetCharCode(END_CHAR)] == cur_p)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">FindStruct</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> p;</div><div class="line">		String prefix=<span class="string">""</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> FindStruct <span class="title">Find</span><span class="params">(String word)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> pre_p = <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> cur_p = <span class="number">0</span>;</div><div class="line">		FindStruct fs = <span class="keyword">new</span> FindStruct();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();++i)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">// BUG</span></div><div class="line">			fs.prefix += word.charAt(i);</div><div class="line">			cur_p = Base[pre_p]+GetCharCode(word.charAt(i));</div><div class="line">			<span class="keyword">if</span>(Check[cur_p] != pre_p)</div><div class="line">			&#123;</div><div class="line">				fs.p = -<span class="number">1</span>;</div><div class="line">				<span class="keyword">return</span> fs;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(Base[cur_p] &lt; <span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(TailContainString(-Base[cur_p],word.substring(i+<span class="number">1</span>)))</div><div class="line">				&#123;</div><div class="line">					fs.p = cur_p;</div><div class="line">					<span class="keyword">return</span> fs;</div><div class="line">				&#125;</div><div class="line">				fs.p = -<span class="number">1</span>;</div><div class="line">				<span class="keyword">return</span> fs;</div><div class="line">			&#125;</div><div class="line">			pre_p = cur_p;</div><div class="line">		&#125;</div><div class="line">		fs.p =  cur_p;</div><div class="line">		<span class="keyword">return</span> fs;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">GetAllChildWord</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line">	&#123;</div><div class="line">		ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		<span class="keyword">if</span>(Base[index] == <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			result.add(<span class="string">""</span>);</div><div class="line">			<span class="keyword">return</span> result;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(Base[index] &lt; <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			String r=<span class="string">""</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=-Base[index];Tail[i]!=END_CHAR;++i)</div><div class="line">			&#123;</div><div class="line">				r+= Tail[i];</div><div class="line">			&#125;</div><div class="line">			result.add(r);</div><div class="line">			<span class="keyword">return</span> result;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=CharMap.size();++i)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(Check[Base[index]+i] == index)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">for</span>(String s:GetAllChildWord(Base[index]+i))</div><div class="line">				&#123;</div><div class="line">					result.add(CharList.get(i)+s);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">//result.addAll(GetAllChildWord(Base[index]+i));</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">FindAllWords</span><span class="params">(String word)</span></span></div><div class="line">	&#123;</div><div class="line">		ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		String prefix = <span class="string">""</span>;</div><div class="line">		FindStruct fs = Find(word);</div><div class="line">		<span class="keyword">int</span> p = fs.p;</div><div class="line">		<span class="keyword">if</span> (p == -<span class="number">1</span>) <span class="keyword">return</span> result;</div><div class="line">		<span class="keyword">if</span>(Base[p]&lt;<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			String r=<span class="string">""</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=-Base[p];Tail[i]!=END_CHAR;++i)</div><div class="line">			&#123;</div><div class="line">				r+= Tail[i];</div><div class="line">			&#125;</div><div class="line">			result.add(fs.prefix+r);</div><div class="line">			<span class="keyword">return</span> result;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(Base[p] &gt; <span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			ArrayList&lt;String&gt; r =  GetAllChildWord(p);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r.size();++i)</div><div class="line">			&#123;</div><div class="line">				r.set(i, fs.prefix+r.get(i));</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> r;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Trie树的应用"><a href="#Trie树的应用" class="headerlink" title="Trie树的应用"></a>Trie树的应用</h4><ol>
<li><p>字符串检索，词频统计，搜索引擎的热门查询</p>
<p> 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。举例：</p>
<ol>
<li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
<li>给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</li>
<li>给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。</li>
<li>1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串</li>
<li>寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</li>
</ol>
</li>
<li><p>字符串最长公共前缀</p>
<p> Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。举例：</p>
<ol>
<li><p>给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少.  解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线  （Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法：</p>
<ol>
<li>利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法；</li>
<li>求出字母树的欧拉序列（Euler Sequence ）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了；</li>
</ol>
</li>
</ol>
</li>
<li><p>排序</p>
<p>Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。举例： 给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。</p>
</li>
<li>作为其他数据结构和算法的辅助结构如后缀树，AC自动机等。</li>
</ol>
<p>参考：</p>
<ul>
<li><a href="http://turbopeter.github.io/2013/09/02/prefix-match/" target="_blank" rel="external">http://turbopeter.github.io/2013/09/02/prefix-match/</a></li>
<li><a href="http://blog.csdn.net/zzran/article/details/8462002" target="_blank" rel="external">http://blog.csdn.net/zzran/article/details/8462002</a></li>
<li><a href="http://dongxicheng.org/structure/trietree/" target="_blank" rel="external">http://dongxicheng.org/structure/trietree/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文属于一个整理性质，参考了几篇较好的文章，在文末给出参考链接。&lt;/p&gt;
&lt;h4 id=&quot;什么是Trie树&quot;&gt;&lt;a href=&quot;#什么是Trie树&quot; class=&quot;headerlink&quot; title=&quot;什么是Trie树&quot;&gt;&lt;/a&gt;什么是Trie树&lt;/h4&gt;&lt;p&gt;Trie树，
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://vinoit.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://vinoit.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://vinoit.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="trie树" scheme="http://vinoit.me/tags/trie%E6%A0%91/"/>
    
      <category term="字符串" scheme="http://vinoit.me/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>红黑树介绍及实现</title>
    <link href="http://vinoit.me/2016/10/30/rb-tree/"/>
    <id>http://vinoit.me/2016/10/30/rb-tree/</id>
    <published>2016-10-30T04:07:38.000Z</published>
    <updated>2016-11-09T00:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自平衡二叉查找树（AVL）"><a href="#自平衡二叉查找树（AVL）" class="headerlink" title="自平衡二叉查找树（AVL）"></a>自平衡二叉查找树（AVL）</h4><p>了解自平衡二叉查找树前，先讲讲二叉查找树。二叉查找树是一颗二叉树，对于其中的每一个节点，左孩子小于自己，右孩子大于自己。在插入一个节点时，判断插入节点与当前遍历的树节点的大小，若小于当前树节点，则与左孩子比较，反之，则与右孩子比较。<br><img src="/images/data-structure/rb-tree-0.png" alt=""><br>但是，一颗普通的二叉查找树容易退化成链表：<br><img src="/images/data-structure/rb-tree-1.png" alt=""><br>我们希望一颗二叉查找树的时间复杂度为O（logn）,而这种情况下时间复杂度已经变成了O（n）。所以就出现了<code>自平衡二叉查找树</code>。</p>
<p>在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。</p>
<p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<p>当失去平衡时，就需要通过所谓的<code>AVL旋转</code>来恢复平衡。以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。<br><img src="/images/data-structure/rb-tree-2.png" alt=""></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>AVL有几种不同的实现方式，红黑树就是其中一种，其他常见的还有树堆（Treap,树和堆的合并写法）、伸展树（Splay）等。它们之间的具体区别有兴趣的同学可以Google下，<code>总的来说红黑树是功能、性能、空间开销的折中结果</code>。以下比较来自知乎：</p>
<blockquote>
<p>AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。</p>
<p>红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。</p>
<p>Splay Tree，读取维护速度不稳定，属于理论上的统计logN时间复杂度，特殊情况下能直接退化为链表，空间最节省，部分功能优于前两者。</p>
<p>Treap，速度快，功能有缺失。</p>
<p>作者：Coldwings<br>链接：<a href="https://www.zhihu.com/question/20545708/answer/44370878" target="_blank" rel="external">https://www.zhihu.com/question/20545708/answer/44370878</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
</blockquote>
<p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求，每次改动之后都必须保证不破坏这些性质，或者破坏之后恢复：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
<p>下面是一个具体的红黑树的图例：<br><img src="/images/data-structure/rb-tree-3.png" alt=""><br>“nil叶子”或”空（null）叶子”不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。</p>
<p>因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再匹配红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>红黑树作为一颗特殊的二叉树，在插入的第一阶段和普通二叉树一样，先不考虑是否破坏红黑树的性质，而是找到一个合适的插入位置，这个位置处于树分支的最底下的某个节点。</p>
<p>注：未出现的数据结构和函数可在附录找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数z为需插入的节点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(treeNodeP&amp; root,treeNodeP z)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        root = z;</div><div class="line">        root-&gt;color = BLACK;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    treeNodeP y = NIL;</div><div class="line">    treeNodeP x = root;</div><div class="line">    <span class="keyword">while</span>(x != NIL)&#123;</div><div class="line">        y = x;</div><div class="line">        <span class="keyword">if</span>(z-&gt;val &lt; x-&gt;val)&#123;<span class="comment">//插入节点的值小于当前比较的树节点</span></div><div class="line">            x = x-&gt;leftChild;<span class="comment">//切换到左孩子</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            x = x-&gt;rightChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    z-&gt;parent = y;<span class="comment">//y就是插入节点的父节点，y是没有左右孩子的</span></div><div class="line">    <span class="keyword">if</span>(y == NIL)&#123;</div><div class="line">        root = z;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;val &lt; y-&gt;val)&#123;<span class="comment">//判断插入节点应该是左孩子还是右孩子</span></div><div class="line">        y-&gt;leftChild = z;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        y-&gt;rightChild = z;</div><div class="line">    &#125;</div><div class="line">    insertFixup(root,z);<span class="comment">//此函数用于在插入新节点后恢复红黑树的性质</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的新插入节点都是红色的，这样的话不会破坏性质5。插入节点是红色的，如果父节点是黑色的，红黑树的任何性质都不会被破坏，所以在插入时需要恢复的所有情况下，插入节点的父节点都是红色的。因为红色节点不会连续，所以祖父节点必定是黑色的。<strong>把叔叔节点为红色分为情况一;叔叔节点是黑色，而自己为父节点的右孩子分为情况二;叔叔节点是黑色，自己为父节点的左孩子分为情况三。</strong>以上三种情况针对插入节点属于祖父节点的左分支，右分支的情况类似。<code>insertFixup</code>函数会将情况一和情况二转换（构造）为情况三，然后情况三通过一个旋转操作后就可以恢复红黑树的性质。下图中深色的表示黑色，z为新插入节点，y为z的叔叔。<br><img src="/images/data-structure/rb-tree-4.png" alt=""><br>在上图的情况一中，如果2号节点是黑色的，那么只要一遍染色就恢复了红黑树性质，无需转换为情况二、三了。最后的(d)图就是恢复红黑树性质的树。</p>
<p>调用<code>insertFixup</code>函数来恢复红黑树的性质，参数<code>z</code>为新插入的节点,<code>z</code>在插入前<code>需要已被初始化为红色</code>(初始化函数查看附录)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertFixup</span><span class="params">(treeNodeP&amp; root, treeNodeP z)</span></span>&#123;</div><div class="line"><span class="comment">//如果插入节点z的父节点是黑色的，那么插入的红色节点不破坏任何红黑树的性质</span></div><div class="line">    <span class="keyword">while</span> (z-&gt;parent &amp;&amp; z-&gt;parent-&gt;color == RED) &#123;</div><div class="line">    <span class="comment">//插入节点z处于祖父的左分支</span></div><div class="line">        <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;leftChild)&#123;</div><div class="line">	        <span class="comment">//y是插入节点z的叔叔</span></div><div class="line">            treeNodeP y = z-&gt;parent-&gt;parent-&gt;rightChild;</div><div class="line">			 <span class="comment">//情况一</span></div><div class="line">            <span class="keyword">if</span>(y-&gt;color == RED)&#123;</div><div class="line">                y-&gt;color = BLACK;</div><div class="line">                z-&gt;parent-&gt;color = BLACK;</div><div class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">                z = z-&gt;parent-&gt;parent;</div><div class="line">            &#125;<span class="comment">//情况二</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z == z-&gt;parent-&gt;rightChild)&#123;</div><div class="line">                z = z-&gt;parent;</div><div class="line">                leftRotate(root, z);</div><div class="line">            &#125;<span class="comment">//情况三</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                z-&gt;parent-&gt;color = BLACK;</div><div class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">                rightRoate(root, z-&gt;parent-&gt;parent);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;<span class="comment">//插入节点z处于祖父节点的右分支，和上面的代码左右互反即可</span></div><div class="line">            treeNodeP y = z-&gt;parent-&gt;parent-&gt;leftChild;</div><div class="line">            <span class="keyword">if</span>(y-&gt;color == RED)&#123;</div><div class="line">                y-&gt;color = BLACK;</div><div class="line">                z-&gt;parent-&gt;color = BLACK;</div><div class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">                z = z-&gt;parent-&gt;parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z == z-&gt;parent-&gt;leftChild)&#123;</div><div class="line">                z = z-&gt;parent;</div><div class="line">                rightRoate(root, z);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                z-&gt;parent-&gt;color = BLACK;</div><div class="line">                z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">                leftRotate(root, z-&gt;parent-&gt;parent);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        root-&gt;color = BLACK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除一个节点同样可能破坏红黑树的性质，然而和插入的时候一样，在删除的第一阶段，同样先不考虑颜色，先按照一颗普通二叉树将节点正常删除，然后再恢复。普通二叉查找树在几种情况下的删除示意图如下（z为需删除的节点）：<br><img src="/images/data-structure/rb-tree-5.png" alt=""><br>上面的图里面没有<code>z</code>的两个孩子都是NIL的情况，因为这种情况其实可以合并到第一种情况中，最后的结果是一样的。当<code>z</code>的左右孩子都不为NIL时，需要找到z的右孩子分支中的最左（小）节点，用于替换<code>z</code>（貌似左孩子的最右（大）节点也是可以的）。图（c）和图(d)中的<code>y</code>就是<code>z</code>的右孩子的最左（小）节点，<code>z</code>被删除后<code>y</code>就用于顶替<code>z</code>的位置,<strong>同时<code>y</code>被染上与<code>z</code>同样的颜色（这个染色只有在（c）、(d)的情况下）</strong>。</p>
<p><code>del</code>函数就是按照上面的示意图实现的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(treeNodeP&amp; root,treeNodeP z)</span></span>&#123;</div><div class="line">    <span class="keyword">bool</span> originalColor = z-&gt;color;<span class="comment">//（a）、(b)情况下的删除节点的颜色</span></div><div class="line">    treeNodeP x = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span>(z-&gt;leftChild == NIL)&#123;<span class="comment">//z的左节点为NIL，用右节点替换z</span></div><div class="line">        x = z-&gt;rightChild;</div><div class="line">        translate(root, z, x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;rightChild == NIL)&#123;<span class="comment">//z的右节点为NIL，用左节点替换z</span></div><div class="line">        x = z-&gt;leftChild;</div><div class="line">        translate(root, z, x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        treeNodeP y = treeMiniMum(z-&gt;rightChild);<span class="comment">//y为z的后继节点（z删除后用y替换）</span></div><div class="line">        originalColor = y-&gt;color;<span class="comment">//因为y要用来替换z，所以需要记住y的原来颜色</span></div><div class="line">        x = y-&gt;rightChild;<span class="comment">//x为y移走后替换y的节点</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(y-&gt;parent == z)&#123;</div><div class="line">            x-&gt;parent = y;<span class="comment">//如果x==NIL时有用</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            translate(root, y, x);<span class="comment">//x替换y</span></div><div class="line">            y-&gt;rightChild = z-&gt;rightChild;<span class="comment">//y替换z（和z的右孩子建立联系）</span></div><div class="line">            y-&gt;rightChild-&gt;parent = y;<span class="comment">//y替换z（和z的右孩子建立联系）</span></div><div class="line">        &#125;</div><div class="line">        translate(root, z, y);<span class="comment">//y替换z（和z的父节点建立联系）</span></div><div class="line">        y-&gt;leftChild = z-&gt;leftChild;<span class="comment">//y替换z（和z的左孩子建立联系）</span></div><div class="line">        y-&gt;leftChild-&gt;parent = y;<span class="comment">//y替换z（和z的左孩子建立联系）</span></div><div class="line">        y-&gt;color = z-&gt;color;<span class="comment">//此时y已成功替换了z,将z的颜色赋予y</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(originalColor == BLACK)&#123;<span class="comment">//原因在下文给出</span></div><div class="line">        delFixup(root, x);<span class="comment">//删除完成后修复红黑树的性质</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于（a）、（b）来说，删除节点至少有一个是NIL节点，<code>如果删除节点是红色的</code>，则性质5没有被破坏，其他性质也一样，无需恢复。为什么性质5没有被破坏呢？因为对于其中一个NIL节点来说，在删除节点后就没有黑色节点了，所以在删除节点的另一个分支上，也不会出现任何黑色节点，用于替换删除节点的那个节点只可能是红色的。<code>如果删除节点是黑色的</code>,那么删除节点的2个分支的性质5都被破坏了，此时需要恢复。</p>
<p>对于（c）、(d)来说，因为删除节点被替换的时候包括颜色，所以删除节点处的性质都能保持，重点就是替换节点了 。<code>如果替换节点是红色的</code>，那么替换节点处的性质也能保持。<code>如果替换节点是黑色的</code>，那么替换节点的分支处的红黑树性质就会被破坏，最明显的就是性质5，因为少了个黑色节点。</p>
<p><strong>综上，对于（a)(b),在删除节点是黑色时，性质被破坏。对于(c)(d)，替换节点是黑色时，性质被破坏。</strong></p>
<p>现在来看下如何恢复。</p>
<p>对于(a)(b)的情况，如果替换的节点是红色的，那么直接将该节点的颜色染成黑色便可以了。如果替换的节点是NIL（这种情况是2个子节点都是NIL），那么将这种情况分到(c)(d)中去。</p>
<p>对于(c)(d)的情况，如果替换y节点的x节点是红色的，同样直接将颜色染成黑色就可以了(注意：x为替换y的那个节点，y替换了删除节点z)。如果x节点是黑色的，可分为如下4种情况，这4种情况针对x为左孩子，右孩子的情况类似(黑色最深)：<br><img src="/images/data-structure/rb-tree-6.png" alt=""></p>
<ul>
<li>情况一：x的兄弟节点w是红色的。</li>
<li>情况二：x的兄弟节点w是黑色的，w的两个孩子也是黑色的。</li>
<li>情况三：x的兄弟节点w是黑色的，w的左孩子是红色的，右孩子是黑色的。</li>
<li>情况四：x的兄弟节点w是黑色的，w的右孩子是红色的。</li>
</ul>
<p>因为少了一个黑色节点，x在某种意义上就是<code>双重黑色</code>了，但要想办法把这个黑色抽出来。上面4种情况的最终目标是转换为情况四，在情况四中可以通过旋转和染色，把失去的黑色给重新补回来。所以恢复时，将黑色不断地往上移，过程中不能破坏原有的性质，当黑色移动到了根节点，或者构造出了情况四，就可以恢复红黑树性质了。</p>
<p><code>delFixup</code>函数实现如下(<strong>这个实现是有一点问题的，因为树的每一个NIL节点都是独立的，而我在实现的时候只有一个NIL对象，所有需要用的地方都使用了这一个。当在恢复红黑树性质的过程中涉及到了多个节点的左右孩子（孩子又是NIL节点）时，因为无法区分，所以会出现问题。但是这个NIL节点在上面的插入函数中不影响结果。在这个函数当中的NIL节点你可以把它当做是独立的来看待（虽然不是独立的^-^）。</strong>):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delFixup</span><span class="params">(treeNodeP&amp; root,treeNodeP x)</span></span>&#123;</div><div class="line">   </div><div class="line">    treeNodeP w = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(x != root &amp;&amp; x-&gt;color == BLACK)&#123;</div><div class="line">    <span class="comment">//x是左孩子</span></div><div class="line">        <span class="keyword">if</span>(x == x-&gt;parent-&gt;leftChild)&#123;</div><div class="line">            w = x-&gt;parent-&gt;rightChild;<span class="comment">//w是x的兄弟节点</span></div><div class="line">            <span class="comment">//情况一</span></div><div class="line">            <span class="keyword">if</span>(w-&gt;color == RED)&#123;</div><div class="line">                w-&gt;color = BLACK;</div><div class="line">                x-&gt;parent-&gt;color= RED;<span class="comment">//w为x的兄弟，w为RED，则父节点之前不可能为RED</span></div><div class="line">                leftRotate(root, x-&gt;parent);</div><div class="line">                w = x-&gt;parent-&gt;rightChild;</div><div class="line">                </div><div class="line">            &#125;<span class="comment">//情况二</span></div><div class="line">            <span class="keyword">if</span>(w-&gt;leftChild-&gt;color == BLACK &amp;&amp; w-&gt;rightChild-&gt;color == BLACK)&#123;</div><div class="line">                w-&gt;color = RED;<span class="comment">//抽去黑色，因为x有双重黑色，所以x依旧是黑色</span></div><div class="line">                x = x-&gt;parent;<span class="comment">//在循环最后给新的x节点染上抽出的黑色,使黑色上移</span></div><div class="line">            &#125;<span class="comment">//情况三</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w-&gt;rightChild-&gt;color == BLACK)&#123;</div><div class="line">                w-&gt;leftChild-&gt;color = BLACK;</div><div class="line">                w-&gt;color = RED;</div><div class="line">                rightRoate(root, w);</div><div class="line">               </div><div class="line">            &#125;<span class="comment">//情况四</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                w-&gt;color = x-&gt;parent-&gt;color;</div><div class="line">                x-&gt;parent-&gt;color = BLACK;</div><div class="line">                w-&gt;rightChild-&gt;color = BLACK;</div><div class="line">                leftRotate(root, x-&gt;parent);</div><div class="line">                x = root;<span class="comment">//到了情况四就可以通过这一步结束循环了</span></div><div class="line">            &#125;</div><div class="line">        &#125;<span class="comment">//x是右孩子，代码和上面的左右互反即可</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            w = x-&gt;parent-&gt;leftChild;</div><div class="line">            <span class="keyword">if</span>(w-&gt;color == RED)&#123;</div><div class="line">                w-&gt;color = BLACK;</div><div class="line">                x-&gt;parent-&gt;color = RED;</div><div class="line">                rightRoate(root, x-&gt;parent);</div><div class="line">                x = x-&gt;parent;</div><div class="line">                w = x-&gt;parent-&gt;leftChild;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(w-&gt;leftChild-&gt;color == BLACK &amp;&amp; w-&gt;rightChild-&gt;color == BLACK)&#123;</div><div class="line">                w-&gt;color = RED;</div><div class="line">                x = x-&gt;parent;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w-&gt;leftChild-&gt;color == BLACK)&#123;</div><div class="line">                w-&gt;rightChild-&gt;color = BLACK;</div><div class="line">                w-&gt;color = RED;</div><div class="line">                leftRotate(root, w);</div><div class="line">            </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                w-&gt;color = x-&gt;parent-&gt;color;</div><div class="line">                x-&gt;parent-&gt;color = BLACK;</div><div class="line">                w-&gt;leftChild-&gt;color = BLACK;</div><div class="line">                rightRoate(root, x-&gt;parent);</div><div class="line">                x = root;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        x-&gt;color = BLACK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="树节点数据结构"><a href="#树节点数据结构" class="headerlink" title="树节点数据结构"></a>树节点数据结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> BLACK = <span class="literal">true</span>;</div><div class="line"><span class="keyword">bool</span> RED = <span class="literal">false</span>;</div><div class="line"><span class="keyword">struct</span> treeNode&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    <span class="keyword">bool</span> color;</div><div class="line">    <span class="keyword">struct</span> treeNode * parent;</div><div class="line">    <span class="keyword">struct</span> treeNode * leftChild;</div><div class="line">    <span class="keyword">struct</span> treeNode * rightChild;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeNode * treeNodeP;</div></pre></td></tr></table></figure>
<h5 id="NIL节点表示"><a href="#NIL节点表示" class="headerlink" title="NIL节点表示"></a>NIL节点表示</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> treeNode node = &#123;<span class="number">-1</span>,BLACK,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</div><div class="line">treeNodeP NIL = &amp;node;</div></pre></td></tr></table></figure>
<h5 id="初始化节点"><a href="#初始化节点" class="headerlink" title="初始化节点"></a>初始化节点</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(treeNodeP node,<span class="keyword">int</span> val,<span class="keyword">bool</span> color)</span></span>&#123;</div><div class="line">    node-&gt;parent = NIL;</div><div class="line">    node-&gt;leftChild = NIL;</div><div class="line">    node-&gt;rightChild = NIL;</div><div class="line">    node-&gt;val = val;</div><div class="line">    node-&gt;color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="左旋右旋代码"><a href="#左旋右旋代码" class="headerlink" title="左旋右旋代码"></a>左旋右旋代码</h5><p>左旋和右旋都是有规律的，可以按照上面的示意图对照理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//左旋，x为旋转的顶点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(treeNodeP&amp; root,treeNodeP x)</span></span>&#123;</div><div class="line">    treeNodeP y = x-&gt;rightChild;</div><div class="line">    x-&gt;rightChild = y-&gt;leftChild;</div><div class="line">    <span class="keyword">if</span>(y-&gt;leftChild != NIL)&#123;<span class="comment">//若不判断，有可能空指针异常</span></div><div class="line">        y-&gt;leftChild-&gt;parent = x;</div><div class="line">    &#125;</div><div class="line">    y-&gt;parent = x-&gt;parent;</div><div class="line">    <span class="keyword">if</span>(x-&gt;parent == NIL)&#123;<span class="comment">//根节点的父节点为NIL</span></div><div class="line">        root = y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;leftChild)&#123;</div><div class="line">        x-&gt;parent-&gt;leftChild = y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        x-&gt;parent-&gt;rightChild = y;</div><div class="line">    &#125;</div><div class="line">    y-&gt;leftChild = x;</div><div class="line">    x-&gt;parent = y;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">//右旋，x为旋转的顶点</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRoate</span><span class="params">(treeNodeP&amp; root, treeNodeP x)</span></span>&#123;</div><div class="line">    treeNodeP y = x-&gt;leftChild;</div><div class="line">    x-&gt;leftChild = y-&gt;rightChild;</div><div class="line">    <span class="keyword">if</span>(y-&gt;rightChild != NIL)&#123;</div><div class="line">        y-&gt;rightChild-&gt;parent = x;</div><div class="line">    &#125;</div><div class="line">    y-&gt;parent = x-&gt;parent;</div><div class="line">    <span class="keyword">if</span>(x-&gt;parent == NIL)&#123;</div><div class="line">        root = y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;leftChild)&#123;</div><div class="line">        x-&gt;parent-&gt;leftChild = y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        x-&gt;parent-&gt;rightChild = y;</div><div class="line">    &#125;</div><div class="line">    y-&gt;rightChild = x;</div><div class="line">    x-&gt;parent = y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="translate函数"><a href="#translate函数" class="headerlink" title="translate函数"></a>translate函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//v替换u（仅仅是v和u的父节点建立联系）</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">translate</span><span class="params">(treeNodeP&amp; root, treeNodeP u, treeNodeP v)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(u-&gt;parent == NIL)&#123;</div><div class="line">        root = v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u == u-&gt;parent-&gt;leftChild)&#123;</div><div class="line">        u-&gt;parent-&gt;leftChild = v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        u-&gt;parent-&gt;rightChild = v;</div><div class="line">    &#125;</div><div class="line">    v-&gt;parent = u-&gt;parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="treeMiniMum函数"><a href="#treeMiniMum函数" class="headerlink" title="treeMiniMum函数"></a>treeMiniMum函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找到节点x的右子树种的最左（小）节点</span></div><div class="line"><span class="function">treeNodeP <span class="title">treeMiniMum</span><span class="params">(treeNodeP x)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span> (x-&gt;leftChild != NIL) &#123;</div><div class="line">        x = x-&gt;leftChild;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li>《算法导论》</li>
<li>维基百科</li>
</ul>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> 
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自平衡二叉查找树（AVL）&quot;&gt;&lt;a href=&quot;#自平衡二叉查找树（AVL）&quot; class=&quot;headerlink&quot; title=&quot;自平衡二叉查找树（AVL）&quot;&gt;&lt;/a&gt;自平衡二叉查找树（AVL）&lt;/h4&gt;&lt;p&gt;了解自平衡二叉查找树前，先讲讲二叉查找树。二叉查找树
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://vinoit.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://vinoit.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="http://vinoit.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="算法" scheme="http://vinoit.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="红黑树" scheme="http://vinoit.me/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="查找" scheme="http://vinoit.me/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基础以及常用操作</title>
    <link href="http://vinoit.me/2016/10/27/binary-tree/"/>
    <id>http://vinoit.me/2016/10/27/binary-tree/</id>
    <published>2016-10-27T05:47:14.000Z</published>
    <updated>2016-11-09T00:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="常见基本概念"><a href="#常见基本概念" class="headerlink" title="常见基本概念"></a>常见基本概念</h4><ul>
<li>节点的度：某节点的度定义为该节点孩子节点的个数。</li>
<li>叶子节点：度为0 的结点称为叶结点，或者称为终端结点。</li>
<li>树的度：树中各结点度的最大值。</li>
<li>节点的高度：从该节点起到叶子节点的最长简单路径的边数。(简单路径：无重复边的路径)</li>
<li>树的高度：根节点的高度。</li>
<li>节点的层数：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1。</li>
<li>节点的深度：即该节点的层数。</li>
<li>树的层数：树中所有节点的最大层数。</li>
<li>树的深度：树中所有结点的最大层数。</li>
<li>外节点：叶子节点。</li>
<li>内节点：除叶子节点之外的节点。</li>
<li>满二叉树：所有终端都在同一层次，且非终端结点的度数为2。在满二叉树中若其深度为k，则其所包含的结点数必为2^k-1。</li>
<li>完全二叉树：除最后一层，每一层的节点数都达到最大。最后一层若是没满，则节点集中在左边，空的只能是右边。对于完全二叉树，设一个结点为i则其父节点为i/2，2i为左子节点，2i+1为右子节点。</li>
<li>扩充二叉树：对二叉树中度为1的节点和叶子节点添加空节点，使之成为满二叉树。<br>二叉树的每个结点最多有两棵子树，左子树和右子树，次序不可以颠倒。</li>
</ul>
<p>与树不同，树的节点个数至少为1，而二叉树的节点个数可以为0；树中节点的最大度数没有限制，而二叉树节点的最大度数为2；树的节点无左、右之分，而二叉树的节点有左、右之分。</p>
<p>注：关于树深度、层数、高度的定义会有不同的说法：有从0开始计数的，也有从1开始计数的。从哪儿开始计数不是关键，关键在于一致性，量的写法要一致。</p>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><h5 id="顺序存储表示"><a href="#顺序存储表示" class="headerlink" title="顺序存储表示"></a>顺序存储表示</h5><p>二叉树可以用数组或链接串列来存储，而且如果这是满二叉树，这种方法不会浪费空间。用这种紧凑排列，如果一个节点的索引为i，它的子节点能在索引2i+1和2i+2找到，并且它的父节点（如果有）能在索引floor((i-1)/2)找到（假设根节点的索引为0）。这种方法更有利于紧凑存储和更好的访问的局部性，特别是在[前序遍历]中。然而，它需要连续的存储空间，这样在存储高度为h的n个结点组成的一般普通树时将会浪费很多空间。一种最极坏的情况下如果深度为h的二叉树每个节点只有右孩子需要占用2的h次幂减1，而实际却只有h个结点，空间的浪费太大，这是顺序存储结构的一大缺点。</p>
<p><img src="/images/data-structure/binary-tree-0.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100 <span class="comment">/* 二叉树的最大节点数 */</span></span></div><div class="line"> <span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE]; <span class="comment">/* 顺序存储的数组 */</span></div><div class="line"></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line"> &#123;</div><div class="line">   <span class="keyword">int</span> level,order; <span class="comment">/* 节点所在层以及在该层的序号 */</span></div><div class="line"> &#125;position;</div></pre></td></tr></table></figure>
<h5 id="二叉链表存储表示"><a href="#二叉链表存储表示" class="headerlink" title="二叉链表存储表示"></a>二叉链表存储表示</h5><p>在使用记录或内存地址指针的程序设计语言中，二叉树通常用树结点结构来存储。有时也包含指向唯一的父节点的指针。如果一个结点的子结点个数小于2，一些子结点指针可能为空值，或者为特殊的哨兵结点。 使用链表能避免顺序存储浪费空间的问题，算法和结构相对简单，但使用二叉链表，由于缺乏父链的指引，在找回父节点时需要重新扫描树得知父节点的节点地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 二叉树的二叉链表存储表示 */</span></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> BiTNode</div><div class="line"> &#123;</div><div class="line">   TElemType data;</div><div class="line">   <span class="keyword">struct</span> BiTNode *lchild,*rchild; <span class="comment">/* 左右孩子指針 */</span></div><div class="line"> &#125;BiTNode,*BiTree;</div></pre></td></tr></table></figure>
<h5 id="三叉链表存储表示"><a href="#三叉链表存储表示" class="headerlink" title="三叉链表存储表示"></a>三叉链表存储表示</h5><p>改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。 当二叉树用三叉链表表示时，有N个结点，就会有N+2个空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 二叉树的三叉链表存储表示 */</span></div><div class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> BiTPNode</div><div class="line"> &#123;</div><div class="line">   TElemType data;</div><div class="line">   <span class="keyword">struct</span> BiTPNode *parent,*lchild,*rchild; <span class="comment">/* 父、左右孩子指針 */</span></div><div class="line"> &#125;BiTPNode,*BiPTree;</div></pre></td></tr></table></figure>
<h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><p>本文使用二叉树的二叉链表存储表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> dataType;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> treeNode&#123;</div><div class="line">    dataType val;</div><div class="line">    <span class="keyword">struct</span> treeNode * leftChild;</div><div class="line">    <span class="keyword">struct</span> treeNode * rightChild;</div><div class="line">    <span class="keyword">int</span> visit = <span class="number">0</span>;<span class="comment">//后序遍历时使用</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeNode * treeNodeP;</div></pre></td></tr></table></figure>
<p>创建如下这样一颗二叉树：<br><img src="/images/data-structure/binary-tree-1.png" alt=""></p>
<h5 id="括号表示法创建"><a href="#括号表示法创建" class="headerlink" title="括号表示法创建"></a>括号表示法创建</h5><p>对应的括号表示法为：<code>A(B(D(H),E(I,J)),C(F,G))</code>,括号表示法中，对应<code>()</code>中的内容为<code>(</code>前节点的孩子，<code>()</code>中的<code>,</code>用于分隔左右孩子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(treeNodeP &amp;root,<span class="keyword">char</span>* str)</span></span>&#123;</div><div class="line">    root = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;<span class="comment">//字符串遍历时的当前位置</span></div><div class="line">    <span class="keyword">char</span> ch = str[pos];</div><div class="line">    treeNodeP node = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> type= <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)&#123;</div><div class="line">        <span class="keyword">switch</span> (ch) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'('</span>:<span class="comment">//遇到'('时，表示下一个节点是上一个节点的左孩子。</span></div><div class="line">                push(&amp;<span class="built_in">stack</span>, node);<span class="comment">//此时node保存着上一个节点，将上一个节点入栈。</span></div><div class="line">                ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">                type = <span class="number">1</span>;<span class="comment">//表示下一个元素是左孩子</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">','</span>:</div><div class="line">                type = <span class="number">2</span>;<span class="comment">//表示下一个孩子是右孩子</span></div><div class="line">                ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">')'</span>:<span class="comment">//遇到`)`时，表示栈顶元素的孩子输入完毕了，可以将栈顶节点出栈了。</span></div><div class="line">                pop(&amp;<span class="built_in">stack</span>);<span class="comment">//栈顶节点出栈</span></div><div class="line">                ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:<span class="comment">//表示遇到的是节点的内容值</span></div><div class="line">                node = <span class="keyword">new</span> treeNode();<span class="comment">//新建节点并初始化</span></div><div class="line">                node-&gt;val = ch;</div><div class="line">                node-&gt;leftChild = <span class="literal">NULL</span>;</div><div class="line">                node-&gt;rightChild = <span class="literal">NULL</span>;</div><div class="line">                <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//如果root节点为NULL,则当前输入的节点为根节点</span></div><div class="line">                    root = node;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>)&#123;<span class="comment">//栈不为空</span></div><div class="line">                    treeNodeP t = top(&amp;<span class="built_in">stack</span>);<span class="comment">//获取栈顶节点（不弹出）</span></div><div class="line">                    <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</div><div class="line">                        t-&gt;leftChild = node;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</div><div class="line">                        t-&gt;rightChild = node;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                ch = str[++pos];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="按前序遍历输入"><a href="#按前序遍历输入" class="headerlink" title="按前序遍历输入"></a>按前序遍历输入</h5><p>表示为：<code>ABDH###EI##J##CF##G##</code>，此表示法按照<code>前序遍历</code>的顺序输入，<code>#</code>表示<code>NULL</code>。</p>
<p>核心思想：如果字符连续的出现，则下一个字符为上一个字符的左孩子，在<code>#</code>出现之前，所有的字符按照顺序都入栈。如果字符在<code>#</code>后第一次出现，则必为栈顶节点的右节点。当出现第一个<code>#</code>时，说明上一个字符为当前分支的最左节点，上一个字符的左孩子赋值NULL。连续出现第二个<code>#</code>时，说第一个<code>#</code>前的字符的右孩子也赋值NULL。当一个节点的右孩子赋值完成时，便可以从栈中弹出了。如果连续出现2个以上的<code>#</code>,则栈顶的节点的右孩子依次置NULL，并弹出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createByPreorder</span><span class="params">(treeNodeP &amp;root, <span class="keyword">char</span>* str)</span></span>&#123;</div><div class="line">    root = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> ch = str[pos];</div><div class="line">    treeNodeP node = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录`#`连续出现的记录</span></div><div class="line">    <span class="keyword">while</span>(ch != <span class="string">'\0'</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(ch != <span class="string">'#'</span>)&#123;</div><div class="line">            count = <span class="number">0</span>;<span class="comment">//一旦`#`终止连续出现，count赋0</span></div><div class="line">            node = <span class="keyword">new</span> treeNode();<span class="comment">//新建节点并初始化</span></div><div class="line">            node-&gt;val = ch;</div><div class="line">            node-&gt;leftChild = <span class="literal">NULL</span>;</div><div class="line">            node-&gt;rightChild = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;<span class="comment">//如果root节点为NULL,则当前输入的节点为根节</span></div><div class="line">                root = node;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>((&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>)&#123;<span class="comment">//栈不为空</span></div><div class="line">            <span class="comment">//遇见一个字符，既然栈中存在节点，则不为左节点便为右节点</span></div><div class="line">                <span class="keyword">if</span>(top(&amp;<span class="built_in">stack</span>)-&gt;leftChild)&#123;</div><div class="line">                    pop(&amp;<span class="built_in">stack</span>)-&gt;rightChild = node;<span class="comment">//如果是右节点，则赋值完整后便可以将节点弹出栈</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    top(&amp;<span class="built_in">stack</span>)-&gt;leftChild = node;</div><div class="line">                &#125;   </div><div class="line">            &#125;        </div><div class="line">            push(&amp;<span class="built_in">stack</span>, node);<span class="comment">//节点入栈</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            count++;</div><div class="line">            <span class="keyword">if</span>((&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;<span class="comment">//`#`第一次出现时，必然是栈顶节点的左孩子</span></div><div class="line">                    top(&amp;<span class="built_in">stack</span>)-&gt;leftChild = <span class="literal">NULL</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(count == <span class="number">2</span>)&#123;<span class="comment">//`#`第二次连续出现时，必然是栈顶节点的右孩子</span></div><div class="line">                    pop(&amp;<span class="built_in">stack</span>)-&gt;rightChild = <span class="literal">NULL</span>;<span class="comment">//此时栈顶节点已完成左右孩子的赋值，可以弹出。</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(count &gt; <span class="number">2</span>)&#123;<span class="comment">//将栈中的元素弹出并将右孩子置NULL</span></div><div class="line">                    pop(&amp;<span class="built_in">stack</span>)-&gt;rightChild = <span class="literal">NULL</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ch = str[++pos];<span class="comment">//遍历下一个字符</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="非递归的前序遍历"><a href="#非递归的前序遍历" class="headerlink" title="非递归的前序遍历"></a>非递归的前序遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="comment">//只有栈空（所有节点的右孩子都已开始访问或已访问完成）或者</span></div><div class="line">    <span class="comment">//节点为NULL（栈空时，当访问到最右孩子时tmp为NULL）遍历才算完成</span></div><div class="line">    <span class="keyword">while</span> (tmp || (&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(tmp)&#123;<span class="comment">//此循环的目的是遍历到当前分支的最左节点，将遍历的节点依次输出并入栈。</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);<span class="comment">//栈中的所有节点的右孩子都没有开始访问</span></div><div class="line">            tmp = tmp-&gt;leftChild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//上面的循环结束表示当前分支的所有左孩子都入栈了，此时弹出最后一个左孩子节点。</span></div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        tmp = tmp-&gt;rightChild;<span class="comment">//这里考虑的逻辑就是右孩子是否为NULL，</span></div><div class="line">        <span class="comment">//若为NULL，则弹出栈顶节点，弹出节点为此节点的父节点，此节点后的内容遍历完成，开始父节点的右孩子的前序遍历。</span></div><div class="line">        <span class="comment">//若不为NULL，开始上面的循环，遍历到此节点右孩子分支的最左节点。</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：<code>ABDHEIJCFG</code>。</p>
<h4 id="非递归的中序遍历"><a href="#非递归的中序遍历" class="headerlink" title="非递归的中序遍历"></a>非递归的中序遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">midorder</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="keyword">while</span> (tmp || (&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(tmp)&#123;</div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);</div><div class="line">            tmp = tmp-&gt;leftChild;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//来到当前分支的最左，弹出最左节点，输出。</span></div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">        tmp = tmp-&gt;rightChild;<span class="comment">//这里考虑的逻辑就是右孩子是否为NULL，</span></div><div class="line">        <span class="comment">//若为NULL，则弹出栈顶节点，弹出节点为此节点的父节点，并输出，此节点后的内容遍历完成，开始父节点的右孩子的遍历。</span></div><div class="line">        <span class="comment">//若不为NULL，则再次上面的循环，开始当前节点右孩子的遍历。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与前序遍历唯一的不同就是输出字符的位置变了。前序遍历先是父节点，而中序遍历则是左孩子先。两个输出位置可以细细体味一下。</p>
<p>输出结果为：<code>HDBIEJAFCG</code>。</p>
<h4 id="非递归的后序遍历"><a href="#非递归的后序遍历" class="headerlink" title="非递归的后序遍历"></a>非递归的后序遍历</h4><p>考虑到后序遍历时父节点需要被回溯2次，所以用一个int型的visit变量加以区分，初始值为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeStack <span class="built_in">stack</span>;</div><div class="line">    (&amp;<span class="built_in">stack</span>)-&gt;top = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="keyword">while</span> (tmp || (&amp;<span class="built_in">stack</span>)-&gt;top &gt; <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(tmp)&#123;</div><div class="line">            <span class="keyword">if</span>(tmp-&gt;visit == <span class="number">1</span>)&#123;<span class="comment">//入栈次数为1，表示还未访问过右孩子，需要先访问右孩子，此节点入栈，入栈次数+1，同时切换到右孩子分支。</span></div><div class="line">                push(&amp;<span class="built_in">stack</span>, tmp);</div><div class="line">                tmp-&gt;visit++;</div><div class="line">                tmp = tmp-&gt;rightChild;</div><div class="line">                <span class="keyword">goto</span> right;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp-&gt;visit == <span class="number">2</span>)&#123;<span class="comment">//入栈次数为2，表示右孩子以访问完成，可以输出。输出完毕后从栈中取下一个访问节点，也就是此节点的父节点，开始内循环。</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">                tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">                <span class="keyword">goto</span> right;</div><div class="line">            &#125;</div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);</div><div class="line">            tmp-&gt;visit = <span class="number">1</span>;<span class="comment">//第一次入栈</span></div><div class="line">            tmp = tmp-&gt;leftChild;</div><div class="line">        &#125;</div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;rightChild)&#123;<span class="comment">//如果最左节点有右孩子，因为后序遍历时右孩子前于父节点，所以右孩子入栈。</span></div><div class="line">            push(&amp;<span class="built_in">stack</span>, tmp);<span class="comment">//此节点需再次入栈</span></div><div class="line">            tmp-&gt;visit++;<span class="comment">//入栈次数+1</span></div><div class="line">            tmp = tmp-&gt;rightChild;<span class="comment">//切换到右孩子</span></div><div class="line">            <span class="keyword">continue</span>;<span class="comment">//继续内循环，遍历到右孩子的最左节点</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//节点无右孩子，则可以输出。</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">        tmp = pop(&amp;<span class="built_in">stack</span>);</div><div class="line">        </div><div class="line">    right:;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为visit一开始都为0，所以内循环中直接遍历到最左节点，并将节点依次入栈。</p>
<p>输出结果为：<code>HDIJEBFGCA</code>。</p>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>层次遍历的思想即使将当前节点的孩子依次从左到右入队列，此节点访问后便从队列中取下一个节点。重复以上过程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the tree is empty!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> treeQueue <span class="built_in">queue</span>;</div><div class="line">    (&amp;<span class="built_in">queue</span>)-&gt;front = <span class="number">-1</span>;</div><div class="line">    (&amp;<span class="built_in">queue</span>)-&gt;rear = <span class="number">-1</span>;</div><div class="line">    treeNodeP tmp = root;</div><div class="line">    <span class="keyword">while</span>(tmp)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,tmp-&gt;val);</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;leftChild)&#123;</div><div class="line">            enterNode(&amp;<span class="built_in">queue</span>, tmp-&gt;leftChild);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;rightChild)&#123;</div><div class="line">            enterNode(&amp;<span class="built_in">queue</span>, tmp-&gt;rightChild);</div><div class="line">        &#125;</div><div class="line">        tmp = getNode(&amp;<span class="built_in">queue</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：<code>ABCDEFGHIJ</code>。</p>
<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">treeNodeP <span class="title">findNode</span><span class="params">(treeNodeP root,<span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root-&gt;val == ch)&#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        treeNodeP node = findNode(root-&gt;leftChild, ch);</div><div class="line">        <span class="keyword">if</span>(node)&#123;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            node = findNode(root-&gt;rightChild, ch);</div><div class="line">            <span class="keyword">if</span>(node)&#123;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="求高度"><a href="#求高度" class="headerlink" title="求高度"></a>求高度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHigh</span><span class="params">(treeNodeP root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> h1 = getHigh(root-&gt;leftChild);</div><div class="line">    <span class="keyword">int</span> h2 = getHigh(root-&gt;rightChild);</div><div class="line">    <span class="keyword">return</span> h1 &gt; h2 ? h1 + <span class="number">1</span> : h2 +<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="所使用的栈、队列数据结构"><a href="#所使用的栈、队列数据结构" class="headerlink" title="所使用的栈、队列数据结构"></a>所使用的栈、队列数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> treeStack&#123;</div><div class="line">    treeNodeP node[SIZE];</div><div class="line">    <span class="keyword">int</span> top;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeStack * treeStackP;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(treeStackP <span class="built_in">stack</span>, treeNodeP node)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top &lt; SIZE - <span class="number">1</span>)&#123;</div><div class="line">        <span class="built_in">stack</span>-&gt;node[++<span class="built_in">stack</span>-&gt;top] = node;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the stack is full!\n"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">treeNodeP <span class="title">pop</span><span class="params">(treeStackP <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top &gt; <span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;node[<span class="built_in">stack</span>-&gt;top--];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">treeNodeP <span class="title">top</span><span class="params">(treeStackP <span class="built_in">stack</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top &gt; <span class="number">-1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;node[<span class="built_in">stack</span>-&gt;top];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> treeQueue &#123;</div><div class="line">    treeNodeP node[SIZE];</div><div class="line">    <span class="keyword">int</span> front;</div><div class="line">    <span class="keyword">int</span> rear;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> treeQueue * treeQueueP;</div><div class="line"></div><div class="line"><span class="function">treeNodeP <span class="title">getNode</span><span class="params">(treeQueueP <span class="built_in">queue</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % SIZE;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;node[<span class="built_in">queue</span>-&gt;front];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enterNode</span><span class="params">(treeQueueP <span class="built_in">queue</span>, treeNodeP node)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % SIZE == <span class="built_in">queue</span>-&gt;front)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"the queue is full!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>)% SIZE;</div><div class="line">    <span class="built_in">queue</span>-&gt;node[<span class="built_in">queue</span>-&gt;rear] = node;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> 
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;常见基本概念&quot;&gt;&lt;a href=&quot;#常见基本概念&quot; class=&quot;headerlink&quot; title=&quot;常见基本概念&quot;&gt;&lt;/a&gt;常见基本概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;节点的度：某节点的度定义为该节点孩子节点的个数。&lt;/li&gt;
&lt;li&gt;叶子节点：度为0 的结点称为
    
    </summary>
    
      <category term="算法与数据结构" scheme="http://vinoit.me/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://vinoit.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="http://vinoit.me/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="算法" scheme="http://vinoit.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聊聊java中codepoint和UTF-16相关的一些事</title>
    <link href="http://vinoit.me/2016/10/07/codePoint-in-java-and-utf16/"/>
    <id>http://vinoit.me/2016/10/07/codePoint-in-java-and-utf16/</id>
    <published>2016-10-07T05:43:06.000Z</published>
    <updated>2016-10-31T08:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Unicode和UTF-8-UTF-16-UTF-32的关系"><a href="#Unicode和UTF-8-UTF-16-UTF-32的关系" class="headerlink" title="Unicode和UTF-8/UTF-16/UTF-32的关系"></a>Unicode和UTF-8/UTF-16/UTF-32的关系</h4><p>Unicode和UTF-8/UTF-16/UTF-32之间就是字符集和编码的关系。字符集的概念实际上包含两个方面，一个是字符的集合，一个是编码方案。字符集定义了它所包含的所有符号，狭义上的字符集并不包含编码方案，它仅仅是定义了属于这个字符集的所有符号。但通常来说，一个字符集并不仅仅定义字符集合，它还为每个符号定义一个二进制编码。当我们提到GB2312或者ASCII的时候，它隐式地指明了编码方案是GB2312或者ASCII，在这些情况下可以认为字符集与编码方案互等。</p>
<p>但是Unicode具有多种编码方案。Unicode字符集规定的标准编码方案是UCS-2（UTF-16），用两个字节表示一个Unicode字符（UTF-16中两个字节的为基本多语言平面字符，4个字节的为辅助平面字符）。而UCS-4(UTF-32）用4个字节表示一个Unicode字符。另外一个常用的Unicode编码方案–UTF-8用1到4个变长字节来表示一个Unicode字符，并可以从一个简单的转换算法从UTF-16直接得到。所以在使用Unicode字符集时有多种编码方案，分别用于合适的场景。</p>
<p>再通俗一点地讲，Unicode字符集就相当于是一本字典，里面记载着所有字符（即图像）以及各自所对应的Unicode码（与具体编码方案无关），UTF-8/UTF-16/UTF-32码就是Unicode码经过相应的公式计算得到的并且实际存储、传输的数据。</p>
<h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>JVM规范中明确说明了java的char类型使用的编码方案是UTF-16，所以先来了解下UTF-16。</p>
<p>Unicode的编码空间从U+0000到U+10FFFF，共有1112064个码位(code point)可用来映射字符，码位就是字符的数字形式。这部分编码空间可以划分为17个平面（plane）,每个平面包含2^16（65536）个码位。第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。基本多语言平面内，从U+D800到U+DFFF之间的码位区块是永久保留不映射到Unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。</p>
<p>最常用的字符都包含在BMP中，用2个字节表示。辅助平面中的码位，在UTF-16中被编码为一对16比特长的码元，称作代理对（surrogate pair），具体方法是：</p>
<ol>
<li>将码位减去0x10000,得到的值的范围为20比特长的0~0xFFFFF。</li>
<li>高位的10比特的值（值的范围为0~0x3FF）被加上0xD800得到第一个码元或称作高位代理（high surrogate），值的范围是0xD800~0xDBFF.由于高位代理比低位代理的值要小，所以为了避免混淆使用，Unicode标准现在称高位代理为前导代理（lead surrogates）。</li>
<li>低位的10比特的值（值的范围也是0~0x3FF）被加上0xDC00得到第二个码元或称作低位代理（low surrogate），现在值的范围是0xDC00~0xDFFF.由于低位代理比高位代理的值要大，所以为了避免混淆使用，Unicode标准现在称低位代理为后尾代理（trail surrogates）。</li>
</ol>
<p>例如U+10437编码:</p>
<ul>
<li>0x10437减去0x10000,结果为0x00437,二进制为0000 0000 0100 0011 0111。</li>
<li>分区它的上10位值和下10位值（使用二进制）:0000000001 and 0000110111。</li>
<li>添加0xD800到上值，以形成高位：0xD800 + 0x0001 = 0xD801。</li>
<li>添加0xDC00到下值，以形成低位：0xDC00 + 0x0037 = 0xDC37。</li>
</ul>
<p>由于前导代理、后尾代理、BMP中的有效字符的码位，三者互不重叠，搜索时一个字符编码的一部分不可能与另一个字符编码的不同部分相重叠。所以可以通过仅检查一个码元（构成码位的基本单位，2个字节）就可以判定给定字符的下一个字符的起始码元。</p>
<h4 id="java中的codepoint相关"><a href="#java中的codepoint相关" class="headerlink" title="java中的codepoint相关"></a>java中的codepoint相关</h4><p>对于一个字符串对象，其内容是通过一个char数组存储的。char类型由2个字节存储，这2个字节实际上存储的就是UTF-16编码下的码元。我们使用charAt和length方法的时候，返回的实际上是一个码元和码元的数量，虽然一般情况下没有问题，但是如果这个字符属于辅助平面字符，以上2个方法便无法得到正确的结果。正确的处理方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> character = aString.codePointAt(i);</div><div class="line"><span class="keyword">int</span> length = aString.codePointCount(<span class="number">0</span>, aString.length())；</div></pre></td></tr></table></figure>
<p>需要注意codePointAt的返回值，是int而非char,这个值就是Unicode码。</p>
<p>codePointAt方法调用了codePointAtImpl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointAtImpl</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> index, <span class="keyword">int</span> limit)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> c1 = a[index];</div><div class="line">        <span class="keyword">if</span> (isHighSurrogate(c1) &amp;&amp; ++index &lt; limit) &#123;</div><div class="line">            <span class="keyword">char</span> c2 = a[index];</div><div class="line">            <span class="keyword">if</span> (isLowSurrogate(c2)) &#123;</div><div class="line">                <span class="keyword">return</span> toCodePoint(c1, c2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c1;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>isHighSurrogate方法判断下标字符的2个字节是否为UTF-16中的前导代理（0xD800~0xDBFF）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHighSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">        <span class="comment">// Help VM constant-fold; MAX_HIGH_SURROGATE + 1 == MIN_LOW_SURROGATE</span></div><div class="line">        <span class="keyword">return</span> ch &gt;= MIN_HIGH_SURROGATE &amp;&amp; ch &lt; (MAX_HIGH_SURROGATE + <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MIN_HIGH_SURROGATE = <span class="string">'\uD800'</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MAX_HIGH_SURROGATE = <span class="string">'\uDBFF'</span>;</div></pre></td></tr></table></figure>
<p>然后++index,isLowSurrogate方法判断下一个字符的2个字节是否为后尾代理（0xDC00~0xDFFF）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ch &gt;= MIN_LOW_SURROGATE &amp;&amp; ch &lt; (MAX_LOW_SURROGATE + <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MIN_LOW_SURROGATE  = <span class="string">'\uDC00'</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MAX_LOW_SURROGATE  = <span class="string">'\uDFFF'</span>;</div></pre></td></tr></table></figure>
<p>toCodePoint方法将这2个码元组装成一个Unicode码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toCodePoint</span><span class="params">(<span class="keyword">char</span> high, <span class="keyword">char</span> low)</span> </span>&#123;</div><div class="line">        <span class="comment">// Optimized form of:</span></div><div class="line">        <span class="comment">// return ((high - MIN_HIGH_SURROGATE) &lt;&lt; 10)</span></div><div class="line">        <span class="comment">//         + (low - MIN_LOW_SURROGATE)</span></div><div class="line">        <span class="comment">//         + MIN_SUPPLEMENTARY_CODE_POINT;</span></div><div class="line">        <span class="keyword">return</span> ((high &lt;&lt; <span class="number">10</span>) + low) + (MIN_SUPPLEMENTARY_CODE_POINT</div><div class="line">                                       - (MIN_HIGH_SURROGATE &lt;&lt; <span class="number">10</span>)</div><div class="line">                                       - MIN_LOW_SURROGATE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p> 这个过程就是以上将一个辅助平面的Unicode码位转换成2个码元的逆过程。</p>
<p> 所以，枚举字符串的正确方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aString.length();) &#123;</div><div class="line">	<span class="keyword">int</span> character = aString.codePointAt(i);</div><div class="line">	<span class="comment">//如果是辅助平面字符，则i+2</span></div><div class="line">	<span class="keyword">if</span> (Character.isSupplementaryCodePoint(character)) i += <span class="number">2</span>;</div><div class="line">	<span class="keyword">else</span> ++i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将codePoint转换为char[]可调用Character.toChars方法，然后可进一步转换为字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> String(Character.toChars(codePoint));</div></pre></td></tr></table></figure>
<p>toChars方法所做的就是以上将Unicode码位转换为2个码元的过程,这2个码元最后就成了字符串对象包含的char数组中的2个元素。</p>
<p>参考：</p>
<ul>
<li>维基百科</li>
<li><a href="https://www.zhihu.com/question/30945431/answer/50046808" target="_blank" rel="external">https://www.zhihu.com/question/30945431/answer/50046808</a></li>
</ul>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font>  
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Unicode和UTF-8-UTF-16-UTF-32的关系&quot;&gt;&lt;a href=&quot;#Unicode和UTF-8-UTF-16-UTF-32的关系&quot; class=&quot;headerlink&quot; title=&quot;Unicode和UTF-8/UTF-16/UTF-32的关系&quot;&gt;
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="String" scheme="http://vinoit.me/tags/String/"/>
    
      <category term="utf-16" scheme="http://vinoit.me/tags/utf-16/"/>
    
  </entry>
  
  <entry>
    <title>Ext3日志文件系统简述</title>
    <link href="http://vinoit.me/2016/09/25/ext3-journal-file-system/"/>
    <id>http://vinoit.me/2016/09/25/ext3-journal-file-system/</id>
    <published>2016-09-25T03:32:57.000Z</published>
    <updated>2016-10-31T08:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是日志文件系统"><a href="#什么是日志文件系统" class="headerlink" title="什么是日志文件系统"></a>什么是日志文件系统</h4><p>当我们修改某个文件时，必然要对相应文件系统上的块进行更新。但是对文件系统块的更新可能因为页高速缓存的影响在内存保留相当长的时间后才刷新到磁盘，此时若发生断电故障或系统崩溃这样的不可预测的时间，可能会导致文件系统处于不一致的状态。文件系统的不一致状态，是指元数据中存储的信息与磁盘实际情况不一致。这个相当长的时间是相对于计算机运行速度来说，事实上也是极短的（通常为1/500 秒?）。为了克服这个问题，传统的Unix文件系统在安装之前都要进行检查；如果它没有被正常卸载（例如：超级块的<code>s_mount_state</code> ！= <code>EXT2_VALID_FS</code>），那么一个特定的程序（e2fsck）将执行彻底、耗时的检查，并修正磁盘文件系统的所有数据结构。</p>
<p>然而当文件系统的文件数、目录数增大到一定程度时，一次一致性检查接可能花费数个小时，这显然是无法接受的。日志文件系统的目标就是避免对整个文件系统进行耗时的一致性检查。简单来说，当文件系统没有被正常卸载时，只需要直接去查看日志的内容，日志存放在一个特定的磁盘区，然后对日志中的内容进行检查和修正就可以了。</p>
<h4 id="Ext3日志文件系统"><a href="#Ext3日志文件系统" class="headerlink" title="Ext3日志文件系统"></a>Ext3日志文件系统</h4><p>Ext3的核心思想是对文件系统进行的任何高级修改都分成以下步骤：</p>
<ol>
<li>将待写块的一个副本存放在日志中。</li>
<li>将此次操作记录在日志中。</li>
<li>将已在内存中修改好的块写入文件系统。</li>
<li>将日志中的待写块的副本删除。</li>
</ol>
<p>但是如果文件的内容非常多，岂不是要花费大量的时间在副本的拷贝上？</p>
<p>事实上，每个文件系统都由所谓的元数据块和普通数据块组成。在Ext2和Ext3的文件系统中，有六种元数据：超级块、块组描述符、索引节点表、用于间接寻址的块、数据位图块和索引节点位图块。很多日志文件系统（如SGI的XFS以及IBM的JFS）都限定自己把影响元数据的操作计入日志。元数据的日志记录足以恢复磁盘文件系统数据结构的一致性，但因为文件的数据块不记入日志，就无法防止系统故障造成的文件内容损坏。</p>
<p>Ext3文件系统可以通过配置把影响文件系统元数据的操作和影响文件数据块的操作都计入日志，但每种写操作都计入日志会导致极大的性能损失，因此，Ext3让系统管理员决定应当把什么计入日志。Ext3提供三种不同的日志模式:</p>
<ul>
<li>日志（Journal）<br>  文件系统所有数据和元数据的改变都被记入日志。这提高了安全性，但损失性能，因为所有数据要写入两次。</li>
<li>预定（Ordered）<br>  只将文件元数据的改变记入日志。但在日志被写入前，数据必须被先写入文件系统。这是Ext3的缺省模式。</li>
<li>写回（Writeback）<br> 只将文件元数据的改变记入日志。不要求日志必须在数据被写入之后才被写，可以同时进行。</li>
</ul>
<p>三种模式下的所有文件元数据都是通过下文的JBD来写入磁盘的。日志模式下的文件数据由JBD写入磁盘，预定模式下的文件数据由JBD写入磁盘（PS：UTLK中写到该模式下的缓冲区同时被加入到了索引节点的脏缓冲区链表，这我不是很理解，望明白的同学可以指教一下。），写回模式下的数据则由磁盘高速缓存的刷新机制写入磁盘（脏页写回）。</p>
<h4 id="JBD"><a href="#JBD" class="headerlink" title="JBD"></a>JBD</h4><p>Ext3文件系统本身不处理日志，而是利用所谓的日志块设备（Journaling Block Device,JBD）的通用内核层。</p>
<p>EXT3文件系统和JBD之间相互独立，它们交互的基本单元有3个:</p>
<ol>
<li>日志记录:记录日志文件系统中一个磁盘块的一次更新;</li>
<li>原子操作处理(handle_s):文件系统的一次系统调用所对应的日志记录，包含了多个日志记录，具有原子性，要么包含的日志记录全部完成，要么全不完成;</li>
<li>事务(journal_s):包含多个原子操作处理，是JBD对磁盘写操作的单位。</li>
</ol>
<p>一般情况下，JBD如下工作，每次系统调用都会把若干对文件系统的修改以原子操作处理的方式打包，然后写入当前的事务中，当前的事务收集原子操作处理。每隔固定的时间间隔(5 s)，或是事务剩余空间不足，JBD会将事务写到磁盘的日志中，如下图所示：<br><img src="/images/ext3/ext3-journal-file-system-0.png" alt="JBD处理原始流程"></p>
<p>若出现断电或是系统崩溃，重启后自动进行的 e2fsck 检查可分为以下2种情况:</p>
<ul>
<li>若事务是完整的，则将日志中的事务内容重新写到磁盘上;</li>
<li>若事务是不完整的，不论该事务是否完成，但没有顺利地完整写到日志中，事务中的内容均是无效的，e2fsck 无视它。这样就缩短了EXT3用于恢复系统一致性状态所需的时间。</li>
</ul>
<h4 id="日志如何工作"><a href="#日志如何工作" class="headerlink" title="日志如何工作"></a>日志如何工作</h4><p>以下是一个比较通用的模式，可能在默写特定情况下不是很符合，但还是具有参考意义的。</p>
<ol>
<li>用户使用<code>write()</code>系统调用写入文件。</li>
<li>（1）操作对应于一个原子操作，被加入到JBD的一个事务中。</li>
<li>JBD在条件满足时将该事务写入到日志的磁盘区。（文件数据并没有开始写）</li>
<li>JBD激活事务中的所有I/O数据传送。</li>
<li>传送成功完成后，磁盘上相应的事务记录由内核的一个周期性程序删除。</li>
</ol>
<h4 id="存在的缺陷"><a href="#存在的缺陷" class="headerlink" title="存在的缺陷"></a>存在的缺陷</h4><p>理论上，上述机制足以应付断电或是系统崩溃等状况，但在实际操作中存在着不足之处。在频繁地断电或是系统故障条件下，表现尤为明显。</p>
<p>EXT3日志型文件系统存在以下缺陷:</p>
<ol>
<li><p>日志与文件系统存储在同一个磁盘上，这是最常见的情况。日志也是存储于磁盘上的文件，并不能免受磁盘故障 的损害。在出现故障时，磁盘上的日志文件写入状态是不可保证的。若是作为恢复依据的日志内容出错，则在进行检查 恢复时，也必定会出现错误，并且循环下去，出现错误的概 率会越来越大，直到整个文件系统崩溃不可再用为止;</p>
</li>
<li><p>事务是先缓存在内存中，等待一定时间间隔后(默认为 5 s)或是剩余空间不够了，才写到磁盘中的日志中。这样的话 若是在写入磁盘之前出现断电，这些事务就会丢失。这样的话，会发生同上述情况一样的结果，作为恢复根据的日志内容不完整，或是有错。</p>
</li>
</ol>
<p>EXT3 及 JBD 原有机制只是为了缩短用于磁盘检查修复 所需的时间，但作为该机制核心基础的日志内容在一些频繁 出现故障的情况下，仍然会出现错误，该机制就无法保证其 可靠性，这在些极端情况下无法保证文件系统应有的可用性。</p>
<p>参考：</p>
<ul>
<li>UTLK</li>
<li>[PDF]基于 JBD 的日志型文件系统性能优化（作者：陈 颖，奚宏生）</li>
</ul>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> 

</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是日志文件系统&quot;&gt;&lt;a href=&quot;#什么是日志文件系统&quot; class=&quot;headerlink&quot; title=&quot;什么是日志文件系统&quot;&gt;&lt;/a&gt;什么是日志文件系统&lt;/h4&gt;&lt;p&gt;当我们修改某个文件时，必然要对相应文件系统上的块进行更新。但是对文件系统块的更新可能
    
    </summary>
    
      <category term="文件系统" scheme="http://vinoit.me/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="文件系统" scheme="http://vinoit.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Ext3" scheme="http://vinoit.me/tags/Ext3/"/>
    
  </entry>
  
  <entry>
    <title>Ext2文件系统简述</title>
    <link href="http://vinoit.me/2016/09/23/ext2-file-system/"/>
    <id>http://vinoit.me/2016/09/23/ext2-file-system/</id>
    <published>2016-09-23T09:57:48.000Z</published>
    <updated>2016-10-31T08:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Ext2磁盘数据结构"><a href="#Ext2磁盘数据结构" class="headerlink" title="Ext2磁盘数据结构"></a>Ext2磁盘数据结构</h4><p>任何Ext2分区中的第一个块从不受Ext2文件系统的管理，因为第一个块是分区的引导扇区。分区中剩下来的其他部分分成了块组，其分布图如下:<br><img src="/images/ext2/ext2-file-system-0.png" alt="Ext2块组分布图"><br>典型的块大小是1024 bytes或者4096 bytes。这个大小在创建Ext2文件系统的时候被决定，它可以由系统管理员指定，也可以由文件系统的创建程序根据硬盘分区的大小，自动选择一个较合理的值。</p>
<p>每个块组的开头部分都由超级块描述符和块组描述符占用，而且每个块组的超级块描述符和块组描述符都是相同的，冗余的主要目的就是保证超级块描述符和组描述符能在描述符数据损坏的情况下依旧能回到一个一致的状态。这里的块组描述符其实是一个块组描述符组，这n个块中存放着分区中所有的块组对应的块组描述符。只有块组0中所包含的超级块和块组描述符才由内核使用，其余的保持不变。</p>
<p>在Ext2中定义了如下几种数据类型:</p>
<ul>
<li><code>__u8</code> 、<code>__u16</code> 、<code>__u32</code>分别表示长度为8、16、32的无符号数。</li>
<li><code>__s8</code> 、<code>__s16</code> 、<code>__s32</code>分别表示长度为8、16、32的有符号数。</li>
<li><code>__le16</code> 、<code>__le32</code>分别表示字、双字的little-endian排序方式。 </li>
<li><code>__be16</code> 、<code>__be32</code>分别表示字、双字的big-endian排序方式。</li>
</ul>
<h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>超级块描述符如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ext2_super_block &#123;</div><div class="line">        <span class="number">__u</span>32 s_inodes_count;      		<span class="comment">/* 索引节点总数 */</span></div><div class="line">        <span class="number">__u</span>32 s_blocks_count;      		<span class="comment">/* 块的数量*/</span></div><div class="line">        <span class="number">__u</span>32 s_r_blocks_count;    		<span class="comment">/* 保留的块数 */</span></div><div class="line">        <span class="number">__u</span>32 s_free_blocks_count; 		<span class="comment">/* 空闲的块数 */</span></div><div class="line">        <span class="number">__u</span>32 s_free_inodes_count;      <span class="comment">/* 空闲的索引节点数 */</span></div><div class="line">        <span class="number">__u</span>32 s_first_data_block;       <span class="comment">/* 第一个使用的块号 */</span></div><div class="line">        <span class="number">__u</span>32 s_log_block_size;         <span class="comment">/* 块的大小 */</span></div><div class="line">        <span class="number">__l</span>e32  s_log_frag_size;        <span class="comment">/* Fragment size */</span></div><div class="line">        <span class="number">__l</span>e32  s_blocks_per_group;     <span class="comment">/* 每个块组的块数量 */</span></div><div class="line">        <span class="number">__l</span>e32  s_frags_per_group;      <span class="comment">/* Fragments per group */</span></div><div class="line">        <span class="number">__l</span>e32  s_inodes_per_group;     <span class="comment">/* 每个块组的索引节点数量 */</span></div><div class="line">        <span class="number">__l</span>e32  s_mtime;                <span class="comment">/* Mount time */</span></div><div class="line">        <span class="number">__l</span>e32  s_wtime;                <span class="comment">/* Write time */</span></div><div class="line">        <span class="number">__l</span>e16  s_mnt_count;            <span class="comment">/* Mount count */</span></div><div class="line">        <span class="number">__l</span>e16  s_max_mnt_count;        <span class="comment">/* Maximal mount count */</span></div><div class="line">        <span class="number">__l</span>e16  s_magic;                <span class="comment">/* Magic signature */</span></div><div class="line">        <span class="number">__l</span>e16  s_state;                <span class="comment">/* File system state */</span></div><div class="line">        <span class="number">__l</span>e16  s_errors;               <span class="comment">/* Behaviour when detecting errors */</span></div><div class="line">        <span class="number">__l</span>e16  s_minor_rev_level;      <span class="comment">/* minor revision level */</span></div><div class="line">        <span class="number">__l</span>e32  s_lastcheck;            <span class="comment">/* time of last check */</span></div><div class="line">        <span class="number">__l</span>e32  s_checkinterval;        <span class="comment">/* max. time between checks */</span></div><div class="line">        <span class="number">__l</span>e32  s_creator_os;           <span class="comment">/* OS */</span></div><div class="line">        <span class="number">__l</span>e32  s_rev_level;            <span class="comment">/* Revision level */</span></div><div class="line">        <span class="number">__l</span>e16  s_def_resuid;           <span class="comment">/* Default uid for reserved blocks */</span></div><div class="line">        <span class="number">__l</span>e16  s_def_resgid;           <span class="comment">/* Default gid for reserved blocks */</span></div><div class="line">        <span class="number">__l</span>e32  s_first_ino;            <span class="comment">/* First non-reserved inode */</span></div><div class="line">        <span class="number">__l</span>e16   s_inode_size;          <span class="comment">/* size of inode structure */</span></div><div class="line">        <span class="number">__l</span>e16  s_block_group_nr;       <span class="comment">/* block group # of this superblock */</span></div><div class="line">        <span class="number">__l</span>e32  s_feature_compat;       <span class="comment">/* compatible feature set */</span></div><div class="line">        <span class="number">__l</span>e32  s_feature_incompat;     <span class="comment">/* incompatible feature set */</span></div><div class="line">        <span class="number">__l</span>e32  s_feature_ro_compat;    <span class="comment">/* readonly-compatible feature set */</span></div><div class="line">        <span class="number">__u</span>8    s_uuid[<span class="number">16</span>];             <span class="comment">/* 128-bit uuid for volume */</span></div><div class="line">        <span class="keyword">char</span>    s_volume_name[<span class="number">16</span>];      <span class="comment">/* volume name */</span></div><div class="line">        <span class="keyword">char</span>    s_last_mounted[<span class="number">64</span>];     <span class="comment">/* directory where last mounted */</span></div><div class="line">        <span class="number">__l</span>e32  s_algorithm_usage_bitmap; <span class="comment">/* For compression */</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Performance hints.  Directory preallocation should only</div><div class="line">         * happen if the EXT2_COMPAT_PREALLOC flag is on.</div><div class="line">         */</div><div class="line">        <span class="number">__u</span>8    s_prealloc_blocks;      <span class="comment">/* Nr of blocks to try to preallocate*/</span></div><div class="line">        <span class="number">__u</span>8    s_prealloc_dir_blocks;  <span class="comment">/* Nr to preallocate for dirs */</span></div><div class="line">        <span class="number">__u</span>16   s_padding1;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.</div><div class="line">         */</div><div class="line">        <span class="number">__u</span>8    s_journal_uuid[<span class="number">16</span>];     <span class="comment">/* uuid of journal superblock */</span></div><div class="line">        <span class="number">__u</span>32   s_journal_inum;         <span class="comment">/* inode number of journal file */</span></div><div class="line">        <span class="number">__u</span>32   s_journal_dev;          <span class="comment">/* device number of journal file */</span></div><div class="line">        <span class="number">__u</span>32   s_last_orphan;          <span class="comment">/* start of list of inodes to delete */</span></div><div class="line">        <span class="number">__u</span>32   s_hash_seed[<span class="number">4</span>];         <span class="comment">/* HTREE hash seed */</span></div><div class="line">        <span class="number">__u</span>8    s_def_hash_version;     <span class="comment">/* Default hash version to use */</span></div><div class="line">        <span class="number">__u</span>8    s_reserved_char_pad;</div><div class="line">        <span class="number">__u</span>16   s_reserved_word_pad;</div><div class="line">        <span class="number">__l</span>e32  s_default_mount_opts;</div><div class="line">        <span class="number">__l</span>e32  s_first_meta_bg;        <span class="comment">/* First metablock block group */</span></div><div class="line">        <span class="number">__u</span>32   s_reserved[<span class="number">190</span>];        <span class="comment">/* Padding to the end of the block */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>s_magic</code>字段是 magic 签名，对于 ext2 和 ext3 文件系统来说，这个字段的值应该正好等于 0xEF53。从这里可以看出ext2 和 ext3 的兼容性一定是很强的，不然不会使用同一个magic签名。</p>
<p><code>s_log_block_size</code>这个字段以2的幂次方表示的 block 的大小。我们把 block 的大小记作 B，B = 1 &lt;&lt; (s_log_block_size + 10)，单位是 bytes。举例来说，如果这个字段是 0，那么 block 的大小就是 1024 bytes，这正好就是最小的 block 大小；如果这个字段是 1，那么 block 大小就是 2048 bytes。</p>
<p><code>s_mnt_count</code>、<code>s_max_mnt_count</code>、<code>s_lastcheck</code>、<code>s_checkinterval</code>字段用于系统启动时自动检查Ext2文件系统。</p>
<p><code>s_state</code>字段表示Ext2文件系统的安装和卸载情况，如果Ext2文件系统被安装或未被全部卸载，则字段的值为0；如果被正常卸载，则字段的值为1；如果包含错误，则字段的值为2。</p>
<p>其他常用字段的含义通过注释基本上可以理解，或者可以查阅<code>UTLK</code>。</p>
<h4 id="组描述符"><a href="#组描述符" class="headerlink" title="组描述符"></a>组描述符</h4><p>Ext2分区中存在多少个块组，从超级块所在块的下个块开始，就跟着由相应数量组成的块组描述符组。<br>每一个块组描述符如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ext2_group_desc</div><div class="line">&#123;</div><div class="line">		<span class="number">__u</span>32 bg_block_bitmap;      <span class="comment">/* 块位图的块号 */</span></div><div class="line">		<span class="number">__u</span>32 bg_inode_bitmap;      <span class="comment">/* 索引节点位图的块号 */</span></div><div class="line">		<span class="number">__u</span>32 bg_inode_table;       <span class="comment">/* 索引节点表的第一个块的块号 */</span></div><div class="line"> 		<span class="number">__u</span>16 bg_free_blocks_count; <span class="comment">/* 空闲块的数量 */</span></div><div class="line"> 		<span class="number">__u</span>16 bg_free_inodes_count; <span class="comment">/* 空闲索引节点的数量 */</span></div><div class="line">		<span class="number">__u</span>16   bg_used_dirs_count; <span class="comment">/* 组中目录的数量 */</span></div><div class="line">		<span class="number">__u</span>16   bg_pad;</div><div class="line">		<span class="number">__u</span>32   bg_reserved[<span class="number">3</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>数据块位图和索引节点位图的作用主要就是记录数据块和索引节点的使用情况。0表示空闲，1表示使用中。每个位图都存放在一个单独的块中，块的大小通常为1024 bytes或者4096 bytes,所以一个单独的位图描述8192或者32768个数据块或索引节点的使用情况。当分配或释放数据块、索引节点时都要修改对应的位图。</p>
<h4 id="索引节点表"><a href="#索引节点表" class="headerlink" title="索引节点表"></a>索引节点表</h4><p>索引节点表由连续的块组成，所有索引节点的大小相同，都为128 bytes。索引节点的结构为<code>ext2_innode</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ext2_inode &#123;</div><div class="line">        <span class="number">__l</span>e16  i_mode;         <span class="comment">/* File mode */</span></div><div class="line">        <span class="number">__l</span>e16  i_uid;          <span class="comment">/* Low 16 bits of Owner Uid */</span></div><div class="line">        <span class="number">__l</span>e32  i_size;         <span class="comment">/* Size in bytes */</span></div><div class="line">        <span class="number">__l</span>e32  i_atime;        <span class="comment">/* Access time */</span></div><div class="line">        <span class="number">__l</span>e32  i_ctime;        <span class="comment">/* Creation time */</span></div><div class="line">        <span class="number">__l</span>e32  i_mtime;        <span class="comment">/* Modification time */</span></div><div class="line">        <span class="number">__l</span>e32  i_dtime;        <span class="comment">/* Deletion Time */</span></div><div class="line">        <span class="number">__l</span>e16  i_gid;          <span class="comment">/* Low 16 bits of Group Id */</span></div><div class="line">        <span class="number">__l</span>e16  i_links_count;  <span class="comment">/* Links count */</span></div><div class="line">        <span class="number">__l</span>e32  i_blocks;       <span class="comment">/* Blocks count */</span></div><div class="line">        <span class="number">__l</span>e32  i_flags;        <span class="comment">/* File flags */</span></div><div class="line">        <span class="keyword">union</span> &#123;</div><div class="line">                <span class="keyword">struct</span> &#123;</div><div class="line">                        <span class="number">__l</span>e32  l_i_reserved1;</div><div class="line">                &#125; linux1;</div><div class="line">                <span class="keyword">struct</span> &#123;</div><div class="line">                        <span class="number">__l</span>e32  h_i_translator;</div><div class="line">                &#125; hurd1;</div><div class="line">                <span class="keyword">struct</span> &#123;</div><div class="line">                        <span class="number">__l</span>e32  m_i_reserved1;</div><div class="line">                &#125; masix1;</div><div class="line">        &#125; osd1;                         <span class="comment">/* OS dependent 1 */</span></div><div class="line">        <span class="number">__l</span>e32  i_block[EXT2_N_BLOCKS];<span class="comment">/* Pointers to blocks */</span></div><div class="line">        <span class="number">__l</span>e32  i_generation;   <span class="comment">/* File version (for NFS) */</span></div><div class="line">        <span class="number">__l</span>e32  i_file_acl;     <span class="comment">/* File ACL */</span></div><div class="line">        <span class="number">__l</span>e32  i_dir_acl;      <span class="comment">/* Directory ACL */</span></div><div class="line">        <span class="number">__l</span>e32  i_faddr;        <span class="comment">/* Fragment address */</span></div><div class="line">        <span class="keyword">union</span> &#123;</div><div class="line">                <span class="keyword">struct</span> &#123;</div><div class="line">                        <span class="number">__u</span>8    l_i_frag;       <span class="comment">/* Fragment number */</span></div><div class="line">                        <span class="number">__u</span>8    l_i_fsize;      <span class="comment">/* Fragment size */</span></div><div class="line">                        <span class="number">__u</span>16   i_pad1;</div><div class="line">                        <span class="number">__l</span>e16  l_i_uid_high;   <span class="comment">/* these 2 fields    */</span></div><div class="line">                        <span class="number">__l</span>e16  l_i_gid_high;   <span class="comment">/* were reserved2[0] */</span></div><div class="line">                        <span class="number">__u</span>32   l_i_reserved2;</div><div class="line">                &#125; linux2;</div><div class="line">                <span class="keyword">struct</span> &#123;</div><div class="line">                        <span class="number">__u</span>8    h_i_frag;       <span class="comment">/* Fragment number */</span></div><div class="line">                        <span class="number">__l</span>e16  h_i_mode_high;</div><div class="line">                        <span class="number">__l</span>e32  h_i_author;</div><div class="line">                &#125; hurd2;</div><div class="line">                <span class="keyword">struct</span> &#123;</div><div class="line">                        <span class="number">__u</span>8    m_i_frag;       <span class="comment">/* Fragment number */</span></div><div class="line">                        <span class="number">__u</span>8    m_i_fsize;      <span class="comment">/* Fragment size */</span></div><div class="line">                        <span class="number">__u</span>16   m_pad1;</div><div class="line">                        <span class="number">__u</span>32   m_i_reserved2[<span class="number">2</span>];</div><div class="line">                &#125; masix2;</div><div class="line">        &#125; osd2;                         <span class="comment">/* OS dependent 2 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>i_size</code>字段表示文件的长度（字节），<code>i_blocks</code>字段存放文件占用的数据块数量（文件的数据块以512字节为一个单位）。<code>i_block</code>是一个长度为<code>EXT2_N_BLOCKS</code>的数组，每个元素都是一个指针，指向实际的文件块号，<code>EXT2_N_BLOCKS</code>通常为15，具体在后文分析。</p>
<p>VFS模型要求每个文件都有不同的索引节点号，但是在结构中并没有看到索引节点号。这是因为每个块组的索引节点数量相同，完全可以根据块组号、每块组索引节点数量、索引节点表来进行索引节点和块号的转换。假设每个块组包含4096个索引节点，则索引节点13021属于第三个块组，并且存放在对应索引节点表的第733项。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>目录和普通文件一样都有着一个对应的索引节点，但是普通文件的数据块内容就是文件内容，而目录的数据块里面存放着一种数据结构<code>ext2_dir_entry_2</code>,该结构表示目录中的某一项内容，类型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> ext2_dir_entry &#123;</div><div class="line">        <span class="number">__l</span>e32  inode;                  <span class="comment">/* Inode number */</span></div><div class="line">        <span class="number">__l</span>e16  rec_len;                <span class="comment">/* Directory entry length */</span></div><div class="line">        <span class="number">__l</span>e16  name_len;               <span class="comment">/* Name length */</span></div><div class="line">        <span class="number">__u</span>8    file_type;		<span class="comment">/* 文件类型 */</span></div><div class="line">        <span class="keyword">char</span>    name[];                 <span class="comment">/* File name, up to EXT2_NAME_LEN */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>rec_len</code>表示目录项的长度，也可以理解为下一个目录项距当前目录项起始地址的偏移量。因为效率的原因，目录项的长度总是为4的倍数，在必要时用null字符（\0）填充文件名的末尾部分。当我们想删除一个目录项时，只需把那一项的<code>inode</code>设置为0，并且把删除项的上一项的<code>rec_len</code>加上删除项的<code>rec_len</code>(相当于把删除项给跳过)。</p>
<p><code>name_len</code>表示目录项名字的实际长度。</p>
<p><code>file_type</code>表示该项的文件类型，Ext2中的文件类型有如下几种:</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">未知</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">普通文件</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">目录</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">字符设备</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">块设备</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">命名管道</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">套接字</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">符号链接</td>
</tr>
</tbody>
</table>
<p><code>name</code>是一个char数组，数组长度上限为<code>EXT2_NAME_LEN</code>(通常为255)。</p>
<p>下图是一个Ext2目录的例子:<br><img src="/images/ext2/ext2-file-system-1.png" alt="Ext2目录"><br>其中文件名为<code>oldfile</code>那一项的<code>inode</code>值为0，所以该目录项已经被删除，也可以看到该项的上一项(文件名<code>user</code>)的<code>rec_len</code>为28（user项的长度加上oldfile项长度）。</p>
<h4 id="数据块寻址"><a href="#数据块寻址" class="headerlink" title="数据块寻址"></a>数据块寻址</h4><p>每个非空的普通文件都含有一组数据块，这些数据块可以由所在文件的文件块号或者磁盘分区的逻辑块号来标识。在索引节点中有一个<code>i_block</code>字段，这是一个数组，元素内容就是一个指向数据块的指针，<code>i_block</code>的示意图如下:<br><img src="/images/ext2/ext2-file-system-2.png" alt="数据块寻址"><br><code>i_block</code>数组就相当于是一个目录，用于进行文件块号和逻辑块号的转换。其中0~11号元素直接进行一对一映射，将一个文件块号对应到块组数据块中的某一个逻辑快号，而下标12、13、14的元素分别指向一个一级数组、二级数组、三级数组。</p>
<p>根据文件内的偏移量ƒ导出相应数据块的逻辑块号需要两个步骤：</p>
<ol>
<li>将偏移量ƒ转换为文件块号。</li>
<li>将文件块号转换为数据块的逻辑块号。</li>
</ol>
<p>假设数据块的大小为1024 bytes，如果ƒ小于1024,则ƒ对应的字符存在于第0个文件块号，也就是<code>i_block</code>数组的第0项，<code>i_block[0]</code>的内容就是该文件块号所对应的数据块块号。如果转换出来的文件块号n满足  <code>12 &lt;= n &lt;= b/4 + 11</code>(b表示块大小，在这里就是1024。除以4是因为一个文件块号占用4 bytes，也就是i_block数组的元素大小为4 bytes。)，则表示该文件块号存在于<code>i_block[11]</code>指向的数组中。通过<code>i_block[11]</code>的值，找到一个间接块（结构类似于i_block数组），然后找到下标为<code>n-12</code>的项，其中的值便是对应的逻辑块号。<code>i_block[12]</code>、<code>i_block[13]</code>情况类似，只不过中间多了些转换过程。</p>
<p>参考：</p>
<ul>
<li>UTLK</li>
</ul>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> 
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Ext2磁盘数据结构&quot;&gt;&lt;a href=&quot;#Ext2磁盘数据结构&quot; class=&quot;headerlink&quot; title=&quot;Ext2磁盘数据结构&quot;&gt;&lt;/a&gt;Ext2磁盘数据结构&lt;/h4&gt;&lt;p&gt;任何Ext2分区中的第一个块从不受Ext2文件系统的管理，因为第一个块是分区
    
    </summary>
    
      <category term="文件系统" scheme="http://vinoit.me/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Ext2" scheme="http://vinoit.me/tags/Ext2/"/>
    
      <category term="文件系统" scheme="http://vinoit.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统启动流程</title>
    <link href="http://vinoit.me/2016/09/16/how-linux-start/"/>
    <id>http://vinoit.me/2016/09/16/how-linux-start/</id>
    <published>2016-09-16T11:40:21.000Z</published>
    <updated>2016-09-23T07:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文在原文:<a href="http://www.linux178.com/linux/linuxinit.html" target="_blank" rel="external">http://www.linux178.com/linux/linuxinit.html</a> 的基础上进行了些许修改</p>
</blockquote>
<h4 id="Linux系统启动流程概览"><a href="#Linux系统启动流程概览" class="headerlink" title="Linux系统启动流程概览"></a>Linux系统启动流程概览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST（Power On Self Test/上电自检）--&gt;BootLoader(MBR)--&gt;Kernel(硬件探测、加载驱动、挂载根文件系统、/sbin/init)</div><div class="line">--&gt;init(/etc/inittab:设定默认级别、系统初始化脚本、启动及关闭对应级别的服务、启动终端)</div></pre></td></tr></table></figure>
<h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p>计算机电源接通后，CPU默认执行<code>0xFFFF0000</code>处的指令，而此内存地址应该存放的就是<code>BIOS ROM</code>（硬件把这个地址映射成ROM芯片）。系统将有一个对内部各个设备进行检查的过程，这是由一个通常称之为POST（Power On Self Test/上电自检）的程序来完成，这也是BIOS程序的一个功能。完整的自检包括了对CPU、640K基本内存、1M以上的扩展内存、ROM、主板、CMOS存贮器、串并口、显示卡、软硬盘子系统及键盘的测试。在自检过程中若发现问题，系统将给出提示信息或鸣笛警告。</p>
<p>如果没有任何问题，完成自检后BIOS将按照系统CMOS设置中的启动顺序搜寻软、硬盘驱动器及CDROM、网络服务器等有效的启动驱动器 ，读入操作系统引导记录（BootLoader），然后将系统控制权交给引导记录，由引导记录完成系统的启动。如果一直没有找到可启动的设备，那么本次启动宣告失败。</p>
<h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p>在上一步中，BIOS找到硬盘的MBR（位于硬盘的0磁道0扇区 大小为512字节，该区域不能被分配给任何分区），然后在MBR中寻找BootLoader（目前比较常用有LILO 和 GRUB，LILO已经不常用，BootLoader在MBR所占446字节，所以必须短小精悍，接下来64字节是分区表信息，最后2字节是用来标明该MBR是否有效），然后把BootLoader加载到内存中开始执行，BootLoader主要功能就是从硬盘找到内核文件，把内核文件加载到内存执行。</p>
<p>MBR的三部分如下:</p>
<ul>
<li>第1-446字节：BootLoader。</li>
<li>第447-510字节：分区表（Partition table）。</li>
<li>第511-512字节：主引导记录签名（0x55和0xAA）。</li>
</ul>
<p>扩充（源于阮一峰的网络日志）：</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。<br>每个主分区的16个字节，由6个部分组成：</p>
<ul>
<li>第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</li>
<li>第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</li>
<li>第5个字节：主分区类型。</li>
<li>第6-8个字节：主分区最后一个扇区的物理位置。</li>
<li>第9-12字节：该主分区第一个扇区的逻辑地址。</li>
<li>第13-16字节：主分区的扇区总数。</li>
</ul>
<p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。</p>
<p>疑问? 内核文件在哪里？GRUB是怎么找到内核文件？</p>
<p>内核文件（vmlinuz-2.6.18-308.el5）是位于/boot分区下（在我们给硬盘分区的时候都会把/boot单独分区），这时又有疑问了，这时候/都没有被挂载，又如何从硬盘上找到内核文件？<br><img src="/images/linux/how-linux-start-0.png" alt=""></p>
<p>这时看GRUB的配置文件/boot/grub/grub.conf 可以看到 root (hd0,0)，这一行实际上就是指定boot目录所在的位置<br>而kernel /vmlinuz-2.6.18-308.el5 ro root=LABEL=/ 这里指定的是内核文件所在的位置，而前面的/并不是真正的根，而是指的是boot目录所在的位置，那么其全路径为(hd0,0)/vmlinuz-2.6.18-308.el5,而这里的(hd0,0)指的是第1个硬盘的第1个分区，GRUB在识别硬盘的时候都是识别为hd开头的。</p>
<p>总结: GRUB 不是通过文件系统来找内核文件的，因为这时候内核还没有启动所以也不存在什么文件系统，而是直接访问硬盘的第1个硬盘第1个分区（MBR里面存在分区表）的来找到内核文件。</p>
<p>这时候又有个问题 GRUB是怎么识别分区表中这些分区的文件系统的？ 且看/boot/grub目录下的文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@server1 grub]# ll</div><div class="line">总计 257</div><div class="line">-rw-r--r-- 1 root root     63 2013-01-05 device.map</div><div class="line">-rw-r--r-- 1 root root   7584 2013-01-05 e2fs_stage1_5</div><div class="line">-rw-r--r-- 1 root root   7456 2013-01-05 fat_stage1_5</div><div class="line">-rw-r--r-- 1 root root   6720 2013-01-05 ffs_stage1_5</div><div class="line">-rw------- 1 root root    562 2013-01-05 grub.conf</div><div class="line">-rw-r--r-- 1 root root   6720 2013-01-05 iso9660_stage1_5</div><div class="line">-rw-r--r-- 1 root root   8192 2013-01-05 jfs_stage1_5</div><div class="line">lrwxrwxrwx 1 root root     11 2013-01-05 menu.lst -&gt; ./grub.conf</div><div class="line">-rw-r--r-- 1 root root   6880 2013-01-05 minix_stage1_5</div><div class="line">-rw-r--r-- 1 root root   9248 2013-01-05 reiserfs_stage1_5</div><div class="line">-rw-r--r-- 1 root root  55808 2009-03-13 splash.xpm.gz</div><div class="line">-rw-r--r-- 1 root root    512 2013-01-05 stage1</div><div class="line">-rw-r--r-- 1 root root 104988 2013-01-05 stage2</div><div class="line">-rw-r--r-- 1 root root   7072 2013-01-05 ufs2_stage1_5</div><div class="line">-rw-r--r-- 1 root root   6272 2013-01-05 vstafs_stage1_5</div><div class="line">-rw-r--r-- 1 root root   8904 2013-01-05 xfs_stage1_5</div></pre></td></tr></table></figure>
<p>其实GRUB启动是分阶段的：</p>
<p>第1个阶段  BIOS加载MBR里面的GRUB（属于第1阶段的文件），由于只有GRUB只占用446字节所以不能实现太多的功能，所以就有此阶段里面的文件来加载第1.5阶段的文件（/boot/grub下的文件）。</p>
<p>第1.5个阶段 这个阶段里面的就是加载识别文件系统的程序，来识别文件系统，不加载就无法识别文件系统，进而就找不到boot目录，由于GRUB是无法识别LVM，所以你不能把/boot分区设置为LVM，所以必须要把/boot单独分区。</p>
<p>第2个阶段 这里面才是正在的开始寻找内核的过程，然后是启动内核。</p>
<h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p>在上一步中，GRUB成功找到内核文件，并把内核加载到内存，同时把/boot/initrd-2.6.18-308.el5.img这个文件也加载进来，这个文件是做什么的呢？</p>
<p>那么首先看看内核在这一步骤里面做的事情：</p>
<ol>
<li>探测硬件</li>
<li>加载驱动</li>
<li>挂载根文件系统</li>
<li>执行第一个程序/sbin/init</li>
</ol>
<p>BIOS检查硬件，而内核是会初始化硬件设备，那么首先会探测硬件（第1步），知道是什么硬件了就该加载硬件驱动程序（第2步），不然是没办法指挥着硬件工作的，关键是内核去哪里找驱动程序（驱动程序是硬盘上，是内核模块.ko存在的）而此时根文件系统还没有挂载上，怎么办？ 那可以②③对调，先挂载根文件系统，然后再加载驱动，那此时又有问题了，我不加载驱动程序又如何驱动着硬盘工作呢？ 这个陷入了是先有蛋还是有先鸡的问题了，这该如何解决？</p>
<p>这时候 这个文件/boot/initrd-2.6.18-308.el5.img（该文件是一个.gz的压缩文件） 就派上用场了，这个文件也是被GRUB加载内存当中，构建成一个虚拟的根文件系统，这个文件里面包含有硬件驱动程序（），这个文件是可以展开如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@server1 boot]# cp initrd-2.6.18-308.el5.img ~</div><div class="line">[root@server1 boot]# cd</div><div class="line">[root@server1 ~]# ls</div><div class="line">initrd-2.6.18-308.el5.img</div><div class="line">[root@server1 ~]# mv initrd-2.6.18-308.el5.img initrd-2.6.18-308.el5.img.gz</div><div class="line">[root@server1 ~]# gzip -d initrd-2.6.18-308.el5.img.gz</div><div class="line">[root@server1 ~]# ls</div><div class="line">initrd-2.6.18-308.el5.img</div><div class="line">[root@server1 ~]# file initrd-2.6.18-308.el5.img</div><div class="line">initrd-2.6.18-308.el5.img: ASCII cpio archive (SVR4 with no CRC) 可以看到此时是一个cpio的归档文件</div><div class="line">[root@server1 ~]# mkdir test</div><div class="line">[root@server1 ~]# mv initrd-2.6.18-308.el5.img  test</div><div class="line">[root@server1 ~]# cd test</div><div class="line">[root@server1 test]# ls</div><div class="line">initrd-2.6.18-308.el5.img</div><div class="line">[root@server1 test]# cpio -id &lt; initrd-2.6.18-308.el5.img  利用cpio来展开该文件</div><div class="line">12111 blocks</div><div class="line">[root@server1 test]# ls</div><div class="line">bin  dev  etc  init  initrd-2.6.18-308.el5.img  lib  proc  sbin  sys  sysroot</div><div class="line">[root@server1 test]# mv initrd-2.6.18-308.el5.img ../</div><div class="line">[root@server1 test]# ls  可以看到这不就是跟真实的根很像吗</div><div class="line">bin  dev  etc  init  lib  proc  sbin  sys  sysroot</div><div class="line">[root@server1 test]# ls lib/    可以看到这目录下包含了ext3.ko的内核模块，该模块就可以驱动着硬盘进行工作了</div><div class="line">ata_piix.ko            dm-mod.ko              ext3.ko                mptbase.ko             scsi_mod.ko</div><div class="line">dm-log.ko              dm-raid45.ko           firmware/              mptscsih.ko            scsi_transport_spi.ko</div><div class="line">dm-mem-cache.ko        dm-region_hash.ko      jbd.ko                 mptspi.ko              sd_mod.ko</div><div class="line">dm-message.ko          ehci-hcd.ko            libata.ko              ohci-hcd.ko            uhci-hcd.ko</div><div class="line">[root@server1 test]#</div></pre></td></tr></table></figure>
<p>至此内核利用虚拟的根文件系统的ext3.ko内核模块，驱动了硬盘，然后挂载了真正的根文件系统，那么此时虚拟的根文件系统是否还有作用，它还可以挂载/proc文件系统等操作。</p>
<p>此阶段中最后一个步骤 由内核来启动第一个程序/sbin/init，启动好之后剩下的工作就有init进程来完成了。</p>
<h4 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h4><p>init进程首先会读取/etc/inittab文件，根据inittab文件中的内容依次执行</p>
<p>设定系统运行的默认级别（id:3:initdefault:）<br>执行系统初始化脚本文件（si::sysinit:/etc/rc.d/rc.sysinit）<br>执行在该运行级别下所启动或关闭对应的服务（l3:3:wait:/etc/rc.d/rc 3）<br>启动6个虚拟终端:</p>
<ul>
<li>l0:0:wait:/etc/rc.d/rc 0</li>
<li>l1:1:wait:/etc/rc.d/rc 1</li>
<li>l2:2:wait:/etc/rc.d/rc 2</li>
<li>l3:3:wait:/etc/rc.d/rc 3</li>
<li>l4:4:wait:/etc/rc.d/rc 4</li>
<li>l5:5:wait:/etc/rc.d/rc 5</li>
<li>l6:6:wait:/etc/rc.d/rc 6</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文在原文:&lt;a href=&quot;http://www.linux178.com/linux/linuxinit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.linux178.com/linux/li
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="Boot" scheme="http://vinoit.me/tags/Boot/"/>
    
      <category term="GRUB" scheme="http://vinoit.me/tags/GRUB/"/>
    
  </entry>
  
  <entry>
    <title>JNI探秘--FileDescriptor、FileInputStream 解惑</title>
    <link href="http://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/"/>
    <id>http://vinoit.me/2016/09/14/JNI-explore-FileDescriptor-and-FileInputStream/</id>
    <published>2016-09-14T01:13:07.000Z</published>
    <updated>2016-10-31T08:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>使用JAVA读取文件时需要用到<code>FileInputStream</code>这个类，最简单的使用方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">            System.out.println(fileInputStream.read());</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>FileInputStream</code>源码中的构造方法一共有3个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name != <span class="keyword">null</span> ? <span class="keyword">new</span> File(name) : <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</div><div class="line">        String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            security.checkRead(name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (file.isInvalid()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"Invalid file path"</span>);</div><div class="line">        &#125;</div><div class="line">        fd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">        fd.attach(<span class="keyword">this</span>);</div><div class="line">        path = name;</div><div class="line">        open(name);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            security.checkRead(fdObj);</div><div class="line">        &#125;</div><div class="line">        fd = fdObj;</div><div class="line">        path = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * FileDescriptor is being shared by streams.</div><div class="line">         * Register this stream with FileDescriptor tracker.</div><div class="line">         */</div><div class="line">        fd.attach(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>fd</code>和<code>path</code>定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* File Descriptor - handle to the open file */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * The path of the referenced file</div><div class="line">   * (null if the stream is created with a file descriptor)</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String path;</div></pre></td></tr></table></figure>
<p>参数为<code>String name</code>或者<code>File file</code>的构造方法都新建了一个<code>fileDescriptor</code>,并赋值给<code>fd</code>，而参数为<code>FileDescriptor fdObj</code>的构造方法直接将<code>fdObj</code>参数赋值给<code>fd</code>。其实从这里可以感觉出<code>FileDescriptor</code>(文件描述符)是JAVA中的文件操作核心。</p>
<h4 id="疑惑一"><a href="#疑惑一" class="headerlink" title="疑惑一"></a>疑惑一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException </span>&#123;</div><div class="line"></div><div class="line">        FileDescriptor fileDescriptor = <span class="keyword">null</span>;</div><div class="line">        FileDescriptor fileDescriptor1 = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">        FileInputStream fileInputStream1 = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</div><div class="line">        </div><div class="line">        System.out.println(fileInputStream.getFD().valid());</div><div class="line">        System.out.println(fileInputStream1.getFD().valid());</div><div class="line">        fileDescriptor = fileInputStream.getFD();</div><div class="line">        fileDescriptor1 = fileInputStream1.getFD();</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<p>其中<code>fileDescriptor</code>和<code>fileDescriptor1</code>的值分别为:<br><img src="/images/JNI/FileDescriptor-and-FileInputStream-0.png" alt=""><br>查看<code>FileDescriptor</code>的源码，2个构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  <span class="title">FileDescriptor</span><span class="params">()</span> </span>&#123;</div><div class="line">    fd = -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span>  <span class="title">FileDescriptor</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.fd = fd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>FileDescriptor</code>中的<code>fd</code>是一个<code>int</code>类型的值。<code>FileDescriptor</code>源码中只有一个public的构造方法，而且<code>fd</code>的初始值为<code>-1</code>,但是<code>FileInputStream</code>中的<code>fd</code>(FileDescriptor类型)的<code>fd</code>值通过调试看到不为<code>-1</code>（2个fd是包含的关系）。输出<code>true</code>的条件就是<code>fd != -1</code>。</p>
<h4 id="疑惑一解密"><a href="#疑惑一解密" class="headerlink" title="疑惑一解密"></a>疑惑一解密</h4><p>在参数为<code>File file</code>的构造方法的最后调用了一个<code>open</code>方法，初步怀疑在这个方法内改变了<code>fd</code>的内容。通过打断点调试，的确在<code>open</code>方法调用之后<code>fd</code>的值改变了。<code>open</code>方法的最终调用为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>;</div></pre></td></tr></table></figure>
<p>可以看到是一个<code>native</code>方法，对应的JNI方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileInputStream_open</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path)</span> &#123;</div><div class="line">    fileOpen(env, <span class="keyword">this</span>, path, fis_fd, O_RDONLY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>env</code>是JNI的一个对象，<code>this</code>表示调用<code>open</code>方法的<code>FileInputStream</code>对象，<code>path</code>为传进来的参数（文件名）,<code>O_RDONLY</code>表示只读，<code>fis_fd</code>是在JNI中定义的一个变量:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">jfieldID fis_fd; <span class="comment">/* id for jobject 'fd' in java.io.FileInputStream */</span></div><div class="line"></div><div class="line"><span class="comment">/**************************************************************</span></div><div class="line"> * static methods to store field ID's in initializers</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileInputStream_initIDs</span><span class="params">(JNIEnv *env, jclass fdClass)</span> &#123;</div><div class="line">    fis_fd = (*env)-&gt;GetFieldID(env, fdClass, <span class="string">"fd"</span>, <span class="string">"Ljava/io/FileDescriptor;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fis_fd</code>通过<code>Java_java_io_FileInputStream_initIDs</code>方法初始化，该方法对应了<code>FileInputStream</code>如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">        initIDs();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以，在<code>FileInputStream</code>类加载阶段，<code>fis_fd</code>就被初始化了，<code>fid_fd</code>相当于是<code>fd</code>字段的一个内存偏移量。<code>open</code>方法直接调用了<code>fileOpen</code>方法，<code>fileOpen</code>方法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">fileOpen</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jstring path, jfieldID fid, <span class="keyword">int</span> flags)</span></div><div class="line">&#123;</div><div class="line">    WITH_PLATFORM_STRING(env, path, ps) &#123;</div><div class="line">        FD fd;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__) || defined(_ALLBSD_SOURCE)</span></div><div class="line">        <span class="comment">/* Remove trailing slashes, since the kernel won't */</span></div><div class="line">        <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)ps + <span class="built_in">strlen</span>(ps) - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> ((p &gt; ps) &amp;&amp; (*p == <span class="string">'/'</span>))</div><div class="line">            *p-- = <span class="string">'\0'</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        fd = handleOpen(ps, flags, <span class="number">0666</span>);</div><div class="line">        <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</div><div class="line">            SET_FD(<span class="keyword">this</span>, fd, fid);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            throwFileNotFoundException(env, path);</div><div class="line">        &#125;</div><div class="line">    &#125; END_PLATFORM_STRING(env, ps);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的<code>handleOpen</code>函数打开了一个文件句柄（一个数字），相当于和文件建立了联系，并且将返回的句柄赋值给了局部变量<code>fd</code>,然后调用了<code>SET_FD</code>宏:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_FD(this, fd, fid) \</span></div><div class="line">    <span class="meta-keyword">if</span> ((*env)-&gt;GetObjectField(env, (this), (fid)) != NULL) \</div><div class="line">        (*env)-&gt;SetIntField(env, (*env)-&gt;GetObjectField(env, (this), (fid)),IO_fd_fdID, (fd))</div></pre></td></tr></table></figure>
<p>该函数首先判断FileInputStream这个对象的fd属性是不是空，如果不为空，则进行赋值。<code>fd</code>是刚得到的文件句柄，<code>(*env)-&gt;GetObjectField(env, (this), (fid))</code>是<code>FileInputStream</code>对象的<code>fd</code>字段。但是句柄<code>fd</code>是<code>int</code>类型的，而<code>FileInputStream</code>对象的<code>fd</code>字段是<code>FileDescriptor</code>类型的，如何赋值?理所当然，我们需要一个偏移量，一个<code>FileDescriptor</code>中的<code>fd</code>字段的偏移量，也就是<code>IO_fd_fdID</code>的值。<code>IO_fd_fdID</code>是在<code>FileDescriptor</code>对应JNI代码的一个变量，在类加载时期初始化,通过静态代码块:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">        initIDs();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对应的<code>native</code>方法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* field id for jint 'fd' in java.io.FileDescriptor */</span></div><div class="line">jfieldID IO_fd_fdID;</div><div class="line"></div><div class="line"><span class="comment">/**************************************************************</span></div><div class="line"> * static methods to store field ID's in initializers</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileDescriptor_initIDs</span><span class="params">(JNIEnv *env, jclass fdClass)</span> &#123;</div><div class="line">    IO_fd_fdID = (*env)-&gt;GetFieldID(env, fdClass, <span class="string">"fd"</span>, <span class="string">"I"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可得，调用<code>open</code>方法之后，<code>FileInputSream</code>对象的<code>fd</code>的值被改变了。</p>
<h4 id="疑惑二"><a href="#疑惑二" class="headerlink" title="疑惑二"></a>疑惑二</h4><p>既然<code>FileDescriptor</code>是文件操作的核心，那么<code>read</code>方法调用又是怎么和它联系起来的？</p>
<h4 id="疑惑二解密"><a href="#疑惑二解密" class="headerlink" title="疑惑二解密"></a>疑惑二解密</h4><p><code>FileInputStream</code>中的<code>read</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> read0();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure>
<p>对应的<code>native</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jint JNICALL</span></div><div class="line"><span class="title">Java_java_io_FileInputStream_read</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>)</span> &#123;</div><div class="line">    <span class="keyword">return</span> readSingle(env, <span class="keyword">this</span>, fis_fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>readSingle()</code>方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">jint</span></div><div class="line"><span class="title">readSingle</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>, jfieldID fid)</span> &#123;</div><div class="line">    jint nread;</div><div class="line">    <span class="keyword">char</span> ret;</div><div class="line">    FD fd = GET_FD(<span class="keyword">this</span>, fid);</div><div class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</div><div class="line">        JNU_ThrowIOException(env, <span class="string">"Stream Closed"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    nread = IO_Read(fd, &amp;ret, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123; <span class="comment">/* EOF */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123; <span class="comment">/* error */</span></div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Read error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret &amp; <span class="number">0xFF</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然java代码中没有表现出对<code>fd</code>的使用，但是在<code>native</code>代码中的确使用了<code>fd</code>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JAVA中的文件操作最终都是要通过<code>FileDescriptor</code>，在Unix/Linux中的文件描述符就是一个数字，对应了进程打开文件数组的下标，该数组的0,1,2号文件分别表示标准输入、标准输出，标准错误输出。这和JAVA中是一致的，<code>FileDescriptor</code>中的fd为0，1，2时也表示同样的意义。所以以下代码也可以用于输出<code>&#39;A&#39;</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</div><div class="line">        fileOutputStream.write(<span class="string">'A'</span>);</div></pre></td></tr></table></figure>
<p>当我们通过<code>文件名</code>或者<code>文件对象</code>new一个FileInputStream的时候，做了以下步骤：</p>
<ol>
<li><p>如果FileInputStream类尚未加载，则执行initIDs方法，否则这一步直接跳过。</p>
</li>
<li><p>如果FileDescriptor类尚未加载，则执行initIDs方法，否则这一步也直接跳过。</p>
</li>
<li><p>new一个FileDescriptor对象赋给FileInputStream的fd属性。</p>
</li>
<li><p>打开一个文件句柄。</p>
</li>
<li><p>将文件句柄赋给FileDescriptor对象的fd字段。</p>
</li>
</ol>
<p>注：本文JDK版本为1.8</p>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> </blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;使用JAVA读取文件时需要用到&lt;code&gt;FileInputStream&lt;/code&gt;这个类，最简单的使用方式如下:&lt;/p&gt;
&lt;figure
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
      <category term="JNI" scheme="http://vinoit.me/categories/java/JNI/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="JNI" scheme="http://vinoit.me/tags/JNI/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程地址空间</title>
    <link href="http://vinoit.me/2016/09/10/linux-kernel-note-process-address-space/"/>
    <id>http://vinoit.me/2016/09/10/linux-kernel-note-process-address-space/</id>
    <published>2016-09-10T05:34:16.000Z</published>
    <updated>2016-09-10T13:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h4><p>进程的地址空间由允许进程使用的全部线性地址组成，在32位系统中为0~3GB，每个进程看到的线性地址集合是不同的。</p>
<p>内核通过线性区的资源（数据结构）来表示线性地址区间，线性区是由起始线性地址，长度和一些访问权限来描述的。线性区的大小为页框的整数倍，起始地址为4096的整数倍。</p>
<p>下图展示了x86 Linux 进程的地址空间组织结构：<br><img src="/images/linux-kernel-note/process-address-space-0.png" alt=""></p>
<ul>
<li>正文段 .text ，这是CPU执行的机器指令部分。通常正文段是共享的，而且是只读的，以防止程序修改其自身的指令。</li>
<li>数据段 .data。数据段包含了程序中需要明确赋初值的变量。</li>
<li>非初始化数据段 bss。bss 起始于 IBM 704汇编语言中的 Block Storage Start 指令的首字母缩写,并且沿用至今。</li>
</ul>
<h4 id="线性区描述符"><a href="#线性区描述符" class="headerlink" title="线性区描述符"></a>线性区描述符</h4><p>进程地址空间中的堆、栈等，就是一个线性区，线性区的结构类型为<code>struct vm_area_struct</code>：<br><a href="http://lxr.free-electrons.com/source/include/linux/mm_types.h#L299" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/mm_types.h#L299</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="number">299</span> <span class="keyword">struct</span> vm_area_struct &#123;</div><div class="line"><span class="number">300</span>         <span class="comment">/* The first cache line has the info for VMA tree walking. */</span></div><div class="line"><span class="number">301</span> </div><div class="line"><span class="number">302</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">/* Our start address within vm_mm. */</span></div><div class="line"><span class="number">303</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">/* The first byte after our end address</span></div><div class="line">304                                            within vm_mm. */</div><div class="line"><span class="number">305</span> </div><div class="line"><span class="number">306</span>         <span class="comment">/* linked list of VM areas per task, sorted by address */</span></div><div class="line"><span class="number">307</span>         <span class="keyword">struct</span> vm_area_struct *vm_next, *vm_prev;</div><div class="line"><span class="number">308</span> </div><div class="line"><span class="number">309</span>         <span class="keyword">struct</span> rb_node vm_rb;</div><div class="line"><span class="number">310</span> </div><div class="line"><span class="number">311</span>         <span class="comment">/*</span></div><div class="line">312          * Largest free memory gap in bytes to the left of this VMA.</div><div class="line">313          * Either between this VMA and vma-&gt;vm_prev, or between one of the</div><div class="line">314          * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</div><div class="line">315          * get_unmapped_area find a free area of the right size.</div><div class="line">316          */</div><div class="line"><span class="number">317</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</div><div class="line"><span class="number">318</span> </div><div class="line"><span class="number">319</span>         <span class="comment">/* Second cache line starts here. */</span></div><div class="line"><span class="number">320</span> </div><div class="line"><span class="number">321</span>         <span class="keyword">struct</span> mm_struct *vm_mm;        <span class="comment">/* The address space we belong to. */</span></div><div class="line"><span class="number">322</span>         <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">/* Access permissions of this VMA. */</span></div><div class="line"><span class="number">323</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;         <span class="comment">/* Flags, see mm.h. */</span></div><div class="line"><span class="number">324</span> </div><div class="line"><span class="number">325</span>         <span class="comment">/*</span></div><div class="line">326          * For areas with an address space and backing store,</div><div class="line">327          * linkage into the address_space-&gt;i_mmap interval tree.</div><div class="line">328          */</div><div class="line"><span class="number">329</span>         <span class="keyword">struct</span> &#123;</div><div class="line"><span class="number">330</span>                 <span class="keyword">struct</span> rb_node rb;</div><div class="line"><span class="number">331</span>                 <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</div><div class="line"><span class="number">332</span>         &#125; shared;</div><div class="line"><span class="number">333</span> </div><div class="line"><span class="number">334</span>         <span class="comment">/*</span></div><div class="line">335          * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</div><div class="line">336          * list, after a COW of one of the file pages.  A MAP_SHARED vma</div><div class="line">337          * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</div><div class="line">338          * or brk vma (with NULL file) can only be in an anon_vma list.</div><div class="line">339          */</div><div class="line"><span class="number">340</span>         <span class="keyword">struct</span> list_head anon_vma_chain; <span class="comment">/* Serialized by mmap_sem &amp;</span></div><div class="line">341                                           * page_table_lock */</div><div class="line"><span class="number">342</span>         <span class="keyword">struct</span> anon_vma *anon_vma;      <span class="comment">/* Serialized by page_table_lock */</span></div><div class="line"><span class="number">343</span> </div><div class="line"><span class="number">344</span>         <span class="comment">/* Function pointers to deal with this struct. */</span></div><div class="line"><span class="number">345</span>         <span class="keyword">const</span> <span class="keyword">struct</span> vm_operations_struct *vm_ops;</div><div class="line"><span class="number">346</span> </div><div class="line"><span class="number">347</span>         <span class="comment">/* Information about our backing store: */</span></div><div class="line"><span class="number">348</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;         <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></div><div class="line">349                                            units */</div><div class="line"><span class="number">350</span>         <span class="keyword">struct</span> file * vm_file;          <span class="comment">/* File we map to (can be NULL). */</span></div><div class="line"><span class="number">351</span>         <span class="keyword">void</span> * vm_private_data;         <span class="comment">/* was vm_pte (shared mem) */</span></div><div class="line"><span class="number">352</span> </div><div class="line"><span class="number">353</span> <span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></div><div class="line"><span class="number">354</span>         <span class="keyword">struct</span> vm_region *vm_region;    <span class="comment">/* NOMMU mapping region */</span></div><div class="line"><span class="number">355</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">356</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></div><div class="line"><span class="number">357</span>         <span class="keyword">struct</span> mempolicy *vm_policy;    <span class="comment">/* NUMA policy for the VMA */</span></div><div class="line"><span class="number">358</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">359</span>         <span class="keyword">struct</span> vm_userfaultfd_ctx vm_userfaultfd_ctx;</div><div class="line"><span class="number">360</span> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>vm_start</code>:线性区的起始地址</li>
<li><code>vm_end</code>:线性区的结束地址</li>
<li><code>vm_rb</code>:作为红黑树中的一个节点使用</li>
<li><code>vm_mm</code>:指向所在的内存描述符</li>
<li><code>vm_page_prot</code>:线性区中页框的访问权限</li>
<li><code>vm_flags</code>:线性区的标志</li>
<li><code>vm_next, vm_prev</code>:分别指向线性区链表中的下一个和上一个线性区描述符</li>
<li>… …</li>
</ul>
<h4 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h4><p>内存描述符中包含了与进程地址空间有关的所有信息，结构类型为<code>struct mm_struct</code>:<br><a href="http://lxr.free-electrons.com/source/include/linux/mm_types.h#L395" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/mm_types.h#L395</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="number">395</span> <span class="keyword">struct</span> mm_struct &#123;</div><div class="line"><span class="number">396</span>         <span class="keyword">struct</span> vm_area_struct *mmap;            <span class="comment">/* list of VMAs */</span></div><div class="line"><span class="number">397</span>         <span class="keyword">struct</span> rb_root mm_rb;</div><div class="line"><span class="number">398</span>         u32 vmacache_seqnum;                   <span class="comment">/* per-thread vmacache */</span></div><div class="line"><span class="number">399</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></div><div class="line"><span class="number">400</span>         <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span></div><div class="line"><span class="number">401</span>                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</div><div class="line"><span class="number">402</span>                                 <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</div><div class="line"><span class="number">403</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">404</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;                <span class="comment">/* base of mmap area */</span></div><div class="line"><span class="number">405</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_legacy_base;         <span class="comment">/* base of mmap area in bottom-up allocations */</span></div><div class="line"><span class="number">406</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;                <span class="comment">/* size of task vm space */</span></div><div class="line"><span class="number">407</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> highest_vm_end;           <span class="comment">/* highest vma end address */</span></div><div class="line"><span class="number">408</span>         <span class="keyword">pgd_t</span> * pgd;</div><div class="line"><span class="number">409</span>         <span class="keyword">atomic_t</span> mm_users;                      <span class="comment">/* How many users with user space? */</span></div><div class="line"><span class="number">410</span>         <span class="keyword">atomic_t</span> mm_count;                      <span class="comment">/* How many references to "struct mm_struct" (users count as 1) */</span></div><div class="line"><span class="number">411</span>         <span class="keyword">atomic_long_t</span> nr_ptes;                  <span class="comment">/* PTE page table pages */</span></div><div class="line"><span class="number">412</span> <span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></div><div class="line"><span class="number">413</span>         <span class="keyword">atomic_long_t</span> nr_pmds;                  <span class="comment">/* PMD page table pages */</span></div><div class="line"><span class="number">414</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">415</span>         <span class="keyword">int</span> map_count;                          <span class="comment">/* number of VMAs */</span></div><div class="line"><span class="number">416</span> </div><div class="line"><span class="number">417</span>         <span class="keyword">spinlock_t</span> page_table_lock;             <span class="comment">/* Protects page tables and some counters */</span></div><div class="line"><span class="number">418</span>         <span class="keyword">struct</span> rw_semaphore mmap_sem;</div><div class="line"><span class="number">419</span> </div><div class="line"><span class="number">420</span>         <span class="keyword">struct</span> list_head mmlist;                <span class="comment">/* List of maybe swapped mm's.  These are globally strung</span></div><div class="line">421                                                  * together off init_mm.mmlist, and are protected</div><div class="line">422                                                  * by mmlist_lock</div><div class="line">423                                                  */</div><div class="line"><span class="number">424</span> </div><div class="line"><span class="number">425</span> </div><div class="line"><span class="number">426</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;      <span class="comment">/* High-watermark of RSS usage */</span></div><div class="line"><span class="number">427</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;       <span class="comment">/* High-water virtual memory usage */</span></div><div class="line"><span class="number">428</span> </div><div class="line"><span class="number">429</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;         <span class="comment">/* Total pages mapped */</span></div><div class="line"><span class="number">430</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;        <span class="comment">/* Pages that have PG_mlocked set */</span></div><div class="line"><span class="number">431</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm;        <span class="comment">/* Refcount permanently increased */</span></div><div class="line"><span class="number">432</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> data_vm;          <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></div><div class="line"><span class="number">433</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;          <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></div><div class="line"><span class="number">434</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;         <span class="comment">/* VM_STACK */</span></div><div class="line"><span class="number">435</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</div><div class="line"><span class="number">436</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</div><div class="line"><span class="number">437</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</div><div class="line"><span class="number">438</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</div><div class="line"><span class="number">439</span> </div><div class="line"><span class="number">440</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></div><div class="line"><span class="number">441</span> </div><div class="line"><span class="number">442</span>         <span class="comment">/*</span></div><div class="line">443          * Special counters, in some configurations protected by the</div><div class="line">444          * page_table_lock, in other configurations by being atomic.</div><div class="line">445          */</div><div class="line"><span class="number">446</span>         <span class="keyword">struct</span> mm_rss_stat rss_stat;</div><div class="line"><span class="number">447</span> </div><div class="line"><span class="number">448</span>         <span class="keyword">struct</span> linux_binfmt *binfmt;</div><div class="line"><span class="number">449</span> </div><div class="line"><span class="number">450</span>         <span class="keyword">cpumask_var_t</span> cpu_vm_mask_var;</div><div class="line"><span class="number">451</span> </div><div class="line"><span class="number">452</span>         <span class="comment">/* Architecture-specific MM context */</span></div><div class="line"><span class="number">453</span>         <span class="keyword">mm_context_t</span> context;</div><div class="line"><span class="number">454</span> </div><div class="line"><span class="number">455</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></div><div class="line"><span class="number">456</span> </div><div class="line"><span class="number">457</span>         <span class="keyword">struct</span> core_state *core_state; <span class="comment">/* coredumping support */</span></div><div class="line"><span class="number">458</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AIO</span></div><div class="line"><span class="number">459</span>         <span class="keyword">spinlock_t</span>                      ioctx_lock;</div><div class="line"><span class="number">460</span>         <span class="keyword">struct</span> kioctx_table <span class="number">__</span>rcu       *ioctx_table;</div><div class="line"><span class="number">461</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">462</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></div><div class="line"><span class="number">463</span>         <span class="comment">/*</span></div><div class="line">464          * "owner" points to a task that is regarded as the canonical</div><div class="line">465          * user/owner of this mm. All of the following must be true in</div><div class="line">466          * order for it to be changed:</div><div class="line">467          *</div><div class="line">468          * current == mm-&gt;owner</div><div class="line">469          * current-&gt;mm != mm</div><div class="line">470          * new_owner-&gt;mm == mm</div><div class="line">471          * new_owner-&gt;alloc_lock is held</div><div class="line">472          */</div><div class="line"><span class="number">473</span>         <span class="keyword">struct</span> task_struct <span class="number">__</span>rcu *owner;</div><div class="line"><span class="number">474</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">475</span> </div><div class="line"><span class="number">476</span>         <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></div><div class="line"><span class="number">477</span>         <span class="keyword">struct</span> file <span class="number">__</span>rcu *exe_file;</div><div class="line"><span class="number">478</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></div><div class="line"><span class="number">479</span>         <span class="keyword">struct</span> mmu_notifier_mm *mmu_notifier_mm;</div><div class="line"><span class="number">480</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">481</span> <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span></div><div class="line"><span class="number">482</span>         <span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page_table_lock */</span></div><div class="line"><span class="number">483</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">484</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUMASK_OFFSTACK</span></div><div class="line"><span class="number">485</span>         <span class="keyword">struct</span> cpumask cpumask_allocation;</div><div class="line"><span class="number">486</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">487</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></div><div class="line"><span class="number">488</span>         <span class="comment">/*</span></div><div class="line">489          * numa_next_scan is the next time that the PTEs will be marked</div><div class="line">490          * pte_numa. NUMA hinting faults will gather statistics and migrate</div><div class="line">491          * pages to new nodes if necessary.</div><div class="line">492          */</div><div class="line"><span class="number">493</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> numa_next_scan;</div><div class="line"><span class="number">494</span> </div><div class="line"><span class="number">495</span>         <span class="comment">/* Restart point for scanning and setting pte_numa */</span></div><div class="line"><span class="number">496</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> numa_scan_offset;</div><div class="line"><span class="number">497</span> </div><div class="line"><span class="number">498</span>         <span class="comment">/* numa_scan_seq prevents two threads setting pte_numa */</span></div><div class="line"><span class="number">499</span>         <span class="keyword">int</span> numa_scan_seq;</div><div class="line"><span class="number">500</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">501</span> <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NUMA_BALANCING) || defined(CONFIG_COMPACTION)</span></div><div class="line"><span class="number">502</span>         <span class="comment">/*</span></div><div class="line">503          * An operation with batched TLB flushing is going on. Anything that</div><div class="line">504          * can move process memory needs to flush the TLB when moving a</div><div class="line">505          * PROT_NONE or PROT_NUMA mapped page.</div><div class="line">506          */</div><div class="line"><span class="number">507</span>         <span class="keyword">bool</span> tlb_flush_pending;</div><div class="line"><span class="number">508</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">509</span>         <span class="keyword">struct</span> uprobes_state uprobes_state;</div><div class="line"><span class="number">510</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_INTEL_MPX</span></div><div class="line"><span class="number">511</span>         <span class="comment">/* address of the bounds directory */</span></div><div class="line"><span class="number">512</span>         <span class="keyword">void</span> <span class="number">__u</span>ser *bd_addr;</div><div class="line"><span class="number">513</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">514</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HUGETLB_PAGE</span></div><div class="line"><span class="number">515</span>         <span class="keyword">atomic_long_t</span> hugetlb_usage;</div><div class="line"><span class="number">516</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">517</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></div><div class="line"><span class="number">518</span>         <span class="keyword">struct</span> work_struct async_put_work;</div><div class="line"><span class="number">519</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">520</span> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>mmap</code>:线性区描述符链表中的头元素</li>
<li><code>mm_rb</code>:线性区描述符所在红黑树的根</li>
<li><code>get_unmapped_area</code>:在进程地址空间中搜索有效线性地址区间的方法</li>
<li><code>mmap_base</code>:标识第一个分配的匿名线性区或文件内存映射的线性地址</li>
<li><code>task_size</code>:进程地址空间的大小</li>
<li><code>highest_vm_end</code>:能使用的最高线性地址</li>
<li><code>pgd</code>:指向页全局目录</li>
<li><code>mm_users</code>:次使用计数器</li>
<li><code>mm_count</code>:主使用计数器</li>
<li><code>nr_ptes</code>:页表项数量</li>
<li><code>map_count</code>：线性区数量</li>
<li><code>mmlist</code>:链接内存描述符链表中的相邻描述符</li>
<li>… …</li>
</ul>
<h4 id="线性区相关"><a href="#线性区相关" class="headerlink" title="线性区相关"></a>线性区相关</h4><p>进程所拥有的所有线性区通过一个简单地链表链接在一起，链表中的线性区按内存地址升序排列。内核通过进程的内存描述符的<code>mmap</code>字段找到线性区链表的第一个线性区。<br><img src="/images/linux-kernel-note/process-address-space-2.png" alt=""></p>
<p>内核频繁执行的一个操作就是查找包含指定线性地址的的线性区，虽然可以通过遍历链表来查找，但是当线性区数量很庞大时，例如面向对象的数据库，此时的效率会变得非常低效。</p>
<p>Linux2.6把内存描述符存放在红黑树的数据结构中，当插入或删除一个线性区描述符时，内核通过红黑树搜索前后元素，并用搜索结果快速更新链表而不用扫描链表。一般来说，红黑树用来确定含有指定地址的线性区，而链表通常在扫描整个线性区集合的时候使用。</p>
<h4 id="内存描述符相关"><a href="#内存描述符相关" class="headerlink" title="内存描述符相关"></a>内存描述符相关</h4><p>进程、内存描述符、线性区描述符、线性地址之间的关系如下:<br><img src="/images/linux-kernel-note/process-address-space-1.png" alt=""></p>
<p>所有内存描述符存放在一个双向链表中，每个描述符中的<code>mmlist</code>字段存放链表中相邻元素的地址。链表的第一个元素是<code>init_mm</code>的<code>mmlist</code>字段，<code>init_mm</code>是初始化阶段进程0所使用的内存描述符。</p>
<p><code>mm_users</code>字段存放共享<code>mm_struct</code>数据结构的轻量级进程（线程）的个数，<code>mm_count</code>字段是内存描述符的主使用器，<code>mm_users</code>的所有使用者在<code>mm_count</code>中只占有一个单位，也就是说多个线程只使得<code>mm_count</code>的值增加了1。假如一个内核线程使用了该内存描述符，则<code>mm_count</code>的值增加1。</p>
<p>对于内核线程来说，因为仅运行在内核态，所以永远不会访问低于<code>TASK_SIZE</code>（3GB）的地址。每个进程的描述符中包含了两种内存描述符指针:<code>mm</code>和<code>active_mm</code>。对于普通进程，两者都指向进程的内存描述符，而内核线程的<code>active_mm</code>指向进程的内存描述符，<code>mm</code>为null。（PS:内核线程使用的全局页表存放在主内存描述符的pgd字段中）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简单地描述了进程地址空间中的一些主要数据结构以及之间的联系，关于源码以及更多细节内容在日后整理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;进程的地址空间&quot;&gt;&lt;a href=&quot;#进程的地址空间&quot; class=&quot;headerlink&quot; title=&quot;进程的地址空间&quot;&gt;&lt;/a&gt;进程的地址空间&lt;/h4&gt;&lt;p&gt;进程的地址空间由允许进程使用的全部线性地址组成，在32位系统中为0~3GB，每个进程看到的线性地址集
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之高端内存映射</title>
    <link href="http://vinoit.me/2016/09/09/linux-kernel-note-high-memory-mapping/"/>
    <id>http://vinoit.me/2016/09/09/linux-kernel-note-high-memory-mapping/</id>
    <published>2016-09-09T11:06:04.000Z</published>
    <updated>2016-09-10T06:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是高端内存"><a href="#什么是高端内存" class="headerlink" title="什么是高端内存"></a>什么是高端内存</h4><p>在32位的系统上，内核使用第3GB~第4GB的线性地址空间，共1GB大小。内核将其中的前896MB与物理内存的0~896MB进行直接映射，即线性映射，将剩余的128M线性地址空间作为访问高于896M的内存的一个窗口。</p>
<p>引入高端内存映射这样一个概念的主要原因就是我们所安装的内存大于1G时，内核的1G线性地址空间无法建立一个完全的直接映射来触及整个物理内存空间，而对于80x86开启PAE的情况下，允许的最大物理内存可达到64G，因此内核将自己的最后128M的线性地址空间腾出来，用以完成对高端内存的暂时性映射。</p>
<p>而在64位的系统上就不存在这样的问题了，因为可用的线性地址空间远大于可安装的内存。下图描述了内核1GB线性地址空间是如何划分的。 </p>
<p><img src="/images/linux-kernel-note/high-memory-mapping-0.png" alt=""></p>
<p>其中PAGE_OFFSET表示内核使用的1GB线性地址的起始处(第3GB)，high_memory往右的部分则表示高端内存，共<code>128M</code>的线性地址。可以用来完成上述映射目的的区域为vmalloc area，Persistent kernel mappings区域和固定映射线性地址空间中的FIX_KMAP区域，这三个区域对应的映射机制分别为<code>非连续内存分配</code>， <code>永久内核映射</code>和 <code>临时内核映射</code>。</p>
<h4 id="永久内核映射"><a href="#永久内核映射" class="headerlink" title="永久内核映射"></a>永久内核映射</h4><p>在内核初始化页表管理机制时，专门用pkmap_page_table这个变量保存了PKMAP_BASE对应的页表项的地址，由pkmap_page_table来维护永久内核映射区的页表项的映射，页表项总数为LAST_PKMAP个。</p>
<p>这里的永久并不是指调用kmap()建立的映射关系会一直持续下去无法解除，而是指在调用kunmap()解除映射之间这种映射会一直存在，这是相对于临时内核映射机制而言的。</p>
<p>需要注意一点的是，当永久内核映射区没有空闲的页表项可供映射时，请求映射的进程会被阻塞，因此永久内核映射请求不能发生在中断和可延迟函数中。</p>
<h4 id="临时内核映射"><a href="#临时内核映射" class="headerlink" title="临时内核映射"></a>临时内核映射</h4><p>临时内核映射和永久内核映射相比，其最大的特点就是不会阻塞请求映射页框的进程，因此临时内核映射请求可以发生在中断和可延迟函数中。系统中的每个CPU都有自己的13个临时内核映射窗口，根据不同的需求（用于内核控制路径），选择不同的窗口来创建映射。</p>
<p>每个CPU的映射窗口集合用<code>enum km_type</code>数据结构表示，该数据结构中的每个符号，如<code>KM_BOUNCE_READ</code>、<code>KM_USER0</code>或<code>KM_PTE0</code>,标识了窗口的线性地址，其实是一个下标。内核根据<code>cpu_id</code>和<code>窗口下标</code>来确定临时映射的地址。</p>
<p>临时内核映射的实现也比永久内核映射要简单，当一个进程申请在某个窗口创建映射，即使这个窗口已经在之前就建立了映射，新的映射也会建立并且覆盖之前的映射，所以说这种映射机制是临时的，并且不会阻塞当前进程。</p>
<h4 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h4><p>非连续内存分配是指将物理地址不连续的页框映射到线性地址连续的线性地址空间，主要应用于大容量的内存分配。采用这种方式分配内存的主要优点是避免了外部碎片，而缺点是必须打乱内核页表，而且访问速度较连续分配的物理页框慢。</p>
<p>非连续内存分配的线性地址空间是从<code>VMALLOC_START</code>到<code>VMALLOC_END</code>，每当内核要用vmalloc类的函数进行非连续内存分配，就会申请一个vm_struct结构来描述对应的vmalloc区，两个vmalloc区之间的间隔至少为一个页框的大小，即PAGE_SIZE。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于内核的线性地址空间有限，因此采取上面介绍的三种方式来映射高端内存。但是每种映射的本质都是通过页表来建立线性地址与物理地址之间的联系。</p>
<p>永久内核映射和临时内核映射，都由内核指定了需要进行映射的页面，也就是说指定了页描述符(页描述符和物理页框之间的关系是固定不可变的)。在永久内核映射中，内核只需要在永久内核映射区找到空闲的，也就是未被映射的线性地址对应的页表项，然后将其分配给page即可，若找不到则将阻塞申请建立映射的进程；而临时内核映射更直接，连进行映射的线性地址窗口都是固定的，若是其已经分配给了某个页框，则直接抢过来用，因此之前的映射就被覆盖了，体现出了临时性。</p>
<p>非连续内存分配，内核不用指定具体的页框,只需指定要申请的内存大小，内核将在非连续内存分配区找到一块相应大小虚拟地址空间，然后再由伙伴系统分配页框，还要通过slab分配器为一些数据结构分配内存，最后再用同样的方式(设置PTE表项)来建立映射。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是高端内存&quot;&gt;&lt;a href=&quot;#什么是高端内存&quot; class=&quot;headerlink&quot; title=&quot;什么是高端内存&quot;&gt;&lt;/a&gt;什么是高端内存&lt;/h4&gt;&lt;p&gt;在32位的系统上，内核使用第3GB~第4GB的线性地址空间，共1GB大小。内核将其中的前896MB与
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux内核中hlist_head和hlist_node结构解析</title>
    <link href="http://vinoit.me/2016/09/01/linux-kernel-hlist_head-and-hlist_node/"/>
    <id>http://vinoit.me/2016/09/01/linux-kernel-hlist_head-and-hlist_node/</id>
    <published>2016-09-01T07:57:17.000Z</published>
    <updated>2016-10-31T08:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>hlist_head</code>和<code>hlist_node</code>用于散列表，分表表示列表头（数组中的一项）和列表头所在双向链表中的某项，两者结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_head &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *first;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_node &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *next, **pprev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在内核中的普通双向链表基本上都是通过<code>list_head</code>实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> list_head &#123;</div><div class="line">        <span class="keyword">struct</span> list_head *next, *prev;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p><code>list_head</code>很好理解，但是<code>hlist_head</code>和<code>hlist_node</code>为何要这样设计呢？</p>
<p>先看下<code>hlist_head</code>和<code>hlist_node</code>的示意图:</p>
<p><img src="/images/linux/list_head-and-hlist_node-0.png" alt=""></p>
<p><code>hash_table</code>为散列表（数组），其中的元素类型为<code>struct hlist_head</code>。以<code>hlist_head</code>为链表头的链表，其中的节点<code>hash值</code>是相同的（也叫冲突）。<code>first指针</code>指向链表中的节点①，然后节点①的<code>pprev指针</code>指向<code>hlist_head</code>中的<code>first</code>，节点①的<code>next指针</code>指向节点②。以此类推。</p>
<p><code>hash_table</code>的列表头仅存放一个指针,也就是first指针,指向的是对应链表的头结点,没有tail指针也就是指向链表尾节点的指针,这样的考虑是为了节省空间——尤其在<code>hash bucket</code>(数组size)很大的情况下可以节省一半的指针空间。</p>
<p>为什么<code>pprev</code>是一个指向指针的指针呢？按照这个设计，我们如果想要得到尾节点，必须遍历整个链表，可如果是一个指向节点的指针，那么头结点现在的<code>pprev</code>便可以直接指向尾节点，也就是<code>list_head</code>的做法。</p>
<p>对于散列表来说，一般发生冲突的情况并不多（除非hash设计出现了问题），所以一个链表中的元素数量比较有限，遍历的劣势基本可以忽略。</p>
<p>在删除链表头结点的时候，<code>pprev</code>这个设计无需判断删除的节点是否为头结点。如果是普通双向链表的设计，那么删除头结点之后，<code>hlist_head</code>中的<code>first指针</code>需要指向新的头结点。通过下面2个函数来加深理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加节点到链表头</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *first = h-&gt;first;</div><div class="line">    n-&gt;next = first;<span class="comment">//新节点的next指针指向原头结点</span></div><div class="line">    <span class="keyword">if</span> (first)</div><div class="line">        first-&gt;pprev = &amp;n-&gt;next;<span class="comment">//原头结点的pprev指向新节点的next字段</span></div><div class="line">    h-&gt;first = n;<span class="comment">//first指针指向新的节点（更换了头结点）</span></div><div class="line">    n-&gt;pprev = &amp;h-&gt;first; <span class="comment">//此时n是链表的头结点,将它的pprev指向list_head的first字段</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//删除节点</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="number">__</span>hlist_del(<span class="keyword">struct</span> hlist_node *n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *next = n-&gt;next;</div><div class="line">    <span class="keyword">struct</span> hlist_node **pprev = n-&gt;pprev;</div><div class="line">    *pprev = next; <span class="comment">// pprev指向的是前一个节点的next指针,当该节点是头节点时指向 hlist_head的first,两种情况下不论该节点是一般的节点还是头结点都可以通过这个操作删除掉所需删除的节点。</span></div><div class="line">    <span class="keyword">if</span> (next)</div><div class="line">        next-&gt;pprev = pprev;<span class="comment">//使删除节点的后一个节点的pprev指向删除节点的前一个节点的next字段，节点成功删除。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> </blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;hlist_head&lt;/code&gt;和&lt;code&gt;hlist_node&lt;/code&gt;用于散列表，分表表示列表头（数组中的一项）和列表头所在双向链表中的某项，两者结构如下:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="源码" scheme="http://vinoit.me/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之内存管理</title>
    <link href="http://vinoit.me/2016/08/30/linux-kernel-note-memory-manage/"/>
    <id>http://vinoit.me/2016/08/30/linux-kernel-note-memory-manage/</id>
    <published>2016-08-30T12:10:18.000Z</published>
    <updated>2016-10-31T08:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="非一致内存访问（NUMA）"><a href="#非一致内存访问（NUMA）" class="headerlink" title="非一致内存访问（NUMA）"></a>非一致内存访问（NUMA）</h4><p>我们习惯上认为计算机内存是一种均匀、共享的资源。在忽略硬件高速缓存的情况下，我们期望不管内存单元处于何处，也不管CPU处于何处，CPU对内存单元的访问都需要相同的时间。但是，在某些体系结构中并不总是成立。</p>
<p>在NUMA模型中，给定CPU对不同内存单元的访问时间可能不一样。系统的物理内存被划分为几个节点(node)。在一个单独的节点内，任一给定CPU访问页面所需的时间都是相同的。然而，对不同的CPU，这个时间可能就不同。每个节点的物理内存又可以分为几个管理区（zone）。</p>
<p>Linux支持NUMA模型，但是Linux将所有物理内存看作一个节点。在存放节点的链表中，只有一个元素。</p>
<h4 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h4><p>80x86体系结构存在两种硬件约束:</p>
<ul>
<li>ISA总线的DMA处理器只能对RAM的前16M寻址。</li>
<li>在具有大量RAM的现代32位计算机中，因为线性地址空间太小，CPU不能直接访问所有的物理内存。</li>
</ul>
<p>为了应对这两种限制，Linux2.6把每个内存节点的物理内存划分为3个管理区。在80x86 UMA体系结构中的管理区为:</p>
<ul>
<li>ZONE_DMA(包含低于16M的内存页框)</li>
<li>ZONE_NORMAL(包含高于16M低于896M的内存页框)</li>
<li>ZONE_HIGHMEM(包含高于896M的所有内存页框)</li>
</ul>
<p>ZONE_DMA中的页框可以由老式基于ISA的设备通过DMA使用。</p>
<p>ZONE_NORMAL中的页框全部映射到内核使用的第4个GB地址空间，这部分页框的映射方式很简单，例如物理地址为<code>0x10000000</code>,只需要直接加上3GB的地址，得到的线性地址为<code>0xc0000000</code>。</p>
<p>ZONE_HIGHMEM和ZONE_NORMAL都属于“常规”页框，但内核使用的第4个GB地址空间的最后128M才能映射到ZONE_HIGHMEM的部分页框。</p>
<h4 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h4><p>分区页框分配器是一个内核子系统，处理对连续页框组的内存分配请求。这部分内容对于理解Linux的内存管理十分关键，它的主要组成如下:<br><img src="/images/linux-kernel-note/memory-manage-0.png" alt=""></p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>linux内核的伙伴算法最大限度的减少了内存的碎片，其实应该说成是尽自己最大的努力减少了内存的碎片。其思想就是将物理内存分成11个块链表，每个链表包含的是大小为1,2,4,8…512,1024的连续页框块。举例来说要分配256个连续页框，会先到块大小为256的链表中查找空闲块，若有直接返回，若没有，去大小为512的链表中进行查找，将512大小块分为两部分，一部分返回，一部分插入256大小的链表中，若512大小的链表中还没有，到1024大小的链表中查找，取出256大小的块，将剩下的512,256的块分别插入到各个链表中，内存释放的过程则是相反的。</p>
<p>满足以下条件的两个快称为伙伴:</p>
<ul>
<li>两个块具有相同的大小，记作b。</li>
<li>它们的物理地址是连续的。</li>
<li>第一个块的的第一个页框的物理地址是<code>2*b*2^12</code>的倍数。</li>
</ul>
<h4 id="每CPU页框高速缓存（冷热页）"><a href="#每CPU页框高速缓存（冷热页）" class="headerlink" title="每CPU页框高速缓存（冷热页）"></a>每CPU页框高速缓存（冷热页）</h4><p>内核经常请求和释放<code>单个页框</code>，为了提升性能，每个内存管理区定义了一个“每CPU”高速缓存。冷页表示该空闲页已经不再高速缓存中了(一般是指L2 Cache)，热页表示该空闲页仍然在高速缓存中。冷热页是针对于每CPU的，每个zone中，都会针对于所有的CPU初始化一个冷热页的per-cpu-pageset.</p>
<h4 id="分配页框小结"><a href="#分配页框小结" class="headerlink" title="分配页框小结"></a>分配页框小结</h4><p>当内核接收一个分配若干个页框的请求时，如果页框数量为1，则从每CPU页框高速缓存中分配一个页框。如果页框数大于1，则从伙伴系统中分配符合要求的若干个连续页框。其中的大致流程如下：</p>
<ol>
<li>管理区分配器选择一个合适的内存管理区。</li>
<li>如果需要的页框数量为1，则从每CPU页框高速缓存中获取一个空闲的页框。一般情况下获取一个热页，但如果用于DMA等不需要CPU参与的请求，获取一个冷页。</li>
<li>如果数量大于1，则从伙伴系统中选择一个大于0中的最小order链表，然后返回一个块。</li>
</ol>
<p>如果冷热页中无空闲页框，则从伙伴系统中分配一些页框给冷热页机制。</p>
<h4 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h4><p>当我们需要分配一些小对象时，如果还使用页框分配器，那未免太浪费了，无论是从时间上还是空间上。slab分配器用于这些小对象的分配，一个slab由若干个页框构成，可由页框分配器分配。</p>
<p>每个slab根据其内部对象的大小，都被链接到一个相应的高速缓存描述符中:<br><img src="/images/linux-kernel-note/memory-manage-1.png" alt=""><br>其中的高速缓存的大小为2的幂，从32B到131072B共13个级别，所链接的slab链表中的每个slab中的对象的大小都与其对应。其中每个级别的高速缓存描述符都存放于<code>malloc_sizes</code>数组中，数组的元素类型为<code>struct cache_sizes</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cache_sizes &#123;</div><div class="line">        <span class="keyword">size_t</span>                  cs_size;</div><div class="line">        <span class="keyword">struct</span> kmem_cache       *cs_cachep;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></div><div class="line">        <span class="keyword">struct</span> kmem_cache       *cs_dmacachep;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> cache_sizes malloc_sizes[];</div></pre></td></tr></table></figure>
<p>高速缓存描述符(kmem_cache)如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_cache &#123;  </div><div class="line"><span class="comment">/* 1) per-cpu data, touched during every alloc/free */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache *<span class="built_in">array</span>[NR_CPUS];<span class="comment">/*local cache*/</span>  </div><div class="line"><span class="comment">/* 2) Cache tunables. Protected by cache_chain_mutex */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shared;  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size;<span class="comment">/*slab中对象大小*/</span>  </div><div class="line">    u32 reciprocal_buffer_size;<span class="comment">/*slab中对象大小的倒数*/</span>  </div><div class="line"><span class="comment">/* 3) touched by every alloc &amp; free from the backend */</span>  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;     <span class="comment">/* constant flags */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;       <span class="comment">/* # of objs per slab */</span>  </div><div class="line">  </div><div class="line"><span class="comment">/* 4) cache_grow/shrink */</span>  </div><div class="line">    <span class="comment">/* order of pgs per slab (2^n) */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> gfporder;  </div><div class="line">  </div><div class="line">    <span class="comment">/* force GFP flags, e.g. GFP_DMA */</span>  </div><div class="line">    <span class="keyword">gfp_t</span> gfpflags;  </div><div class="line">  </div><div class="line">    <span class="keyword">size_t</span> colour;<span class="comment">/*着色块个数*/</span> <span class="comment">/* cache colouring range */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_off;<span class="comment">/* cache的着色块的单位大小 */</span>    <span class="comment">/* colour offset */</span>  </div><div class="line">    <span class="keyword">struct</span> kmem_cache *slabp_cache;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slab_size;<span class="comment">/*slab管理区大小,包含slab对象和kmem_bufctl_t数组*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dflags;        <span class="comment">/* dynamic flags */</span>  </div><div class="line">  </div><div class="line">    <span class="comment">/* constructor func */</span>  </div><div class="line">    <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *obj);  </div><div class="line">  </div><div class="line"><span class="comment">/* 5) cache creation/removal */</span>  </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  </div><div class="line">    <span class="keyword">struct</span> list_head next; <span class="comment">//链接下一个高速缓存描述符 </span></div><div class="line">  </div><div class="line"><span class="comment">/* 6) statistics */</span>  </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SLAB  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_active;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_allocations;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> high_mark;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> grown;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reaped;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> errors;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> max_freeable;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_allocs;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_frees;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_overflow;  </div><div class="line">    <span class="keyword">atomic_t</span> allochit;<span class="comment">/*cache命中计数，在分配中更新*/</span>  </div><div class="line">    <span class="keyword">atomic_t</span> allocmiss;<span class="comment">/*cache未命中计数，在分配中更新*/</span>  </div><div class="line">    <span class="keyword">atomic_t</span> freehit;  </div><div class="line">    <span class="keyword">atomic_t</span> freemiss;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * If debugging is enabled, then the allocator can add additional </div><div class="line">     * fields and/or padding to every object. buffer_size contains the total </div><div class="line">     * object size including these internal fields, the following two </div><div class="line">     * variables contain the offset to the user object and its size. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int</span> obj_offset;  </div><div class="line">    <span class="keyword">int</span> obj_size;  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span>  </span></div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * We put nodelists[] at the end of kmem_cache, because we want to size </div><div class="line">     * this array to nr_node_ids slots instead of MAX_NUMNODES </div><div class="line">     * (see kmem_cache_init()) </div><div class="line">     * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache </div><div class="line">     * is statically defined, so we reserve the max number of nodes. </div><div class="line">     */  </div><div class="line">    <span class="keyword">struct</span> kmem_list3 *nodelists[MAX_NUMNODES];  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * Do not add fields after nodelists[] </div><div class="line">     */  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后面的<code>struct kmem_list3</code>结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_list3 &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_partial;<span class="comment">/*slab链表，包含空闲对象和已分配对象的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_full;   <span class="comment">/*slab链表，只包含非空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_free;   <span class="comment">/*slab链表，只包含空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;    <span class="comment">/*高速缓存中空闲对象的个数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;       <span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;       <span class="comment">/*下一个slab使用的颜色*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> list_lock;  </div><div class="line">    <span class="keyword">struct</span> array_cache *shared; <span class="comment">/* shared per node */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache **alien; <span class="comment">/* on other nodes */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;    <span class="comment">/* updated without locking */</span>  </div><div class="line">    <span class="keyword">int</span> free_touched;       <span class="comment">/* updated without locking */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个高速缓存描述符包含3条slab链表，通过<code>struct kmem_list3</code>字段链接，每个同大小（对象）的高速缓存描述符链接在一起：<br><img src="/images/linux-kernel-note/memory-manage-2.png" alt=""></p>
<p>slab描述符如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> slab &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;  <span class="comment">/*用于将slab链入kmem_list3的链表*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;<span class="comment">/*该slab的着色偏移*/</span>  </div><div class="line">    <span class="keyword">void</span> *s_mem;            <span class="comment">/*指向slab中的第一个对象*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;     <span class="comment">/*已分配出去的对象*/</span>  </div><div class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;     <span class="comment">/*下一个空闲对象的下标*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;  <span class="comment">/*节点标识号*/</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个slab中每个对象的大小都是相同的2的幂，其中的对象描述符为<code>kmem_bufctl_t</code>,它是一个无符号整数，用于表示对象在slab中的下标：</p>
<p><code>typedef unsigned int kmem_bufctl_t;</code></p>
<p>对象描述符存放在slab描述符后面，按照描述符是否存放在slab中，slab描述符和对象描述符的关系如下：<br><img src="/images/linux-kernel-note/memory-manage-3.png" alt=""></p>
<p>高速缓存描述符中的<code>struct array_cache *array[NR_CPUS];/*local cache*/</code>表示本地高速缓存数组，每个CPU对应一个本地高速缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> array_cache &#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> avail;<span class="comment">/*本地高速缓存中可用的空闲对象数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;<span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;<span class="comment">/*一次转入和转出的对象数量*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> touched;   <span class="comment">/*标识本地CPU最近是否被使用*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> lock;  </div><div class="line">    <span class="keyword">void</span> *entry[];  <span class="comment">/*这是一个伪数组，便于对后面用于跟踪空闲对象的指针数组的访问 </span></div><div class="line">             * Must have this definition in here for the proper </div><div class="line">             * alignment of array_cache. Also simplifies accessing </div><div class="line">             * the entries. </div><div class="line">             */  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当我们要求内核给我们分配一个小对象时，是从本地高速缓存中获取的。<strong>本地高速缓存中的对象依次放置在该本地高速缓存描述符的地址后面。</strong>从本地高速缓存获取对象时，首先根据当前CPU，从本地高速缓存数组中获取对应的到本地高速缓存描述符指针<code>ac</code>，<code>((void **)(ac+1))[--ac-&gt;avail]</code>返回的就是所分配的对象。</p>
<h4 id="slab分配对象小结"><a href="#slab分配对象小结" class="headerlink" title="slab分配对象小结"></a>slab分配对象小结</h4><p>当我们需要一个小对象时，首先根据该对象大小，选择合适的<strong>高速缓存</strong>(kmem_cache)。然后获取当前CPU id,到对应的<strong>本地高速缓存</strong>(array_cache)中获取对象。如果无空闲对象，则从空闲slab链表或者半空闲slab链表中分配一些对象，数量为本地高速缓存描述符中<code>batchcount</code>值。如果slab链表中的对象都已被使用，则从伙伴系统中分配若干个页框作为slab添加到高速缓存中，并且初始化，然后分配对象给本地高速缓存。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文从整体上描述了Linux中的内存管理，并没有涉及到具体源码以及细节问题，更多细节待日后整理。</p>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> </blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;非一致内存访问（NUMA）&quot;&gt;&lt;a href=&quot;#非一致内存访问（NUMA）&quot; class=&quot;headerlink&quot; title=&quot;非一致内存访问（NUMA）&quot;&gt;&lt;/a&gt;非一致内存访问（NUMA）&lt;/h4&gt;&lt;p&gt;我们习惯上认为计算机内存是一种均匀、共享的资源。在忽
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>根据字节码探讨JAVA自增运算符的原理</title>
    <link href="http://vinoit.me/2016/08/29/understand-java-auto-increment-by-bytecode/"/>
    <id>http://vinoit.me/2016/08/29/understand-java-auto-increment-by-bytecode/</id>
    <published>2016-08-29T02:47:24.000Z</published>
    <updated>2016-10-31T08:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        x++;</div><div class="line">        myMethod();</div><div class="line">        System.out.println(x + y + ++x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        y = x++ + ++x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果以上代码的结果你很自信能做对,那么本文或许对你帮助不大,但仍然可以看下java底层的实现.在最后将给出以上代码的结果以及解析.</strong></p>
<h4 id="情况举例"><a href="#情况举例" class="headerlink" title="情况举例"></a>情况举例</h4><p>本文中的例子主要针对以下情况:</p>
<p>①x=y++</p>
<p>②x=++y</p>
<p>③x=x++</p>
<p>④x=++x</p>
<p>a : x,y为形参</p>
<p>b : x,y为成员变量</p>
<p>废话不多说,直接上代码:</p>
<h4 id="代码1-①-b"><a href="#代码1-①-b" class="headerlink" title="代码1(①+b):"></a>代码1(①+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x,y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = y++;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:01</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field y:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #3                  // Field y:I</div><div class="line">         9: putstatic     #4                  // Field x:I</div><div class="line">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #4                  // Field x:I</div><div class="line">        18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:y(值)入操作栈</p>
<p>3:得到y(值)的一个快照y’(值)</p>
<p>(个人认为相当于是将栈顶元素也就是y(值)复制了一份,然后将复制得到的y’(值)入操作栈,现在操作栈中有y(值)和y’(值))</p>
<p>4:常量1入操作栈</p>
<p>5:常量1和y’(值)弹出栈,进行加操作,并将结果s入栈</p>
<p>6:将结果s弹出栈,赋给y(变量)(此时y==1)</p>
<p>9:将y(值)弹出栈,赋给x(变量)(此时x==0)</p>
<p>因为y(值)入操作栈之后没有修改,所以x依旧是0,而y变成了1</p>
<h4 id="代码2-②-b"><a href="#代码2-②-b" class="headerlink" title="代码2(②+b):"></a>代码2(②+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x,y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = ++y;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果11</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field y:I</div><div class="line">         3: iconst_1</div><div class="line">         4: iadd</div><div class="line">         5: dup</div><div class="line">         6: putstatic     #3                  // Field y:I</div><div class="line">         9: putstatic     #4                  // Field x:I</div><div class="line">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #4                  // Field x:I</div><div class="line">        18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:y(值)入操作栈</p>
<p>3:常量1入操作栈</p>
<p>4:常量1和y(值)弹出栈,进行加操作,并将结果s入栈</p>
<p>5:得到栈顶元素也就是s的快照s’,并入操作栈</p>
<p>6:将s’弹出栈,并赋给y(变量)(此时y==1)</p>
<p>9:将s弹出栈,并赋给x(变量)(此时x==1)</p>
<h4 id="代码3-③-b"><a href="#代码3-③-b" class="headerlink" title="代码3(③+b):"></a>代码3(③+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = x++;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:0</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field x:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #3                  // Field x:I</div><div class="line">         9: putstatic     #3                  // Field x:I</div><div class="line">        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #3                  // Field x:I</div><div class="line">        18: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:x(值)入操作栈</p>
<p>3:得到x(值)的快照x’,入操作栈</p>
<p>4:常量1入操作栈</p>
<p>5:常量1和x’弹出操作栈,进行加操作,将结果s入操作栈</p>
<p>6:将s弹出栈,并赋给x(变量)(此时x==1)</p>
<p>9:将x(值)弹出栈,并赋给x(变量)(此时x的值被覆盖,x==0)</p>
<h4 id="代码4-④-b"><a href="#代码4-④-b" class="headerlink" title="代码4(④+b):"></a>代码4(④+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = ++x;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:1</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field x:I</div><div class="line">         3: iconst_1</div><div class="line">         4: iadd</div><div class="line">         5: dup</div><div class="line">         6: putstatic     #3                  // Field x:I</div><div class="line">         9: putstatic     #3                  // Field x:I</div><div class="line">        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #3                  // Field x:I</div><div class="line">        18: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:x(值)入操作栈</p>
<p>3:常量1如入操作栈</p>
<p>4:常量1和x(值)弹出操作栈,进行加操作,并将结果s入操作栈</p>
<p>5:得到栈顶元素s的快照s’,入操作栈</p>
<p>6.将s’弹出操作栈,并赋给x(变量)(此时x==1)</p>
<p>9:将s弹出操作栈,并赋给x(变量)(此时x==1)</p>
<h4 id="代码5-①-a"><a href="#代码5-①-a" class="headerlink" title="代码5(①+a):"></a>代码5(①+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        x = y++;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y); &#125; &#125;</div></pre></td></tr></table></figure>
<p><code>结果:01</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0: iload_1</div><div class="line">         1: iinc          1, 1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: new           #4                  // class java/lang/StringBuilder</div><div class="line">        11: dup</div><div class="line">        12: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">        15: iload_0</div><div class="line">        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        19: ldc           #7                  // String</div><div class="line">        21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">        24: iload_1</div><div class="line">        25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">        34: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:将本地变量区的y(值)入操作栈</p>
<p>1:将本地变量y加1(y==1)</p>
<p>4:将0中的y(值)弹出栈,并赋给本地变量区的x(x==0)</p>
<h4 id="代码6-②-a"><a href="#代码6-②-a" class="headerlink" title="代码6(②+a):"></a>代码6(②+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        x = ++y;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:11</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0: iinc          1, 1</div><div class="line">         3: iload_1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: new           #4                  // class java/lang/StringBuilder</div><div class="line">        11: dup</div><div class="line">        12: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">        15: iload_0</div><div class="line">        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        19: ldc           #7                  // String</div><div class="line">        21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">        24: iload_1</div><div class="line">        25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">        34: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:将本地变量y加1(此时y==1)</p>
<p>3:将本地变量y(值)入操作栈</p>
<p>4:将y(值)弹出操作栈,并赋给x(此时x==1)</p>
<h4 id="代码7-③-a"><a href="#代码7-③-a" class="headerlink" title="代码7(③+a):"></a>代码7(③+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        x = x++;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:0</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: iload_0</div><div class="line">         1: iinc          0, 1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: iload_0</div><div class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        12: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:本地变量x(值)入操作栈</p>
<p>1:本地变量x加1(此时x==1)</p>
<p>4:将x(值)弹出栈,并赋给本地变量x(此时x==0)</p>
<h4 id="代码8-④-a"><a href="#代码8-④-a" class="headerlink" title="代码8(④+a):"></a>代码8(④+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        x = ++x;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:1</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: iinc          0, 1</div><div class="line">         3: iload_0</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: iload_0</div><div class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        12: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:本地变量x加1(此时x==1)</p>
<p>3:本地变量x(值)入操作栈</p>
<p>4:将x(值)弹出操作栈,并赋给x(此时x==1) </p>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><font color="red">事实上i++和++i在底层的实现都是先自增,区别在于返回值.i++返回自增前的值,++i返回自增后的值。</font>



<p>现在来看看一开始那段代码的结果和解析:</p>
<p><code>结果:11</code></p>
<p><strong>myMethod()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #2                  // Field x:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #2                  // Field x:I</div><div class="line">         9: getstatic     #2                  // Field x:I</div><div class="line">        12: iconst_1</div><div class="line">        13: iadd</div><div class="line">        14: dup</div><div class="line">        15: putstatic     #2                  // Field x:I</div><div class="line">        18: iadd</div><div class="line">        19: putstatic     #5                  // Field y:I</div><div class="line">        22: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:变量x(值)入操作栈(栈状态:x0)</p>
<p>3:得到栈顶元素x(值)的快照x’(值),并入操作栈(栈状态:x0-&gt;x0’)</p>
<p>4:常量1入操作栈(栈状态:x0-&gt;x0’-&gt;1)</p>
<p>5:常量1和x’(值)弹出操作栈,进行加操作,将结果s0入操作栈(栈状态:x0-&gt;s0)</p>
<p>6:弹出s0,并赋给x(变量)(栈状态:x0,此时x(变量)==2)</p>
<p>9:将修改后的x(值)入操作栈(栈状态:x0-&gt;x1)</p>
<p>12:常量1入操作栈(栈状态:x0-&gt;x1-&gt;1)</p>
<p>13:常量1和X1(值)弹出操作栈,进行加操作,将结果s1入操作栈(栈状态:x0-&gt;s1)</p>
<p>14:得到栈顶元素s1(值)的快照s1’(值),并入操作栈(栈状态:x0-&gt;s1-&gt;s1’)</p>
<p>15:弹出s1’并赋给x(变量)(栈状态:x0-&gt;s1)</p>
<p>18:s1和x0弹出栈,进行加操作,将结果s2入栈(栈状态:s2)</p>
<p>19:弹出s2,并赋给y(变量) </p>
<p>所以在myMethod之后x的值为经过两次自增后的值,为x+2==3,而y的值为x0+s1,其中x0为最初传进来的值==1,s1是x经过两次自增后的值==3,所以y==4</p>
<p>x==3,y==4</p>
<p>最后输出的结果就是3+4+4==11</p>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> </blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
    
    </summary>
    
      <category term="java" scheme="http://vinoit.me/categories/java/"/>
    
    
      <category term="java" scheme="http://vinoit.me/tags/java/"/>
    
      <category term="字节码" scheme="http://vinoit.me/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程调度</title>
    <link href="http://vinoit.me/2016/08/26/linux-kernel-note-process-scheduling/"/>
    <id>http://vinoit.me/2016/08/26/linux-kernel-note-process-scheduling/</id>
    <published>2016-08-26T08:23:54.000Z</published>
    <updated>2016-10-31T08:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>传统Unix操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。决定什么时候以怎样的方式选择一个新进程运行的这组规则就是所谓的调度策略（scheduling policy）。</p>
<p>Linux的进程调度是基于分时技术（time-sharing）。允许多个进程“并发”运行就意味着CPU 的时间被粗略地分成“片”，给每个可运行进程分配一片。</p>
<p>当然，单处理器在任何给定的时刻只能运行一个进程。当一个并发执行的进程其时间片或时限（quantum）到期时还没有终止，进程切换就可以发生。分时依赖于定时中断，因此，对进程是透明的。为保证CPU 分时，不需要在程序中插入额外的代码。</p>
<p>在Linux 中，进程的优先级是动态的。调度程序跟踪进程做了些什么，并周期性地调整它们的优先级。在这种方式下，在较长的时间间隔内没有使用CPU的进程，通过动态地增加它们的优先级来提升它们。相应地，对于已经在CPU上运行了较长时间的进程，通过减少它们的优先级来处罚它们。每个进程在创建之初有一个基本的优先级，执行期间调度系统会动态调整它的优先级，交互性高的任务会获得一个高的动态优先级，而交互性低的任务获得一个低的动态优先级。</p>
<h4 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h4><p>传统上把进程分类为“I/O 受限（I/O-bound）”或“CPU受限（CPU-bound）”。前者频繁地使用I/O 设备，并花费很多时间等待I/O操作的完成；而后者是需要大量CPU 时间的数值计算应用程序。</p>
<p>另一种分类法把进程区分为三类:<strong>交互式进程</strong> 、<strong>批处理进程</strong> 、<strong>实时进程</strong>。</p>
<p>交互式进程经常与用户交互，需要花很多时间等待键盘和鼠标操作。典型的交互式程序是命令shel、文本编辑程序、图形应用程序等。批处理程序不必与用户交互，经常在后台运行。因为这些进程不必被很快地相应，因此常受到调度程序的慢待。典型的批处理程序是编译程序、数据库搜索引擎、科学计算等。实时进程有很强的调度需要，他们不会被低优先级的进程阻塞，响应的时间很短。典型的实时程序有视频和音频应用程序、机器人控制程序、从物理传感器上收集数据的程序等。</p>
<p>这2种分类法在一定程度上互相独立。例如一个批处理程序可能是I/O受限型的（如数据库服务器），也可能是CPU受限型的（图像绘制程序）。Linux的调度算法可以明确的区分实时程序，但是没有办法区分交互式程序和批处理程序。Linux根据进程的过去行为，通过特定的算法区分交互式程序和批处理程序。因为交互式程序需要给用户一个良好的体验，所以Linux调度程序对交互式程序比较偏爱。</p>
<h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>交互式程序和批处理程序都叫做<strong>非实时进程（普通进程）</strong>，每个非实时进程都有自己的静态优先级（nice值），<code>值越大优先级越低</code>。。nice值是所有Unix系统的标准化概念，在OS X系统中nice值代表分配给进程的时间片的绝对值，<code>而Linux中代表时间片的比例</code>。通过<code>ps -el</code>命令查看系统中的进程列表，结果中标记<code>NI</code>的一列就是进程对应的nice值。</p>
<p>对于<strong>实时进程</strong>，实时优先级的范围是从1（最低优先级）~ 99（最高优先级），含义与nice值相反。任何实时进程的优先级总高于非实时进程（普通进程）。你可以通过<code>ps -eo stata,uid,pid,ppid,rtprio,time,com</code>查看系统中的进程列表，在<code>RTPRIO</code>列的就是实时优先级，如果显示<code>-</code>，则该进程不是实时进程。</p>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。一般来说，调度策略必须规定一个默认的时间片，但是Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比划分给了进程。这样一来，进程所获得的处理器时间其实是和系统负载密切相关的。nice值作为权重将调整使用比，值越大，使用比越小。Linux中CFS调度器的抢占时机取决于新进程所消耗的使用比。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。</p>
<p>不过，当可运行进程的数量区域无限时，每个进程获得使用比则趋于0，岂不是时间都花在切换进程上了？CFS为此引入了每个进程获得的时间片最小粒度，默认是1ms,也就是每个进程最少能获得1ms的运行时间。</p>
<h4 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h4><p>每个Linux进程都按照以下调度类型被调度：</p>
<ul>
<li><p>SCHED_FIFO<br>先进先出的实时进程。如果没有优先级更高的可运行的实时进程，则当前运行的实时进程想运行多久便运行多久，即使还有其他优先级相同的可运行实时进程</p>
</li>
<li><p>SCHED_RR<br>时间片轮转的实时进程。保证对所有相同优先级的实时进程公平地分配CPU时间。</p>
</li>
<li><p>SCHED_NORMAL<br>普通的分时进程。</p>
</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>早期Linux的调度算法非常简单，在每次进程切换时，内核扫描可运行进程的链表，然后选择“最佳”的进程来运行。这个算法的主要缺点是选择进程所消耗的时间与可运行进程的数量相关。当可运行进程的数量很多时，扫描花费的时间很不可观。</p>
<p>如今Linux采用的算法为“完全公平调度算法”，简称<code>CFS</code>。CFS是一个针对普通进程的调度器，期调度类型为<code>SCHED_NORMAL</code>。在#时间片#中已经讲到，nice值在CFS中被作为进程获得处理器运行比的权重。</p>
<p>CFS使用一个<code>struct sched_entity</code>数据结构来记录进程的调度情况，包括运行时间。进程描述符中的<code>se</code>字段便是该数据类型,<code>se</code>是当前进程的调度实体，该结构部分内容如下:</p>
<p><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.24#L866" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.24#L866</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sched_entity &#123;</div><div class="line">        <span class="keyword">struct</span> load_weight      load;           <span class="comment">/* for load-balancing */</span></div><div class="line">        <span class="keyword">struct</span> rb_node          run_node;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>            on_rq;</div><div class="line"></div><div class="line">        u64                     exec_start;</div><div class="line">        u64                     sum_exec_runtime;</div><div class="line">        u64                     vruntime;</div><div class="line">        u64                     prev_sum_exec_runtime;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>vruntime</code>变量存放进程的虚拟运行时间，CFS使用<code>vruntime</code>来记录一个程序到底运行了多长时间以及它应该再运行多久。可以简单地认为<code>vruntime</code>通过以下公式计算:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vruntime ＝ delta_time / load</div></pre></td></tr></table></figure>
<p>其中<code>delta_time</code>表示该进程以运行的时间，<code>load</code>表示进程对CPU的使用比，和nice值相关。当运行相同时间时，使用比大的进程vruntime更小，表明能获得更多的CPU时间。更新函数通过时钟中断调用。</p>
<p><strong>进程选择</strong></p>
<p>CFS调度算法的核心便是选择具有最小vruntime的进程，CFS使用红黑树来组织可运行进程队列，并且通过红黑树迅速找到最小vruntime的进程。红黑树中的每一个节点的值便是<code>vruntime</code>,越小的<code>vruntime</code>，位置越靠左下，所以只需找到最左下的节点的进程。</p>
<h4 id="调度相关数据结构"><a href="#调度相关数据结构" class="headerlink" title="调度相关数据结构"></a>调度相关数据结构</h4><h5 id="struct-rq"><a href="#struct-rq" class="headerlink" title="struct rq"></a>struct rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rq &#123;</div><div class="line"><span class="number">279</span>         <span class="comment">/* runqueue lock: */</span></div><div class="line"><span class="number">280</span>         <span class="keyword">spinlock_t</span> lock;</div><div class="line"><span class="number">281</span> </div><div class="line"><span class="number">282</span>         <span class="comment">/*</span></div><div class="line">283          * nr_running and cpu_load should be in the same cacheline because</div><div class="line">284          * remote CPUs use both these fields when doing load calculation.</div><div class="line">285          */</div><div class="line"><span class="number">286</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</div><div class="line"><span class="number">287</span>         <span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></div><div class="line"><span class="number">288</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</div><div class="line"><span class="number">289</span>         <span class="keyword">unsigned</span> <span class="keyword">char</span> idle_at_tick;</div><div class="line"><span class="number">290</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ</span></div><div class="line"><span class="number">291</span>         <span class="keyword">unsigned</span> <span class="keyword">char</span> in_nohz_recently;</div><div class="line"><span class="number">292</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">293</span>         <span class="comment">/* capture load from *all* tasks on this cpu: */</span></div><div class="line"><span class="number">294</span>         <span class="keyword">struct</span> load_weight load;</div><div class="line"><span class="number">295</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_load_updates;</div><div class="line"><span class="number">296</span>         u64 nr_switches;</div><div class="line"><span class="number">297</span> </div><div class="line"><span class="number">298</span>         <span class="keyword">struct</span> cfs_rq cfs;</div><div class="line"><span class="number">299</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></div><div class="line"><span class="number">300</span>         <span class="comment">/* list of leaf cfs_rq on this cpu: */</span></div><div class="line"><span class="number">301</span>         <span class="keyword">struct</span> list_head leaf_cfs_rq_list;</div><div class="line"><span class="number">302</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">303</span>         <span class="keyword">struct</span> rt_rq rt;</div><div class="line"><span class="number">304</span> </div><div class="line"><span class="number">305</span>         <span class="comment">/*</span></div><div class="line">306          * This is part of a global counter where only the total sum</div><div class="line">307          * over all CPUs matters. A task can increase this counter on</div><div class="line">308          * one CPU and if it got migrated afterwards it may decrease</div><div class="line">309          * it on another CPU. Always updated under the runqueue lock:</div><div class="line">310          */</div><div class="line"><span class="number">311</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_uninterruptible;</div><div class="line"><span class="number">312</span> </div><div class="line"><span class="number">313</span>         <span class="keyword">struct</span> task_struct *curr, *idle;</div><div class="line"><span class="number">314</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> next_balance;</div><div class="line"><span class="number">315</span>         <span class="keyword">struct</span> mm_struct *prev_mm;</div><div class="line"><span class="number">316</span> </div><div class="line"><span class="number">317</span>         u64 clock, prev_clock_raw;</div><div class="line"><span class="number">318</span>         s64 clock_max_delta;</div><div class="line"><span class="number">319</span> </div><div class="line"><span class="number">320</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> clock_warps, clock_overflows;</div><div class="line"><span class="number">321</span>         u64 idle_clock;</div><div class="line"><span class="number">322</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> clock_deep_idle_events;</div><div class="line"><span class="number">323</span>         u64 tick_timestamp;</div><div class="line"><span class="number">324</span> </div><div class="line"><span class="number">325</span>         <span class="keyword">atomic_t</span> nr_iowait;</div><div class="line"><span class="number">326</span> </div><div class="line"><span class="number">327</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></div><div class="line"><span class="number">328</span>         <span class="keyword">struct</span> sched_domain *sd;</div><div class="line"><span class="number">329</span> </div><div class="line"><span class="number">330</span>         <span class="comment">/* For active balancing */</span></div><div class="line"><span class="number">331</span>         <span class="keyword">int</span> active_balance;</div><div class="line"><span class="number">332</span>         <span class="keyword">int</span> push_cpu;</div><div class="line"><span class="number">333</span>         <span class="comment">/* cpu of this runqueue: */</span></div><div class="line"><span class="number">334</span>         <span class="keyword">int</span> cpu;</div><div class="line"><span class="number">335</span> </div><div class="line"><span class="number">336</span>         <span class="keyword">struct</span> task_struct *migration_thread;</div><div class="line"><span class="number">337</span>         <span class="keyword">struct</span> list_head migration_queue;</div><div class="line"><span class="number">338</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">339</span> </div><div class="line"><span class="number">340</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></div><div class="line"><span class="number">341</span>         <span class="comment">/* latency stats */</span></div><div class="line"><span class="number">342</span>         <span class="keyword">struct</span> sched_info rq_sched_info;</div><div class="line"><span class="number">343</span> </div><div class="line"><span class="number">344</span>         <span class="comment">/* sys_sched_yield() stats */</span></div><div class="line"><span class="number">345</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_exp_empty;</div><div class="line"><span class="number">346</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_act_empty;</div><div class="line"><span class="number">347</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_both_empty;</div><div class="line"><span class="number">348</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_count;</div><div class="line"><span class="number">349</span> </div><div class="line"><span class="number">350</span>         <span class="comment">/* schedule() stats */</span></div><div class="line"><span class="number">351</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_switch;</div><div class="line"><span class="number">352</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_count;</div><div class="line"><span class="number">353</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_goidle;</div><div class="line"><span class="number">354</span> </div><div class="line"><span class="number">355</span>         <span class="comment">/* try_to_wake_up() stats */</span></div><div class="line"><span class="number">356</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> ttwu_count;</div><div class="line"><span class="number">357</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> ttwu_local;</div><div class="line"><span class="number">358</span> </div><div class="line"><span class="number">359</span>         <span class="comment">/* BKL stats */</span></div><div class="line"><span class="number">360</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> bkl_count;</div><div class="line"><span class="number">361</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">362</span>         <span class="keyword">struct</span> lock_class_key rq_lock_key;</div><div class="line"><span class="number">363</span> &#125;;</div></pre></td></tr></table></figure>
<h5 id="struct-cfs-rq"><a href="#struct-cfs-rq" class="headerlink" title="struct cfs_rq"></a>struct cfs_rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cfs_rq &#123;</div><div class="line"><span class="number">232</span>         <span class="keyword">struct</span> load_weight load;</div><div class="line"><span class="number">233</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</div><div class="line"><span class="number">234</span> </div><div class="line"><span class="number">235</span>         u64 exec_clock;</div><div class="line"><span class="number">236</span>         u64 min_vruntime;</div><div class="line"><span class="number">237</span> </div><div class="line"><span class="number">238</span>         <span class="keyword">struct</span> rb_root tasks_timeline;</div><div class="line"><span class="number">239</span>         <span class="keyword">struct</span> rb_node *rb_leftmost;</div><div class="line"><span class="number">240</span>         <span class="keyword">struct</span> rb_node *rb_load_balance_curr;</div><div class="line"><span class="number">241</span>         <span class="comment">/* 'curr' points to currently running entity on this cfs_rq.</span></div><div class="line">242          * It is set to NULL otherwise (i.e when none are currently running).</div><div class="line">243          */</div><div class="line"><span class="number">244</span>         <span class="keyword">struct</span> sched_entity *curr;</div><div class="line"><span class="number">245</span> </div><div class="line"><span class="number">246</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_spread_over;</div><div class="line"><span class="number">247</span> </div><div class="line"><span class="number">248</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></div><div class="line"><span class="number">249</span>         <span class="keyword">struct</span> rq *rq;  <span class="comment">/* cpu runqueue to which this cfs_rq is attached */</span></div><div class="line"><span class="number">250</span> </div><div class="line"><span class="number">251</span>         <span class="comment">/*</span></div><div class="line">252          * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in</div><div class="line">253          * a hierarchy). Non-leaf lrqs hold other higher schedulable entities</div><div class="line">254          * (like users, containers etc.)</div><div class="line">255          *</div><div class="line">256          * leaf_cfs_rq_list ties together list of leaf cfs_rq's in a cpu. This</div><div class="line">257          * list is used during load balance.</div><div class="line">258          */</div><div class="line"><span class="number">259</span>         <span class="keyword">struct</span> list_head leaf_cfs_rq_list;</div><div class="line"><span class="number">260</span>         <span class="keyword">struct</span> task_group *tg;  <span class="comment">/* group that "owns" this runqueue */</span></div><div class="line"><span class="number">261</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">262</span> &#125;;</div></pre></td></tr></table></figure>
<h5 id="struct-rt-rq"><a href="#struct-rt-rq" class="headerlink" title="struct rt_rq"></a>struct rt_rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rt_rq &#123;</div><div class="line"><span class="number">266</span>         <span class="keyword">struct</span> rt_prio_array active;</div><div class="line"><span class="number">267</span>         <span class="keyword">int</span> rt_load_balance_idx;</div><div class="line"><span class="number">268</span>         <span class="keyword">struct</span> list_head *rt_load_balance_head, *rt_load_balance_curr;</div><div class="line"><span class="number">269</span> &#125;;</div></pre></td></tr></table></figure>
<p><code>struct rq</code>为一个运行队列，每个CPU都有一个这样的数据结构，在<code>rq</code>中有<code>struct cfs_rq</code>类型的cfs字段，该字段表示一个CFS调度器的运行队列，<code>rq</code>中的<code>struct rt_rq</code>类型的rt字段表示一个实时进程的运行队列。具体细节日后有时间在整理。</p>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> </blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h4&gt;&lt;p&gt;传统Unix操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux中x86的内联汇编</title>
    <link href="http://vinoit.me/2016/08/24/linux-x86-assembly-inline/"/>
    <id>http://vinoit.me/2016/08/24/linux-x86-assembly-inline/</id>
    <published>2016-08-24T07:45:39.000Z</published>
    <updated>2016-08-24T08:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址:<a href="https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/</a></p>
</blockquote>
<p>如果您是 Linux 内核的开发人员，您会发现自己经常要对与体系结构高度相关的功能进行编码或优化代码路径。您很可能是通过将汇编语言指令插入到 C 语句的中间（又称为内联汇编的一种方法）来执行这些任务的。让我们看一下 Linux 中内联汇编的特定用法。（我们将讨论限制在 IA32 汇编。）</p>
<h4 id="GNU-汇编程序简述"><a href="#GNU-汇编程序简述" class="headerlink" title="GNU 汇编程序简述"></a>GNU 汇编程序简述</h4><p>让我们首先看一下 Linux 中使用的基本汇编程序语法。GCC（用于 Linux 的 GNU C 编译器）使用 AT&amp;T 汇编语法。下面列出了这种语法的一些基本规则。（该列表肯定不完整；只包括了与内联汇编相关的那些规则。）</p>
<p><strong>寄存器命名</strong><br>寄存器名称有 % 前缀。即，如果必须使用 eax，它应该用作 %eax。<br>源操作数和目的操作数的顺序<br>在所有指令中，先是源操作数，然后才是目的操作数。这与将源操作数放在目的操作数之后的 Intel 语法不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov %eax, %ebx, transfers the contents of eax to ebx.</div></pre></td></tr></table></figure>
<p><strong>操作数大小</strong><br>根据操作数是字节 (byte)、字 (word) 还是长型 (long)，指令的后缀可以是 b、w 或 l。这并不是强制性的；GCC 会尝试通过读取操作数来提供相应的后缀。但手工指定后缀可以改善代码的可读性，并可以消除编译器猜测不正确的可能性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movb %al, %bl -- Byte move</div><div class="line">movw %ax, %bx -- Word move</div><div class="line">movl %eax, %ebx -- Longword move</div></pre></td></tr></table></figure>
<p><strong>立即操作数</strong><br>通过使用 $ 指定直接操作数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movl $0xffff, %eax -- will move the value of 0xffff into eax register.</div></pre></td></tr></table></figure></p>
<p><strong>间接内存引用</strong><br>任何对内存的间接引用都是通过使用 ( ) 来完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movb (%esi), %al -- will transfer the byte in the memory pointed by esi into al register</div></pre></td></tr></table></figure>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>GCC 为内联汇编提供特殊结构，它具有以下格式：</p>
<p><strong>GCG 的 “asm” 结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  asm ( assembler template</div><div class="line">    </div><div class="line">: output operands               (optional)</div><div class="line">    </div><div class="line">: input operands                (optional)</div><div class="line">    </div><div class="line">: list of clobbered registers   </div><div class="line">    (optional)</div><div class="line">    </div><div class="line">);</div></pre></td></tr></table></figure>
<p>本例中，汇编程序模板由汇编指令组成。输入操作数是充当指令输入操作数使用的 C 表达式。输出操作数是将对其执行汇编指令输出的 C 表达式。<br>内联汇编的重要性体现在它能够灵活操作，而且可以使其输出通过 C 变量显示出来。因为它具有这种能力，所以 “asm” 可以用作汇编指令和包含它的 C 程序之间的接口。<br>一个非常基本但很重要的区别在于 简单内联汇编只包括指令，而 扩展内联汇编包括操作数。要说明这一点，考虑以下示例：</p>
<p><strong>内联汇编的基本要素</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int a=10, b;</div><div class="line">    asm ("movl %1, %%eax;</div><div class="line">    </div><div class="line">movl %%eax, %0;"</div><div class="line">        :"=r"(b)  /* output */    </div><div class="line">        :"r"(a)       /* input */</div><div class="line">        :"%eax"); /* clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，我们使用汇编指令使 “b” 的值等于 “a”。请注意以下几点：</p>
<ul>
<li>“b” 是输出操作数，由 %0 引用，”a” 是输入操作数，由 %1 引用。</li>
<li>“r” 是操作数的约束，它指定将变量 “a” 和 “b” 存储在寄存器中。请注意，输出操作数约束应该带有一个约束修饰符 “=”，指定它是输出操作数。</li>
<li>要在 “asm” 内使用寄存器 %eax，%eax 的前面应该再加一个 %，换句话说就是 %%eax，因为 “asm” 使用 %0、%1 等来标识变量。任何带有一个 % 的数都看作是输入／输出操作数，而不认为是寄存器。</li>
<li>第三个冒号后的修饰寄存器 %eax 告诉将在 “asm” 中修改 GCC %eax 的值，这样 GCC 就不使用该寄存器存储任何其它的值。</li>
<li>movl %1, %%eax 将 “a” 的值移到 %eax 中， movl %%eax, %0 将 %eax 的内容移到 “b” 中。</li>
<li>因为 “b” 被指定成输出操作数，因此当 “asm” 的执行完成后，它将反映出更新的值。换句话说，对 “asm” 内 “b” 所做的更改将在 “asm” 外反映出来。</li>
</ul>
<p>现在让我们更详细的了解每一项的含义。</p>
<h4 id="汇编程序模板"><a href="#汇编程序模板" class="headerlink" title="汇编程序模板"></a>汇编程序模板</h4><p>汇编程序模板是一组插入到 C 程序中的汇编指令（可以是单个指令，也可以是一组指令）。每条指令都应该由双引号括起，或者整组指令应该由双引号括起。每条指令还应该用一个定界符结尾。有效的定界符为新行 (\n) 和分号 (;)。 ‘\n’ 后可以跟一个 tab(\t) 作为格式化符号，增加 GCC 在汇编文件中生成的指令的可读性。 指令通过数 %0、%1 等来引用 C 表达式（指定为操作数）。</p>
<p>如果希望确保编译器不会在 “asm” 内部优化指令，可以在 “asm” 后使用关键字 “volatile”。如果程序必须与 ANSI C 兼容，则应该使用 <code>__asm__</code> 和 <code>__volatile__</code>，而不是 asm 和 volatile。</p>
<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>C 表达式用作 “asm” 内的汇编指令操作数。在汇编指令通过对 C 程序的 C 表达式进行操作来执行有意义的作业的情况下，操作数是内联汇编的主要特性。</p>
<p>每个操作数都由操作数约束字符串指定，后面跟用括弧括起的 C 表达式，例如：”constraint” (C expression)。操作数约束的主要功能是确定操作数的寻址方式。<br>可以在输入和输出部分中同时使用多个操作数。每个操作数由逗号分隔开。</p>
<p>在汇编程序模板内部，操作数由数字引用。如果总共有 n 个操作数（包括输入和输出），那么第一个输出操作数的编号为 0，逐项递增，最后那个输入操作数的编号为 n -1。总操作数的数目限制在 10，如果机器描述中任何指令模式中的最大操作数数目大于 10，则使用后者作为限制。</p>
<h4 id="修饰寄存器列表"><a href="#修饰寄存器列表" class="headerlink" title="修饰寄存器列表"></a>修饰寄存器列表</h4><p>如果 “asm” 中的指令指的是硬件寄存器，可以告诉 GCC 我们将自己使用和修改它们。这样，GCC 就不会假设它装入到这些寄存器中的值是有效值。通常不需要将输入和输出寄存器列为 clobbered，因为 GCC 知道 “asm” 使用它们（因为它们被明确指定为约束）。不过，如果指令使用任何其它的寄存器，无论是明确的还是隐含的（寄存器不在输入约束列表中出现，也不在输出约束列表中出现），寄存器都必须被指定为修饰列表。修饰寄存器列在第三个冒号之后，其名称被指定为字符串。</p>
<p>至于关键字，如果指令以某些不可预知且不明确的方式修改了内存，则可能将 “memory” 关键字添加到修饰寄存器列表中。这样就告诉 GCC 不要在不同指令之间将内存值高速缓存在寄存器中。</p>
<h4 id="操作数约束"><a href="#操作数约束" class="headerlink" title="操作数约束"></a>操作数约束</h4><p>前面提到过，”asm” 中的每个操作数都应该由操作数约束字符串描述，后面跟用括弧括起的 C 表达式。操作数约束主要是确定指令中操作数的寻址方式。约束也可以指定：</p>
<ul>
<li>是否允许操作数位于寄存器中，以及它可以包括在哪些种类的寄存器中</li>
<li>操作数是否可以是内存引用，以及在这种情况下使用哪些种类的地址</li>
<li>操作数是否可以是立即数</li>
</ul>
<p>约束还要求两个操作数匹配。</p>
<h4 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h4><p>在可用的操作数约束中，只有一小部分是常用的；下面列出了这些约束以及简要描述。有关操作数约束的完整列表，请参考 GCC 和 GAS 手册。</p>
<p><strong>寄存器操作数约束 (r)</strong><br>使用这种约束指定操作数时，它们存储在通用寄存器中。请看下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asm (&quot;movl %%cr3, %0\n&quot; :&quot;=r&quot;(cr3val));</div></pre></td></tr></table></figure>
<p>这里，变量 cr3val 保存在寄存器中，%cr3 的值复制到寄存器上，cr3val 的值从该寄存器更新到内存中。指定 “r” 约束时，GCC 可以将变量 cr3val 保存在任何可用的 GPR 中。要指定寄存器，必须通过使用特定的寄存器约束直接指定寄存器名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">a        eax</div><div class="line">b        ebx</div><div class="line">c        ecx</div><div class="line">d        edx</div><div class="line">S        esi</div><div class="line">D        edi</div><div class="line">I        constant value (0 to 31)</div><div class="line">q,r      dynamically allocated register (see below)</div><div class="line">g        eax, ebx, ecx, edx or variable in memory</div><div class="line">A        eax and edx combined into a 64-bit integer (use long longs)</div></pre></td></tr></table></figure>
<p><strong>内存操作数约束 (m)</strong><br>当操作数位于内存中时，任何对它们执行的操作都将在内存位置中直接发生，这与寄存器约束正好相反，后者先将值存储在要修改的寄存器中，然后将它写回内存位置中。但寄存器约束通常只在对于指令来说它们是绝对必需的，或者它们可以大大提高进程速度时使用。当需要在 “asm” 内部更新 C 变量，而您又确实不希望使用寄存器来保存其值时，使用内存约束最为有效。例如，idtr 的值存储在内存位置 loc 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&quot;sidt %0\n&quot; : :&quot;m&quot;(loc));</div></pre></td></tr></table></figure>
<p><strong>匹配（数字）约束</strong><br>在某些情况下，一个变量既要充当输入操作数，也要充当输出操作数。可以通过使用匹配约束在 “asm” 中指定这种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asm (&quot;incl %0&quot; :&quot;=a&quot;(var):&quot;0&quot;(var));</div></pre></td></tr></table></figure>
<p>在匹配约束的示例中，寄存器 %eax 既用作输入变量，也用作输出变量。将 var 输入读取到 %eax，增加后将更新的 %eax 再次存储在 var 中。这里的 “0” 指定第 0 个输出变量相同的约束。即，它指定 var 的输出实例只应该存储在 %eax 中。该约束可以用于以下情况：</p>
<ul>
<li>输入从变量中读取，或者变量被修改后，修改写回到同一变量中</li>
<li>不需要将输入操作数和输出操作数的实例分开</li>
</ul>
<p>使用匹配约束最重要的意义在于它们可以导致有效地使用可用寄存器。</p>
<h4 id="一般内联汇编用法示例"><a href="#一般内联汇编用法示例" class="headerlink" title="一般内联汇编用法示例"></a>一般内联汇编用法示例</h4><p>以下示例通过各种不同的操作数约束说明了用法。有如此多的约束以至于无法将它们一一列出，这里只列出了最经常使用的那些约束类型。</p>
<p><code>&quot;asm&quot; 和寄存器约束 &quot;r&quot;</code> 让我们先看一下使用寄存器约束 r 的 “asm”。我们的示例显示了 GCC 如何分配寄存器，以及它如何更新输出变量的值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int x = 10, y;</div><div class="line">    </div><div class="line">    asm ("movl %1, %%eax;</div><div class="line">    </div><div class="line"> "movl %%eax, %0;"</div><div class="line">        :"=r"(y)  /* y is output operand */</div><div class="line">        :"r"(x)       /* x is input operand */</div><div class="line">        :"%eax"); /* %eax is clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该例中，x 的值复制为 “asm” 中的 y。x 和 y 都通过存储在寄存器中传递给 “asm”。为该例生成的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $8,%esp</div><div class="line">movl $10,-4(%ebp)    </div><div class="line">movl -4(%ebp),%edx  /* x=10 is stored in %edx */</div><div class="line">#APP    /* asm starts here */   </div><div class="line">movl %edx, %eax     /* x is moved to %eax */</div><div class="line">movl %eax, %edx     /* y is allocated in edx and updated */</div><div class="line">#NO_APP /* asm ends here */</div><div class="line">movl %edx,-8(%ebp)  /* value of y in stack is updated with </div><div class="line">                </div><div class="line"> the value in %edx */</div></pre></td></tr></table></figure>
<p>当使用 “r” 约束时，GCC 在这里可以自由分配任何寄存器。在我们的示例中，它选择 %edx 来存储 x。在读取了 %edx 中 x 的值后，它为 y 也分配了相同的寄存器。</p>
<p>因为 y 是在输出操作数部分中指定的，所以 %edx 中更新的值存储在 -8(%ebp)，堆栈上 y 的位置中。如果 y 是在输入部分中指定的，那么即使它在 y 的临时寄存器存储值 (%edx) 中被更新，堆栈上 y 的值也不会更新。</p>
<p>因为 %eax 是在修饰列表中指定的，GCC 不在任何其它地方使用它来存储数据。</p>
<p>输入 x 和输出 y 都分配在同一个 %edx 寄存器中，假设输入在输出产生之前被消耗。请注意，如果您有许多指令，就不是这种情况了。要确保输入和输出分配到不同的寄存器中，可以指定 &amp; 约束修饰符。下面是添加了约束修饰符的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int x = 10, y;</div><div class="line">    </div><div class="line">    asm (&quot;movl %1, %%eax;</div><div class="line">    </div><div class="line"> &quot;movl %%eax, %0;&quot;</div><div class="line">        :&quot;=&amp;r&quot;(y) /* y is output operand, note the    </div><div class="line">                </div><div class="line"> &amp; constraint modifier. */</div><div class="line">        :&quot;r&quot;(x)       /* x is input operand */</div><div class="line">        :&quot;%eax&quot;); /* %eax is clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是为该示例生成的汇编代码，从中可以明显地看出 x 和 y 存储在 “asm” 中不同的寄存器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $8,%esp</div><div class="line">movl $10,-4(%ebp)</div><div class="line">movl -4(%ebp),%ecx  /* x, the input is in %ecx */</div><div class="line">#APP</div><div class="line">    movl %ecx, %eax</div><div class="line">    movl %eax, %edx     /* y, the output is in %edx */</div><div class="line">#NO_APP</div><div class="line">movl %edx,-8(%ebp)</div></pre></td></tr></table></figure>
<h4 id="特定寄存器约束的使用"><a href="#特定寄存器约束的使用" class="headerlink" title="特定寄存器约束的使用"></a>特定寄存器约束的使用</h4><p>现在让我们看一下如何将个别寄存器作为操作数的约束指定。在下面的示例中，cpuid 指令采用 %eax 寄存器中的输入，然后在四个寄存器中给出输出：%eax、%ebx、%ecx、%edx。对 cpuid 的输入（变量 “op”）传递到 “asm” 的 eax 寄存器中，因为 cpuid 希望它这样做。在输出中使用 a、b、c 和 d 约束，分别收集四个寄存器中的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">asm (&quot;cpuid&quot;</div><div class="line">: &quot;=a&quot; (_eax),</div><div class="line">&quot;=b&quot; (_ebx),</div><div class="line">&quot;=c&quot; (_ecx),</div><div class="line">&quot;=d&quot; (_edx)</div><div class="line">: &quot;a&quot; (op));</div></pre></td></tr></table></figure>
<p>在下面可以看到为它生成的汇编代码（假设 _eax、_ebx 等… 变量都存储在堆栈上）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">movl -20(%ebp),%eax /* store &apos;op&apos; in %eax -- input */</div><div class="line">#APP</div><div class="line">cpuid</div><div class="line">#NO_APP</div><div class="line">movl %eax,-4(%ebp)  /* store %eax in _eax -- output */</div><div class="line">movl %ebx,-8(%ebp)  /* store other registers in</div><div class="line">movl %ecx,-12(%ebp) </div><div class="line"> respective output variables */</div><div class="line">movl %edx,-16(%ebp)</div></pre></td></tr></table></figure>
<p>strcpy 函数可以通过以下方式使用 “S” 和 “D” 约束来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">asm (&quot;cld\n</div><div class="line">    </div><div class="line">rep\n</div><div class="line">    </div><div class="line">movsb&quot;</div><div class="line">    </div><div class="line">: /* no input */</div><div class="line">    </div><div class="line">:&quot;S&quot;(src), &quot;D&quot;(dst), &quot;c&quot;(count));</div></pre></td></tr></table></figure>
<p>通过使用 “S” 约束将源指针 src 放入 %esi 中，使用 “D” 约束将目的指针 dst 放入 %edi 中。因为 rep 前缀需要 count 值，所以将它放入 %ecx 中。</p>
<p>在下面可以看到另一个约束，它使用两个寄存器 %eax 和 %edx 将两个 32 位的值合并在一起，然后生成一个64 位的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define rdtscll(val) \</div><div class="line"> __asm__ __volatile__ (&quot;rdtsc&quot; : &quot;=A&quot; (val))</div><div class="line">The generated assembly looks like this (if val has a 64 bit memory space).</div><div class="line">#APP</div><div class="line">rdtsc</div><div class="line">#NO_APP</div><div class="line">movl %eax,-8(%ebp)  /* As a result of A constraint </div><div class="line">movl %edx,-4(%ebp)  </div><div class="line"> %eax and %edx serve as outputs */</div><div class="line">Note here that the values in %edx:%eax serve as 64 bit output.</div></pre></td></tr></table></figure>
<h4 id="使用匹配约束"><a href="#使用匹配约束" class="headerlink" title="使用匹配约束"></a>使用匹配约束</h4><p>在下面将看到系统调用的代码，它有四个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \</div><div class="line">type name (type1 arg1, type2 arg2, type3 arg3, type4 arg4) \</div><div class="line">&#123; \</div><div class="line">long __res; \</div><div class="line">__asm__ volatile (&quot;int $0x80&quot; \</div><div class="line">: &quot;=a&quot; (__res) \</div><div class="line">: &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1)),&quot;c&quot; ((long)(arg2)), \</div><div class="line">&quot;d&quot; ((long)(arg3)),&quot;S&quot; ((long)(arg4))); \</div><div class="line">__syscall_return(type,__res); \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，通过使用 b、c、d 和 S 约束将系统调用的四个自变量放入 %ebx、%ecx、%edx 和 %esi 中。请注意，在输出中使用了 “=a” 约束，这样，位于 %eax 中的系统调用的返回值就被放入变量 <strong>res 中。通过将匹配约束 “0” 用作输入部分中第一个操作数约束，syscall 号 </strong>NR_##name 被放入 %eax 中，并用作对系统调用的输入。这样，这里的 %eax 既可以用作输入寄存器，又可以用作输出寄存器。没有其它寄存器用于这个目的。另请注意，输入（syscall 号）在产生输出（syscall 的返回值）之前被消耗（使用）。</p>
<h4 id="内存操作数约束的使用"><a href="#内存操作数约束的使用" class="headerlink" title="内存操作数约束的使用"></a>内存操作数约束的使用</h4><p>请考虑下面的原子递减操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__asm__ __volatile__(</div><div class="line">&quot;lock; decl %0&quot;</div><div class="line">:&quot;=m&quot; (counter)</div><div class="line">:&quot;m&quot; (counter));</div></pre></td></tr></table></figure>
<p>为它生成的汇编类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#APP</div><div class="line">    lock</div><div class="line">    decl -24(%ebp) /* counter is modified on its memory location */</div><div class="line">#NO_APP.</div></pre></td></tr></table></figure>
<p>您可能考虑在这里为 counter 使用寄存器约束。如果这样做，counter 的值必须先复制到寄存器，递减，然后对其内存更新。但这样您会无法理解锁定和原子性的全部意图，这些明确显示了使用内存约束的必要性。</p>
<h4 id="使用修饰寄存器"><a href="#使用修饰寄存器" class="headerlink" title="使用修饰寄存器"></a>使用修饰寄存器</h4><p>请考虑内存拷贝的基本实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   asm (&quot;movl $count, %%ecx;</div><div class="line">    </div><div class="line">up: lodsl;  </div><div class="line">    </div><div class="line">stosl;</div><div class="line">    </div><div class="line">loop up;&quot;</div><div class="line">        :           /* no output */</div><div class="line">        :&quot;S&quot;(src), &quot;D&quot;(dst) /* input */</div><div class="line">        :&quot;%ecx&quot;, &quot;%eax&quot; );  /* clobbered list */</div></pre></td></tr></table></figure>
<p>当 lodsl 修改 %eax 时，lodsl 和 stosl 指令隐含地使用它。%ecx 寄存器明确装入 count。但 GCC 在我们通知它以前是不知道这些的，我们是通过将 %eax 和 %ecx 包括在修饰寄存器集中来通知 GCC 的。在完成这一步之前，GCC 假设 %eax 和 %ecx 是自由的，它可能决定将它们用作存储其它的数据。请注意，%esi 和 %edi 由 “asm” 使用，它们不在修饰列表中。这是因为已经声明 “asm” 将在输入操作数列表中使用它们。这里最低限度是，如果在 “asm” 内部使用寄存器（无论是明确还是隐含地），既不出现在输入操作数列表中，也不出现在输出操作数列表中，必须将它列为修饰寄存器。</p>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>总的来说，内联汇编非常巨大，它提供的许多特性我们甚至在这里根本没有涉及到。但如果掌握了本文描述的基本材料，您应该可以开始对自己的内联汇编进行编码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.i
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
      <category term="汇编" scheme="http://vinoit.me/categories/Linux/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="汇编" scheme="http://vinoit.me/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>linux内核笔记之进程（三）</title>
    <link href="http://vinoit.me/2016/08/24/linux-kernel-note-process-three/"/>
    <id>http://vinoit.me/2016/08/24/linux-kernel-note-process-three/</id>
    <published>2016-08-24T05:42:48.000Z</published>
    <updated>2016-10-31T08:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。</p>
<h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。</p>
<p>进程恢复执行前必须装入寄存器的一组数据成为硬件上下文（hardware context）。硬件上下文是进程可执行上下文的一个自己，因为可执行上下文包含进程执行时所需要的所有信息。在Linux中，进程硬件上下午的一部分存放在<code>TSS段</code>，而剩余部分存放在<code>内核态堆栈</code>中。</p>
<p>在下面描述中，假定用prev局部变量表示切换出的进程描述符，next表示切换进的进程描述符,<code>这2个局部变量都存放在进程的内核堆栈中</code>。因此，我们把进程切换定义为这样的行为：保存prev硬件上下文，用next硬件上下文代替prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。</p>
<p>早期Linux版本利用80x86体系结构所需提供的硬件支持，并通过far jmp1指令跳到next进程TSS描述符的选择符来执行进程切换。当执行这条指令时，CPU通过自动保存原来的硬件上下文，装入新的硬件上下文来执行硬件上下文切换。但Linux2.6使用软件执行进程切换，原因有：</p>
<p>通过一组mov指令逐步执行切换，这样能较好地控制所装入的数据的合法性，一面被恶意用户伪造。far jmp指令不会有这样的检查。<br>旧方法和新方法所需时间大致相同。<br>进程切换值发生在<code>内核态</code>，在执行进程切换之前，用户态进程使用的所有寄存器内容已保存在内核堆栈上，这也包括ss和esp这对寄存器的内容。</p>
<h4 id="任务状态段"><a href="#任务状态段" class="headerlink" title="任务状态段"></a>任务状态段</h4><p>80x86体系结构包含了一个特殊的段类型，叫任务状态段（Task State Segment，TSS）来存放硬件上下文，尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS，这样做主要有两个理由：</p>
<p>当80x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址。<br>当用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存放在TSS中的I/O许可位图以检查该进程是否有访问端口的权利。<br>更确切的说，当进程在用户态执行in或out指令时，控制单元执行下列操作：</p>
<p>检查eflags寄存器中的2位IOPL字段，如果字段的值为3，控制单元就执行I/O指令。否则，执行下一个检查。<br>访问tr寄存器以确定当前的TSS和相应的I/O许可权位图。<br>检查I/O指令中指定的I/O端口在I/O许可权位图中对应的位，如果该位清，这条指令就执行，否则控制单元产生一个异常。<br>tss_struct结构描述TSS的格式，<code>init_tss数组</code>为系统上每个不同的CPU存放一个TSS。在每次进程切换时，内核都更新TSS的某些字段以便相应的CPU控制单元可以安全地检索到它需要的信息。因此，<code>TSS反映了CPU上当前进程的特权级，但不必为没有在运行的进程保留TSS</code>。</p>
<p>每个TSS有它自己8字节的任务状态段描述符（Task State Segment Descriptor，TSSD）。和其他描述符一样，这个描述符包括指向TSS起始地址的32位Base字段，20位Limit字段。TSSD的S标志位被清0，以表示相应的TSS是<code>系统段</code>的事实。</p>
<p>Type字段被置位11或9以表示这个段实际上是一个TSS。在Intel的原始设计中，<code>系统中的每个进程都应当指向自己的TSS</code>；Type字段的第二个有效位叫Busy位；如果进程正由CPU执行，则该位置1，否则为0。在Linux的设计中，<code>每个CPU只有一个TSS</code>，因此Busy位总是为1.</p>
<p>由Linux创建的TSSD存放在全局描述符表（GDT）中，GDT的基地址存放在每个CPU的gdtr寄存器中。<br><img src="/images/linux-kernel-note/process-three-0.png" alt=""><br>每个CPU的tr寄存器包含相应TSS的TSSD选择符，也包含了两个<code>隐藏的非编程字段</code>：TSSD的Base字段和Limit字段。这样，处理器就能够直接TSS寻址而不需要从GDT中检索TSS地址。</p>
<h4 id="thread字段"><a href="#thread字段" class="headerlink" title="thread字段"></a>thread字段</h4><p>在每次进程切换时，被替换的进程的硬件上下文必须保存在别处。不能像Intel原始设计那样保存在TSS中，因为<code>Linux为每个处理器而不是为每个进程使用TSS</code>。</p>
<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后可以看到，这个数据结构包含的字段涉及大部分CPU寄存器，但不包括eax、ebx等等这些通用寄存器。它们的值保留在内核堆栈中。</p>
<h4 id="执行进程切换"><a href="#执行进程切换" class="headerlink" title="执行进程切换"></a>执行进程切换</h4><p>进程切换可能只发生在精心定义的点：schedule()函数，这个函数在专门整理进程调度的篇幅里讲解。这里，只关注内核如何执行一个进程切换。</p>
<p>进程切换由两步组成：</p>
<ul>
<li>切换页全局目录以安装一个新的地址空间。</li>
<li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</li>
</ul>
<p>第二步由<code>switch_to</code>宏来完成，源码如下:</p>
<p><a href="http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*</span></div><div class="line">  * Context switching is now performed out-of-line in switch_to.S</div><div class="line">  */</div><div class="line"> <span class="keyword">extern</span> <span class="keyword">struct</span> task_struct *<span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *,</div><div class="line">                                        <span class="keyword">struct</span> task_struct *);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev, next, last)                                      											                         \</span></div><div class="line">        do &#123;                                                            \</div><div class="line">                ((last) = __switch_to((prev), (next)));                 			                                                   \</div><div class="line">        &#125; while (0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ASM_GENERIC_SWITCH_TO_H */</span></span></div></pre></td></tr></table></figure>
<p>首先，该宏有三个参数，prev、next和last，prev和next的作用仅是<code>内核堆栈中</code>的局部变量prev和next的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。</p>
<p>在任何进程切换中，涉及到的是三个进程而不是两个。假设内核决定暂停进程A而激活进程B，在schedule()函数中，prev指向A的描述符，而next指向B的进程描述符。switch_to宏一旦使A暂停，A的执行流就被冻结。</p>
<p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。B的内核堆栈中的<code>prev</code>指向B的描述符，<code>next</code>指向other(下一个要调度的进程描述符，目前未知)。</strong></p>
<p>随后，当内核想再次激活A，就必须暂停另一个进程C，因为这通常不是B，因为B有可能被其他进程比如C切换。于是就要用prev指向C而next指向A来执行另一个switch_to宏。当A恢复它执行的流时，就会找到它原来的内核栈，于是prev局部变量还是指向A的描述符而next指向B的描述符。</p>
<p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。C的内核堆栈中的<code>prev</code>指向C的描述符，<code>next</code>指向A的描述符。</strong></p>
<p>所以，<code>代表进程A执行的内核就失去了对C的任何引用</code>。但引用对于完成进程切换是有用的，所以需要保留。</p>
<p>switch_to宏的最后一个参数是输出参数，它表示宏把进程C的描述符地址写在内存的什么位置了，不过，这个是在恢复A执行之后完成的。在进程切换之前，宏把第一个输入参数prev表示的变量存入CPU的eax寄存器。在完成进程切换，A已经恢复执行时，宏把CPU的eax寄存器的内容写入由第三个参数last所指示的A在内存中的位置。因为CPU寄存器不会在切换点发生变化，所以C的描述符地址也存在内存的这个位置。在schedule()执行过程中，last参数指向A的局部变量prev，所以prev被C的地址覆盖。</p>
<h4 id="switch-to-函数"><a href="#switch-to-函数" class="headerlink" title="__switch_to()函数"></a>__switch_to()函数</h4><p><strong>switch_to()函数执行大多数开始于switch_to()宏的进程切换。这个函数作用于prev_p和next_p参数，这两个参数表示前一个进程和新进程。这个函数的调用不同于一般的函数调用。因为</strong>switch_to()从eax和edx取参数prev_p和next_p，而不像大多数函数一样从栈中取参数。</p>
<p><a href="http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *prev_p, <span class="keyword">struct</span> task_struct *next_p)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> thread_struct *prev = &amp;prev_p-&gt;thread,</div><div class="line">                             *next = &amp;next_p-&gt;thread;</div><div class="line">        <span class="keyword">struct</span> fpu *prev_fpu = &amp;prev-&gt;fpu;</div><div class="line">        <span class="keyword">struct</span> fpu *next_fpu = &amp;next-&gt;fpu;</div><div class="line">        <span class="keyword">int</span> cpu = smp_processor_id();</div><div class="line">        <span class="keyword">struct</span> tss_struct *tss = &amp;per_cpu(cpu_tss, cpu);</div><div class="line">        <span class="keyword">fpu_switch_t</span> fpu_switch;</div><div class="line"></div><div class="line">        <span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></div><div class="line"></div><div class="line">        fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Save away %gs. No need to save %fs, as it was saved on the</div><div class="line">         * stack on entry.  No need to save %es and %ds, as those are</div><div class="line">         * always kernel segments while inside the kernel.  Doing this</div><div class="line">         * before setting the new TLS descriptors avoids the situation</div><div class="line">         * where we temporarily have non-reloadable segments in %fs</div><div class="line">         * and %gs.  This could be an issue if the NMI handler ever</div><div class="line">         * used %fs or %gs (it does not today), or if the kernel is</div><div class="line">         * running inside of a hypervisor layer.</div><div class="line">         */</div><div class="line">        lazy_save_gs(prev-&gt;gs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Load the per-thread Thread-Local Storage descriptor.</div><div class="line">         */</div><div class="line">        load_TLS(next, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore IOPL if needed.  In normal use, the flags restore</div><div class="line">         * in the switch assembly will handle this.  But if the kernel</div><div class="line">         * is running virtualized at a non-zero CPL, the popf will</div><div class="line">         * not restore flags, so it must be done in a separate step.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</div><div class="line">                set_iopl_mask(next-&gt;iopl);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Now maybe handle debug registers and/or IO bitmaps</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (unlikely(task_thread_info(prev_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_PREV ||</div><div class="line">                     task_thread_info(next_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_NEXT))</div><div class="line">                <span class="number">__</span>switch_to_xtra(prev_p, next_p, tss);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Leave lazy mode, flushing any hypercalls made here.</div><div class="line">         * This must be done before restoring TLS segments so</div><div class="line">         * the GDT and LDT are properly updated, and must be</div><div class="line">         * done before fpu__restore(), so the TS bit is up</div><div class="line">         * to date.</div><div class="line">         */</div><div class="line">        arch_end_context_switch(next_p);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Reload esp0 and cpu_current_top_of_stack.  This changes</div><div class="line">         * current_thread_info().</div><div class="line">         */</div><div class="line">        load_sp0(tss, next);</div><div class="line">        this_cpu_write(cpu_current_top_of_stack,</div><div class="line">                       (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task_stack_page(next_p) +</div><div class="line">                       THREAD_SIZE);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore %gs if needed (which is common)</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</div><div class="line">                lazy_load_gs(next-&gt;gs);</div><div class="line"></div><div class="line">        switch_fpu_finish(next_fpu, fpu_switch);</div><div class="line"></div><div class="line">        this_cpu_write(current_task, next_p);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> prev_p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数执行步骤如下：</p>
<ul>
<li><p>执行由__unlay_fpu()宏代码产生的代码，以有选择地保存prev_p进程的FPU、MMX以及XMM寄存器的内容。</p>
</li>
<li><p>执行smp_processor_id()宏获得本地CPU的下标，即执行代码当前的CPU。该宏从当前进程的thread_info结构的cpu字段获得下标并保存到cpu局部变量。</p>
</li>
<li><p>把next_p-&gt;thread.esp0装入对应于本地CPU的TSS的esp0字段。其实，任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址拷贝到esp寄存器中。</p>
</li>
<li><p>把next_p进程使用的线程局部存储（TLS）段装载入本地CPU的全局描述符表。</p>
</li>
<li><p>把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中。esi寄存器指向prev_p-&gt;thread结构。</p>
</li>
<li><p>如果fs或gs段寄存器已经被prev_p或next_p进程中的任意一个使用，则将next_p进程的thread_struct描述符中保存的值装入这些寄存器。</p>
</li>
<li><p>用next_p-&gt;thread.debugreg数组内容装载dr0…dr7中的6个调试寄存器。只有在next_p被挂起时正在使用调试寄存器，这种操作才能进行。</p>
</li>
<li><p>如果必要，则更新TSS中的I/O位图。因为进程很少修改I/O权限位图，所以当且仅当一个进程在当前时间片内实际访问I/O端口时，真实的位图才被拷贝到本地CPU的TSS中。进程的定制I/O权限位图被保存在thread_info结构的io_bitmap_ptr字段指向的缓冲区中。当prev_p或者next_p拥有自己定制的I/O权限位图（io_bitmap_ptr不为null）时,TSS的io_bitmap字段被设为0x9000,否则为0x8000。</p>
</li>
<li><p>终止，prev_p参数被拷贝到eax，<code>因为缺省情况下任何C函数的返回值被传给eax寄存器</code>。所以eax的值在调用__switch_to()的过程中被保护起来；这很重要，因为调用该函数时会假定eax总是用来存放将被替换的进程描述符地址。</p>
</li>
<li><p>汇编语言指令ret把栈顶保存的返回地址装入eip程序计数器。不过，__swtich_to()函数时通过简单的跳转被调用的。因此，ret汇编指令在栈中找到标号为1的指令地址，其中标号为1的地址是由switch_to()宏推入堆栈的。</p>
</li>
</ul>
<blockquote>
<font color="Darkorange">因本人水平有限，若文章内容存在问题，恳请指出。允许转载，转载请在正文明显处注明<a href="http://vinoit.me">原站地址</a>以及原文地址，谢谢！</font> </blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程切换&quot;&gt;&lt;a href=&quot;#进程切换&quot; class=&quot;headerlink&quot; title=&quot;进程切换&quot;&gt;&lt;/a&gt;进程切换&lt;/h3&gt;&lt;p&gt;为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（pro
    
    </summary>
    
      <category term="Linux" scheme="http://vinoit.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://vinoit.me/tags/Linux/"/>
    
      <category term="内核" scheme="http://vinoit.me/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
</feed>
