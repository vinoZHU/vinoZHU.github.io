<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vino</title>
  <subtitle>Vino&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.vino.ren/"/>
  <updated>2016-05-19T06:14:13.954Z</updated>
  <id>http://blog.vino.ren/</id>
  
  <author>
    <name>Vino Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM内存模型及垃圾收集策略解析</title>
    <link href="http://blog.vino.ren/2016/05/19/jvm-gc-tactics/"/>
    <id>http://blog.vino.ren/2016/05/19/jvm-gc-tactics/</id>
    <published>2016-05-19T05:26:25.000Z</published>
    <updated>2016-05-19T06:14:13.954Z</updated>
    
    <content type="html">&lt;h3 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h3&gt;&lt;p&gt;Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。&lt;/p&gt;
&lt;p&gt;这五个区域既然是存储空间，那么为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。&lt;/p&gt;
&lt;p&gt;这个垃圾收集者就是平常我们所说的“垃圾收集器”，那么垃圾收集器在何时清扫内存？清扫哪些数据？这就是接下来我们要解决的问题。&lt;/p&gt;
&lt;p&gt;程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，也就是每条线程都拥有这三块区域，而且会随着线程的创建而创建，线程的结束而销毁。那么，垃圾收集器在何时清扫这三块区域的问题就解决了。&lt;/p&gt;
&lt;p&gt;此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，方法的结束而出栈，并且每个栈帧中的本地变量表都是在类被加载的时候就确定的。因此以上三个区域的垃圾收集工作具有确定性，垃圾收集器能够清楚地知道何时清扫这三块区域中的哪些数据。&lt;/p&gt;
&lt;p&gt;然而，堆和方法区中的内存清理工作就没那么容易了。&lt;br&gt;堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。&lt;/p&gt;
&lt;p&gt;堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。&lt;/p&gt;
&lt;p&gt;方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。&lt;br&gt;因此，堆和方法区的内存回收具有不确定性。&lt;/p&gt;
&lt;h4 id=&quot;Generation&quot;&gt;&lt;a href=&quot;#Generation&quot; class=&quot;headerlink&quot; title=&quot;Generation&quot;&gt;&lt;/a&gt;Generation&lt;/h4&gt;&lt;p&gt;JVM堆一般又可以分为以下三部分：&lt;br&gt;&lt;img src=&quot;/images/jvm/jvm-gc-tactics-0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Perm代主要保存class,method,filed对象，这部门的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tenured&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Young&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Young区间变满的时候，minor GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。&lt;/p&gt;
&lt;h4 id=&quot;Sizing-the-Generations&quot;&gt;&lt;a href=&quot;#Sizing-the-Generations&quot; class=&quot;headerlink&quot; title=&quot;Sizing the Generations&quot;&gt;&lt;/a&gt;Sizing the Generations&lt;/h4&gt;&lt;p&gt;JVM提供了相应的参数来对内存大小进行配置。正如上面描述，JVM中堆被分为了3个大的区间，同时JVM也提供了一些选项对Young,Tenured的大小进行控制。&lt;br&gt;&lt;img src=&quot;/images/jvm/jvm-gc-tactics-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Total Heap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-Xms:&lt;/code&gt;指定了JVM初始启动以后初始化内存&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-Xmx：&lt;/code&gt;指定JVM堆得最大内存，在JVM启动以后，会分配&lt;code&gt;-Xmx&lt;/code&gt;参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-Xmx -Xms&lt;/code&gt;之差就是三个Virtual空间的大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Young Generation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-XX:NewRatio=8&lt;/code&gt;意味着tenured 和 young的比值8：1，这样eden+2*survivor=1/9&lt;/p&gt;
&lt;p&gt;堆内存&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:SurvivorRatio=32&lt;/code&gt;意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-Xmn&lt;/code&gt; 参数设置了年轻代的大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Perm Generation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-XX:PermSize=16M -XX:MaxPermSize=64M&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Thread Stack&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:Xss=128K&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;堆栈分离的好处&quot;&gt;&lt;a href=&quot;#堆栈分离的好处&quot; class=&quot;headerlink&quot; title=&quot;堆栈分离的好处&quot;&gt;&lt;/a&gt;堆栈分离的好处&lt;/h4&gt;&lt;p&gt;如果从JAVA内存模型的角度去理解面向对象的设计，我们就会发现对象它完美的表示了堆和栈，对象的数据放在堆中，而我们编写的那些方法一般都是运行在栈中，因此面向对象的设计是一种非常完美的设计方式，它完美的统一了数据存储和运行。&lt;/p&gt;
&lt;h3 id=&quot;JAVA垃圾收集器&quot;&gt;&lt;a href=&quot;#JAVA垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;JAVA垃圾收集器&quot;&gt;&lt;/a&gt;JAVA垃圾收集器&lt;/h3&gt;&lt;h4 id=&quot;常见的垃圾收集策略&quot;&gt;&lt;a href=&quot;#常见的垃圾收集策略&quot; class=&quot;headerlink&quot; title=&quot;常见的垃圾收集策略&quot;&gt;&lt;/a&gt;常见的垃圾收集策略&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/jvm/jvm-gc-tactics-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面得不可到达主要是指应用程序已经没有内存块的引用了，而在JAVA中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。&lt;/p&gt;
&lt;h5 id=&quot;Reference-Counting-引用计数）&quot;&gt;&lt;a href=&quot;#Reference-Counting-引用计数）&quot; class=&quot;headerlink&quot; title=&quot;Reference Counting(引用计数）&quot;&gt;&lt;/a&gt;Reference Counting(引用计数）&lt;/h5&gt;&lt;p&gt;  引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优点：&lt;/code&gt;&lt;br&gt;简单，直接，不需要暂停整个应用&lt;br&gt;&lt;code&gt;缺点：&lt;/code&gt;&lt;br&gt;1.需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作，比如每次将对象赋值给新的引用，或者者对象的引用超出了作用域等。&lt;br&gt;2.不能处理循环引用的问题&lt;/p&gt;
&lt;h5 id=&quot;跟踪收集器&quot;&gt;&lt;a href=&quot;#跟踪收集器&quot; class=&quot;headerlink&quot; title=&quot;跟踪收集器&quot;&gt;&lt;/a&gt;跟踪收集器&lt;/h5&gt;&lt;p&gt;跟踪收集器首先要暂停整个应用程序，然后开始从根对象扫描整个堆，判断扫描的对象是否有对象引用，这里面有三个问题需要搞清楚：&lt;br&gt;&lt;img src=&quot;/images/jvm/jvm-gc-tactics-3.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;1．如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了分代收集，在新生代收集的时候minor gc只需要扫描新生代，而不需要扫描老生代。&lt;/p&gt;
&lt;p&gt;2．JVM采用了分代收集以后，minor gc只扫描新生代，但是minor gc怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，卡片标记将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆。具体如下图：&lt;br&gt;3．GC在收集一个对象的时候会判断是否有引用指向对象，在JAVA中的引用主要有四种：Strong reference,Soft reference,Weak reference,Phantom reference.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Strong Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testStrongReference&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Object referent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Object strongReference = referent;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      referent = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.gc();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      assertNotNull(strongReference);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Soft Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Public &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testSoftReference&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String  str =  &lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      SoftReference&amp;lt;String&amp;gt; softreference = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SoftReference&amp;lt;String&amp;gt;(str);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      str=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.gc();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      assertNotNull(softreference.get());  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Weak reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Public &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testWeakReference&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String  str =  &lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      WeakReference&amp;lt;String&amp;gt; weakReference = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WeakReference&amp;lt;String&amp;gt;(str);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      str=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.gc();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      assertNull(weakReference.get());  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Phantom reference&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;Mark-Sweep-Collector-标记-清除收集器）&quot;&gt;&lt;a href=&quot;#Mark-Sweep-Collector-标记-清除收集器）&quot; class=&quot;headerlink&quot; title=&quot;Mark-Sweep Collector(标记-清除收集器）&quot;&gt;&lt;/a&gt;Mark-Sweep Collector(标记-清除收集器）&lt;/h6&gt;&lt;p&gt;标记清除收集器最早由Lisp的发明人于1960年提出，标记清除收集器停止所有的工作，从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;优点：&lt;/code&gt;&lt;br&gt;1.解决循环引用的问题&lt;br&gt;2.不需要编译器的配合，从而就不执行额外的指令&lt;br&gt;&lt;code&gt;缺点：&lt;/code&gt;&lt;br&gt;1.每个活跃的对象都要进行扫描，收集暂停的时间比较长。&lt;/p&gt;
&lt;h6 id=&quot;Copying-Collector-复制收集器）&quot;&gt;&lt;a href=&quot;#Copying-Collector-复制收集器）&quot; class=&quot;headerlink&quot; title=&quot;Copying Collector(复制收集器）&quot;&gt;&lt;/a&gt;Copying Collector(复制收集器）&lt;/h6&gt;&lt;p&gt;复制收集器将内存分为两块一样大小空间，某一个时刻，只有一个空间处于活跃的状态，当活跃的空间满的时候，GC就会将活跃的对象复制到未使用的空间中去，原来不活跃的空间就变为了活跃的空间。复制收集器具体过程可以参考下图：&lt;br&gt;&lt;img src=&quot;/images/jvm/jvm-gc-tactics-4.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;code&gt;优点：&lt;/code&gt;&lt;br&gt;1.只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间&lt;br&gt;&lt;code&gt;缺点：&lt;/code&gt;&lt;br&gt;1.需要额外的空间消耗，某一个时刻，总是有一块内存处于未使用状态&lt;br&gt;2.复制对象需要一定的开销&lt;/p&gt;
&lt;h6 id=&quot;Mark-Compact-Collector-标记-整理收集器）&quot;&gt;&lt;a href=&quot;#Mark-Compact-Collector-标记-整理收集器）&quot; class=&quot;headerlink&quot; title=&quot;Mark-Compact Collector(标记-整理收集器）&quot;&gt;&lt;/a&gt;Mark-Compact Collector(标记-整理收集器）&lt;/h6&gt;&lt;p&gt;标记整理收集器汲取了标记清除和复制收集器的优点，它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的的对象复制到堆得底部。标记整理收集器的过程示意图请参考下图：Mark-compact策略极大的减少了内存碎片，并且不需要像Copy Collector一样需要两倍的空间。&lt;br&gt;&lt;img src=&quot;/images/jvm/jvm-gc-tactics-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;JVM的垃圾收集策略&quot;&gt;&lt;a href=&quot;#JVM的垃圾收集策略&quot; class=&quot;headerlink&quot; title=&quot;JVM的垃圾收集策略&quot;&gt;&lt;/a&gt;JVM的垃圾收集策略&lt;/h4&gt;&lt;p&gt;GC的执行时要耗费一定的CPU资源和时间的，因此在JDK1.2以后，JVM引入了分代收集的策略，其中对新生代采用&lt;code&gt;&amp;quot;Copying Collector&amp;quot;&lt;/code&gt;策略，而对老生代采用了&lt;code&gt;“Mark-Compact&amp;quot;&lt;/code&gt;的策略。其中新生代的垃圾收集器命名为&lt;code&gt;“minor gc”&lt;/code&gt;，老生代的GC命名为&lt;code&gt;&amp;quot;Full Gc&lt;/code&gt; 或者&lt;code&gt;Major GC&amp;quot;&lt;/code&gt;.其中用&lt;code&gt;System.gc()&lt;/code&gt;强制执行的是&lt;code&gt;Full Gc&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&quot;新生代垃圾收集&quot;&gt;&lt;a href=&quot;#新生代垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;新生代垃圾收集&quot;&gt;&lt;/a&gt;新生代垃圾收集&lt;/h5&gt;&lt;p&gt;在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。&lt;/p&gt;
&lt;p&gt;通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。&lt;/p&gt;
&lt;p&gt;但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。&lt;/p&gt;
&lt;h5 id=&quot;什么是分配担保？&quot;&gt;&lt;a href=&quot;#什么是分配担保？&quot; class=&quot;headerlink&quot; title=&quot;什么是分配担保？&quot;&gt;&lt;/a&gt;什么是分配担保？&lt;/h5&gt;&lt;p&gt;当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发MinorGC，对该区域的废弃对象进行回收。但如果MinorGC过后只有少量对象被回收，仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。&lt;/p&gt;
&lt;h5 id=&quot;老年代垃圾收集&quot;&gt;&lt;a href=&quot;#老年代垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;老年代垃圾收集&quot;&gt;&lt;/a&gt;老年代垃圾收集&lt;/h5&gt;&lt;p&gt;老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。&lt;/p&gt;
&lt;h5 id=&quot;方法区垃圾收集&quot;&gt;&lt;a href=&quot;#方法区垃圾收集&quot; class=&quot;headerlink&quot; title=&quot;方法区垃圾收集&quot;&gt;&lt;/a&gt;方法区垃圾收集&lt;/h5&gt;&lt;p&gt;很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。&lt;/p&gt;
&lt;p&gt;永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。&lt;/p&gt;
&lt;p&gt;判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：&lt;/p&gt;
&lt;p&gt;该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。&lt;/p&gt;
&lt;p&gt;加载该类的ClassLoader已经被回收。&lt;/p&gt;
&lt;p&gt;该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&lt;/p&gt;
&lt;p&gt;虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了&lt;code&gt;-Xnoclassgc&lt;/code&gt;参数进行控制，还可以使用&lt;code&gt;-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading&lt;/code&gt;查看类的加载和卸载信息。&lt;/p&gt;
&lt;p&gt;在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;external&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/&quot; target=&quot;_blank&quot;&gt;知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议&lt;/a&gt;进行许可,转载请在正文明显处注明原文地址。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h3&gt;&lt;p&gt;Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。
    
    </summary>
    
      <category term="JVM" scheme="http://blog.vino.ren/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://blog.vino.ren/tags/JVM/"/>
    
      <category term="GC" scheme="http://blog.vino.ren/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java内存模型（一）——基础</title>
    <link href="http://blog.vino.ren/2016/05/19/java-memory-model-basis/"/>
    <id>http://blog.vino.ren/2016/05/19/java-memory-model-basis/</id>
    <published>2016-05-19T00:17:16.000Z</published>
    <updated>2016-05-19T05:34:52.381Z</updated>
    
    <content type="html">&lt;h3 id=&quot;并发编程模型的分类&quot;&gt;&lt;a href=&quot;#并发编程模型的分类&quot; class=&quot;headerlink&quot; title=&quot;并发编程模型的分类&quot;&gt;&lt;/a&gt;并发编程模型的分类&lt;/h3&gt;&lt;p&gt;在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。&lt;/p&gt;
&lt;p&gt;在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。&lt;/p&gt;
&lt;p&gt;同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。&lt;/p&gt;
&lt;p&gt;Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。&lt;/p&gt;
&lt;h3 id=&quot;Java内存模型的抽象&quot;&gt;&lt;a href=&quot;#Java内存模型的抽象&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型的抽象&quot;&gt;&lt;/a&gt;Java内存模型的抽象&lt;/h3&gt;&lt;p&gt;在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。&lt;/p&gt;
&lt;p&gt;Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：&lt;br&gt;&lt;img src=&quot;/images/jmm/jmm-0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。&lt;/li&gt;
&lt;li&gt;然后，线程B到主内存中去读取线程A之前已更新过的共享变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面通过示意图来说明这两个步骤：&lt;br&gt;&lt;img src=&quot;/images/jmm/jmm-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。&lt;/p&gt;
&lt;p&gt;从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。&lt;/p&gt;
&lt;h3 id=&quot;重排序&quot;&gt;&lt;a href=&quot;#重排序&quot; class=&quot;headerlink&quot; title=&quot;重排序&quot;&gt;&lt;/a&gt;重排序&lt;/h3&gt;&lt;p&gt;在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
&lt;li&gt;指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
&lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：&lt;br&gt;&lt;img src=&quot;/images/jmm/jmm-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。&lt;/p&gt;
&lt;p&gt;JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。&lt;/p&gt;
&lt;h3 id=&quot;处理器重排序与内存屏障指令&quot;&gt;&lt;a href=&quot;#处理器重排序与内存屏障指令&quot; class=&quot;headerlink&quot; title=&quot;处理器重排序与内存屏障指令&quot;&gt;&lt;/a&gt;处理器重排序与内存屏障指令&lt;/h3&gt;&lt;p&gt;现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Process A&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Process B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;a = 1; //A1 &lt;br&gt; x = b; //A2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;b = 2; //B1 &lt;br&gt; y = a; //B2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;初始状态：a = b = 0 &lt;br&gt; 处理器允许执行后得到结果：x = y = 0&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;(合并行)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：&lt;br&gt;&lt;img src=&quot;/images/jmm/jmm-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。&lt;/p&gt;
&lt;p&gt;从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&amp;gt;A2，但内存操作实际发生的顺序却是：A2-&amp;gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。&lt;/p&gt;
&lt;p&gt;这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操做重排序。&lt;/p&gt;
&lt;p&gt;下面是常见处理器允许的重排序类型的列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;th&gt;Load-Load&lt;/th&gt;
&lt;th&gt;Load-Store&lt;/th&gt;
&lt;th&gt;Store-Store&lt;/th&gt;
&lt;th&gt;Store-Load&lt;/th&gt;
&lt;th&gt;数据依赖&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;sparc-TSO&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;X86&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;ia64&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;PowerPC&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。&lt;/p&gt;
&lt;p&gt;从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注2：上表中的x86包括x64及AMD64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注4：数据依赖性后文会专门说明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;屏障类型&lt;/th&gt;
&lt;th&gt;指令示例&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;LoadLoad Barriers&lt;/td&gt;
&lt;td&gt;Load1; LoadLoad; Load2&lt;/td&gt;
&lt;td&gt;确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;StoreStore Barriers&lt;/td&gt;
&lt;td&gt;Store1; StoreStore; Store2&lt;/td&gt;
&lt;td&gt;确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;LoadStore Barriers&lt;/td&gt;
&lt;td&gt;Load1; LoadStore; Store2&lt;/td&gt;
&lt;td&gt;确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;StoreLoad Barriers&lt;/td&gt;
&lt;td&gt;Store1; StoreLoad; Load2&lt;/td&gt;
&lt;td&gt;确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。&lt;/p&gt;
&lt;h3 id=&quot;happens-before&quot;&gt;&lt;a href=&quot;#happens-before&quot; class=&quot;headerlink&quot; title=&quot;happens-before&quot;&gt;&lt;/a&gt;happens-before&lt;/h3&gt;&lt;p&gt;从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的happens-before规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。&lt;/li&gt;
&lt;li&gt;监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。&lt;/li&gt;
&lt;li&gt;volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。&lt;/li&gt;
&lt;li&gt;传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。&lt;/p&gt;
&lt;p&gt;happens-before与JMM的关系如下图所示：&lt;br&gt;&lt;img src=&quot;/images/jmm/jmm-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如上图所示，一个happens-before规则通常对应于多个编译器重排序规则和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;并发编程模型的分类&quot;&gt;&lt;a href=&quot;#并发编程模型的分类&quot; class=&quot;headerlink&quot; title=&quot;并发编程模型的分类&quot;&gt;&lt;/a&gt;并发编程模型的分类&lt;/h3&gt;&lt;p&gt;在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线
    
    </summary>
    
      <category term="JMM" scheme="http://blog.vino.ren/categories/JMM/"/>
    
    
      <category term="JMM" scheme="http://blog.vino.ren/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入解析String#intern</title>
    <link href="http://blog.vino.ren/2016/05/18/java-intern-in-depth-analysis/"/>
    <id>http://blog.vino.ren/2016/05/18/java-intern-in-depth-analysis/</id>
    <published>2016-05-18T05:24:51.000Z</published>
    <updated>2016-05-18T08:07:26.101Z</updated>
    
    <content type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。&lt;/p&gt;
&lt;p&gt;8种基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接使用双引号声明出来的String对象会直接存储在常量池中。&lt;/li&gt;
&lt;li&gt;如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们主要来谈一下String#intern方法。&lt;/p&gt;
&lt;h3 id=&quot;intern-的实现原理&quot;&gt;&lt;a href=&quot;#intern-的实现原理&quot; class=&quot;headerlink&quot; title=&quot;intern 的实现原理&quot;&gt;&lt;/a&gt;intern 的实现原理&lt;/h3&gt;&lt;p&gt;首先深入看一下它的实现原理。&lt;/p&gt;
&lt;h4 id=&quot;java代码&quot;&gt;&lt;a href=&quot;#java代码&quot; class=&quot;headerlink&quot; title=&quot;java代码&quot;&gt;&lt;/a&gt;java代码&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Returns a canonical representation for the string object.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * A pool of strings, initially empty, is maintained privately by the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * class &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * When the intern method is invoked, if the pool already contains a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * string equal to this &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; object as determined by&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * the &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; #equals(Object)&amp;#125; method, then the string from the pool is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * returned. Otherwise, this &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; object is added to the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * pool and a reference to this &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; object is returned.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * It follows that for any two strings &amp;lt;code&amp;gt;s&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;t&amp;lt;/code&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;code&amp;gt;s.intern()&amp;amp;nbsp;==&amp;amp;nbsp;t.intern()&amp;lt;/code&amp;gt; is &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * if and only if &amp;lt;code&amp;gt;s.equals(t)&amp;lt;/code&amp;gt; is &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * All literal strings and string-valued constant expressions are&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * interned. String literals are defined in section 3.10.5 of the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;lt;cite&amp;gt;The Java&amp;amp;trade; Language Specification&amp;lt;/cite&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;  a string that has the same contents as this string, but is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *          guaranteed to be from a pool of unique strings.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;intern&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;String#intern方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。&lt;/p&gt;
&lt;h4 id=&quot;native代码&quot;&gt;&lt;a href=&quot;#native代码&quot; class=&quot;headerlink&quot; title=&quot;native代码&quot;&gt;&lt;/a&gt;native代码&lt;/h4&gt;&lt;p&gt;在 jdk7后，oracle 接管了 JAVA 的源码后就不对外开放了，根据 jdk 的主要开发人员声明 openJdk7 和 jdk7 使用的是同一分主代码，只是分支代码会有些许的变动。所以可以直接跟踪 openJdk7 的源码来探究 intern 的实现。&lt;/p&gt;
&lt;h5 id=&quot;native实现代码&quot;&gt;&lt;a href=&quot;#native实现代码&quot; class=&quot;headerlink&quot; title=&quot;native实现代码:&quot;&gt;&lt;/a&gt;native实现代码:&lt;/h5&gt;&lt;p&gt;&lt;code&gt;\openjdk7\jdk\src\share\native\java\lang\String.c&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Java_java_lang_String_intern(JNIEnv *env, jobject &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; JVM_InternString(env, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\openjdk7\hotspot\src\share\vm\prims\jvm.h&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* java.lang.String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;JNIEXPORT jstring JNICALL  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;JVM_InternString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(JNIEnv *env, jstring str)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\openjdk7\hotspot\src\share\vm\prims\jvm.cpp&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// String support ///////////////////////////////////////////////////////////////////////////  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  JVMWrapper(&lt;span class=&quot;string&quot;&gt;&quot;JVM_InternString&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  JvmtiVMObjectAllocEventCollector oam;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (str == NULL) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; NULL;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  oop string = JNIHandles::resolve_non_null(str);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  oop result = StringTable::intern(string, CHECK_NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (jstring) JNIHandles::make_local(env, result);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JVM_END&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;oop StringTable::intern(Handle string_or_null, jchar* name,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len, TRAPS) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  unsigned &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hashValue = java_lang_String::hash_string(name, len);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index = the_table()-&amp;gt;hash_to_index(hashValue);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  oop string = the_table()-&amp;gt;lookup(index, name, len, hashValue);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Found  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (string != NULL) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; string;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Otherwise, add to symbol to table  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; the_table()-&amp;gt;basic_add(index, string_or_null, name, len,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                hashValue, CHECK_NULL);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;oop StringTable::lookup(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index, jchar* name,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len, unsigned &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (HashtableEntry&amp;lt;oop&amp;gt;* l = bucket(index); l != NULL; l = l-&amp;gt;next()) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l-&amp;gt;hash() == hash) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (java_lang_String::equals(l-&amp;gt;literal(), name, len)) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; l-&amp;gt;literal();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; NULL;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;它的大体实现结构就是:&lt;br&gt;JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容。默认大小是1009。&lt;/p&gt;
&lt;p&gt;要注意的是，String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。&lt;/p&gt;
&lt;p&gt;在 jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:StringTableSize=99991&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;jdk6-和-jdk7-下-intern-的区别&quot;&gt;&lt;a href=&quot;#jdk6-和-jdk7-下-intern-的区别&quot; class=&quot;headerlink&quot; title=&quot;jdk6 和 jdk7 下 intern 的区别&quot;&gt;&lt;/a&gt;jdk6 和 jdk7 下 intern 的区别&lt;/h3&gt;&lt;p&gt;相信很多 JAVA 程序员都做做类似 &lt;code&gt;String s = new String(&amp;quot;abc&amp;quot;)&lt;/code&gt;这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。&lt;/p&gt;
&lt;p&gt;来看一段代码：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.intern();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s2 = &lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(s == s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;) + &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s3.intern();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s4 = &lt;span class=&quot;string&quot;&gt;&quot;11&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(s3 == s4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;打印结果是&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jdk6 下false false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jdk7 下false true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;具体为什么稍后再解释，然后将&lt;code&gt;s3.intern();&lt;/code&gt;语句下调一行，放到&lt;code&gt;String s4 = &amp;quot;11&amp;quot;;&lt;/code&gt;后面。将&lt;code&gt;s.intern();&lt;/code&gt;放到&lt;code&gt;String s2 = &amp;quot;1&amp;quot;;&lt;/code&gt;后面。是什么结果呢&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s2 = &lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.intern();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(s == s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;) + &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String s4 = &lt;span class=&quot;string&quot;&gt;&quot;11&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s3.intern();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(s3 == s4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jdk6 下false false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jdk7 下false false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;jdk6中的解释&quot;&gt;&lt;a href=&quot;#jdk6中的解释&quot; class=&quot;headerlink&quot; title=&quot;jdk6中的解释&quot;&gt;&lt;/a&gt;jdk6中的解释&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/java/java-intern-in-depth-analysis-0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;code&gt;注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern方法也是没有任何关系的。&lt;/p&gt;
&lt;h4 id=&quot;jdk7中的解释&quot;&gt;&lt;a href=&quot;#jdk7中的解释&quot; class=&quot;headerlink&quot; title=&quot;jdk7中的解释&quot;&gt;&lt;/a&gt;jdk7中的解释&lt;/h4&gt;&lt;p&gt;再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生&lt;code&gt;java.lang.OutOfMemoryError: PermGen space&lt;/code&gt;错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。&lt;/p&gt;
&lt;p&gt;正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。&lt;br&gt;&lt;img src=&quot;/images/java/java-intern-in-depth-analysis-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在第一段代码中，先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”);，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的new String(“1”)我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。&lt;/li&gt;
&lt;li&gt;接下来s3.intern();这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。&lt;/li&gt;
&lt;li&gt;最后String s4 = “11”; 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 s3 == s4 是 true。&lt;/li&gt;
&lt;li&gt;再看 s 和 s2 对象。 String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。&lt;/li&gt;
&lt;li&gt;接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。&lt;br&gt;&lt;img src=&quot;/images/java/java-intern-in-depth-analysis-2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern(); 的顺序是放在String s4 = “11”;后了。这样，首先执行String s4 = “11”;声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern();时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二段代码中的 s 和 s2 代码中，s.intern();，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(“1”);的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的。&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h4&gt;&lt;p&gt;从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将String常量池 从 Perm 区移动到了 Java Heap区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String#intern&lt;/code&gt; 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。&lt;h3 id=&quot;使用intern&quot;&gt;&lt;a href=&quot;#使用intern&quot; class=&quot;headerlink&quot; title=&quot;使用intern&quot;&gt;&lt;/a&gt;使用intern&lt;/h3&gt;&lt;h4 id=&quot;intern-正确使用例子&quot;&gt;&lt;a href=&quot;#intern-正确使用例子&quot; class=&quot;headerlink&quot; title=&quot;intern 正确使用例子&quot;&gt;&lt;/a&gt;intern 正确使用例子&lt;/h4&gt;接下来我们来看一下一个比较常见的使用String#intern方法的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; MAX = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String[] arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[MAX];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Integer[] DB_DATA = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; DB_DATA.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DB_DATA[i] = random.nextInt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; t = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; MAX; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         arr[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println((System.currentTimeMillis() - t) + &lt;span class=&quot;string&quot;&gt;&quot;ms&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行的参数是：-Xmx2g -Xms2g -Xmn1500M 上述代码是一个演示代码，其中有两条语句不一样，一条是使用 intern，一条是未使用 intern。结果如下图&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2160ms&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/images/java/java-intern-in-depth-analysis-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;code&gt;826ms&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;/images/java/java-intern-in-depth-analysis-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;通过上述结果，我们发现不使用 intern 的代码生成了1000w 个字符串，占用了大约640m 空间。 使用了 intern 的代码生成了1345个字符串，占用总空间 133k 左右。其实通过观察程序中只是用到了10个字符串，所以准确计算后应该是正好相差100w 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。&lt;/p&gt;
&lt;p&gt;细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 new String 后，然后又进行 intern 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 intern 占用空间导致 jvm 垃圾回收的时间是要远远大于这点时间的。 毕竟这里使用了1000w次intern 才多出来1秒钟多的时间。&lt;/p&gt;
&lt;h4 id=&quot;intern-不当使用&quot;&gt;&lt;a href=&quot;#intern-不当使用&quot; class=&quot;headerlink&quot; title=&quot;intern 不当使用&quot;&gt;&lt;/a&gt;intern 不当使用&lt;/h4&gt;&lt;p&gt;看过了 intern 的使用和 intern 的原理等，我们来看一个不当使用 intern 操作导致的问题。&lt;/p&gt;
&lt;p&gt;在使用 fastjson 进行接口读取的时候，我们发现在读取了近70w条数据后，我们的日志打印变的非常缓慢，每打印一次日志用时30ms左右，如果在一个请求中打印2到3条日志以上会发现请求有一倍以上的耗时。在重新启动 jvm 后问题消失。继续读取接口后，问题又重现。接下来我们看一下出现问题的过程。&lt;/p&gt;
&lt;h5 id=&quot;根据-log4j-打印日志查找问题原因&quot;&gt;&lt;a href=&quot;#根据-log4j-打印日志查找问题原因&quot; class=&quot;headerlink&quot; title=&quot;根据 log4j 打印日志查找问题原因&quot;&gt;&lt;/a&gt;根据 log4j 打印日志查找问题原因&lt;/h5&gt;&lt;p&gt;在使用&lt;code&gt;log4j#info&lt;/code&gt;打印日志的时候时间非常长。所以使用 housemd 软件跟踪 info 方法的耗时堆栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trace SLF4JLogger.&lt;/li&gt;
&lt;li&gt;trace AbstractLoggerWrapper:&lt;/li&gt;
&lt;li&gt;trace AsyncLogger&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org/apache/logging/log4j/core/async/AsyncLogger.actualAsyncLog(RingBufferLogEvent)                sun.misc.Launcher$AppClassLoader@&lt;span class=&quot;number&quot;&gt;109&lt;/span&gt;aca82            &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;            &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;ms    org.apache.logging.log4j.core.async.AsyncLogger@&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;de86bb  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org/apache/logging/log4j/core/async/AsyncLogger.location(String)                                  sun.misc.Launcher$AppClassLoader@&lt;span class=&quot;number&quot;&gt;109&lt;/span&gt;aca82            &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;           &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;ms    org.apache.logging.log4j.core.async.AsyncLogger@&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;de86bb  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org/apache/logging/log4j/core/async/AsyncLogger.log(Marker, String, Level, Message, Throwable)    sun.misc.Launcher$AppClassLoader@&lt;span class=&quot;number&quot;&gt;109&lt;/span&gt;aca82            &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;           &lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;ms    org.apache.logging.log4j.core.async.AsyncLogger@&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;de86bb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码出在 &lt;code&gt;AsyncLogger.location&lt;/code&gt; 这个方法上. 里边主要是调用了 &lt;code&gt;return Log4jLogEvent.calcLocation(fqcnOfLogger);&lt;/code&gt;和&lt;code&gt;Log4jLogEvent.calcLocation()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Log4jLogEvent.calcLocation()&lt;/code&gt;的代码如下:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; StackTraceElement &lt;span class=&quot;title&quot;&gt;calcLocation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String fqcnOfLogger)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fqcnOfLogger == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; next = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; StackTraceElement element : stackTrace) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String className = element.getClassName();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fqcnOfLogger.equals(className)) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; element;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fqcnOfLogger.equals(className)) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            next = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (NOT_AVAIL.equals(className)) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;经过跟踪发现是 &lt;code&gt;Thread.currentThread().getStackTrace();&lt;/code&gt; 的问题。&lt;/p&gt;
&lt;h5 id=&quot;跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern&quot;&gt;&lt;a href=&quot;#跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern&quot; class=&quot;headerlink&quot; title=&quot;跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern&quot;&gt;&lt;/a&gt;跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Thread.currentThread().getStackTrace();native&lt;/code&gt;的方法:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; StackTraceElement[] getStackTrace() &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; != Thread.currentThread()) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// check for getStackTrace permission  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SecurityManager security = System.getSecurityManager();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (security != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            security.checkPermission(  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                SecurityConstants.GET_STACK_TRACE_PERMISSION);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// optimization so we do not call into the vm for threads that  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// have not yet started or have terminated  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isAlive()) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; EMPTY_STACK_TRACE;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;        StackTraceElement[][] stackTraceArray = dumpThreads(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread[] &amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;&amp;#125;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        StackTraceElement[] stackTrace = stackTraceArray[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// a thread that was alive during the previous isAlive call may have  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// since terminated, therefore not having a stacktrace.  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stackTrace == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stackTrace = EMPTY_STACK_TRACE;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; stackTrace;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Don&#39;t need JVM help for current thread  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Exception()).getStackTrace();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; StackTraceElement[][] dumpThreads(Thread[] threads);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下载 openJdk7的源码查询 jdk 的 native 实现代码，列表如下【这里因为篇幅问题，不详细罗列涉及到的代码，有兴趣的可以根据文件名称和行号查找相关代码】：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;\openjdk7\jdk\src\share\native\java\lang\Thread.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\openjdk7\hotspot\src\share\vm\prims\jvm.h line:294:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\openjdk7\hotspot\src\share\vm\prims\jvm.cpp line:4382-4414:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:235-267:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:566-577:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\openjdk7\hotspot\src\share\vm\classfile\javaClasses.cpp line:1635-[1651,1654,1658]:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完成跟踪了底层的 jvm 源码后发现，是下边的三条代码引发了整个程序的变慢问题。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;oop classname = StringTable::intern((&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*) str, CHECK_0);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;oop methodname = StringTable::intern(method-&amp;gt;name(), CHECK_0);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;oop filename = StringTable::intern(source, CHECK_0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这三段代码是获取类名、方法名、和文件名。因为类名、方法名、文件名都是存储在字符串常量池中的，所以每次获取它们都是通过String#intern方法。但没有考虑到的是默认的 StringPool 的长度是1009且不可变的。因此一旦常量池中的字符串达到的一定的规模后，性能会急剧下降。&lt;/p&gt;
&lt;h5 id=&quot;fastjson-不当使用-String-intern&quot;&gt;&lt;a href=&quot;#fastjson-不当使用-String-intern&quot; class=&quot;headerlink&quot; title=&quot;fastjson 不当使用 String#intern&quot;&gt;&lt;/a&gt;fastjson 不当使用 String#intern&lt;/h5&gt;&lt;p&gt;导致这个 intern 变慢的原因是因为 fastjson 对String#intern方法的使用不当造成的。跟踪 fastjson 中的实现代码发现，&lt;br&gt;&lt;code&gt;com.alibaba.fastjson.parser.JSONScanner#scanFieldSymbol()&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ch == &lt;span class=&quot;string&quot;&gt;&#39;\&quot;&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bp = index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ch = ch = buf[bp];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    strVal = symbolTable.addSymbol(buf, start, index - start - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, hash);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;com.alibaba.fastjson.parser.SymbolTable#addSymbol():&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Constructs a new entry from the specified symbol information and next entry reference.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Entry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] ch, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash, Entry next)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    characters = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.arraycopy(ch, offset, characters, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    symbol = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(characters).intern();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.hashCode = hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytes = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;fastjson 中对所有的 json 的 key 使用了 intern 方法，缓存到了字符串常量池中，这样每次读取的时候就会非常快，大大减少时间和空间。而且 json 的 key 通常都是不变的。这个地方没有考虑到大量的 json key 如果是变化的，那就会给字符串常量池带来很大的负担。&lt;/p&gt;
&lt;p&gt;这个问题 fastjson 在1.1.24版本中已经将这个漏洞修复了。程序加入了一个最大的缓存大小，超过这个大小后就不会再往字符串常量池中放了。&lt;/p&gt;
&lt;p&gt;[1.1.24版本的com.alibaba.fastjson.parser.SymbolTable#addSymbol() Line:113]代码&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; MAX_SIZE           = &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (size &amp;gt;= MAX_SIZE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(buffer, offset, len);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个问题是70w 数据量时候的引发的，如果是几百万的数据量的话可能就不只是30ms 的问题了。因此在使用系统级提供的String#intern方式一定要慎重！&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;本文大体的描述了 String#intern和字符串常量池的日常使用，jdk 版本的变化和String#intern方法的区别，以及不恰当使用导致的危险等内容，让大家对系统级别的 String#intern有一个比较深入的认识。让我们在使用和接触它的时候能避免出现一些 bug，增强系统的健壮性。&lt;/p&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;以下是几个比较关键的几篇博文。感谢！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Save Memory by Using String Intern in Java&lt;/li&gt;
&lt;li&gt;Java String array: is there a size of method?&lt;/li&gt;
&lt;li&gt;Understanding String Table Size in HotSpot&lt;/li&gt;
&lt;li&gt;How is Java’s String#intern() method implemented?&lt;/li&gt;
&lt;li&gt;JDK7里的String.intern的变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://tech.meituan.com/in_depth_understanding_string_intern.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.meituan.com/in_depth_understanding_string_intern.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的
    
    </summary>
    
      <category term="java" scheme="http://blog.vino.ren/categories/java/"/>
    
    
      <category term="java" scheme="http://blog.vino.ren/tags/java/"/>
    
      <category term="string" scheme="http://blog.vino.ren/tags/string/"/>
    
      <category term="intern" scheme="http://blog.vino.ren/tags/intern/"/>
    
  </entry>
  
  <entry>
    <title>java参数传递（值传递还是引用传递）</title>
    <link href="http://blog.vino.ren/2016/05/18/java-parameters-transfer/"/>
    <id>http://blog.vino.ren/2016/05/18/java-parameters-transfer/</id>
    <published>2016-05-18T02:36:52.000Z</published>
    <updated>2016-05-18T03:00:03.609Z</updated>
    
    <content type="html">&lt;p&gt;Java中的参数传递机制一直以来大家都争论不休，究竟是“传值”还是“传址（传引用）”，争论的双方各执一词，互不相让。不但“菜鸟”们一头雾水，一些“老鸟”也只知道结果却说不出所以然来。我相信看过下面的内容后，你就会明白一些。&lt;/p&gt;
&lt;p&gt;先看基本类型作为参数传递的例子：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Before change, n = &quot;&lt;/span&gt; + n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    changeData(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;After changeData(n), n = &quot;&lt;/span&gt; + n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nn)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   n = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我想这个例子大家都明白，基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的，输出的结果证明了这一点：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before change, n = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After changeData(n), n = 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么，我们现在来看看对象作为参数传递的例子，这也是大家争论的地方。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test2&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          StringBuffer sb = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;string&quot;&gt;&quot;Hello &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Before change, sb = &quot;&lt;/span&gt; + sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          changeData(sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;After changeData(n), sb = &quot;&lt;/span&gt; + sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                                                                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StringBuffer strBuf)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          strBuf.append(&lt;span class=&quot;string&quot;&gt;&quot;World!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先看输出结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before change, sb = Hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After changeData(n), sb = Hello World!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从结果来看，sb的值被改变了，那么是不是可以说：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。从上面例子的输出结果来看，这样解释是合理。&lt;/p&gt;
&lt;p&gt;现在我们对上面的例子稍加改动一下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test3&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          StringBuffer sb = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;string&quot;&gt;&quot;Hello &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Before change, sb = &quot;&lt;/span&gt; + sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          changeData(sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;After changeData(n), sb = &quot;&lt;/span&gt; + sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                                                                                                                                                                                                                     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StringBuffer strBuf)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           strBuf = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;string&quot;&gt;&quot;Hi &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           strBuf.append(&lt;span class=&quot;string&quot;&gt;&quot;World!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;按照上面例子的经验：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。你会认为应该输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before change, sb = Hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After changeData(n), sb = Hi World!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但运行一下这个程序，你会发现结果是这样的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Before change, sb = Hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After changeData(n), sb = Hello&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这就是让人迷惑的地方，对象作为参数传递时，同样是在方法内改变了对象的值，为什么有的是改变了原对象的值，而有的并没有改变原对象的值呢？这时候究竟是“传值”还是“传引用”呢？&lt;/p&gt;
&lt;p&gt;下面就让我们仔细分析一下，来揭开这中间的奥秘吧。&lt;/p&gt;
&lt;p&gt;先看Test2这个程序：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StringBuffer sb = new StringBuffer(&amp;quot;Hello &amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这一句执行完后，就会在内存的堆里生成一个sb对象，请看图1：&lt;br&gt;&lt;img src=&quot;/images/java/java-parameter-transfer-0.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;如图1所示，sb是一个引用，里面存放的是一个地址“@3a”（这个“@3a”是我举的代表内存地址的例子，你只需知道是个内存地址就行了），而这个地址正是“Hello ”这个字符串在内存中的地址。&lt;br&gt;&lt;code&gt;changeData(sb);&lt;/code&gt;&lt;br&gt;执行这一句后，就把&lt;code&gt;sb&lt;/code&gt;传给了&lt;code&gt;changeData&lt;/code&gt;方法中的&lt;code&gt;StringBuffer strBuf&lt;/code&gt;，由于&lt;code&gt;sb&lt;/code&gt;中存放的是地址，所以，&lt;code&gt;strBuf&lt;/code&gt;中也将存放相同的地址，请看图2：&lt;br&gt;&lt;img src=&quot;/images/java/java-parameter-transfer-1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;此时，&lt;code&gt;sb&lt;/code&gt;和&lt;code&gt;strBuf&lt;/code&gt;中由于存放的内存地址相同，因此都指向了“Hello”。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strBuf.append(&amp;quot;World!&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;changeData&lt;/code&gt;方法中的这一句后，改变了&lt;code&gt;strBuf&lt;/code&gt;指向的内存中的值，如下图3所示：&lt;br&gt;&lt;img src=&quot;/images/java/java-parameter-transfer-2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以，Test2 这个程序最后会输出：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;After changeData(n), sb = Hello World!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再看看Test3这个程序。&lt;/p&gt;
&lt;p&gt;在没有执行到&lt;code&gt;changeData&lt;/code&gt;方法的&lt;code&gt;strBuf = new StringBuffer(“Hi “);&lt;/code&gt;之前，对象在内存中的图和上例中“图2”是一样的，而执行了&lt;code&gt;strBuf = new StringBuffer(“Hi “);&lt;/code&gt;之后，则变成了：&lt;br&gt;&lt;img src=&quot;/images/java/java-parameter-transfer-3.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;此时，&lt;code&gt;strBuf&lt;/code&gt;中存放的不再是指向“Hello”的地址，而是指向“Hi ”的地址“@3b” （同样“@3b”是个例子）了，&lt;code&gt;new&lt;/code&gt;操作符操作成功后总会在内存中新开辟一块存储区域。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strBuf.append(&amp;quot;World!&amp;quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而执行完这句后，&lt;br&gt;&lt;img src=&quot;/images/java/java-parameter-transfer-4.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;通过上图可以看到，由于sb和strBuf中存放地址不一样了，所以虽然strBuf指向的内存中的值改变了，但sb指向的内存中值并不会变，因此也就输出了下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;After changeData(n), sb = Hello&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因此，你只要按上面的方法去分析，就会发现String对象和基本类型一样，一般情况下作为参数传递，在方法内改变了值，而原对象是不会被改变的。&lt;/p&gt;
&lt;p&gt;综上所述，我们就会明白，在Java中对象作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。&lt;/p&gt;
&lt;p&gt;你可以试着按上面的画图法分析一下下面例子的结果，看看运行结果与你分析的结果是否一样：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test4&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      StringBuffer sb = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;string&quot;&gt;&quot;Hello &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Before change, sb = &quot;&lt;/span&gt; + sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      changeData(sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;After changeData(n), sb = &quot;&lt;/span&gt; + sb);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;changeData&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StringBuffer strBuf)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      StringBuffer sb2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuffer(&lt;span class=&quot;string&quot;&gt;&quot;Hi &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      strBuf = sb2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      sb2.append(&lt;span class=&quot;string&quot;&gt;&quot;World!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;执行完&lt;code&gt;strBuf = sb2；&lt;/code&gt;后：&lt;br&gt;&lt;img src=&quot;/images/java/java-parameter-transfer-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的参数传递机制一直以来大家都争论不休，究竟是“传值”还是“传址（传引用）”，争论的双方各执一词，互不相让。不但“菜鸟”们一头雾水，一些“老鸟”也只知道结果却说不出所以然来。我相信看过下面的内容后，你就会明白一些。&lt;/p&gt;
&lt;p&gt;先看基本类型作为参数传递的例子：&lt;b
    
    </summary>
    
      <category term="java" scheme="http://blog.vino.ren/categories/java/"/>
    
    
      <category term="java" scheme="http://blog.vino.ren/tags/java/"/>
    
      <category term="参数传递" scheme="http://blog.vino.ren/tags/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>java类静态域、块，非静态域、块，构造函数的初始化顺序</title>
    <link href="http://blog.vino.ren/2016/05/18/java-init-order/"/>
    <id>http://blog.vino.ren/2016/05/18/java-init-order/</id>
    <published>2016-05-18T02:21:11.000Z</published>
    <updated>2016-05-18T02:30:41.061Z</updated>
    
    <content type="html">&lt;h4 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h4&gt;&lt;p&gt;面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，&lt;/p&gt;
&lt;p&gt;构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的&lt;br&gt;结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解。&lt;br&gt;我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序以此是&lt;br&gt;（静态变量、静态初始化块）&amp;gt;（变量、初始化块）&amp;gt;构造器。&lt;br&gt;我们也可以通过下面的测试代码来验证这一点：&lt;br&gt;Java代码:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InitialOrderTest&lt;/span&gt; &lt;/span&gt;&amp;#123;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String staticField = &lt;span class=&quot;string&quot;&gt;&quot;静态变量&quot;&lt;/span&gt;;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String field = &lt;span class=&quot;string&quot;&gt;&quot;变量&quot;&lt;/span&gt;;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态初始化块        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(staticField);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;静态初始化块&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化块              &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(field);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;初始化块&quot;&lt;/span&gt;);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造器          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InitialOrderTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;构造器&quot;&lt;/span&gt;);     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InitialOrderTest();              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行以上代码，我们会得到如下的输出结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;静态变量  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;静态初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;变量  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;构造器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这与上文中说的完全符合。&lt;br&gt;那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果：&lt;br&gt;Java代码 :&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; &lt;/span&gt;&amp;#123;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String p_StaticField = &lt;span class=&quot;string&quot;&gt;&quot;父类--静态变量&quot;&lt;/span&gt;;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String p_Field = &lt;span class=&quot;string&quot;&gt;&quot;父类--变量&quot;&lt;/span&gt;;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态初始化块              &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(p_StaticField);                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;父类--静态初始化块&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化块              &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(p_Field);          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;父类--初始化块&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造器          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;父类--构造器&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubClass&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; &lt;/span&gt;&amp;#123;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String s_StaticField = &lt;span class=&quot;string&quot;&gt;&quot;子类--静态变量&quot;&lt;/span&gt;;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String s_Field = &lt;span class=&quot;string&quot;&gt;&quot;子类--变量&quot;&lt;/span&gt;;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态初始化块              &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s_StaticField);                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;子类--静态初始化块&quot;&lt;/span&gt;);          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化块   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s_Field);          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;子类--初始化块&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 构造器          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;子类--构造器&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 程序入口          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubClass();             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行一下上面的代码，结果马上呈现在我们的眼前：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;父类--静态变量  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;父类--静态初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子类--静态变量  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子类--静态初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;父类--变量  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;父类--初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;父类--构造器  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子类--变量  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子类--初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;子类--构造器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，&lt;br&gt;实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。&lt;br&gt;那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？&lt;br&gt;是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。&lt;br&gt;我们以静态变量和静态初始化块为例来进行说明。 同样，我们还是写一个类来进行测试：    &lt;/p&gt;
&lt;p&gt;Java代码:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestOrder&lt;/span&gt; &lt;/span&gt;&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; TestA a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestA();                       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态初始化块              &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;静态初始化块&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;                       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 静态变量          &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; TestB b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestB();                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestOrder();              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestA&lt;/span&gt; &lt;/span&gt;&amp;#123;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestA&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Test--A&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestB&lt;/span&gt; &lt;/span&gt;&amp;#123;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Test--B&quot;&lt;/span&gt;);              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行上面的代码，会得到如下的结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Test--A  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;静态初始化块  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Test--B&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;大家可以随意改变变量a、变量b以及静态初始化块的前后位置，就会发现输出结果随着它们在类中出现的前后顺序而改变，&lt;br&gt;这就说明静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。&lt;br&gt;了解了继承情况下类的初始化顺序之后，如何判断最终输出结果就迎刃而解了。  &lt;/p&gt;
&lt;p&gt;测试函数：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestStaticCon&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;父类的静态代码块在执行a=&quot;&lt;/span&gt; + a);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;父类的非静态代码块在执行a=&quot;&lt;/span&gt; + a);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestStaticCon&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;a在父类带参构造方法中的值：&quot;&lt;/span&gt; + TestStaticCon.a); &lt;span class=&quot;comment&quot;&gt;// 调用另外一个构造方法    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(a);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;父类无参构造方法在执行a=&quot;&lt;/span&gt; + a);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestStaticCon&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String n)&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(n);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(a);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TestStaticCon tsc = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;!!!!!!!!!!!!!!!!!!!!!&quot;&lt;/span&gt;);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tsc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestStaticCon();   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;父类的非静态代码块在执行a=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;!!!!!!!!!!!!!!!!!!!!!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;父类的非静态代码块在执行a=8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a在父类带参构造方法中的值：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;父类无参构造方法在执行a=8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h4&gt;&lt;p&gt;静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。且执行顺序为静态代码块——非静态代码块—-构造函数。&lt;br&gt;扩展：静态代码块  与  静态方法：&lt;br&gt;一般情况下,如果有些代码必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的;&lt;br&gt;需要在项目启动的时候就初始化,在不创建对象的情况下,其他程序来调用的时候,需要使用静态方法,这种代码是被动执行的.&lt;br&gt;两者的区别就是:静态代码块是自动执行的;  静态方法是被调用的时候才执行的.  &lt;/p&gt;
&lt;p&gt;作用:静态代码块可用来初始化一些项目最常用的变量或对象;静态方法可用作不创建对象也可能需要执行的代码&lt;/p&gt;
&lt;h4 id=&quot;阿里笔试题&quot;&gt;&lt;a href=&quot;#阿里笔试题&quot; class=&quot;headerlink&quot; title=&quot;阿里笔试题&quot;&gt;&lt;/a&gt;阿里笔试题&lt;/h4&gt;&lt;p&gt;求下面这段代码的输出：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test1&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Test1 t1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Test1(&lt;span class=&quot;string&quot;&gt;&quot;t1&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Test1 t2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Test1(&lt;span class=&quot;string&quot;&gt;&quot;t2&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = print(&lt;span class=&quot;string&quot;&gt;&quot;i&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = print(&lt;span class=&quot;string&quot;&gt;&quot;j&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;构造块&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;静态块&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String str)&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println((++k)+&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;+str+&lt;span class=&quot;string&quot;&gt;&quot;    i=&quot;&lt;/span&gt;+i+&lt;span class=&quot;string&quot;&gt;&quot;    n=&quot;&lt;/span&gt;+n);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ++i;++n;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String str)&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println((++k)+&lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;+str+&lt;span class=&quot;string&quot;&gt;&quot;    i=&quot;&lt;/span&gt;+i+&lt;span class=&quot;string&quot;&gt;&quot;    n=&quot;&lt;/span&gt;+n);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ++n;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ++i;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// TODO Auto-generated method stub  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Test1 t = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Test1(&lt;span class=&quot;string&quot;&gt;&quot;init&quot;&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;j    i=0    n=0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;构造块    i=1    n=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t1    i=2    n=2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;j    i=3    n=3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;构造块    i=4    n=4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t2    i=5    n=5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i    i=6    n=6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;静态块    i=7    n=99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;j    i=8    n=100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;构造块    i=9    n=101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;init    i=10    n=102&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://ini.iteye.com/blog/2007835&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ini.iteye.com/blog/2007835&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h4&gt;&lt;p&gt;面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，&lt;/p&gt;
&lt;p&gt;构造器里可能还有
    
    </summary>
    
      <category term="java" scheme="http://blog.vino.ren/categories/java/"/>
    
    
      <category term="java" scheme="http://blog.vino.ren/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 虚拟内存和物理内存的理解</title>
    <link href="http://blog.vino.ren/2016/05/17/linux-vm-rm/"/>
    <id>http://blog.vino.ren/2016/05/17/linux-vm-rm/</id>
    <published>2016-05-17T13:59:06.000Z</published>
    <updated>2016-05-18T02:11:17.372Z</updated>
    
    <content type="html">&lt;h3 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h3&gt;&lt;h4 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。&lt;/li&gt;
&lt;li&gt;一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录。&lt;/li&gt;
&lt;li&gt;每个进程已经分配的内存空间，都与对应的磁盘空间映射。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-0.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;二&quot;&gt;&lt;a href=&quot;#二&quot; class=&quot;headerlink&quot; title=&quot;二&quot;&gt;&lt;/a&gt;二&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。&lt;/li&gt;
&lt;li&gt;所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。&lt;/li&gt;
&lt;li&gt;进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录。&lt;/li&gt;
&lt;li&gt;页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。&lt;/li&gt;
&lt;li&gt;当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常。&lt;/li&gt;
&lt;li&gt;缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-1.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处&lt;/li&gt;
&lt;li&gt;当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存&lt;/li&gt;
&lt;li&gt;在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如&lt;code&gt;.text&lt;/code&gt; &lt;code&gt;.data&lt;/code&gt;段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如&lt;code&gt;malloc&lt;/code&gt;时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。&lt;/p&gt;
&lt;h4 id=&quot;补充理解&quot;&gt;&lt;a href=&quot;#补充理解&quot; class=&quot;headerlink&quot; title=&quot;补充理解&quot;&gt;&lt;/a&gt;补充理解&lt;/h4&gt;&lt;p&gt;虚拟存储器涉及三个概念： 虚拟存储空间，磁盘空间，内存空间&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以认为虚拟空间都被映射到了磁盘空间中，（事实上也是按需要映射到磁盘空间上，通过mmap），并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mmap&lt;/code&gt;是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过&lt;code&gt;manmap&lt;/code&gt;可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这也是一种读写磁盘文件的方法，也是一种进程共享数据的方法 共享内存&lt;/p&gt;
&lt;h3 id=&quot;物理内存&quot;&gt;&lt;a href=&quot;#物理内存&quot; class=&quot;headerlink&quot; title=&quot;物理内存&quot;&gt;&lt;/a&gt;物理内存&lt;/h3&gt;&lt;p&gt;在内核态申请内存比在用户态申请内存要更为直接，它没有采用用户态那种延迟分配内存技术。内核认为一旦有内核函数申请内存，那么就必须立刻满足该申请内存的请求，并且这个请求一定是正确合理的。相反，对于用户态申请内存的请求，内核总是尽量延后分配物理内存，用户进程总是先获得一个虚拟内存区的使用权，最终通过缺页异常获得一块真正的物理内存。&lt;/p&gt;
&lt;h4 id=&quot;物理内存的内核映射&quot;&gt;&lt;a href=&quot;#物理内存的内核映射&quot; class=&quot;headerlink&quot; title=&quot;物理内存的内核映射&quot;&gt;&lt;/a&gt;物理内存的内核映射&lt;/h4&gt;&lt;p&gt;IA32架构中内核虚拟地址空间只有1GB大小（从3GB到4GB），因此可以直接将1GB大小的物理内存（即常规内存）映射到内核地址空间，但超出1GB大小的物理内存（即高端内存）就不能映射到内核空间。为此，内核采取了下面的方法使得内核可以使用所有的物理内存。&lt;/p&gt;
&lt;p&gt;1). 高端内存不能全部映射到内核空间，也就是说这些物理内存没有对应的线性地址。不过，内核为每个物理页框都分配了对应的页框描述符，所有的页框描述符都保存在mem_map数组中，因此每个页框描述符的线性地址都是固定存在的。内核此时可以使用alloc_pages()和alloc_page()来分配高端内存，因为这些函数返回页框描述符的线性地址。&lt;/p&gt;
&lt;p&gt;2). 内核地址空间的后128MB专门用于映射高端内存，否则，没有线性地址的高端内存不能被内核所访问。这些高端内存的内核映射显然是暂时映射的，否则也只能映射128MB的高端内存。当内核需要访问高端内存时就临时在这个区域进行地址映射，使用完毕之后再用来进行其他高端内存的映射。&lt;/p&gt;
&lt;p&gt;由于要进行高端内存的内核映射，因此直接能够映射的物理内存大小只有896MB，该值保存在high_memory中。内核地址空间的线性地址区间如下图所示：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从图中可以看出，内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。&lt;/p&gt;
&lt;h4 id=&quot;物理内存管理机制&quot;&gt;&lt;a href=&quot;#物理内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;物理内存管理机制&quot;&gt;&lt;/a&gt;物理内存管理机制&lt;/h4&gt;&lt;p&gt;基于物理内存在内核空间中的映射原理，物理内存的管理方式也有所不同。内核中物理内存的管理机制主要有伙伴算法，slab高速缓存和vmalloc机制。其中伙伴算法和slab高速缓存都在物理内存映射区分配物理内存，而vmalloc机制则在高端内存映射区分配物理内存。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;伙伴算法&lt;/code&gt;&lt;br&gt;伙伴算法负责大块连续物理内存的分配和释放，以页框为基本单位。该机制可以避免外部碎片。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;per-CPU页框高速缓存&lt;/code&gt;&lt;br&gt;内核经常请求和释放单个页框，该缓存包含预先分配的页框，用于满足本地CPU发出的单一页框请求。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slab缓存&lt;/code&gt;&lt;br&gt;slab缓存负责小块物理内存的分配，并且它也作为高速缓存，主要针对内核中经常分配并释放的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vmalloc机制&lt;/code&gt;&lt;br&gt;vmalloc机制使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大限度的使用高端物理内存。&lt;/p&gt;
&lt;h4 id=&quot;物理内存的分配&quot;&gt;&lt;a href=&quot;#物理内存的分配&quot; class=&quot;headerlink&quot; title=&quot;物理内存的分配&quot;&gt;&lt;/a&gt;物理内存的分配&lt;/h4&gt;&lt;p&gt;内核发出内存申请的请求时，根据内核函数调用接口将启用不同的内存分配器。&lt;/p&gt;
&lt;h5 id=&quot;分区页框分配器&quot;&gt;&lt;a href=&quot;#分区页框分配器&quot; class=&quot;headerlink&quot; title=&quot;分区页框分配器&quot;&gt;&lt;/a&gt;分区页框分配器&lt;/h5&gt;&lt;p&gt;分区页框分配器 (zoned page frame allocator) ,处理对连续页框的内存分配请求。分区页框管理器分为两大部分:前端的管理区分配器和伙伴系统，如下图：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;管理区分配器负责搜索一个能满足请求页框块大小的管理区。在每个管理区中,具体的页框分配工作由伙伴系统负责。为了达到更好的系统性能,单个页框的申请工作直接通过per-CPU页框高速缓存完成。&lt;/p&gt;
&lt;p&gt;该分配器通过几个函数和宏来请求页框,它们之间的封装关系如下图所示。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这些函数和宏将核心的分配函数&lt;code&gt;__alloc_pages_nodemask()&lt;/code&gt;封装,形成满足不同分配需求的分配函数。其中，&lt;code&gt;alloc_pages()&lt;/code&gt;系列函数返回物理内存首页框描述符，&lt;code&gt;__get_free_pages()&lt;/code&gt;系列函数返回内存的线性地址。&lt;/p&gt;
&lt;h5 id=&quot;slab分配器&quot;&gt;&lt;a href=&quot;#slab分配器&quot; class=&quot;headerlink&quot; title=&quot;slab分配器&quot;&gt;&lt;/a&gt;slab分配器&lt;/h5&gt;&lt;p&gt;slab 分配器最初是为了解决物理内存的内部碎片而提出的，它将内核中常用的数据结构看做对象。slab分配器为每一种对象建立高速缓存。内核对该对象的分配和释放均是在这块高速缓存中操作。一种对象的slab分配器结构图如下：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-vm-rm-6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以看到每种对象的高速缓存是由若干个slab组成，每个slab是由若干个页框组成的。虽然slab分配器可以分配比单个页框更小的内存块，但它所需的所有内存都是通过&lt;code&gt;伙伴算法&lt;/code&gt;分配的。&lt;/p&gt;
&lt;p&gt;slab高速缓存分专用缓存和通用缓存。专用缓存是对特定的对象，比如为内存描述符创建高速缓存。通用缓存则是针对一般情况，适合分配任意大小的物理内存，其接口即为&lt;code&gt;kmalloc()&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;非连续内存区的分配&quot;&gt;&lt;a href=&quot;#非连续内存区的分配&quot; class=&quot;headerlink&quot; title=&quot;非连续内存区的分配&quot;&gt;&lt;/a&gt;非连续内存区的分配&lt;/h5&gt;&lt;p&gt;内核通过&lt;code&gt;vmalloc()&lt;/code&gt;来申请非连续的物理内存，若申请成功，该函数返回连续内存区的起始地址，否则，返回&lt;code&gt;NULL&lt;/code&gt;。&lt;code&gt;vmalloc()&lt;/code&gt;和&lt;code&gt;kmalloc()&lt;/code&gt;申请的内存有所不同，&lt;code&gt;kmalloc()&lt;/code&gt;所申请内存的线性地址与物理地址都是连续的，而&lt;code&gt;vmalloc()&lt;/code&gt;所申请的内存线性地址连续而物理地址则是离散的，两个地址之间通过内核页表进行映射。 &lt;code&gt;vmalloc()&lt;/code&gt;的工作方式理解起来很简单：&lt;br&gt;1). 寻找一个新的连续线性地址空间；&lt;br&gt;2). 依次分配一组非连续的页框；&lt;br&gt;3). 为线性地址空间和非连续页框建立映射关系，即修改内核页表；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vmalloc()&lt;/code&gt;的内存分配原理与用户态的内存分配相似，都是通过连续的虚拟内存来访问离散的物理内存，并且虚拟地址和物理地址之间是通过页表进行连接的，通过这种方式可以有效的使用物理内存。但是应该注意的是，&lt;code&gt;vmalloc()&lt;/code&gt;申请物理内存时是立即分配的，因为内核认为这种内存分配请求是正当而且紧急的；相反，用户态有内存请求时，内核总是尽可能的延后，毕竟用户态跟内核态不在一个特权级。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h3&gt;&lt;h4 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h4&gt;&lt;o
    
    </summary>
    
      <category term="Linux" scheme="http://blog.vino.ren/categories/Linux/"/>
    
    
      <category term="理解计算机" scheme="http://blog.vino.ren/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://blog.vino.ren/tags/Linux/"/>
    
      <category term="内存" scheme="http://blog.vino.ren/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》学习整理--cpu加载数据（初阶）</title>
    <link href="http://blog.vino.ren/2016/05/17/computer-system-roaming/"/>
    <id>http://blog.vino.ren/2016/05/17/computer-system-roaming/</id>
    <published>2016-05-17T09:58:53.000Z</published>
    <updated>2016-05-17T11:55:11.036Z</updated>
    
    <content type="html">&lt;p&gt;断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。&lt;/p&gt;
&lt;h4 id=&quot;从一条汇编指令开始&quot;&gt;&lt;a href=&quot;#从一条汇编指令开始&quot; class=&quot;headerlink&quot; title=&quot;从一条汇编指令开始&quot;&gt;&lt;/a&gt;从一条汇编指令开始&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;movl (%ebp) %edx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;%ebp&lt;/code&gt; 和 &lt;code&gt;%edx&lt;/code&gt;这两个都是寄存器文件，处于CPU中，如图&lt;br&gt;&lt;img src=&quot;/images/computer-system/computer-system-all.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;每个cpu中都有着有限数量的寄存器在，一个IA32的处理器中包含一组8个存储32位值得寄存器。&lt;br&gt;一般每个寄存器都会存放特定的数据，例如&lt;code&gt;%esp&lt;/code&gt;是用来存放栈指针的，&lt;code&gt;%ebp&lt;/code&gt;是用来存放帧指针的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;movl A B&lt;/code&gt;指令是将A的数据移动到B（覆盖B的数据），&lt;code&gt;(%ebp)&lt;/code&gt;中括号的作用是取得主存中地址为&lt;code&gt;%ebp&lt;/code&gt;的值的数据。也就是说先取得&lt;code&gt;%ebp&lt;/code&gt;的值，然后将该值作为一个地址，去内存中找到这个地址，获取数据，然后将这个数据赋给&lt;code&gt;%edx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在来看看这个过程具体是什么样的：&lt;/p&gt;
&lt;h4 id=&quot;获取虚拟地址&quot;&gt;&lt;a href=&quot;#获取虚拟地址&quot; class=&quot;headerlink&quot; title=&quot;获取虚拟地址&quot;&gt;&lt;/a&gt;获取虚拟地址&lt;/h4&gt;&lt;p&gt;在系统的运行着的每一个进程（程序），它们所接触的都是一个虚拟内存地址，假如系统内存为4G，那么每一个进程在运行时，它都会认为自己拥有着所有的4G内存。假如这些都是物理内存地址，那么每个进程在不经意间都可能会去修改其他进程的数据，造成数据丢失。所以我们从&lt;code&gt;%ebp&lt;/code&gt;中获取到了一个虚拟地址。&lt;/p&gt;
&lt;h4 id=&quot;翻译虚拟地址&quot;&gt;&lt;a href=&quot;#翻译虚拟地址&quot; class=&quot;headerlink&quot; title=&quot;翻译虚拟地址&quot;&gt;&lt;/a&gt;翻译虚拟地址&lt;/h4&gt;&lt;p&gt;获取到虚拟地址之后，需要将虚拟地址转换为物理地址。这时候用到了页表和TLB，这个时候如果页表命中，则将物理地址返回。如果不命中，将产生缺页异常，需要从磁盘中获取数据，并将数据加载到主存，然后将对应地址记录到页表中。接着翻译机制再从页表中获取物理地址。具体细节以后再整理。&lt;/p&gt;
&lt;h4 id=&quot;根据物理地址获取数据&quot;&gt;&lt;a href=&quot;#根据物理地址获取数据&quot; class=&quot;headerlink&quot; title=&quot;根据物理地址获取数据&quot;&gt;&lt;/a&gt;根据物理地址获取数据&lt;/h4&gt;&lt;p&gt;cache中存放着主存中的数据，如果缓存命中，则直接将缓存中的数据返回。如果不命中，则cache从主存中获取值，存放到本地（cache）。cpu再向cache发送一次请求，cache将数据发给cpu。&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h4&gt;&lt;p&gt;以上是一个很粗糙的cpu加载数据的流程，但是基本上几个核心都提到了，以后整理细节的时候就根据这个流程来了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。&lt;/p&gt;
&lt;h4 i
    
    </summary>
    
      <category term="理解计算机" scheme="http://blog.vino.ren/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理解计算机" scheme="http://blog.vino.ren/tags/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Linux" scheme="http://blog.vino.ren/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件描述符与打开文件之间的关系</title>
    <link href="http://blog.vino.ren/2016/05/17/linux-fd-file/"/>
    <id>http://blog.vino.ren/2016/05/17/linux-fd-file/</id>
    <published>2016-05-17T04:37:06.000Z</published>
    <updated>2016-05-17T05:00:25.894Z</updated>
    
    <content type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。&lt;code&gt;POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。&lt;/code&gt;标准文件描述符图如下：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-fd-file-0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;文件描述与打开的文件对应模型如下图：&lt;br&gt;&lt;img src=&quot;/images/linux/linux-fd-file-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;文件描述限制&quot;&gt;&lt;a href=&quot;#文件描述限制&quot; class=&quot;headerlink&quot; title=&quot;文件描述限制&quot;&gt;&lt;/a&gt;文件描述限制&lt;/h4&gt;&lt;p&gt;在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用&lt;code&gt;sysctl -a | grep fs.file-max&lt;/code&gt;命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用&lt;code&gt;ulimit -n&lt;/code&gt;命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看&lt;a href=&quot;http://blog.csdn.net/kumu_linux/article/details/7877770。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kumu_linux/article/details/7877770。&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;文件描述符合打开文件之间的关系&quot;&gt;&lt;a href=&quot;#文件描述符合打开文件之间的关系&quot; class=&quot;headerlink&quot; title=&quot;文件描述符合打开文件之间的关系&quot;&gt;&lt;/a&gt;文件描述符合打开文件之间的关系&lt;/h4&gt;&lt;p&gt;每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程级的文件描述符表&lt;/li&gt;
&lt;li&gt;系统级的打开文件描述符表&lt;/li&gt;
&lt;li&gt;文件系统的i-node表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程级的描述符表的每一条目记录了单个文件描述符的相关信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即&lt;code&gt;close-on-exec&lt;/code&gt;标志）&lt;/li&gt;
&lt;li&gt;对打开文件句柄的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示：&lt;br&gt;当前文件偏移量（调用&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()&lt;/code&gt;时更新，或使用&lt;code&gt;lseek()&lt;/code&gt;直接修改）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当前文件偏移量（调用`read()`和`write()`时更新，或使用`lseek()`直接修改）
2. 打开文件时所使用的状态标识（即，`open()`的flags参数）
3. 文件访问模式（如调用`open()`时所设置的只读模式、只写模式或读写模式）
4. 与信号驱动相关的设置
5. 对该文件i-node对象的引用
6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限
7. 一个指针，指向该文件所持有的锁列表
8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下图展示了文件描述符、打开的文件句柄以及i-node之间的关系，图中，两个进程拥有诸多打开的文件描述符。&lt;br&gt;&lt;img src=&quot;/images/linux/linux-fd-file-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用&lt;code&gt;dup()&lt;/code&gt;、&lt;code&gt;dup2()&lt;/code&gt;、&lt;code&gt;fcntl()&lt;/code&gt;或者对同一个文件多次调用了&lt;code&gt;open()&lt;/code&gt;函数而形成的。&lt;br&gt;   进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用&lt;code&gt;fork()&lt;/code&gt;后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。&lt;br&gt;   此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了&lt;code&gt;open()&lt;/code&gt;调用。同一个进程两次打开同一个文件，也会发生类似情况。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
3. 要获取和修改打开的文件标志（例如：`O_APPEND、O_NONBLOCK`和`O_ASYNC`），可执行`fcntl()`的`F_GETFL`和`F_SETFL`操作，其对作用域的约束与上一条颇为类似。
4. 文件描述符标志（即，`close-on-exec`）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.csdn.net/cywosp/article/details/38965239&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/cywosp/article/details/38965239&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;br&gt;[1] &lt;a href=&quot;http://blog.chinaunix.net/uid-20633888-id-2747146.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.chinaunix.net/uid-20633888-id-2747146.html&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;http://blog.csdn.net/kumu_linux/article/details/7877770&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kumu_linux/article/details/7877770&lt;/a&gt;&lt;br&gt;[4] 《Linux/UNIX系统编程手册》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是
    
    </summary>
    
      <category term="Linux" scheme="http://blog.vino.ren/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.vino.ren/tags/Linux/"/>
    
      <category term="文件描述符" scheme="http://blog.vino.ren/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>理解git分支-远程分支</title>
    <link href="http://blog.vino.ren/2016/05/16/git-branch-remote/"/>
    <id>http://blog.vino.ren/2016/05/16/git-branch-remote/</id>
    <published>2016-05-16T11:16:26.000Z</published>
    <updated>2016-05-16T11:47:52.156Z</updated>
    
    <content type="html">&lt;h3 id=&quot;远程分支&quot;&gt;&lt;a href=&quot;#远程分支&quot; class=&quot;headerlink&quot; title=&quot;远程分支&quot;&gt;&lt;/a&gt;远程分支&lt;/h3&gt;&lt;p&gt;远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。&lt;/p&gt;
&lt;p&gt;远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。&lt;/p&gt;
&lt;p&gt;它们以 (remote)/(branch) 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支；但是在服务器上的分支会指向 origin/iss53 的提交。&lt;/p&gt;
&lt;p&gt;这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。&lt;/p&gt;
&lt;h4 id=&quot;“origin”-并无特殊含义&quot;&gt;&lt;a href=&quot;#“origin”-并无特殊含义&quot; class=&quot;headerlink&quot; title=&quot;“origin” 并无特殊含义&quot;&gt;&lt;/a&gt;“origin” 并无特殊含义&lt;/h4&gt;&lt;p&gt;远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;克隆之后的服务器与本地仓库&quot;&gt;&lt;a href=&quot;#克隆之后的服务器与本地仓库&quot; class=&quot;headerlink&quot; title=&quot;克隆之后的服务器与本地仓库&quot;&gt;&lt;/a&gt;克隆之后的服务器与本地仓库&lt;/h4&gt;&lt;p&gt;如果你在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;本地与远程的工作可以分叉&quot;&gt;&lt;a href=&quot;#本地与远程的工作可以分叉&quot; class=&quot;headerlink&quot; title=&quot;本地与远程的工作可以分叉&quot;&gt;&lt;/a&gt;本地与远程的工作可以分叉&lt;/h4&gt;&lt;p&gt;如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动origin/master 指针指向新的、更新后的位置。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;git-fetch-更新你的远程仓库引用&quot;&gt;&lt;a href=&quot;#git-fetch-更新你的远程仓库引用&quot; class=&quot;headerlink&quot; title=&quot;git fetch 更新你的远程仓库引用&quot;&gt;&lt;/a&gt;git fetch 更新你的远程仓库引用&lt;/h4&gt;&lt;p&gt;为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为整个 URL 的缩写。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加另一个远程仓库&quot;&gt;&lt;a href=&quot;#添加另一个远程仓库&quot; class=&quot;headerlink&quot; title=&quot;添加另一个远程仓库&quot;&gt;&lt;/a&gt;添加另一个远程仓库&lt;/h4&gt;&lt;p&gt;现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支teamone/master 指向 teamone 的 master 分支。&lt;br&gt;&lt;img src=&quot;/images/git/remote-branches-5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;远程跟踪分支-teamone-master&quot;&gt;&lt;a href=&quot;#远程跟踪分支-teamone-master&quot; class=&quot;headerlink&quot; title=&quot;远程跟踪分支 teamone/master&quot;&gt;&lt;/a&gt;远程跟踪分支 teamone/master&lt;/h3&gt;&lt;h4 id=&quot;推送&quot;&gt;&lt;a href=&quot;#推送&quot; class=&quot;headerlink&quot; title=&quot;推送&quot;&gt;&lt;/a&gt;推送&lt;/h4&gt;&lt;p&gt;当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。&lt;/p&gt;
&lt;p&gt;如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch):&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Counting objects: 24, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Delta compression using up to 8 threads.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Compressing objects: 100% (15/15), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Total 24 (delta 2), reused 0 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To https://github.com/schacon/simplegit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      serverfix -&amp;gt; serverfix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分，但是现在可以先把它放在儿。 你也可以运行 git push origin serverfix:serverfix，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的awesomebranch 分支。&lt;/p&gt;
&lt;h5 id=&quot;如何避免每次输入密码&quot;&gt;&lt;a href=&quot;#如何避免每次输入密码&quot; class=&quot;headerlink&quot; title=&quot;如何避免每次输入密码&quot;&gt;&lt;/a&gt;如何避免每次输入密码&lt;/h5&gt;&lt;p&gt;如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。&lt;/p&gt;
&lt;p&gt;如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config –global credential.helper cache 来设置它。&lt;/p&gt;
&lt;p&gt;想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。&lt;/p&gt;
&lt;p&gt;下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Counting objects: 7, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Compressing objects: 100% (2/2), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Total 3 (delta 0), reused 3 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Unpacking objects: 100% (3/3), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;From https://github.com/schacon/simplegit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * [new branch]      serverfix    -&amp;gt; origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix指针。&lt;/p&gt;
&lt;p&gt;可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的serverfix 分支上工作，可以将其建立在远程跟踪分支之上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b serverfix origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch serverfix set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;serverfix&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。&lt;/p&gt;
&lt;h4 id=&quot;跟踪分支&quot;&gt;&lt;a href=&quot;#跟踪分支&quot; class=&quot;headerlink&quot; title=&quot;跟踪分支&quot;&gt;&lt;/a&gt;跟踪分支&lt;/h4&gt;&lt;p&gt;从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。&lt;/p&gt;
&lt;p&gt;当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout --track origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch serverfix set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;serverfix&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b sf origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch sf set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Switched to a new branch &amp;apos;sf&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在，本地分支 sf 会自动从 origin/serverfix 拉取。&lt;/p&gt;
&lt;p&gt;设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -u origin/serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Branch serverfix set up to track remote branch serverfix from origin.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;###　上游快捷方式&lt;br&gt;当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代git merge origin/master。&lt;/p&gt;
&lt;p&gt;如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -vv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  master    1ae2a45 [origin/master] deploying index fix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  testing   5ea463a trying something new&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 2 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。&lt;/p&gt;
&lt;p&gt;需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：$ git fetch –all; git branch -vv&lt;/p&gt;
&lt;h3 id=&quot;拉取&quot;&gt;&lt;a href=&quot;#拉取&quot; class=&quot;headerlink&quot; title=&quot;拉取&quot;&gt;&lt;/a&gt;拉取&lt;/h3&gt;&lt;p&gt;当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。&lt;/p&gt;
&lt;p&gt;由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。&lt;/p&gt;
&lt;h3 id=&quot;删除远程分支&quot;&gt;&lt;a href=&quot;#删除远程分支&quot; class=&quot;headerlink&quot; title=&quot;删除远程分支&quot;&gt;&lt;/a&gt;删除远程分支&lt;/h3&gt;&lt;p&gt;假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 –delete 选项的 git push命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin --delete serverfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To https://github.com/schacon/simplegit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - [deleted]         serverfix&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;远程分支&quot;&gt;&lt;a href=&quot;#远程分支&quot; class=&quot;headerlink&quot; title=&quot;远程分支&quot;&gt;&lt;/a&gt;远程分支&lt;/h3&gt;&lt;p&gt;远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获
    
    </summary>
    
      <category term="Git" scheme="http://blog.vino.ren/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.vino.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>理解git对象</title>
    <link href="http://blog.vino.ren/2016/05/16/git-object/"/>
    <id>http://blog.vino.ren/2016/05/16/git-object/</id>
    <published>2016-05-16T10:51:22.000Z</published>
    <updated>2016-05-16T11:06:16.765Z</updated>
    
    <content type="html">&lt;h5 id=&quot;首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot;&gt;&lt;a href=&quot;#首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot; class=&quot;headerlink&quot; title=&quot;首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：&quot;&gt;&lt;/a&gt;首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：&lt;/h5&gt;&lt;p&gt; &lt;img src=&quot;/images/git/git-object-0.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; 如图所示，生成了 3 个对象，一个 commit 对象，一个 tree 对象，一个 blob 对象。图上蓝底是 commit 对象，灰底的是 tree 对象，白底的是 blob 对象，每个对象节点的标题是对象的 key (SHA 摘要)缩略表示。&lt;br&gt; 对于 commit 对象，tree 内容表示这个 commit 对应根目录的 tree 对象，parent 表示父 commit 节点，通常commit 只有一个父节点，也可能没有（首次提交时 parent 为空），也可能有多个（合并节点），commit 对象还保存了 commit message 等信息。&lt;br&gt; 对于 tree 对象，里面的内容包含了文件名，文件对应的 blob 对象的 key，或者是目录名和目录对应 tree 对象的 key。&lt;br&gt; 对于 blob 对象，表示一个实际文件对象的内容，但不包括文件名，文件名是在 tree 对象里存的。&lt;/p&gt;
&lt;p&gt; 这个图怎么得到的呢？主要是两个命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 git log 命令获取最新 commit 的 key&lt;/li&gt;
&lt;li&gt;通过 git cat-file -p &lt;object key=&quot;&quot;&gt; 获取 key 对应 object 的内容，根据 object 里的内容，继续探索，就可以访问到所有关联 object&lt;/object&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;第-2-次提交，修改了-a-txt-文件：&quot;&gt;&lt;a href=&quot;#第-2-次提交，修改了-a-txt-文件：&quot; class=&quot;headerlink&quot; title=&quot;第 2 次提交，修改了 a.txt 文件：&quot;&gt;&lt;/a&gt;第 2 次提交，修改了 a.txt 文件：&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;因为 a.txt 文件已经修改，生成了一个新的 blob 对象，tree 对象和 commit 对象。如图所示，commit 对象之间是有关联的，新提交的 commit 对象的 parent 是上一次提交的 commit 对象。&lt;/p&gt;
&lt;h5 id=&quot;第-3-次提交，这次已稍微复杂一点，增加一个新文件-b-txt-，一个新目录-lib-，lib-里增加一个文件-c-txt&quot;&gt;&lt;a href=&quot;#第-3-次提交，这次已稍微复杂一点，增加一个新文件-b-txt-，一个新目录-lib-，lib-里增加一个文件-c-txt&quot; class=&quot;headerlink&quot; title=&quot;第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt&quot;&gt;&lt;/a&gt;第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如图所示，目录是有一个 tree 对象表示的，里面的内容指明了目录包含的文件或子目录。&lt;/p&gt;
&lt;h5 id=&quot;第-4-次提交，这次弄出一个新的分支-test1，并且在新分支中做了一次-commit&quot;&gt;&lt;a href=&quot;#第-4-次提交，这次弄出一个新的分支-test1，并且在新分支中做了一次-commit&quot; class=&quot;headerlink&quot; title=&quot;第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit&quot;&gt;&lt;/a&gt;第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;0c5ca 对应的 commit 对象就是生成的分支 test1 中的。分支在 Git 中是一个非常轻量化的操作，建立分支甚至都不增加新的对象。&lt;/p&gt;
&lt;h5 id=&quot;第-5-次提交，这次涉及到一个合并操作，图已经变得比较复杂了&quot;&gt;&lt;a href=&quot;#第-5-次提交，这次涉及到一个合并操作，图已经变得比较复杂了&quot; class=&quot;headerlink&quot; title=&quot;第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了&quot;&gt;&lt;/a&gt;第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/git/git-object-4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;def18 就是合并后的 commit 对象。合并生成了一个新的commit ，这个 commit 的 parent 有两个，指向合并的两个原分支对应的 commit 上。&lt;/p&gt;
&lt;p&gt;作者:vincent (谢文威)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot;&gt;&lt;a href=&quot;#首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：&quot; class=&quot;headerlink&quot; title=&quot;首次提交，提交一个简单的文件 a.txt
    
    </summary>
    
      <category term="Git" scheme="http://blog.vino.ren/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.vino.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git操作手册|命令速查表</title>
    <link href="http://blog.vino.ren/2016/05/16/git-operate-command/"/>
    <id>http://blog.vino.ren/2016/05/16/git-operate-command/</id>
    <published>2016-05-16T06:23:19.000Z</published>
    <updated>2016-05-16T10:50:15.781Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Git与SVN差异&quot;&gt;&lt;a href=&quot;#Git与SVN差异&quot; class=&quot;headerlink&quot; title=&quot;Git与SVN差异&quot;&gt;&lt;/a&gt;Git与SVN差异&lt;/h2&gt;&lt;p&gt;Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。&lt;/p&gt;
&lt;p&gt;Git 和 SVN 思想最大的差别有四个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去中心化&lt;/li&gt;
&lt;li&gt;直接记录快照，而非差异&lt;/li&gt;
&lt;li&gt;不一样的分支概念&lt;/li&gt;
&lt;li&gt;三个文件状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;去中心化&quot;&gt;&lt;a href=&quot;#去中心化&quot; class=&quot;headerlink&quot; title=&quot;去中心化&quot;&gt;&lt;/a&gt;去中心化&lt;/h3&gt;&lt;p&gt;Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/git/git.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。&lt;/p&gt;
&lt;h3 id=&quot;直接记录快照，而非差异&quot;&gt;&lt;a href=&quot;#直接记录快照，而非差异&quot; class=&quot;headerlink&quot; title=&quot;直接记录快照，而非差异&quot;&gt;&lt;/a&gt;直接记录快照，而非差异&lt;/h3&gt;&lt;p&gt;Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：&lt;/p&gt;
&lt;p&gt;SVN：&lt;br&gt;&lt;img src=&quot;/images/git/svn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Git:&lt;br&gt;&lt;img src=&quot;/images/git/git.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。&lt;/p&gt;
&lt;h3 id=&quot;不一样的分支概念异&quot;&gt;&lt;a href=&quot;#不一样的分支概念异&quot; class=&quot;headerlink&quot; title=&quot;不一样的分支概念异&quot;&gt;&lt;/a&gt;不一样的分支概念异&lt;/h3&gt;&lt;p&gt;Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。&lt;/p&gt;
&lt;h3 id=&quot;三个文件状态&quot;&gt;&lt;a href=&quot;#三个文件状态&quot; class=&quot;headerlink&quot; title=&quot;三个文件状态&quot;&gt;&lt;/a&gt;三个文件状态&lt;/h3&gt;&lt;p&gt;在Git中文件有三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已提交（committed）：该文件被安全地保存在了本地数据库&lt;/li&gt;
&lt;li&gt;已修改（modified）：修改了某个文件，但还没有保存&lt;/li&gt;
&lt;li&gt;已暂存（staged）：把已修改的文件放下下次保存的清单中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Git常用命令&quot;&gt;&lt;a href=&quot;#Git常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git常用命令&quot;&gt;&lt;/a&gt;Git常用命令&lt;/h2&gt;&lt;h3 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h3&gt;&lt;p&gt;复制一个已创建的仓库:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone ssh://user@domain.com/repo.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个新的本地仓库:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地修改&quot;&gt;&lt;a href=&quot;#本地修改&quot; class=&quot;headerlink&quot; title=&quot;本地修改&quot;&gt;&lt;/a&gt;本地修改&lt;/h3&gt;&lt;p&gt;显示工作路径下已修改的文件：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示与上次提交版本文件的不同：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git diff&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把当前所有修改添加到下次提交中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把对某个文件的修改添加到下次提交中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add -p &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提交本地的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提交之前已标记的变化：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;附加消息提交：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &amp;apos;message here&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提交，并将提交时间设置为之前的某个日期:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit --date=&amp;quot;`date --date=&amp;apos;n day ago&amp;apos;`&amp;quot; -am &amp;quot;Commit Message&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改上次提交&quot;&gt;&lt;a href=&quot;#修改上次提交&quot; class=&quot;headerlink&quot; title=&quot;修改上次提交&quot;&gt;&lt;/a&gt;修改上次提交&lt;/h3&gt;&lt;p&gt;请勿修改已发布的提交记录!&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit --amend&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;把当前分支中未提交的修改移动到其他分支&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git stash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout branch2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;搜索&quot;&gt;&lt;a href=&quot;#搜索&quot; class=&quot;headerlink&quot; title=&quot;搜索&quot;&gt;&lt;/a&gt;搜索&lt;/h3&gt;&lt;p&gt;从当前目录的所有文件中查找文本内容：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git grep &amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在某一版本中搜索文本：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git grep &amp;quot;Hello&amp;quot; v2.5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;提交历史&quot;&gt;&lt;a href=&quot;#提交历史&quot; class=&quot;headerlink&quot; title=&quot;提交历史&quot;&gt;&lt;/a&gt;提交历史&lt;/h3&gt;&lt;p&gt;从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示所有提交（仅显示提交的hash和message）：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --oneline&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示某个用户的所有提交：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --author=&amp;quot;username&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示某个文件的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log -p &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;谁，在什么时间，修改了文件的什么内容：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git blame &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;分支与标签&quot;&gt;&lt;a href=&quot;#分支与标签&quot; class=&quot;headerlink&quot; title=&quot;分支与标签&quot;&gt;&lt;/a&gt;分支与标签&lt;/h3&gt;&lt;p&gt;列出所有的分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;切换分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建并切换到新分支:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于当前分支创建新分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch &amp;lt;new-branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于远程分支创建新的可追溯的分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch --track &amp;lt;new-branch&amp;gt; &amp;lt;remote-branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除本地分支:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch -d &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;给当前版本打标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git tag &amp;lt;tag-name&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新与发布&quot;&gt;&lt;a href=&quot;#更新与发布&quot; class=&quot;headerlink&quot; title=&quot;更新与发布&quot;&gt;&lt;/a&gt;更新与发布&lt;/h3&gt;&lt;p&gt;列出当前配置的远程端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote -v&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示远程端的信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote show &amp;lt;remote&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加新的远程端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下载远程端版本，但不合并到HEAD中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git fetch &amp;lt;remote&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下载远程端版本，并自动与HEAD版本合并：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote pull &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将远程端版本合并到本地版本中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git pull origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将本地版本发布到远程端：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push remote &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除远程端分支：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push &amp;lt;remote&amp;gt; :&amp;lt;branch&amp;gt; (since Git v1.5.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push &amp;lt;remote&amp;gt; --delete &amp;lt;branch&amp;gt; (since Git v1.7.0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发布标签:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push --tags&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;合并与重置&quot;&gt;&lt;a href=&quot;#合并与重置&quot; class=&quot;headerlink&quot; title=&quot;合并与重置&quot;&gt;&lt;/a&gt;合并与重置&lt;/h3&gt;&lt;p&gt;将分支合并到当前HEAD中：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git merge &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将当前HEAD版本重置到分支中:&lt;br&gt;请勿重置已发布的提交!&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rebase &amp;lt;branch&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;退出重置:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rebase --abort&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决冲突后继续重置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rebase --continue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用配置好的merge tool 解决冲突：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git mergetool&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在编辑器中手动解决冲突后，标记文件为已解决冲突:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add &amp;lt;resolved-file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rm &amp;lt;resolved-file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;撤销&quot;&gt;&lt;a href=&quot;#撤销&quot; class=&quot;headerlink&quot; title=&quot;撤销&quot;&gt;&lt;/a&gt;撤销&lt;/h3&gt;&lt;p&gt;放弃工作目录下的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移除缓存区的所有文件（i.e. 撤销上次git add）:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;放弃某个文件的所有本地修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout HEAD &amp;lt;file&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;重置一个提交（通过创建一个截然不同的新提交）:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git revert &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将HEAD重置到上一次提交的版本，并保留未提交的本地修改：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset --keep &amp;lt;commit&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Git进阶指南&quot;&gt;&lt;a href=&quot;#Git进阶指南&quot; class=&quot;headerlink&quot; title=&quot;Git进阶指南&quot;&gt;&lt;/a&gt;Git进阶指南&lt;/h2&gt;&lt;h3 id=&quot;问：如何修改-origin-仓库信息？&quot;&gt;&lt;a href=&quot;#问：如何修改-origin-仓库信息？&quot; class=&quot;headerlink&quot; title=&quot;问：如何修改 origin 仓库信息？&quot;&gt;&lt;/a&gt;问：如何修改 origin 仓库信息？&lt;/h3&gt;&lt;h4 id=&quot;1、添加-origin-仓库信息&quot;&gt;&lt;a href=&quot;#1、添加-origin-仓库信息&quot; class=&quot;headerlink&quot; title=&quot;1、添加 origin 仓库信息&quot;&gt;&lt;/a&gt;1、添加 origin 仓库信息&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin &amp;lt;git仓库地址&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2、查看-origin-仓库信息&quot;&gt;&lt;a href=&quot;#2、查看-origin-仓库信息&quot; class=&quot;headerlink&quot; title=&quot;2、查看 origin 仓库信息&quot;&gt;&lt;/a&gt;2、查看 origin 仓库信息&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#以下三种方式均可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config get --remote.origin.url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote show origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;3、删除-origin-仓库信息&quot;&gt;&lt;a href=&quot;#3、删除-origin-仓库信息&quot; class=&quot;headerlink&quot; title=&quot;3、删除 origin 仓库信息&quot;&gt;&lt;/a&gt;3、删除 origin 仓库信息&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote rm origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;问：如何配置-git-ssh-keys-？&quot;&gt;&lt;a href=&quot;#问：如何配置-git-ssh-keys-？&quot; class=&quot;headerlink&quot; title=&quot;问：如何配置 git ssh keys ？&quot;&gt;&lt;/a&gt;问：如何配置 git ssh keys ？&lt;/h3&gt;&lt;p&gt;在本地生成 ssh 私钥 / 公钥 文件&lt;br&gt;将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台&lt;br&gt;测试 git ssh 连接是否成功&lt;br&gt;接下来以添加 github ssh keys 为例，请注意替换 github 文件名。&lt;/p&gt;
&lt;p&gt;注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#运行以下命令，一直回车，文件名可随意指定&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;kaiye@macbook&amp;quot; -f ~/.ssh/github&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-add -K ~/.ssh/github&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#将 pub 公钥的内容粘贴到线上网站的后台&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat ~/.ssh/github.pub&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#测试 git ssh 是否连接成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -T git@github.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问：如何撤销修改？&quot;&gt;&lt;a href=&quot;#问：如何撤销修改？&quot; class=&quot;headerlink&quot; title=&quot;问：如何撤销修改？&quot;&gt;&lt;/a&gt;问：如何撤销修改？&lt;/h3&gt;&lt;p&gt;修改包含四种情况，需单独区分。&lt;/p&gt;
&lt;h4 id=&quot;1、新建的文件和目录，且从未提交至版本库&quot;&gt;&lt;a href=&quot;#1、新建的文件和目录，且从未提交至版本库&quot; class=&quot;headerlink&quot; title=&quot;1、新建的文件和目录，且从未提交至版本库&quot;&gt;&lt;/a&gt;1、新建的文件和目录，且从未提交至版本库&lt;/h4&gt;&lt;p&gt;此类文件的状态为 Untracked files ，撤销方法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clean -fd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中,”.”表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。&lt;/p&gt;
&lt;h4 id=&quot;2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）&quot;&gt;&lt;a href=&quot;#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）&quot; class=&quot;headerlink&quot; title=&quot;2、提交过版本库，但未提交至暂存区的文件（未执行 git add）&quot;&gt;&lt;/a&gt;2、提交过版本库，但未提交至暂存区的文件（未执行 git add）&lt;/h4&gt;&lt;p&gt;此类文件的状态为&lt;code&gt;Changes not staged for commit&lt;/code&gt;，撤销方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;3、已提交至暂存区的文件&quot;&gt;&lt;a href=&quot;#3、已提交至暂存区的文件&quot; class=&quot;headerlink&quot; title=&quot;3、已提交至暂存区的文件&quot;&gt;&lt;/a&gt;3、已提交至暂存区的文件&lt;/h4&gt;&lt;p&gt;此类文件的状态为 Changes to be committed，撤销方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。&lt;/p&gt;
&lt;h4 id=&quot;4、已提交至版本库（执行了-git-commit）&quot;&gt;&lt;a href=&quot;#4、已提交至版本库（执行了-git-commit）&quot; class=&quot;headerlink&quot; title=&quot;4、已提交至版本库（执行了 git commit）&quot;&gt;&lt;/a&gt;4、已提交至版本库（执行了 git commit）&lt;/h4&gt;&lt;p&gt;每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reset &amp;lt;版本号&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果需要「回滚至上一次提交」，可直接使用以下命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reset head~1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。&lt;/p&gt;
&lt;h4 id=&quot;5、如果回滚了之后又不想回滚了怎么办？&quot;&gt;&lt;a href=&quot;#5、如果回滚了之后又不想回滚了怎么办？&quot; class=&quot;headerlink&quot; title=&quot;5、如果回滚了之后又不想回滚了怎么办？&quot;&gt;&lt;/a&gt;5、如果回滚了之后又不想回滚了怎么办？&lt;/h4&gt;&lt;p&gt;如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。&lt;/p&gt;
&lt;p&gt;如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &amp;lt;版本号&amp;gt; 。&lt;/p&gt;
&lt;h3 id=&quot;问：遇到冲突了怎么解决？&quot;&gt;&lt;a href=&quot;#问：遇到冲突了怎么解决？&quot; class=&quot;headerlink&quot; title=&quot;问：遇到冲突了怎么解决？&quot;&gt;&lt;/a&gt;问：遇到冲突了怎么解决？&lt;/h3&gt;&lt;p&gt;两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。&lt;/p&gt;
&lt;h4 id=&quot;1、最快的办法&quot;&gt;&lt;a href=&quot;#1、最快的办法&quot; class=&quot;headerlink&quot; title=&quot;1、最快的办法&quot;&gt;&lt;/a&gt;1、最快的办法&lt;/h4&gt;&lt;p&gt;大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 使用当前分支 HEAD 版本，通常是冲突源文件的 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 标记部分，======= 的上方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout --ours &amp;lt;文件名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; # 使用合并分支版本，通常是源冲突文件的 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 标记部分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; git checkout --theirs &amp;lt;文件名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 标记为解决状态加入暂存区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add &amp;lt;文件名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、最通用的办法&quot;&gt;&lt;a href=&quot;#2、最通用的办法&quot; class=&quot;headerlink&quot; title=&quot;2、最通用的办法&quot;&gt;&lt;/a&gt;2、最通用的办法&lt;/h4&gt;&lt;p&gt;用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。&lt;/p&gt;
&lt;p&gt;在 Mac 系统下，运行 git mergetool &amp;lt;文件名&amp;gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。&lt;/p&gt;
&lt;h4 id=&quot;3、最好的习惯&quot;&gt;&lt;a href=&quot;#3、最好的习惯&quot; class=&quot;headerlink&quot; title=&quot;3、最好的习惯&quot;&gt;&lt;/a&gt;3、最好的习惯&lt;/h4&gt;&lt;p&gt;有三个好的习惯，可以减少代码的冲突：&lt;br&gt;在开始修改代码前先 git pull 一下；&lt;br&gt;将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；&lt;br&gt;通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性&lt;/p&gt;
&lt;h4 id=&quot;4、最复杂的情况&quot;&gt;&lt;a href=&quot;#4、最复杂的情况&quot; class=&quot;headerlink&quot; title=&quot;4、最复杂的情况&quot;&gt;&lt;/a&gt;4、最复杂的情况&lt;/h4&gt;&lt;p&gt;如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。&lt;/p&gt;
&lt;p&gt;它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。&lt;/p&gt;
&lt;p&gt;rebase 大概的操作步骤如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 将当前分支的版本追加到从远程 pull 回来的节点之后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull --rebase&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 若发生冲突，则按以上其他方法进行解决，解决后继续&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --continue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 直到所有冲突得以解决，待项目最后上线前再执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rebase --skip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问：如何在不提交修改的前提下，执行-pull-merge-等操作？&quot;&gt;&lt;a href=&quot;#问：如何在不提交修改的前提下，执行-pull-merge-等操作？&quot; class=&quot;headerlink&quot; title=&quot;问：如何在不提交修改的前提下，执行 pull / merge 等操作？&quot;&gt;&lt;/a&gt;问：如何在不提交修改的前提下，执行 pull / merge 等操作？&lt;/h3&gt;&lt;p&gt;有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。&lt;/p&gt;
&lt;p&gt;这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。&lt;/p&gt;
&lt;p&gt;以下是 git stash 常用命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看 stash 队列中已暂存了多少 WIP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 恢复上一次的 WIP 状态，并从队列中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 恢复指定编号的 WIP，同时从队列中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop stash@&amp;#123;num&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 恢复指定编号的 WIP，但不从队列中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash apply stash@&amp;#123;num&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问：如何在-git-log-中查看修改的文件列表？&quot;&gt;&lt;a href=&quot;#问：如何在-git-log-中查看修改的文件列表？&quot; class=&quot;headerlink&quot; title=&quot;问：如何在 git log 中查看修改的文件列表？&quot;&gt;&lt;/a&gt;问：如何在 git log 中查看修改的文件列表？&lt;/h3&gt;&lt;p&gt;默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --name-status --oneline&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.ls &amp;apos;log --name-status --oneline --graph&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.st &amp;apos;status --porcelain&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更多 git log 参数，可通过 git help log 查看手册。&lt;/p&gt;
&lt;p&gt;如果是看上一次提交的版本日志，直接运行 git show 即可。&lt;/p&gt;
&lt;p&gt;此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。&lt;/p&gt;
&lt;h3 id=&quot;问：git-submodule-update-时出错怎么解决？&quot;&gt;&lt;a href=&quot;#问：git-submodule-update-时出错怎么解决？&quot; class=&quot;headerlink&quot; title=&quot;问：git submodule update 时出错怎么解决？&quot;&gt;&lt;/a&gt;问：git submodule update 时出错怎么解决？&lt;/h3&gt;&lt;p&gt;例如，在执行 git submodule update 时有以下错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5&lt;br&gt;Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。&lt;/p&gt;
&lt;p&gt;解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。&lt;/p&gt;
&lt;h3 id=&quot;其他问题&quot;&gt;&lt;a href=&quot;#其他问题&quot; class=&quot;headerlink&quot; title=&quot;其他问题&quot;&gt;&lt;/a&gt;其他问题&lt;/h3&gt;&lt;p&gt;设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin master -u&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config core.quotepath off&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;常用的打 tag 操作，更多请查看《Git 基础 - 打标签》&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有本地 tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 本地新增一个 tag，推送至 origin 服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag -a v1.0.0 -m &amp;apos;tag description&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin v1.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 删除本地与 origin tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag -d v1.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin --delete v1.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &amp;lt;分支名&amp;gt;，以下是常用命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 新建分支 branch1，并切换过去&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b branch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看所有本地与远程分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 修改完成后，切换回 master 分支，将 branch1 分支合并进来&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge branch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 删除已完成合并的分支 branch1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -d branch1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Pro Git 简体中文版&lt;/li&gt;
&lt;li&gt;Git权威指南&lt;/li&gt;
&lt;li&gt;命令行man手册&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址&lt;a href=&quot;http://www.ezlippi.com/blog/2016/02/git-guide.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ezlippi.com/blog/2016/02/git-guide.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.vino.ren/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.vino.ren/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="http://blog.vino.ren/2016/05/16/hexo-create-blog/"/>
    <id>http://blog.vino.ren/2016/05/16/hexo-create-blog/</id>
    <published>2016-05-16T03:21:13.000Z</published>
    <updated>2016-05-16T06:29:03.584Z</updated>
    
    <content type="html">&lt;p&gt;不得不说，hexo给程序猿提供了一种高逼格的写作方式。配置也比较方便，而且目录、Rss和sitemap都是自动生成，你只需花几个小时就能掌握用hexo来编写博客。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;p&gt;安装hexo之前请确保机器上已正确安装、配置了git,node.js,如果出现npm安装太慢，请更换npm源:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm config set registry https://registry.npm.taobao.org&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm info underscore （如果上面配置正确这个命令会有字符串response）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir hexoblog  #创建一个文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd hexoblog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;创建博客&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;生成静态站点文件&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;运行服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;启动成功的话浏览器输入&lt;code&gt;http://localhost:4000/&lt;/code&gt;&lt;br&gt;应该能看到默认的页面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装hexo插件：自动生成sitemap,Rss，部署到git等，建议安装&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-index --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-archive --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-category --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-tag --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-server --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-heroku --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-rsync --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-openshift --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-renderer-marked@0.2 --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-renderer-stylus@0.2 --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-feed@1 --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-sitemap@1 --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;部署到github&quot;&gt;&lt;a href=&quot;#部署到github&quot; class=&quot;headerlink&quot; title=&quot;部署到github&quot;&gt;&lt;/a&gt;部署到github&lt;/h2&gt;&lt;p&gt;部署到Github前需要配置_config.yml文件&lt;/p&gt;
&lt;p&gt;添加如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: https://github.com/vinoZHU/vinoZHU.github.io.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;fancybox&quot;&gt;&lt;a href=&quot;#fancybox&quot; class=&quot;headerlink&quot; title=&quot;fancybox&quot;&gt;&lt;/a&gt;fancybox&lt;/h2&gt;&lt;p&gt;本篇博客开头的图片是这样实现的，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: hexo搭建个人博客&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2016-05-16 11:21:13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;categories: hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;photos:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;主题设置&quot;&gt;&lt;a href=&quot;#主题设置&quot; class=&quot;headerlink&quot; title=&quot;主题设置&quot;&gt;&lt;/a&gt;主题设置&lt;/h2&gt;&lt;p&gt;本博客采用了iissnan的Next主题，他的博客有详细的安装教程，这里贴下链接&lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;next&lt;/a&gt;，其中对next主题的设置讲的很详细了，我在这就不多讲了。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll迁移到Hexo搭建个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;external&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/&quot; target=&quot;_blank&quot;&gt;知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议&lt;/a&gt;进行许可,转载请在正文明显处注明原文地址。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，hexo给程序猿提供了一种高逼格的写作方式。配置也比较方便，而且目录、Rss和sitemap都是自动生成，你只需花几个小时就能掌握用hexo来编写博客。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="hexo" scheme="http://blog.vino.ren/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.vino.ren/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基础语法学习</title>
    <link href="http://blog.vino.ren/2016/05/16/learn-markdown-basic/"/>
    <id>http://blog.vino.ren/2016/05/16/learn-markdown-basic/</id>
    <published>2016-05-16T01:34:01.000Z</published>
    <updated>2016-05-16T06:31:04.796Z</updated>
    
    <content type="html">&lt;h2 id=&quot;优点-emsp-emsp&quot;&gt;&lt;a href=&quot;#优点-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;优点&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;优点&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总结 Markdown 的优点如下&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯文本，所以兼容性极强，可以用所有文本编辑器打开。&lt;/li&gt;
&lt;li&gt;让你专注于文字而不是排版。&lt;/li&gt;
&lt;li&gt;格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。&lt;/li&gt;
&lt;li&gt;Markdown 的标记语法有极好的可读性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;语法介绍-emsp-emsp&quot;&gt;&lt;a href=&quot;#语法介绍-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;语法介绍&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;语法介绍&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;p&gt;这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。&lt;/p&gt;
&lt;p&gt;而在 Markdown 中，你只需要在文本前面加上 &lt;code&gt;#&lt;/code&gt; 即可，同理、你&lt;br&gt;还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加  &lt;code&gt;#&lt;/code&gt; 即可，标题字号相应降低。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h3&gt;&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;/p&gt;
&lt;p&gt;无序列表使用星号、加号或是减号作为列表标记：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*   Red&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   Green&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*   Blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;等同于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+   Red&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   Green&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+   Blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也等同于：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-   Red&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-   Green&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-   Blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有序列表则使用数字接着一个英文句点：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.  Bird&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  McHale&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  Parish&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中数字的数值大小并不影响最后的结果&lt;/p&gt;
&lt;h3 id=&quot;分隔线&quot;&gt;&lt;a href=&quot;#分隔线&quot; class=&quot;headerlink&quot; title=&quot;分隔线&quot;&gt;&lt;/a&gt;分隔线&lt;/h3&gt;&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* * *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*****&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- - -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---------------------------------------&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &lt;code&gt;&amp;gt;&lt;/code&gt; 就好了，例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; 引用的文字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终显示的就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用的文字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;粗体和斜体&quot;&gt;&lt;a href=&quot;#粗体和斜体&quot; class=&quot;headerlink&quot; title=&quot;粗体和斜体&quot;&gt;&lt;/a&gt;粗体和斜体&lt;/h3&gt;&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 &lt;code&gt;*&lt;/code&gt; 包含一段文本就是粗体的语法，用一个 &lt;code&gt;*&lt;/code&gt; 包含一段文本就是斜体的语法。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*这是斜体* ， **这是粗体**&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最终显示的就是：&lt;br&gt;&lt;em&gt;这是斜体&lt;/em&gt; ， &lt;strong&gt;这是粗体&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h3&gt;&lt;p&gt;相关代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;| Tables        | Are           | Cool  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ------------- |:-------------:| -----:|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| col 3 is      | right-aligned | $1600 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| col 2 is      | centered      |   $12 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| zebra stripes | are neat      |    $1 |&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Are&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;Cool&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col 3 is&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;right-aligned&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;$1600&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;col 2 is&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;centered&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;$12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zebra stripes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;are neat&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;$1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;相关代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dog | bird | cat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----|------|----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo | foo  | foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bar | bar  | bar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baz | baz  | baz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;显示效果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;dog&lt;/th&gt;
&lt;th&gt;bird&lt;/th&gt;
&lt;th&gt;cat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;td&gt;foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;td&gt;bar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;baz&lt;/td&gt;
&lt;td&gt;baz&lt;/td&gt;
&lt;td&gt;baz&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;行内链接&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[link text](link.address.here)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行外链接&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方便在文中多个地方引用相同的链接，集中管理，文本内容查看也整洁&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[link_name][link_id]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[link_id]: http://link.address.here &amp;quot;注释: 要加 http:// 不然会解析为本地路径&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片&quot;&gt;&lt;a href=&quot;#图片&quot; class=&quot;headerlink&quot; title=&quot;图片&quot;&gt;&lt;/a&gt;图片&lt;/h3&gt;&lt;p&gt;和链接模式类似，只要在前面添加一个 &lt;code&gt;!&lt;/code&gt; 叹号即可&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;![inline text](/path/to/img.jpg &amp;quot;Optional title&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![outline text][id]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[id]: url/to/image  &amp;quot;Optional title attribute&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;p&gt;行内的一小段代码，可以使用反引号（在TAB上面的那位）来将其包起来&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;``There is a back door here.``&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整段代码可以用三个反引号&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;以上几种格式是比较常用的格式，Markdown 还有其他语法，如想了解和学习更多，可以参考&lt;a href=&quot;http://wowubuntu.com/markdown/#link&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Markdown 语法说明 (简体中文版)》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;external&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/&quot; target=&quot;_blank&quot;&gt;知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议&lt;/a&gt;进行许可,转载请在正文明显处注明原文地址。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优点-emsp-emsp&quot;&gt;&lt;a href=&quot;#优点-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;优点&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;优点&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;总结 Markdown 的优点如下&lt;
    
    </summary>
    
      <category term="markdown" scheme="http://blog.vino.ren/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://blog.vino.ren/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>开始我的hexo之旅</title>
    <link href="http://blog.vino.ren/2016/05/16/start-my-blog/"/>
    <id>http://blog.vino.ren/2016/05/16/start-my-blog/</id>
    <published>2016-05-15T23:51:05.000Z</published>
    <updated>2016-05-16T06:33:49.253Z</updated>
    
    <content type="html">&lt;h2 id=&quot;第一次hexo之旅-emsp-emsp&quot;&gt;&lt;a href=&quot;#第一次hexo之旅-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;第一次hexo之旅&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;第一次hexo之旅&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;p&gt;之前一直用博客园来记录学习的过程，虽说比较方便，只需无脑地写到文本框就行了，但是内心一直是想搞一个独立博客的。前几天在github上fork了一份hexo的博客源码，还没了解hexo是怎么用的就直接在源码上改了起来，花了一个周末把博客内容改成了自己的，但是改的都是代码，这样就没有一个可持续的效果。于是乎就开始研究了这个hexo,花了一天时间把博客配了一下，同时也了解了整个博客发布的流程，学习了一下markdown语法，瞬间觉得写博客变成了一种享受，以后可以好好写了。&lt;/p&gt;
&lt;p&gt;顺便贴一下我的&lt;a href=&quot;http://www.cnblogs.com/vinozly/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客园地址&lt;/a&gt; ,记录了我之前的学习过程，有兴趣的同学可以去看看，嘻嘻^^。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一次hexo之旅-emsp-emsp&quot;&gt;&lt;a href=&quot;#第一次hexo之旅-emsp-emsp&quot; class=&quot;headerlink&quot; title=&quot;第一次hexo之旅&amp;emsp;&amp;emsp;&quot;&gt;&lt;/a&gt;第一次hexo之旅&amp;emsp;&amp;emsp;&lt;/h2&gt;&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
