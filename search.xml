<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[linux内核中hlist_head和hlist_node结构解析]]></title>
      <url>http://vinoit.me/2016/09/01/linux-kernel-hlist_head-and-hlist_node/</url>
      <content type="html"><![CDATA[<p><code>hlist_head</code>和<code>hlist_node</code>用于散列表，分表表示列表头（数组中的一项）和列表头所在双向链表中的某项，两者结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_head &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *first;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_node &#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *next, **pprev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在内核中的普通双向链表基本上都是通过<code>list_head</code>实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> list_head &#123;</div><div class="line">        <span class="keyword">struct</span> list_head *next, *prev;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p><code>list_head</code>很好理解，但是<code>hlist_head</code>和<code>hlist_node</code>为何要这样设计呢？</p>
<p>先看下<code>hlist_head</code>和<code>hlist_node</code>的示意图:</p>
<p><img src="/images/linux/list_head-and-hlist_node-0.png" alt=""></p>
<p><code>hash_table</code>为散列表（数组），其中的元素类型为<code>struct hlist_head</code>。以<code>hlist_head</code>为链表头的链表，其中的节点<code>hash值</code>是相同的（也叫冲突）。<code>first指针</code>指向链表中的节点①，然后节点①的<code>pprev指针</code>指向<code>hlist_head</code>中的<code>first</code>，节点①的<code>next指针</code>指向节点②。以此类推。</p>
<p><code>hash_table</code>的列表头仅存放一个指针,也就是first指针,指向的是对应链表的头结点,没有tail指针也就是指向链表尾节点的指针,这样的考虑是为了节省空间——尤其在<code>hash bucket</code>(数组size)很大的情况下可以节省一半的指针空间。</p>
<p>为什么<code>pprev</code>是一个指向指针的指针呢？按照这个设计，我们如果想要得到尾节点，必须遍历整个链表，可如果是一个指向节点的指针，那么头结点现在的<code>pprev</code>便可以直接指向尾节点，也就是<code>list_head</code>的做法。</p>
<p>对于散列表来说，一般发生冲突的情况并不多（除非hash设计出现了问题），所以一个链表中的元素数量比较有限，遍历的劣势基本可以忽略。</p>
<p>在删除链表头结点的时候，<code>pprev</code>这个设计无需判断删除的节点是否为头结点。如果是普通双向链表的设计，那么删除头结点之后，<code>hlist_head</code>中的<code>first指针</code>需要指向新的头结点。通过下面2个函数来加深理解:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加节点到链表头</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *first = h-&gt;first;</div><div class="line">    n-&gt;next = first;<span class="comment">//新节点的next指针指向原头结点</span></div><div class="line">    <span class="keyword">if</span> (first)</div><div class="line">        first-&gt;pprev = &amp;n-&gt;next;<span class="comment">//原头结点的pprev指向新节点的next字段</span></div><div class="line">    h-&gt;first = n;<span class="comment">//first指针指向新的节点（更换了头结点）</span></div><div class="line">    n-&gt;pprev = &amp;h-&gt;first; <span class="comment">//此时n是链表的头结点,将它的pprev指向list_head的first字段</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//删除节点</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="number">__</span>hlist_del(<span class="keyword">struct</span> hlist_node *n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> hlist_node *next = n-&gt;next;</div><div class="line">    <span class="keyword">struct</span> hlist_node **pprev = n-&gt;pprev;</div><div class="line">    *pprev = next; <span class="comment">// pprev指向的是前一个节点的next指针,当该节点是头节点时指向 hlist_head的first,两种情况下不论该节点是一般的节点还是头结点都可以通过这个操作删除掉所需删除的节点。</span></div><div class="line">    <span class="keyword">if</span> (next)</div><div class="line">        next-&gt;pprev = pprev;<span class="comment">//使删除节点的后一个节点的pprev指向删除节点的前一个节点的next字段，节点成功删除。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之内存管理]]></title>
      <url>http://vinoit.me/2016/08/30/linux-kernel-note-memory-manage/</url>
      <content type="html"><![CDATA[<h4 id="非一致内存访问（NUMA）"><a href="#非一致内存访问（NUMA）" class="headerlink" title="非一致内存访问（NUMA）"></a>非一致内存访问（NUMA）</h4><p>我们习惯上认为计算机内存是一种均匀、共享的资源。在忽略硬件高速缓存的情况下，我们期望不管内存单元处于何处，也不管CPU处于何处，CPU对内存单元的访问都需要相同的时间。但是，在某些体系结构中并不总是成立。</p>
<p>在NUMA模型中，给定CPU对不同内存单元的访问时间可能不一样。系统的物理内存被划分为几个节点(node)。在一个单独的节点内，任一给定CPU访问页面所需的时间都是相同的。然而，对不同的CPU，这个时间可能就不同。每个节点的物理内存又可以分为几个管理区（zone）。</p>
<p>Linux支持NUMA模型，但是Linux将所有物理内存看作一个节点。在存放节点的链表中，只有一个元素。</p>
<h4 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h4><p>80x86体系结构存在两种硬件约束:</p>
<ul>
<li>ISA总线的DMA处理器只能对RAM的前16M寻址。</li>
<li>在具有大量RAM的现代32位计算机中，因为线性地址空间太小，CPU不能直接访问所有的物理内存。</li>
</ul>
<p>为了应对这两种限制，Linux2.6把每个内存节点的物理内存划分为3个管理区。在80x86 UMA体系结构中的管理区为:</p>
<ul>
<li>ZONE_DMA(包含低于16M的内存页框)</li>
<li>ZONE_NORMAL(包含高于16M低于896M的内存页框)</li>
<li>ZONE_HIGHMEM(包含高于896M的所有内存页框)</li>
</ul>
<p>ZONE_DMA中的页框可以由老式基于ISA的设备通过DMA使用。</p>
<p>ZONE_NORMAL中的页框全部映射到内核使用的第4个GB地址空间，这部分页框的映射方式很简单，例如物理地址为<code>0x10000000</code>,只需要直接加上3GB的地址，得到的线性地址为<code>0xc0000000</code>。</p>
<p>ZONE_HIGHMEM和ZONE_NORMAL都属于“常规”页框，但内核使用的第4个GB地址空间的最后128M才能映射到该部分页框。</p>
<h4 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h4><p>分区页框分配器是一个内核子系统，处理对连续页框组的内存分配请求。这部分内容对于理解Linux的内存管理十分关键，它的主要组成如下:<br><img src="/images/linux-kernel-note/memory-manage-0.png" alt=""></p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>linux内核的伙伴算法最大限度的减少了内存的碎片，其实应该说成是尽自己最大的努力减少了内存的碎片。其思想就是将物理内存分成11个块链表，每个链表包含的是大小为1,2,4,8…512,1024的连续页框块。举例来说要分配256个连续页框，会先到块大小为256的链表中查找空闲块，若有直接返回，若没有，去大小为512的链表中进行查找，将512大小块分为两部分，一部分返回，一部分插入256大小的链表中，若512大小的链表中还没有，到1024大小的链表中查找，取出256大小的块，将剩下的512,256的块分别插入到各个链表中，内存释放的过程则是相反的。</p>
<p>满足以下条件的两个快称为伙伴:</p>
<ul>
<li>两个块具有相同的大小，记作b。</li>
<li>它们的物理地址是连续的。</li>
<li>第一个块的的第一个页框的物理地址是<code>2*b*2^12</code>的倍数。</li>
</ul>
<h4 id="每CPU页框高速缓存（冷热页）"><a href="#每CPU页框高速缓存（冷热页）" class="headerlink" title="每CPU页框高速缓存（冷热页）"></a>每CPU页框高速缓存（冷热页）</h4><p>内核经常请求和释放<code>单个页框</code>，为了提升性能，每个内存管理区定义了一个“每CPU”高速缓存。冷页表示该空闲页已经不再高速缓存中了(一般是指L2 Cache)，热页表示该空闲页仍然在高速缓存中。冷热页是针对于每CPU的，每个zone中，都会针对于所有的CPU初始化一个冷热页的per-cpu-pageset.</p>
<h4 id="分配页框小结"><a href="#分配页框小结" class="headerlink" title="分配页框小结"></a>分配页框小结</h4><p>当内核接收一个分配若干个页框的请求时，如果页框数量为1，则从每CPU页框高速缓存中分配一个页框。如果页框数大于1，则从伙伴系统中分配符合要求的若干个连续页框。其中的大致流程如下：</p>
<ol>
<li>管理区分配器选择一个合适的内存管理区。</li>
<li>如果需要的页框数量为1，则从每CPU页框高速缓存中获取一个空闲的页框。一般情况下获取一个热页，但如果用于DMA等不需要CPU参与的请求，获取一个冷页。</li>
<li>如果数量大于1，则从伙伴系统中选择一个大于0中的最小order链表，然后返回一个块。</li>
</ol>
<p>如果冷热页中无空闲页框，则从伙伴系统中分配一些页框给冷热页机制。</p>
<h4 id="slab机制"><a href="#slab机制" class="headerlink" title="slab机制"></a>slab机制</h4><p>当我们需要分配一些小对象时，如果还使用页框分配器，那未免太浪费了，无论是从时间上还是空间上。slab分配器用于这些小对象的分配，其大致组成如下:<br><img src="/images/linux-kernel-note/memory-manage-1.png" alt=""><br>高速缓存的大小为2的幂，从32B到131072B共13个级别。对于每种大小都有2个高速缓存：一个适用于ISA DMA分配，另一个适用于常规分配。</p>
<p>高速缓存描述符如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_cache &#123;  </div><div class="line"><span class="comment">/* 1) per-cpu data, touched during every alloc/free */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache *<span class="built_in">array</span>[NR_CPUS];<span class="comment">/*local cache*/</span>  </div><div class="line"><span class="comment">/* 2) Cache tunables. Protected by cache_chain_mutex */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shared;  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer_size;<span class="comment">/*slab中对象大小*/</span>  </div><div class="line">    u32 reciprocal_buffer_size;<span class="comment">/*slab中对象大小的倒数*/</span>  </div><div class="line"><span class="comment">/* 3) touched by every alloc &amp; free from the backend */</span>  </div><div class="line">  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;     <span class="comment">/* constant flags */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num;       <span class="comment">/* # of objs per slab */</span>  </div><div class="line">  </div><div class="line"><span class="comment">/* 4) cache_grow/shrink */</span>  </div><div class="line">    <span class="comment">/* order of pgs per slab (2^n) */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> gfporder;  </div><div class="line">  </div><div class="line">    <span class="comment">/* force GFP flags, e.g. GFP_DMA */</span>  </div><div class="line">    <span class="keyword">gfp_t</span> gfpflags;  </div><div class="line">  </div><div class="line">    <span class="keyword">size_t</span> colour;<span class="comment">/*着色块个数*/</span> <span class="comment">/* cache colouring range */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_off;<span class="comment">/* cache的着色块的单位大小 */</span>    <span class="comment">/* colour offset */</span>  </div><div class="line">    <span class="keyword">struct</span> kmem_cache *slabp_cache;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slab_size;<span class="comment">/*slab管理区大小,包含slab对象和kmem_bufctl_t数组*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dflags;        <span class="comment">/* dynamic flags */</span>  </div><div class="line">  </div><div class="line">    <span class="comment">/* constructor func */</span>  </div><div class="line">    <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *obj);  </div><div class="line">  </div><div class="line"><span class="comment">/* 5) cache creation/removal */</span>  </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  </div><div class="line">    <span class="keyword">struct</span> list_head next;  </div><div class="line">  </div><div class="line"><span class="comment">/* 6) statistics */</span>  </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SLAB  </span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_active;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_allocations;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> high_mark;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> grown;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reaped;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> errors;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> max_freeable;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_allocs;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_frees;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_overflow;  </div><div class="line">    <span class="keyword">atomic_t</span> allochit;<span class="comment">/*cache命中计数，在分配中更新*/</span>  </div><div class="line">    <span class="keyword">atomic_t</span> allocmiss;<span class="comment">/*cache未命中计数，在分配中更新*/</span>  </div><div class="line">    <span class="keyword">atomic_t</span> freehit;  </div><div class="line">    <span class="keyword">atomic_t</span> freemiss;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * If debugging is enabled, then the allocator can add additional </div><div class="line">     * fields and/or padding to every object. buffer_size contains the total </div><div class="line">     * object size including these internal fields, the following two </div><div class="line">     * variables contain the offset to the user object and its size. </div><div class="line">     */  </div><div class="line">    <span class="keyword">int</span> obj_offset;  </div><div class="line">    <span class="keyword">int</span> obj_size;  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span>  </span></div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * We put nodelists[] at the end of kmem_cache, because we want to size </div><div class="line">     * this array to nr_node_ids slots instead of MAX_NUMNODES </div><div class="line">     * (see kmem_cache_init()) </div><div class="line">     * We still use [MAX_NUMNODES] and not [1] or [0] because cache_cache </div><div class="line">     * is statically defined, so we reserve the max number of nodes. </div><div class="line">     */  </div><div class="line">    <span class="keyword">struct</span> kmem_list3 *nodelists[MAX_NUMNODES];  </div><div class="line">    <span class="comment">/* </span></div><div class="line">     * Do not add fields after nodelists[] </div><div class="line">     */  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后面的<code>struct kmem_list3</code>结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_list3 &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_partial;<span class="comment">/*slab链表，包含空闲对象和已分配对象的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_full;   <span class="comment">/*slab链表，只包含非空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_free;   <span class="comment">/*slab链表，只包含空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;    <span class="comment">/*高速缓存中空闲对象的个数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;       <span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;       <span class="comment">/*下一个slab使用的颜色*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> list_lock;  </div><div class="line">    <span class="keyword">struct</span> array_cache *shared; <span class="comment">/* shared per node */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache **alien; <span class="comment">/* on other nodes */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;    <span class="comment">/* updated without locking */</span>  </div><div class="line">    <span class="keyword">int</span> free_touched;       <span class="comment">/* updated without locking */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>struct kmem_list3</code>中包含3条slab链表，slab描述符如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> slab &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;  <span class="comment">/*用于将slab链入kmem_list3的链表*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;<span class="comment">/*该slab的着色偏移*/</span>  </div><div class="line">    <span class="keyword">void</span> *s_mem;            <span class="comment">/*指向slab中的第一个对象*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;     <span class="comment">/*已分配出去的对象*/</span>  </div><div class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;     <span class="comment">/*下一个空闲对象的下标*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;  <span class="comment">/*节点标识号*/</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>一个slab中的是同类对象，一个高速缓存中的是相同大小的对象。</strong></p>
<p>一个高速缓存描述符包含3条slab链表：<br><img src="/images/linux-kernel-note/memory-manage-2.png" alt=""></p>
<p>高速缓存描述符中的<code>struct array_cache *array[NR_CPUS];/*local cache*/</code>表示本地高速缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> array_cache &#123;  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> avail;<span class="comment">/*本地高速缓存中可用的空闲对象数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> limit;<span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;<span class="comment">/*一次转入和转出的对象数量*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> touched;   <span class="comment">/*标识本地CPU最近是否被使用*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> lock;  </div><div class="line">    <span class="keyword">void</span> *entry[];  <span class="comment">/*这是一个伪数组，便于对后面用于跟踪空闲对象的指针数组的访问 </span></div><div class="line">             * Must have this definition in here for the proper </div><div class="line">             * alignment of array_cache. Also simplifies accessing </div><div class="line">             * the entries. </div><div class="line">             */  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当我们要求内核给我们分配一个小对象时，是从本地高速缓存中获取的。本地高速缓存中的对象依次放置在该本地高速缓存描述符的地址后面。</p>
<h4 id="slab分配对象小结"><a href="#slab分配对象小结" class="headerlink" title="slab分配对象小结"></a>slab分配对象小结</h4><p>当我们需要一个小对象时，首先获取当前CPU id,然后到对应的本地高速缓存中获取对象。如果无空闲对象，则从slab链表中分配一些slab对象，数量为本地高速缓存描述符中<code>batchcount</code>值。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文从整体上描述了Linux中的内存管理，并没有涉及到具体源码以及细节问题，更多细节待日后整理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[根据字节码探讨JAVA自增运算符的原理]]></title>
      <url>http://vinoit.me/2016/08/29/understand-java-auto-increment-by-bytecode/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        x++;</div><div class="line">        myMethod();</div><div class="line">        System.out.println(x + y + ++x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        y = x++ + ++x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果以上代码的结果你很自信能做对,那么本文或许对你帮助不大,但仍然可以看下java底层的实现.在最后将给出以上代码的结果以及解析.</strong></p>
<h4 id="情况举例"><a href="#情况举例" class="headerlink" title="情况举例"></a>情况举例</h4><p>本文中的例子主要针对以下情况:</p>
<p>①x=y++</p>
<p>②x=++y</p>
<p>③x=x++</p>
<p>④x=++x</p>
<p>a : x,y为形参</p>
<p>b : x,y为成员变量</p>
<p>废话不多说,直接上代码:</p>
<h4 id="代码1-①-b"><a href="#代码1-①-b" class="headerlink" title="代码1(①+b):"></a>代码1(①+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x,y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = y++;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:01</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field y:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #3                  // Field y:I</div><div class="line">         9: putstatic     #4                  // Field x:I</div><div class="line">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #4                  // Field x:I</div><div class="line">        18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:y(值)入操作栈</p>
<p>3:得到y(值)的一个快照y’(值)</p>
<p>(个人认为相当于是将栈顶元素也就是y(值)复制了一份,然后将复制得到的y’(值)入操作栈,现在操作栈中有y(值)和y’(值))</p>
<p>4:常量1入操作栈</p>
<p>5:常量1和y’(值)弹出栈,进行加操作,并将结果s入栈</p>
<p>6:将结果s弹出栈,赋给y(变量)(此时y==1)</p>
<p>9:将y(值)弹出栈,赋给x(变量)(此时x==0)</p>
<p>因为y(值)入操作栈之后没有修改,所以x依旧是0,而y变成了1</p>
<h4 id="代码2-②-b"><a href="#代码2-②-b" class="headerlink" title="代码2(②+b):"></a>代码2(②+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x,y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = ++y;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果11</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field y:I</div><div class="line">         3: iconst_1</div><div class="line">         4: iadd</div><div class="line">         5: dup</div><div class="line">         6: putstatic     #3                  // Field y:I</div><div class="line">         9: putstatic     #4                  // Field x:I</div><div class="line">        12: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #4                  // Field x:I</div><div class="line">        18: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:y(值)入操作栈</p>
<p>3:常量1入操作栈</p>
<p>4:常量1和y(值)弹出栈,进行加操作,并将结果s入栈</p>
<p>5:得到栈顶元素也就是s的快照s’,并入操作栈</p>
<p>6:将s’弹出栈,并赋给y(变量)(此时y==1)</p>
<p>9:将s弹出栈,并赋给x(变量)(此时x==1)</p>
<h4 id="代码3-③-b"><a href="#代码3-③-b" class="headerlink" title="代码3(③+b):"></a>代码3(③+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = x++;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:0</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field x:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #3                  // Field x:I</div><div class="line">         9: putstatic     #3                  // Field x:I</div><div class="line">        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #3                  // Field x:I</div><div class="line">        18: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:x(值)入操作栈</p>
<p>3:得到x(值)的快照x’,入操作栈</p>
<p>4:常量1入操作栈</p>
<p>5:常量1和x’弹出操作栈,进行加操作,将结果s入操作栈</p>
<p>6:将s弹出栈,并赋给x(变量)(此时x==1)</p>
<p>9:将x(值)弹出栈,并赋给x(变量)(此时x的值被覆盖,x==0)</p>
<h4 id="代码4-④-b"><a href="#代码4-④-b" class="headerlink" title="代码4(④+b):"></a>代码4(④+b):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        x = ++x;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:1</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #3                  // Field x:I</div><div class="line">         3: iconst_1</div><div class="line">         4: iadd</div><div class="line">         5: dup</div><div class="line">         6: putstatic     #3                  // Field x:I</div><div class="line">         9: putstatic     #3                  // Field x:I</div><div class="line">        12: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">        15: getstatic     #3                  // Field x:I</div><div class="line">        18: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        21: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:x(值)入操作栈</p>
<p>3:常量1如入操作栈</p>
<p>4:常量1和x(值)弹出操作栈,进行加操作,并将结果s入操作栈</p>
<p>5:得到栈顶元素s的快照s’,入操作栈</p>
<p>6.将s’弹出操作栈,并赋给x(变量)(此时x==1)</p>
<p>9:将s弹出操作栈,并赋给x(变量)(此时x==1)</p>
<h4 id="代码5-①-a"><a href="#代码5-①-a" class="headerlink" title="代码5(①+a):"></a>代码5(①+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        x = y++;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y); &#125; &#125;</div></pre></td></tr></table></figure>
<p><code>结果:01</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0: iload_1</div><div class="line">         1: iinc          1, 1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: new           #4                  // class java/lang/StringBuilder</div><div class="line">        11: dup</div><div class="line">        12: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">        15: iload_0</div><div class="line">        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        19: ldc           #7                  // String</div><div class="line">        21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">        24: iload_1</div><div class="line">        25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">        34: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:将本地变量区的y(值)入操作栈</p>
<p>1:将本地变量y加1(y==1)</p>
<p>4:将0中的y(值)弹出栈,并赋给本地变量区的x(x==0)</p>
<h4 id="代码6-②-a"><a href="#代码6-②-a" class="headerlink" title="代码6(②+a):"></a>代码6(②+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">        x = ++y;</div><div class="line">        System.out.println(x+<span class="string">""</span>+y);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:11</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">0: iinc          1, 1</div><div class="line">         3: iload_1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: new           #4                  // class java/lang/StringBuilder</div><div class="line">        11: dup</div><div class="line">        12: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">        15: iload_0</div><div class="line">        16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        19: ldc           #7                  // String</div><div class="line">        21: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">        24: iload_1</div><div class="line">        25: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">        28: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">        34: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:将本地变量y加1(此时y==1)</p>
<p>3:将本地变量y(值)入操作栈</p>
<p>4:将y(值)弹出操作栈,并赋给x(此时x==1)</p>
<h4 id="代码7-③-a"><a href="#代码7-③-a" class="headerlink" title="代码7(③+a):"></a>代码7(③+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        x = x++;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:0</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: iload_0</div><div class="line">         1: iinc          0, 1</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: iload_0</div><div class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        12: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:本地变量x(值)入操作栈</p>
<p>1:本地变量x加1(此时x==1)</p>
<p>4:将x(值)弹出栈,并赋给本地变量x(此时x==0)</p>
<h4 id="代码8-④-a"><a href="#代码8-④-a" class="headerlink" title="代码8(④+a):"></a>代码8(④+a):</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        test(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        x = ++x;</div><div class="line">        System.out.println(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果:1</code></p>
<p><strong>test()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: iinc          0, 1</div><div class="line">         3: iload_0</div><div class="line">         4: istore_0</div><div class="line">         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">         8: iload_0</div><div class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</div><div class="line">        12: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:本地变量x加1(此时x==1)</p>
<p>3:本地变量x(值)入操作栈</p>
<p>4:将x(值)弹出操作栈,并赋给x(此时x==1) </p>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><font color="red">事实上i++和++i在底层的实现都是先自增,区别在于返回值.i++返回自增前的值,++i返回自增后的值。</font>



<p>现在来看看一开始那段代码的结果和解析:</p>
<p><code>结果:11</code></p>
<p><strong>myMethod()字节码:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">0: getstatic     #2                  // Field x:I</div><div class="line">         3: dup</div><div class="line">         4: iconst_1</div><div class="line">         5: iadd</div><div class="line">         6: putstatic     #2                  // Field x:I</div><div class="line">         9: getstatic     #2                  // Field x:I</div><div class="line">        12: iconst_1</div><div class="line">        13: iadd</div><div class="line">        14: dup</div><div class="line">        15: putstatic     #2                  // Field x:I</div><div class="line">        18: iadd</div><div class="line">        19: putstatic     #5                  // Field y:I</div><div class="line">        22: return</div></pre></td></tr></table></figure>
<p>解释:</p>
<p>0:变量x(值)入操作栈(栈状态:x0)</p>
<p>3:得到栈顶元素x(值)的快照x’(值),并入操作栈(栈状态:x0-&gt;x0’)</p>
<p>4:常量1入操作栈(栈状态:x0-&gt;x0’-&gt;1)</p>
<p>5:常量1和x’(值)弹出操作栈,进行加操作,将结果s0入操作栈(栈状态:x0-&gt;s0)</p>
<p>6:弹出s0,并赋给x(变量)(栈状态:x0,此时x(变量)==2)</p>
<p>9:将修改后的x(值)入操作栈(栈状态:x0-&gt;x1)</p>
<p>12:常量1入操作栈(栈状态:x0-&gt;x1-&gt;1)</p>
<p>13:常量1和X1(值)弹出操作栈,进行加操作,将结果s1入操作栈(栈状态:x0-&gt;s1)</p>
<p>14:得到栈顶元素s1(值)的快照s1’(值),并入操作栈(栈状态:x0-&gt;s1-&gt;s1’)</p>
<p>15:弹出s1’并赋给x(变量)(栈状态:x0-&gt;s1)</p>
<p>18:s1和x0弹出栈,进行加操作,将结果s2入栈(栈状态:s2)</p>
<p>19:弹出s2,并赋给y(变量) </p>
<p>所以在myMethod之后x的值为经过两次自增后的值,为x+2==3,而y的值为x0+s1,其中x0为最初传进来的值==1,s1是x经过两次自增后的值==3,所以y==4</p>
<p>x==3,y==4</p>
<p>最后输出的结果就是3+4+4==11</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之进程调度]]></title>
      <url>http://vinoit.me/2016/08/26/linux-kernel-note-process-scheduling/</url>
      <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>传统Unix操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。决定什么时候以怎样的方式选择一个新进程运行的这组规则就是所谓的调度策略（scheduling policy）。</p>
<p>Linux的进程调度是基于分时技术（time-sharing）。允许多个进程“并发”运行就意味着CPU 的时间被粗略地分成“片”，给每个可运行进程分配一片。</p>
<p>当然，单处理器在任何给定的时刻只能运行一个进程。当一个并发执行的进程其时间片或时限（quantum）到期时还没有终止，进程切换就可以发生。分时依赖于定时中断，因此，对进程是透明的。为保证CPU 分时，不需要在程序中插入额外的代码。</p>
<p>在Linux 中，进程的优先级是动态的。调度程序跟踪进程做了些什么，并周期性地调整它们的优先级。在这种方式下，在较长的时间间隔内没有使用CPU的进程，通过动态地增加它们的优先级来提升它们。相应地，对于已经在CPU上运行了较长时间的进程，通过减少它们的优先级来处罚它们。每个进程在创建之初有一个基本的优先级，执行期间调度系统会动态调整它的优先级，交互性高的任务会获得一个高的动态优先级，而交互性低的任务获得一个低的动态优先级。</p>
<h4 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h4><p>传统上把进程分类为“I/O 受限（I/O-bound）”或“CPU受限（CPU-bound）”。前者频繁地使用I/O 设备，并花费很多时间等待I/O操作的完成；而后者是需要大量CPU 时间的数值计算应用程序。</p>
<p>另一种分类法把进程区分为三类:<strong>交互式进程</strong> 、<strong>批处理进程</strong> 、<strong>实时进程</strong>。</p>
<p>交互式进程经常与用户交互，需要花很多时间等待键盘和鼠标操作。典型的交互式程序是命令shel、文本编辑程序、图形应用程序等。批处理程序不必与用户交互，经常在后台运行。因为这些进程不必被很快地相应，因此常受到调度程序的慢待。典型的批处理程序是编译程序、数据库搜索引擎、科学计算等。实时进程有很强的调度需要，他们不会被低优先级的进程阻塞，响应的时间很短。典型的实时程序有视频和音频应用程序、机器人控制程序、从物理传感器上收集数据的程序等。</p>
<p>这2种分类法在一定程度上互相独立。例如一个批处理程序可能是I/O受限型的（如数据库服务器），也可能是CPU受限型的（图像绘制程序）。Linux的调度算法可以明确的区分实时程序，但是没有办法区分交互式程序和批处理程序。Linux根据进程的过去行为，通过特定的算法区分交互式程序和批处理程序。因为交互式程序需要给用户一个良好的体验，所以Linux调度程序对交互式程序比较偏爱。</p>
<h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>交互式程序和批处理程序都叫做<strong>非实时进程（普通进程）</strong>，每个非实时进程都有自己的静态优先级（nice值），<code>值越大优先级越低</code>。。nice值是所有Unix系统的标准化概念，在OS X系统中nice值代表分配给进程的时间片的绝对值，<code>而Linux中代表时间片的比例</code>。通过<code>ps -el</code>命令查看系统中的进程列表，结果中标记<code>NI</code>的一列就是进程对应的nice值。</p>
<p>对于<strong>实时进程</strong>，实时优先级的范围是从1（最低优先级）~ 99（最高优先级），含义与nice值相反。任何实时进程的优先级总高于非实时进程（普通进程）。你可以通过<code>ps -eo stata,uid,pid,ppid,rtprio,time,com</code>查看系统中的进程列表，在<code>RTPRIO</code>列的就是实时优先级，如果显示<code>-</code>，则该进程不是实时进程。</p>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。一般来说，调度策略必须规定一个默认的时间片，但是Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比划分给了进程。这样一来，进程所获得的处理器时间其实是和系统负载密切相关的。nice值作为权重将调整使用比，值越大，使用比越小。Linux中CFS调度器的抢占时机取决于新进程所消耗的使用比。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。</p>
<p>不过，当可运行进程的数量区域无限时，每个进程获得使用比则趋于0，岂不是时间都花在切换进程上了？CFS为此引入了每个进程获得的时间片最小粒度，默认是1ms,也就是每个进程最少能获得1ms的运行时间。</p>
<h4 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h4><p>每个Linux进程都按照以下调度类型被调度：</p>
<ul>
<li><p>SCHED_FIFO<br>先进先出的实时进程。如果没有优先级更高的可运行的实时进程，则当前运行的实时进程想运行多久便运行多久，即使还有其他优先级相同的可运行实时进程</p>
</li>
<li><p>SCHED_RR<br>时间片轮转的实时进程。保证对所有相同优先级的实时进程公平地分配CPU时间。</p>
</li>
<li><p>SCHED_NORMAL<br>普通的分时进程。</p>
</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>早期Linux的调度算法非常简单，在每次进程切换时，内核扫描可运行进程的链表，然后选择“最佳”的进程来运行。这个算法的主要缺点是选择进程所消耗的时间与可运行进程的数量相关。当可运行进程的数量很多时，扫描花费的时间很不可观。</p>
<p>如今Linux采用的算法为“完全公平调度算法”，简称<code>CFS</code>。CFS是一个针对普通进程的调度器，期调度类型为<code>SCHED_NORMAL</code>。在#时间片#中已经讲到，nice值在CFS中被作为进程获得处理器运行比的权重。</p>
<p>CFS使用一个<code>struct sched_entity</code>数据结构来记录进程的调度情况，包括运行时间。进程描述符中的<code>se</code>字段便是该数据类型,<code>se</code>是当前进程的调度实体，该结构部分内容如下:</p>
<p><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.24#L866" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.24#L866</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sched_entity &#123;</div><div class="line">        <span class="keyword">struct</span> load_weight      load;           <span class="comment">/* for load-balancing */</span></div><div class="line">        <span class="keyword">struct</span> rb_node          run_node;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>            on_rq;</div><div class="line"></div><div class="line">        u64                     exec_start;</div><div class="line">        u64                     sum_exec_runtime;</div><div class="line">        u64                     vruntime;</div><div class="line">        u64                     prev_sum_exec_runtime;</div><div class="line"></div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>vruntime</code>变量存放进程的虚拟运行时间，CFS使用<code>vruntime</code>来记录一个程序到底运行了多长时间以及它应该再运行多久。可以简单地认为<code>vruntime</code>通过以下公式计算:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vruntime ＝ delta_time / load</div></pre></td></tr></table></figure>
<p>其中<code>delta_time</code>表示该进程以运行的时间，<code>load</code>表示进程对CPU的使用比，和nice值相关。当运行相同时间时，使用比大的进程vruntime更小，表明能获得更多的CPU时间。更新函数通过时钟中断调用。</p>
<p><strong>进程选择</strong></p>
<p>CFS调度算法的核心便是选择具有最小vruntime的进程，CFS使用红黑树来组织可运行进程队列，并且通过红黑树迅速找到最小vruntime的进程。红黑树中的每一个节点的值便是<code>vruntime</code>,越小的<code>vruntime</code>，位置越靠左下，所以只需找到最左下的节点的进程。</p>
<h4 id="调度相关数据结构"><a href="#调度相关数据结构" class="headerlink" title="调度相关数据结构"></a>调度相关数据结构</h4><h5 id="struct-rq"><a href="#struct-rq" class="headerlink" title="struct rq"></a>struct rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rq &#123;</div><div class="line"><span class="number">279</span>         <span class="comment">/* runqueue lock: */</span></div><div class="line"><span class="number">280</span>         <span class="keyword">spinlock_t</span> lock;</div><div class="line"><span class="number">281</span> </div><div class="line"><span class="number">282</span>         <span class="comment">/*</span></div><div class="line">283          * nr_running and cpu_load should be in the same cacheline because</div><div class="line">284          * remote CPUs use both these fields when doing load calculation.</div><div class="line">285          */</div><div class="line"><span class="number">286</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</div><div class="line"><span class="number">287</span>         <span class="meta">#<span class="meta-keyword">define</span> CPU_LOAD_IDX_MAX 5</span></div><div class="line"><span class="number">288</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_load[CPU_LOAD_IDX_MAX];</div><div class="line"><span class="number">289</span>         <span class="keyword">unsigned</span> <span class="keyword">char</span> idle_at_tick;</div><div class="line"><span class="number">290</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ</span></div><div class="line"><span class="number">291</span>         <span class="keyword">unsigned</span> <span class="keyword">char</span> in_nohz_recently;</div><div class="line"><span class="number">292</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">293</span>         <span class="comment">/* capture load from *all* tasks on this cpu: */</span></div><div class="line"><span class="number">294</span>         <span class="keyword">struct</span> load_weight load;</div><div class="line"><span class="number">295</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_load_updates;</div><div class="line"><span class="number">296</span>         u64 nr_switches;</div><div class="line"><span class="number">297</span> </div><div class="line"><span class="number">298</span>         <span class="keyword">struct</span> cfs_rq cfs;</div><div class="line"><span class="number">299</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></div><div class="line"><span class="number">300</span>         <span class="comment">/* list of leaf cfs_rq on this cpu: */</span></div><div class="line"><span class="number">301</span>         <span class="keyword">struct</span> list_head leaf_cfs_rq_list;</div><div class="line"><span class="number">302</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">303</span>         <span class="keyword">struct</span> rt_rq rt;</div><div class="line"><span class="number">304</span> </div><div class="line"><span class="number">305</span>         <span class="comment">/*</span></div><div class="line">306          * This is part of a global counter where only the total sum</div><div class="line">307          * over all CPUs matters. A task can increase this counter on</div><div class="line">308          * one CPU and if it got migrated afterwards it may decrease</div><div class="line">309          * it on another CPU. Always updated under the runqueue lock:</div><div class="line">310          */</div><div class="line"><span class="number">311</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_uninterruptible;</div><div class="line"><span class="number">312</span> </div><div class="line"><span class="number">313</span>         <span class="keyword">struct</span> task_struct *curr, *idle;</div><div class="line"><span class="number">314</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> next_balance;</div><div class="line"><span class="number">315</span>         <span class="keyword">struct</span> mm_struct *prev_mm;</div><div class="line"><span class="number">316</span> </div><div class="line"><span class="number">317</span>         u64 clock, prev_clock_raw;</div><div class="line"><span class="number">318</span>         s64 clock_max_delta;</div><div class="line"><span class="number">319</span> </div><div class="line"><span class="number">320</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> clock_warps, clock_overflows;</div><div class="line"><span class="number">321</span>         u64 idle_clock;</div><div class="line"><span class="number">322</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> clock_deep_idle_events;</div><div class="line"><span class="number">323</span>         u64 tick_timestamp;</div><div class="line"><span class="number">324</span> </div><div class="line"><span class="number">325</span>         <span class="keyword">atomic_t</span> nr_iowait;</div><div class="line"><span class="number">326</span> </div><div class="line"><span class="number">327</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></div><div class="line"><span class="number">328</span>         <span class="keyword">struct</span> sched_domain *sd;</div><div class="line"><span class="number">329</span> </div><div class="line"><span class="number">330</span>         <span class="comment">/* For active balancing */</span></div><div class="line"><span class="number">331</span>         <span class="keyword">int</span> active_balance;</div><div class="line"><span class="number">332</span>         <span class="keyword">int</span> push_cpu;</div><div class="line"><span class="number">333</span>         <span class="comment">/* cpu of this runqueue: */</span></div><div class="line"><span class="number">334</span>         <span class="keyword">int</span> cpu;</div><div class="line"><span class="number">335</span> </div><div class="line"><span class="number">336</span>         <span class="keyword">struct</span> task_struct *migration_thread;</div><div class="line"><span class="number">337</span>         <span class="keyword">struct</span> list_head migration_queue;</div><div class="line"><span class="number">338</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">339</span> </div><div class="line"><span class="number">340</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHEDSTATS</span></div><div class="line"><span class="number">341</span>         <span class="comment">/* latency stats */</span></div><div class="line"><span class="number">342</span>         <span class="keyword">struct</span> sched_info rq_sched_info;</div><div class="line"><span class="number">343</span> </div><div class="line"><span class="number">344</span>         <span class="comment">/* sys_sched_yield() stats */</span></div><div class="line"><span class="number">345</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_exp_empty;</div><div class="line"><span class="number">346</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_act_empty;</div><div class="line"><span class="number">347</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_both_empty;</div><div class="line"><span class="number">348</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> yld_count;</div><div class="line"><span class="number">349</span> </div><div class="line"><span class="number">350</span>         <span class="comment">/* schedule() stats */</span></div><div class="line"><span class="number">351</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_switch;</div><div class="line"><span class="number">352</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_count;</div><div class="line"><span class="number">353</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> sched_goidle;</div><div class="line"><span class="number">354</span> </div><div class="line"><span class="number">355</span>         <span class="comment">/* try_to_wake_up() stats */</span></div><div class="line"><span class="number">356</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> ttwu_count;</div><div class="line"><span class="number">357</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> ttwu_local;</div><div class="line"><span class="number">358</span> </div><div class="line"><span class="number">359</span>         <span class="comment">/* BKL stats */</span></div><div class="line"><span class="number">360</span>         <span class="keyword">unsigned</span> <span class="keyword">int</span> bkl_count;</div><div class="line"><span class="number">361</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">362</span>         <span class="keyword">struct</span> lock_class_key rq_lock_key;</div><div class="line"><span class="number">363</span> &#125;;</div></pre></td></tr></table></figure>
<h5 id="struct-cfs-rq"><a href="#struct-cfs-rq" class="headerlink" title="struct cfs_rq"></a>struct cfs_rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cfs_rq &#123;</div><div class="line"><span class="number">232</span>         <span class="keyword">struct</span> load_weight load;</div><div class="line"><span class="number">233</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_running;</div><div class="line"><span class="number">234</span> </div><div class="line"><span class="number">235</span>         u64 exec_clock;</div><div class="line"><span class="number">236</span>         u64 min_vruntime;</div><div class="line"><span class="number">237</span> </div><div class="line"><span class="number">238</span>         <span class="keyword">struct</span> rb_root tasks_timeline;</div><div class="line"><span class="number">239</span>         <span class="keyword">struct</span> rb_node *rb_leftmost;</div><div class="line"><span class="number">240</span>         <span class="keyword">struct</span> rb_node *rb_load_balance_curr;</div><div class="line"><span class="number">241</span>         <span class="comment">/* 'curr' points to currently running entity on this cfs_rq.</span></div><div class="line">242          * It is set to NULL otherwise (i.e when none are currently running).</div><div class="line">243          */</div><div class="line"><span class="number">244</span>         <span class="keyword">struct</span> sched_entity *curr;</div><div class="line"><span class="number">245</span> </div><div class="line"><span class="number">246</span>         <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_spread_over;</div><div class="line"><span class="number">247</span> </div><div class="line"><span class="number">248</span> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></div><div class="line"><span class="number">249</span>         <span class="keyword">struct</span> rq *rq;  <span class="comment">/* cpu runqueue to which this cfs_rq is attached */</span></div><div class="line"><span class="number">250</span> </div><div class="line"><span class="number">251</span>         <span class="comment">/*</span></div><div class="line">252          * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in</div><div class="line">253          * a hierarchy). Non-leaf lrqs hold other higher schedulable entities</div><div class="line">254          * (like users, containers etc.)</div><div class="line">255          *</div><div class="line">256          * leaf_cfs_rq_list ties together list of leaf cfs_rq's in a cpu. This</div><div class="line">257          * list is used during load balance.</div><div class="line">258          */</div><div class="line"><span class="number">259</span>         <span class="keyword">struct</span> list_head leaf_cfs_rq_list;</div><div class="line"><span class="number">260</span>         <span class="keyword">struct</span> task_group *tg;  <span class="comment">/* group that "owns" this runqueue */</span></div><div class="line"><span class="number">261</span> <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="number">262</span> &#125;;</div></pre></td></tr></table></figure>
<h5 id="struct-rt-rq"><a href="#struct-rt-rq" class="headerlink" title="struct rt_rq"></a>struct rt_rq</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rt_rq &#123;</div><div class="line"><span class="number">266</span>         <span class="keyword">struct</span> rt_prio_array active;</div><div class="line"><span class="number">267</span>         <span class="keyword">int</span> rt_load_balance_idx;</div><div class="line"><span class="number">268</span>         <span class="keyword">struct</span> list_head *rt_load_balance_head, *rt_load_balance_curr;</div><div class="line"><span class="number">269</span> &#125;;</div></pre></td></tr></table></figure>
<p><code>struct rq</code>为一个运行队列，每个CPU都有一个这样的数据结构，在<code>rq</code>中有<code>struct cfs_rq</code>类型的cfs字段，该字段表示一个CFS调度器的运行队列，<code>rq</code>中的<code>struct rt_rq</code>类型的rt字段表示一个实时进程的运行队列。具体细节日后有时间在整理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中x86的内联汇编]]></title>
      <url>http://vinoit.me/2016/08/24/linux-x86-assembly-inline/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文地址:<a href="https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/sdk/assemble/inline/</a></p>
</blockquote>
<p>如果您是 Linux 内核的开发人员，您会发现自己经常要对与体系结构高度相关的功能进行编码或优化代码路径。您很可能是通过将汇编语言指令插入到 C 语句的中间（又称为内联汇编的一种方法）来执行这些任务的。让我们看一下 Linux 中内联汇编的特定用法。（我们将讨论限制在 IA32 汇编。）</p>
<h4 id="GNU-汇编程序简述"><a href="#GNU-汇编程序简述" class="headerlink" title="GNU 汇编程序简述"></a>GNU 汇编程序简述</h4><p>让我们首先看一下 Linux 中使用的基本汇编程序语法。GCC（用于 Linux 的 GNU C 编译器）使用 AT&amp;T 汇编语法。下面列出了这种语法的一些基本规则。（该列表肯定不完整；只包括了与内联汇编相关的那些规则。）</p>
<p><strong>寄存器命名</strong><br>寄存器名称有 % 前缀。即，如果必须使用 eax，它应该用作 %eax。<br>源操作数和目的操作数的顺序<br>在所有指令中，先是源操作数，然后才是目的操作数。这与将源操作数放在目的操作数之后的 Intel 语法不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov %eax, %ebx, transfers the contents of eax to ebx.</div></pre></td></tr></table></figure>
<p><strong>操作数大小</strong><br>根据操作数是字节 (byte)、字 (word) 还是长型 (long)，指令的后缀可以是 b、w 或 l。这并不是强制性的；GCC 会尝试通过读取操作数来提供相应的后缀。但手工指定后缀可以改善代码的可读性，并可以消除编译器猜测不正确的可能性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movb %al, %bl -- Byte move</div><div class="line">movw %ax, %bx -- Word move</div><div class="line">movl %eax, %ebx -- Longword move</div></pre></td></tr></table></figure>
<p><strong>立即操作数</strong><br>通过使用 $ 指定直接操作数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movl $0xffff, %eax -- will move the value of 0xffff into eax register.</div></pre></td></tr></table></figure></p>
<p><strong>间接内存引用</strong><br>任何对内存的间接引用都是通过使用 ( ) 来完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movb (%esi), %al -- will transfer the byte in the memory pointed by esi into al register</div></pre></td></tr></table></figure>
<h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>GCC 为内联汇编提供特殊结构，它具有以下格式：</p>
<p><strong>GCG 的 “asm” 结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  asm ( assembler template</div><div class="line">    </div><div class="line">: output operands               (optional)</div><div class="line">    </div><div class="line">: input operands                (optional)</div><div class="line">    </div><div class="line">: list of clobbered registers   </div><div class="line">    (optional)</div><div class="line">    </div><div class="line">);</div></pre></td></tr></table></figure>
<p>本例中，汇编程序模板由汇编指令组成。输入操作数是充当指令输入操作数使用的 C 表达式。输出操作数是将对其执行汇编指令输出的 C 表达式。<br>内联汇编的重要性体现在它能够灵活操作，而且可以使其输出通过 C 变量显示出来。因为它具有这种能力，所以 “asm” 可以用作汇编指令和包含它的 C 程序之间的接口。<br>一个非常基本但很重要的区别在于 简单内联汇编只包括指令，而 扩展内联汇编包括操作数。要说明这一点，考虑以下示例：</p>
<p><strong>内联汇编的基本要素</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int a=10, b;</div><div class="line">    asm ("movl %1, %%eax;</div><div class="line">    </div><div class="line">movl %%eax, %0;"</div><div class="line">        :"=r"(b)  /* output */    </div><div class="line">        :"r"(a)       /* input */</div><div class="line">        :"%eax"); /* clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，我们使用汇编指令使 “b” 的值等于 “a”。请注意以下几点：</p>
<ul>
<li>“b” 是输出操作数，由 %0 引用，”a” 是输入操作数，由 %1 引用。</li>
<li>“r” 是操作数的约束，它指定将变量 “a” 和 “b” 存储在寄存器中。请注意，输出操作数约束应该带有一个约束修饰符 “=”，指定它是输出操作数。</li>
<li>要在 “asm” 内使用寄存器 %eax，%eax 的前面应该再加一个 %，换句话说就是 %%eax，因为 “asm” 使用 %0、%1 等来标识变量。任何带有一个 % 的数都看作是输入／输出操作数，而不认为是寄存器。</li>
<li>第三个冒号后的修饰寄存器 %eax 告诉将在 “asm” 中修改 GCC %eax 的值，这样 GCC 就不使用该寄存器存储任何其它的值。</li>
<li>movl %1, %%eax 将 “a” 的值移到 %eax 中， movl %%eax, %0 将 %eax 的内容移到 “b” 中。</li>
<li>因为 “b” 被指定成输出操作数，因此当 “asm” 的执行完成后，它将反映出更新的值。换句话说，对 “asm” 内 “b” 所做的更改将在 “asm” 外反映出来。</li>
</ul>
<p>现在让我们更详细的了解每一项的含义。</p>
<h4 id="汇编程序模板"><a href="#汇编程序模板" class="headerlink" title="汇编程序模板"></a>汇编程序模板</h4><p>汇编程序模板是一组插入到 C 程序中的汇编指令（可以是单个指令，也可以是一组指令）。每条指令都应该由双引号括起，或者整组指令应该由双引号括起。每条指令还应该用一个定界符结尾。有效的定界符为新行 (\n) 和分号 (;)。 ‘\n’ 后可以跟一个 tab(\t) 作为格式化符号，增加 GCC 在汇编文件中生成的指令的可读性。 指令通过数 %0、%1 等来引用 C 表达式（指定为操作数）。</p>
<p>如果希望确保编译器不会在 “asm” 内部优化指令，可以在 “asm” 后使用关键字 “volatile”。如果程序必须与 ANSI C 兼容，则应该使用 <code>__asm__</code> 和 <code>__volatile__</code>，而不是 asm 和 volatile。</p>
<h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>C 表达式用作 “asm” 内的汇编指令操作数。在汇编指令通过对 C 程序的 C 表达式进行操作来执行有意义的作业的情况下，操作数是内联汇编的主要特性。</p>
<p>每个操作数都由操作数约束字符串指定，后面跟用括弧括起的 C 表达式，例如：”constraint” (C expression)。操作数约束的主要功能是确定操作数的寻址方式。<br>可以在输入和输出部分中同时使用多个操作数。每个操作数由逗号分隔开。</p>
<p>在汇编程序模板内部，操作数由数字引用。如果总共有 n 个操作数（包括输入和输出），那么第一个输出操作数的编号为 0，逐项递增，最后那个输入操作数的编号为 n -1。总操作数的数目限制在 10，如果机器描述中任何指令模式中的最大操作数数目大于 10，则使用后者作为限制。</p>
<h4 id="修饰寄存器列表"><a href="#修饰寄存器列表" class="headerlink" title="修饰寄存器列表"></a>修饰寄存器列表</h4><p>如果 “asm” 中的指令指的是硬件寄存器，可以告诉 GCC 我们将自己使用和修改它们。这样，GCC 就不会假设它装入到这些寄存器中的值是有效值。通常不需要将输入和输出寄存器列为 clobbered，因为 GCC 知道 “asm” 使用它们（因为它们被明确指定为约束）。不过，如果指令使用任何其它的寄存器，无论是明确的还是隐含的（寄存器不在输入约束列表中出现，也不在输出约束列表中出现），寄存器都必须被指定为修饰列表。修饰寄存器列在第三个冒号之后，其名称被指定为字符串。</p>
<p>至于关键字，如果指令以某些不可预知且不明确的方式修改了内存，则可能将 “memory” 关键字添加到修饰寄存器列表中。这样就告诉 GCC 不要在不同指令之间将内存值高速缓存在寄存器中。</p>
<h4 id="操作数约束"><a href="#操作数约束" class="headerlink" title="操作数约束"></a>操作数约束</h4><p>前面提到过，”asm” 中的每个操作数都应该由操作数约束字符串描述，后面跟用括弧括起的 C 表达式。操作数约束主要是确定指令中操作数的寻址方式。约束也可以指定：</p>
<ul>
<li>是否允许操作数位于寄存器中，以及它可以包括在哪些种类的寄存器中</li>
<li>操作数是否可以是内存引用，以及在这种情况下使用哪些种类的地址</li>
<li>操作数是否可以是立即数</li>
</ul>
<p>约束还要求两个操作数匹配。</p>
<h4 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h4><p>在可用的操作数约束中，只有一小部分是常用的；下面列出了这些约束以及简要描述。有关操作数约束的完整列表，请参考 GCC 和 GAS 手册。</p>
<p><strong>寄存器操作数约束 (r)</strong><br>使用这种约束指定操作数时，它们存储在通用寄存器中。请看下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asm (&quot;movl %%cr3, %0\n&quot; :&quot;=r&quot;(cr3val));</div></pre></td></tr></table></figure>
<p>这里，变量 cr3val 保存在寄存器中，%cr3 的值复制到寄存器上，cr3val 的值从该寄存器更新到内存中。指定 “r” 约束时，GCC 可以将变量 cr3val 保存在任何可用的 GPR 中。要指定寄存器，必须通过使用特定的寄存器约束直接指定寄存器名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">a        eax</div><div class="line">b        ebx</div><div class="line">c        ecx</div><div class="line">d        edx</div><div class="line">S        esi</div><div class="line">D        edi</div><div class="line">I        constant value (0 to 31)</div><div class="line">q,r      dynamically allocated register (see below)</div><div class="line">g        eax, ebx, ecx, edx or variable in memory</div><div class="line">A        eax and edx combined into a 64-bit integer (use long longs)</div></pre></td></tr></table></figure>
<p><strong>内存操作数约束 (m)</strong><br>当操作数位于内存中时，任何对它们执行的操作都将在内存位置中直接发生，这与寄存器约束正好相反，后者先将值存储在要修改的寄存器中，然后将它写回内存位置中。但寄存器约束通常只在对于指令来说它们是绝对必需的，或者它们可以大大提高进程速度时使用。当需要在 “asm” 内部更新 C 变量，而您又确实不希望使用寄存器来保存其值时，使用内存约束最为有效。例如，idtr 的值存储在内存位置 loc 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&quot;sidt %0\n&quot; : :&quot;m&quot;(loc));</div></pre></td></tr></table></figure>
<p><strong>匹配（数字）约束</strong><br>在某些情况下，一个变量既要充当输入操作数，也要充当输出操作数。可以通过使用匹配约束在 “asm” 中指定这种情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asm (&quot;incl %0&quot; :&quot;=a&quot;(var):&quot;0&quot;(var));</div></pre></td></tr></table></figure>
<p>在匹配约束的示例中，寄存器 %eax 既用作输入变量，也用作输出变量。将 var 输入读取到 %eax，增加后将更新的 %eax 再次存储在 var 中。这里的 “0” 指定第 0 个输出变量相同的约束。即，它指定 var 的输出实例只应该存储在 %eax 中。该约束可以用于以下情况：</p>
<ul>
<li>输入从变量中读取，或者变量被修改后，修改写回到同一变量中</li>
<li>不需要将输入操作数和输出操作数的实例分开</li>
</ul>
<p>使用匹配约束最重要的意义在于它们可以导致有效地使用可用寄存器。</p>
<h4 id="一般内联汇编用法示例"><a href="#一般内联汇编用法示例" class="headerlink" title="一般内联汇编用法示例"></a>一般内联汇编用法示例</h4><p>以下示例通过各种不同的操作数约束说明了用法。有如此多的约束以至于无法将它们一一列出，这里只列出了最经常使用的那些约束类型。</p>
<p><code>&quot;asm&quot; 和寄存器约束 &quot;r&quot;</code> 让我们先看一下使用寄存器约束 r 的 “asm”。我们的示例显示了 GCC 如何分配寄存器，以及它如何更新输出变量的值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int x = 10, y;</div><div class="line">    </div><div class="line">    asm ("movl %1, %%eax;</div><div class="line">    </div><div class="line"> "movl %%eax, %0;"</div><div class="line">        :"=r"(y)  /* y is output operand */</div><div class="line">        :"r"(x)       /* x is input operand */</div><div class="line">        :"%eax"); /* %eax is clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该例中，x 的值复制为 “asm” 中的 y。x 和 y 都通过存储在寄存器中传递给 “asm”。为该例生成的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $8,%esp</div><div class="line">movl $10,-4(%ebp)    </div><div class="line">movl -4(%ebp),%edx  /* x=10 is stored in %edx */</div><div class="line">#APP    /* asm starts here */   </div><div class="line">movl %edx, %eax     /* x is moved to %eax */</div><div class="line">movl %eax, %edx     /* y is allocated in edx and updated */</div><div class="line">#NO_APP /* asm ends here */</div><div class="line">movl %edx,-8(%ebp)  /* value of y in stack is updated with </div><div class="line">                </div><div class="line"> the value in %edx */</div></pre></td></tr></table></figure>
<p>当使用 “r” 约束时，GCC 在这里可以自由分配任何寄存器。在我们的示例中，它选择 %edx 来存储 x。在读取了 %edx 中 x 的值后，它为 y 也分配了相同的寄存器。</p>
<p>因为 y 是在输出操作数部分中指定的，所以 %edx 中更新的值存储在 -8(%ebp)，堆栈上 y 的位置中。如果 y 是在输入部分中指定的，那么即使它在 y 的临时寄存器存储值 (%edx) 中被更新，堆栈上 y 的值也不会更新。</p>
<p>因为 %eax 是在修饰列表中指定的，GCC 不在任何其它地方使用它来存储数据。</p>
<p>输入 x 和输出 y 都分配在同一个 %edx 寄存器中，假设输入在输出产生之前被消耗。请注意，如果您有许多指令，就不是这种情况了。要确保输入和输出分配到不同的寄存器中，可以指定 &amp; 约束修饰符。下面是添加了约束修饰符的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    int x = 10, y;</div><div class="line">    </div><div class="line">    asm (&quot;movl %1, %%eax;</div><div class="line">    </div><div class="line"> &quot;movl %%eax, %0;&quot;</div><div class="line">        :&quot;=&amp;r&quot;(y) /* y is output operand, note the    </div><div class="line">                </div><div class="line"> &amp; constraint modifier. */</div><div class="line">        :&quot;r&quot;(x)       /* x is input operand */</div><div class="line">        :&quot;%eax&quot;); /* %eax is clobbered register */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是为该示例生成的汇编代码，从中可以明显地看出 x 和 y 存储在 “asm” 中不同的寄存器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">pushl %ebp</div><div class="line">movl %esp,%ebp</div><div class="line">subl $8,%esp</div><div class="line">movl $10,-4(%ebp)</div><div class="line">movl -4(%ebp),%ecx  /* x, the input is in %ecx */</div><div class="line">#APP</div><div class="line">    movl %ecx, %eax</div><div class="line">    movl %eax, %edx     /* y, the output is in %edx */</div><div class="line">#NO_APP</div><div class="line">movl %edx,-8(%ebp)</div></pre></td></tr></table></figure>
<h4 id="特定寄存器约束的使用"><a href="#特定寄存器约束的使用" class="headerlink" title="特定寄存器约束的使用"></a>特定寄存器约束的使用</h4><p>现在让我们看一下如何将个别寄存器作为操作数的约束指定。在下面的示例中，cpuid 指令采用 %eax 寄存器中的输入，然后在四个寄存器中给出输出：%eax、%ebx、%ecx、%edx。对 cpuid 的输入（变量 “op”）传递到 “asm” 的 eax 寄存器中，因为 cpuid 希望它这样做。在输出中使用 a、b、c 和 d 约束，分别收集四个寄存器中的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">asm (&quot;cpuid&quot;</div><div class="line">: &quot;=a&quot; (_eax),</div><div class="line">&quot;=b&quot; (_ebx),</div><div class="line">&quot;=c&quot; (_ecx),</div><div class="line">&quot;=d&quot; (_edx)</div><div class="line">: &quot;a&quot; (op));</div></pre></td></tr></table></figure>
<p>在下面可以看到为它生成的汇编代码（假设 _eax、_ebx 等… 变量都存储在堆栈上）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">movl -20(%ebp),%eax /* store &apos;op&apos; in %eax -- input */</div><div class="line">#APP</div><div class="line">cpuid</div><div class="line">#NO_APP</div><div class="line">movl %eax,-4(%ebp)  /* store %eax in _eax -- output */</div><div class="line">movl %ebx,-8(%ebp)  /* store other registers in</div><div class="line">movl %ecx,-12(%ebp) </div><div class="line"> respective output variables */</div><div class="line">movl %edx,-16(%ebp)</div></pre></td></tr></table></figure>
<p>strcpy 函数可以通过以下方式使用 “S” 和 “D” 约束来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">asm (&quot;cld\n</div><div class="line">    </div><div class="line">rep\n</div><div class="line">    </div><div class="line">movsb&quot;</div><div class="line">    </div><div class="line">: /* no input */</div><div class="line">    </div><div class="line">:&quot;S&quot;(src), &quot;D&quot;(dst), &quot;c&quot;(count));</div></pre></td></tr></table></figure>
<p>通过使用 “S” 约束将源指针 src 放入 %esi 中，使用 “D” 约束将目的指针 dst 放入 %edi 中。因为 rep 前缀需要 count 值，所以将它放入 %ecx 中。</p>
<p>在下面可以看到另一个约束，它使用两个寄存器 %eax 和 %edx 将两个 32 位的值合并在一起，然后生成一个64 位的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define rdtscll(val) \</div><div class="line"> __asm__ __volatile__ (&quot;rdtsc&quot; : &quot;=A&quot; (val))</div><div class="line">The generated assembly looks like this (if val has a 64 bit memory space).</div><div class="line">#APP</div><div class="line">rdtsc</div><div class="line">#NO_APP</div><div class="line">movl %eax,-8(%ebp)  /* As a result of A constraint </div><div class="line">movl %edx,-4(%ebp)  </div><div class="line"> %eax and %edx serve as outputs */</div><div class="line">Note here that the values in %edx:%eax serve as 64 bit output.</div></pre></td></tr></table></figure>
<h4 id="使用匹配约束"><a href="#使用匹配约束" class="headerlink" title="使用匹配约束"></a>使用匹配约束</h4><p>在下面将看到系统调用的代码，它有四个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \</div><div class="line">type name (type1 arg1, type2 arg2, type3 arg3, type4 arg4) \</div><div class="line">&#123; \</div><div class="line">long __res; \</div><div class="line">__asm__ volatile (&quot;int $0x80&quot; \</div><div class="line">: &quot;=a&quot; (__res) \</div><div class="line">: &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1)),&quot;c&quot; ((long)(arg2)), \</div><div class="line">&quot;d&quot; ((long)(arg3)),&quot;S&quot; ((long)(arg4))); \</div><div class="line">__syscall_return(type,__res); \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上例中，通过使用 b、c、d 和 S 约束将系统调用的四个自变量放入 %ebx、%ecx、%edx 和 %esi 中。请注意，在输出中使用了 “=a” 约束，这样，位于 %eax 中的系统调用的返回值就被放入变量 <strong>res 中。通过将匹配约束 “0” 用作输入部分中第一个操作数约束，syscall 号 </strong>NR_##name 被放入 %eax 中，并用作对系统调用的输入。这样，这里的 %eax 既可以用作输入寄存器，又可以用作输出寄存器。没有其它寄存器用于这个目的。另请注意，输入（syscall 号）在产生输出（syscall 的返回值）之前被消耗（使用）。</p>
<h4 id="内存操作数约束的使用"><a href="#内存操作数约束的使用" class="headerlink" title="内存操作数约束的使用"></a>内存操作数约束的使用</h4><p>请考虑下面的原子递减操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__asm__ __volatile__(</div><div class="line">&quot;lock; decl %0&quot;</div><div class="line">:&quot;=m&quot; (counter)</div><div class="line">:&quot;m&quot; (counter));</div></pre></td></tr></table></figure>
<p>为它生成的汇编类似于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#APP</div><div class="line">    lock</div><div class="line">    decl -24(%ebp) /* counter is modified on its memory location */</div><div class="line">#NO_APP.</div></pre></td></tr></table></figure>
<p>您可能考虑在这里为 counter 使用寄存器约束。如果这样做，counter 的值必须先复制到寄存器，递减，然后对其内存更新。但这样您会无法理解锁定和原子性的全部意图，这些明确显示了使用内存约束的必要性。</p>
<h4 id="使用修饰寄存器"><a href="#使用修饰寄存器" class="headerlink" title="使用修饰寄存器"></a>使用修饰寄存器</h4><p>请考虑内存拷贝的基本实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   asm (&quot;movl $count, %%ecx;</div><div class="line">    </div><div class="line">up: lodsl;  </div><div class="line">    </div><div class="line">stosl;</div><div class="line">    </div><div class="line">loop up;&quot;</div><div class="line">        :           /* no output */</div><div class="line">        :&quot;S&quot;(src), &quot;D&quot;(dst) /* input */</div><div class="line">        :&quot;%ecx&quot;, &quot;%eax&quot; );  /* clobbered list */</div></pre></td></tr></table></figure>
<p>当 lodsl 修改 %eax 时，lodsl 和 stosl 指令隐含地使用它。%ecx 寄存器明确装入 count。但 GCC 在我们通知它以前是不知道这些的，我们是通过将 %eax 和 %ecx 包括在修饰寄存器集中来通知 GCC 的。在完成这一步之前，GCC 假设 %eax 和 %ecx 是自由的，它可能决定将它们用作存储其它的数据。请注意，%esi 和 %edi 由 “asm” 使用，它们不在修饰列表中。这是因为已经声明 “asm” 将在输入操作数列表中使用它们。这里最低限度是，如果在 “asm” 内部使用寄存器（无论是明确还是隐含地），既不出现在输入操作数列表中，也不出现在输出操作数列表中，必须将它列为修饰寄存器。</p>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>总的来说，内联汇编非常巨大，它提供的许多特性我们甚至在这里根本没有涉及到。但如果掌握了本文描述的基本材料，您应该可以开始对自己的内联汇编进行编码了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之进程（三）]]></title>
      <url>http://vinoit.me/2016/08/24/linux-kernel-note-process-three/</url>
      <content type="html"><![CDATA[<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（process switch）、任务切换（task switch）或上下文切换（content switch）。</p>
<h4 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h4><p>尽管每个进程都有自己的地址空间，但所有进程必须共享CPU寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装载了挂起进程时所需要的值。</p>
<p>进程恢复执行前必须装入寄存器的一组数据成为硬件上下文（hardware context）。硬件上下文是进程可执行上下文的一个自己，因为可执行上下文包含进程执行时所需要的所有信息。在Linux中，进程硬件上下午的一部分存放在<code>TSS段</code>，而剩余部分存放在<code>内核态堆栈</code>中。</p>
<p>在下面描述中，假定用prev局部变量表示切换出的进程描述符，next表示切换进的进程描述符,<code>这2个局部变量都存放在进程的内核堆栈中</code>。因此，我们把进程切换定义为这样的行为：保存prev硬件上下文，用next硬件上下文代替prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。</p>
<p>早期Linux版本利用80x86体系结构所需提供的硬件支持，并通过far jmp1指令跳到next进程TSS描述符的选择符来执行进程切换。当执行这条指令时，CPU通过自动保存原来的硬件上下文，装入新的硬件上下文来执行硬件上下文切换。但Linux2.6使用软件执行进程切换，原因有：</p>
<p>通过一组mov指令逐步执行切换，这样能较好地控制所装入的数据的合法性，一面被恶意用户伪造。far jmp指令不会有这样的检查。<br>旧方法和新方法所需时间大致相同。<br>进程切换值发生在<code>内核态</code>，在执行进程切换之前，用户态进程使用的所有寄存器内容已保存在内核堆栈上，这也包括ss和esp这对寄存器的内容。</p>
<h4 id="任务状态段"><a href="#任务状态段" class="headerlink" title="任务状态段"></a>任务状态段</h4><p>80x86体系结构包含了一个特殊的段类型，叫任务状态段（Task State Segment，TSS）来存放硬件上下文，尽管Linux并不使用硬件上下文切换，但是强制它为系统中每个不同的CPU创建一个TSS，这样做主要有两个理由：</p>
<p>当80x86的一个CPU从用户态切换到内核态时，它就从TSS中获取内核态堆栈的地址。<br>当用户态进程试图通过in或out指令访问一个I/O端口时，CPU需要访问存放在TSS中的I/O许可位图以检查该进程是否有访问端口的权利。<br>更确切的说，当进程在用户态执行in或out指令时，控制单元执行下列操作：</p>
<p>检查eflags寄存器中的2位IOPL字段，如果字段的值为3，控制单元就执行I/O指令。否则，执行下一个检查。<br>访问tr寄存器以确定当前的TSS和相应的I/O许可权位图。<br>检查I/O指令中指定的I/O端口在I/O许可权位图中对应的位，如果该位清，这条指令就执行，否则控制单元产生一个异常。<br>tss_struct结构描述TSS的格式，<code>init_tss数组</code>为系统上每个不同的CPU存放一个TSS。在每次进程切换时，内核都更新TSS的某些字段以便相应的CPU控制单元可以安全地检索到它需要的信息。因此，<code>TSS反映了CPU上当前进程的特权级，但不必为没有在运行的进程保留TSS</code>。</p>
<p>每个TSS有它自己8字节的任务状态段描述符（Task State Segment Descriptor，TSSD）。和其他描述符一样，这个描述符包括指向TSS起始地址的32位Base字段，20位Limit字段。TSSD的S标志位被清0，以表示相应的TSS是<code>系统段</code>的事实。</p>
<p>Type字段被置位11或9以表示这个段实际上是一个TSS。在Intel的原始设计中，<code>系统中的每个进程都应当指向自己的TSS</code>；Type字段的第二个有效位叫Busy位；如果进程正由CPU执行，则该位置1，否则为0。在Linux的设计中，<code>每个CPU只有一个TSS</code>，因此Busy位总是为1.</p>
<p>由Linux创建的TSSD存放在全局描述符表（GDT）中，GDT的基地址存放在每个CPU的gdtr寄存器中。<br><img src="/images/linux-kernel-note/process-three-0.png" alt=""><br>每个CPU的tr寄存器包含相应TSS的TSSD选择符，也包含了两个<code>隐藏的非编程字段</code>：TSSD的Base字段和Limit字段。这样，处理器就能够直接TSS寻址而不需要从GDT中检索TSS地址。</p>
<h4 id="thread字段"><a href="#thread字段" class="headerlink" title="thread字段"></a>thread字段</h4><p>在每次进程切换时，被替换的进程的硬件上下文必须保存在别处。不能像Intel原始设计那样保存在TSS中，因为<code>Linux为每个处理器而不是为每个进程使用TSS</code>。</p>
<p>因此，每个进程描述符包含一个类型为thread_struct的thread字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。随后可以看到，这个数据结构包含的字段涉及大部分CPU寄存器，但不包括eax、ebx等等这些通用寄存器。它们的值保留在内核堆栈中。</p>
<h4 id="执行进程切换"><a href="#执行进程切换" class="headerlink" title="执行进程切换"></a>执行进程切换</h4><p>进程切换可能只发生在精心定义的点：schedule()函数，这个函数在专门整理进程调度的篇幅里讲解。这里，只关注内核如何执行一个进程切换。</p>
<p>进程切换由两步组成：</p>
<ul>
<li>切换页全局目录以安装一个新的地址空间。</li>
<li>切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包含CPU寄存器。</li>
</ul>
<p>第二步由<code>switch_to</code>宏来完成，源码如下:</p>
<p><a href="http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/asm-generic/switch_to.h#L25</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*</span></div><div class="line">  * Context switching is now performed out-of-line in switch_to.S</div><div class="line">  */</div><div class="line"> <span class="keyword">extern</span> <span class="keyword">struct</span> task_struct *<span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *,</div><div class="line">                                        <span class="keyword">struct</span> task_struct *);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(prev, next, last)                                      											                         \</span></div><div class="line">        do &#123;                                                            \</div><div class="line">                ((last) = __switch_to((prev), (next)));                 			                                                   \</div><div class="line">        &#125; while (0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __ASM_GENERIC_SWITCH_TO_H */</span></span></div></pre></td></tr></table></figure>
<p>首先，该宏有三个参数，prev、next和last，prev和next的作用仅是<code>内核堆栈中</code>的局部变量prev和next的占位符，即它们是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。</p>
<p>在任何进程切换中，涉及到的是三个进程而不是两个。假设内核决定暂停进程A而激活进程B，在schedule()函数中，prev指向A的描述符，而next指向B的进程描述符。switch_to宏一旦使A暂停，A的执行流就被冻结。</p>
<p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。B的内核堆栈中的<code>prev</code>指向B的描述符，<code>next</code>指向other(下一个要调度的进程描述符，目前未知)。</strong></p>
<p>随后，当内核想再次激活A，就必须暂停另一个进程C，因为这通常不是B，因为B有可能被其他进程比如C切换。于是就要用prev指向C而next指向A来执行另一个switch_to宏。当A恢复它执行的流时，就会找到它原来的内核栈，于是prev局部变量还是指向A的描述符而next指向B的描述符。</p>
<p><strong>此时，A的内核堆栈中的<code>prev</code>指向A的描述符，<code>next</code>指向B的描述符。C的内核堆栈中的<code>prev</code>指向C的描述符，<code>next</code>指向A的描述符。</strong></p>
<p>所以，<code>代表进程A执行的内核就失去了对C的任何引用</code>。但引用对于完成进程切换是有用的，所以需要保留。</p>
<p>switch_to宏的最后一个参数是输出参数，它表示宏把进程C的描述符地址写在内存的什么位置了，不过，这个是在恢复A执行之后完成的。在进程切换之前，宏把第一个输入参数prev表示的变量存入CPU的eax寄存器。在完成进程切换，A已经恢复执行时，宏把CPU的eax寄存器的内容写入由第三个参数last所指示的A在内存中的位置。因为CPU寄存器不会在切换点发生变化，所以C的描述符地址也存在内存的这个位置。在schedule()执行过程中，last参数指向A的局部变量prev，所以prev被C的地址覆盖。</p>
<h4 id="switch-to-函数"><a href="#switch-to-函数" class="headerlink" title="__switch_to()函数"></a>__switch_to()函数</h4><p><strong>switch_to()函数执行大多数开始于switch_to()宏的进程切换。这个函数作用于prev_p和next_p参数，这两个参数表示前一个进程和新进程。这个函数的调用不同于一般的函数调用。因为</strong>switch_to()从eax和edx取参数prev_p和next_p，而不像大多数函数一样从栈中取参数。</p>
<p><a href="http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242" target="_blank" rel="external">http://lxr.free-electrons.com/source/arch/x86/kernel/process_32.c#L242</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="number">__</span>switch_to(<span class="keyword">struct</span> task_struct *prev_p, <span class="keyword">struct</span> task_struct *next_p)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> thread_struct *prev = &amp;prev_p-&gt;thread,</div><div class="line">                             *next = &amp;next_p-&gt;thread;</div><div class="line">        <span class="keyword">struct</span> fpu *prev_fpu = &amp;prev-&gt;fpu;</div><div class="line">        <span class="keyword">struct</span> fpu *next_fpu = &amp;next-&gt;fpu;</div><div class="line">        <span class="keyword">int</span> cpu = smp_processor_id();</div><div class="line">        <span class="keyword">struct</span> tss_struct *tss = &amp;per_cpu(cpu_tss, cpu);</div><div class="line">        <span class="keyword">fpu_switch_t</span> fpu_switch;</div><div class="line"></div><div class="line">        <span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></div><div class="line"></div><div class="line">        fpu_switch = switch_fpu_prepare(prev_fpu, next_fpu, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Save away %gs. No need to save %fs, as it was saved on the</div><div class="line">         * stack on entry.  No need to save %es and %ds, as those are</div><div class="line">         * always kernel segments while inside the kernel.  Doing this</div><div class="line">         * before setting the new TLS descriptors avoids the situation</div><div class="line">         * where we temporarily have non-reloadable segments in %fs</div><div class="line">         * and %gs.  This could be an issue if the NMI handler ever</div><div class="line">         * used %fs or %gs (it does not today), or if the kernel is</div><div class="line">         * running inside of a hypervisor layer.</div><div class="line">         */</div><div class="line">        lazy_save_gs(prev-&gt;gs);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Load the per-thread Thread-Local Storage descriptor.</div><div class="line">         */</div><div class="line">        load_TLS(next, cpu);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore IOPL if needed.  In normal use, the flags restore</div><div class="line">         * in the switch assembly will handle this.  But if the kernel</div><div class="line">         * is running virtualized at a non-zero CPL, the popf will</div><div class="line">         * not restore flags, so it must be done in a separate step.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</div><div class="line">                set_iopl_mask(next-&gt;iopl);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Now maybe handle debug registers and/or IO bitmaps</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (unlikely(task_thread_info(prev_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_PREV ||</div><div class="line">                     task_thread_info(next_p)-&gt;flags &amp; <span class="number">_</span>TIF_WORK_CTXSW_NEXT))</div><div class="line">                <span class="number">__</span>switch_to_xtra(prev_p, next_p, tss);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Leave lazy mode, flushing any hypercalls made here.</div><div class="line">         * This must be done before restoring TLS segments so</div><div class="line">         * the GDT and LDT are properly updated, and must be</div><div class="line">         * done before fpu__restore(), so the TS bit is up</div><div class="line">         * to date.</div><div class="line">         */</div><div class="line">        arch_end_context_switch(next_p);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Reload esp0 and cpu_current_top_of_stack.  This changes</div><div class="line">         * current_thread_info().</div><div class="line">         */</div><div class="line">        load_sp0(tss, next);</div><div class="line">        this_cpu_write(cpu_current_top_of_stack,</div><div class="line">                       (<span class="keyword">unsigned</span> <span class="keyword">long</span>)task_stack_page(next_p) +</div><div class="line">                       THREAD_SIZE);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Restore %gs if needed (which is common)</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</div><div class="line">                lazy_load_gs(next-&gt;gs);</div><div class="line"></div><div class="line">        switch_fpu_finish(next_fpu, fpu_switch);</div><div class="line"></div><div class="line">        this_cpu_write(current_task, next_p);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> prev_p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数执行步骤如下：</p>
<ul>
<li><p>执行由__unlay_fpu()宏代码产生的代码，以有选择地保存prev_p进程的FPU、MMX以及XMM寄存器的内容。</p>
</li>
<li><p>执行smp_processor_id()宏获得本地CPU的下标，即执行代码当前的CPU。该宏从当前进程的thread_info结构的cpu字段获得下标并保存到cpu局部变量。</p>
</li>
<li><p>把next_p-&gt;thread.esp0装入对应于本地CPU的TSS的esp0字段。其实，任何由sysenter汇编指令产生的从用户态到内核态的特权级转换将把这个地址拷贝到esp寄存器中。</p>
</li>
<li><p>把next_p进程使用的线程局部存储（TLS）段装载入本地CPU的全局描述符表。</p>
</li>
<li><p>把fs和gs段寄存器的内容分别存放在prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中。esi寄存器指向prev_p-&gt;thread结构。</p>
</li>
<li><p>如果fs或gs段寄存器已经被prev_p或next_p进程中的任意一个使用，则将next_p进程的thread_struct描述符中保存的值装入这些寄存器。</p>
</li>
<li><p>用next_p-&gt;thread.debugreg数组内容装载dr0…dr7中的6个调试寄存器。只有在next_p被挂起时正在使用调试寄存器，这种操作才能进行。</p>
</li>
<li><p>如果必要，则更新TSS中的I/O位图。因为进程很少修改I/O权限位图，所以当且仅当一个进程在当前时间片内实际访问I/O端口时，真实的位图才被拷贝到本地CPU的TSS中。进程的定制I/O权限位图被保存在thread_info结构的io_bitmap_ptr字段指向的缓冲区中。当prev_p或者next_p拥有自己定制的I/O权限位图（io_bitmap_ptr不为null）时,TSS的io_bitmap字段被设为0x9000,否则为0x8000。</p>
</li>
<li><p>终止，prev_p参数被拷贝到eax，<code>因为缺省情况下任何C函数的返回值被传给eax寄存器</code>。所以eax的值在调用__switch_to()的过程中被保护起来；这很重要，因为调用该函数时会假定eax总是用来存放将被替换的进程描述符地址。</p>
</li>
<li><p>汇编语言指令ret把栈顶保存的返回地址装入eip程序计数器。不过，__swtich_to()函数时通过简单的跳转被调用的。因此，ret汇编指令在栈中找到标号为1的指令地址，其中标号为1的地址是由switch_to()宏推入堆栈的。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven常用命令和操作]]></title>
      <url>http://vinoit.me/2016/08/19/maven-common-command-and-operation/</url>
      <content type="html"><![CDATA[<h4 id="Maven-Archetypes"><a href="#Maven-Archetypes" class="headerlink" title="Maven Archetypes"></a>Maven Archetypes</h4><p>Maven archetypes是一个项目模板，可以让Maven按照指定的模板构建出一个项目最基本的文件结构，以及创建一些文件。Maven中有许多项目模板供我们使用，使用方式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate</div></pre></td></tr></table></figure>
<p>执行完上述命令之后，Maven会将当前可用的模板全部列出，我这边是一共列出了1648条。<br><img src="/images/maven/maven-command-and-operation-0.png" alt=""><br>你可以输入一个模板前面的数字或者一个过滤器(按照提示)选择你想要的模板，但这样不怎么方便去找到自己想要的模板。这里有3种解决的办法:</p>
<ol>
<li>你可以将结果导入到一个文本文件中，然后在文件中可以通过关键字查找你所需要的模板信息。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn archetype:generate &gt; archetypes.txt</div></pre></td></tr></table></figure>
</li>
</ol>
<p>2.<code>mvn archetype:create -DgroupId=[your group id] -DartifactId=[your archetype id] -DarchetypeArtifactId=maven-archetype-webapp</code>指定<code>archetypeArtifactId</code>,这样的话就会直接按照所指定的模板构建项目结构。<br>3.<code>mvn archetype:generate -DarchetypeCatalog=internal</code>其中的-DarchetypeCatalog=internal表明使用内置的模板（默认使用中央仓库的模板），这样的话只会列出一些内置的模板，这些内置的模板一般情况下都是能够满足使用的。<br><img src="/images/maven/maven-command-and-operation-1.png" alt=""><br>现在只列出了10条模板，选择第10条模板，然后构建一个webapp的项目结构。<br><img src="/images/maven/maven-command-and-operation-2.png" alt=""><br>按照提示填写一些项目的信息，然后回车，项目结构构建完成，在当前目录下会出现一个以项目名命名的文件夹。<br><img src="/images/maven/maven-command-and-operation-3.png" alt=""></p>
<h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><p>进入到创建好的项目<code>cd maven-webapp/</code>,执行如下命令:<code>mvn compile</code>。成功之后，在项目根目录会出现一个<code>targer</code>文件夹。因为没有java文件，所以其中的<code>classes</code>文件夹为空。<br><img src="/images/maven/maven-command-and-operation-4.png" alt=""></p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>执行<code>mvn package</code>,<code>target</code>文件夹的内容如下。<br><img src="/images/maven/maven-command-and-operation-5.png" alt=""><br>WAR包解压之后就是一个<code>maven-webapp</code>文件夹。<br><code>maven-archiver</code>文件夹中的<code>pom.properties</code>放了一些项目的基本信息:<br><img src="/images/maven/maven-command-and-operation-6.png" alt=""><br>假如该项目引入了其他依赖，则会将所有需要的JAR包放置在WEB-INF文件夹下的lib文件夹中。</p>
<h4 id="部署到本地仓库"><a href="#部署到本地仓库" class="headerlink" title="部署到本地仓库"></a>部署到本地仓库</h4><p>执行<code>mvn install</code>,在本地仓库中出现了该项目的一个库。<br><img src="/images/maven/maven-command-and-operation-7.png" alt=""><br>如果项目产生的是JAR包，则可以在本地的项目中引入并使用该依赖。</p>
<h4 id="部署到github远程仓库"><a href="#部署到github远程仓库" class="headerlink" title="部署到github远程仓库"></a>部署到github远程仓库</h4><p>首先在Maven的<code>setting.xml</code>中按如下方式配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>github<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>YOUR-GITHUB-USERNAME<span class="tag">&lt;/<span class="name">username</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>YOUR-GITHUB-PASSWORD<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>id</code>可以随意取，在<code>pom.xml</code>中通过该id来引用该信息。<br>在<code>pom.xml</code>中按如下方式配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- github server corresponds to entry in ~/.m2/settings.xml --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">github.global.server</span>&gt;</span>github<span class="tag">&lt;/<span class="name">github.global.server</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>internal.repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Temporary Staging Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;project.build.directory&#125;/mvn-repo<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">altDeploymentRepository</span>&gt;</span>internal.repo::default::file://$&#123;project.build.directory&#125;/mvn-repo<span class="tag">&lt;/<span class="name">altDeploymentRepository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.github<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>site-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- git commit message --&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">message</span>&gt;</span>Maven artifacts for $&#123;project.version&#125;<span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- disable webpage processing --&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">noJekyll</span>&gt;</span>true<span class="tag">&lt;/<span class="name">noJekyll</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- matches distribution management repository url above --&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/mvn-repo<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></div><div class="line">              <span class="comment">&lt;!-- remote branch name --&gt;</span></div><div class="line">              <span class="comment">&lt;!-- &lt;branch&gt;refs/heads/master&lt;/branch&gt; --&gt;</span></div><div class="line">              <span class="comment">&lt;!-- If you remove this then the old artifact will be removed and new </span></div><div class="line">               one will replace. But with the merge tag you can just release by changing </div><div class="line">                                                the version --&gt;</div><div class="line">              <span class="tag">&lt;<span class="name">merge</span>&gt;</span>true<span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- github repo name --&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">repositoryName</span>&gt;</span>项目名<span class="tag">&lt;/<span class="name">repositoryName</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- github username --&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">repositoryOwner</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">repositoryOwner</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>site<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上配置中需要修改的地方只有2个地方，github上的项目名称以及你的用户名（注意不是邮箱）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- github repo name --&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">repositoryName</span>&gt;</span>项目名<span class="tag">&lt;/<span class="name">repositoryName</span>&gt;</span></div><div class="line">         <span class="comment">&lt;!-- github username --&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">repositoryOwner</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">repositoryOwner</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后执行<code>mvn clean deploy</code>，在你的<code>target</code>目录下会生成一个名为<code>mvn-repo</code>的文件夹，这就是生成的库，不出意外的话，在你的指定的github项目上的<code>gh-pages</code>分支（默认）会出现一个Maven库。你也可以指定某个分支,比如master:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- remote branch name --&gt;</div><div class="line">             &lt;branch&gt;refs/heads/master&lt;/branch&gt;</div></pre></td></tr></table></figure>
<h4 id="引用github远程仓库的依赖"><a href="#引用github远程仓库的依赖" class="headerlink" title="引用github远程仓库的依赖"></a>引用github远程仓库的依赖</h4><p><code>pom.xml</code>按如下方式配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>不重样即可<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.github.com/用户名/项目名/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这是我在<code>github</code>上的远程仓库，一个小demo。<a href="https://github.com/vinoZHU/my-maven-repo" target="_blank" rel="external">https://github.com/vinoZHU/my-maven-repo</a></p>
<h4 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h4><p>以下常用命令摘自:<a href="http://lychie.github.io/pages/articles/maven/15040920.html" target="_blank" rel="external">http://lychie.github.io/pages/articles/maven/15040920.html</a></p>
<ul>
<li>test  [ 运行测试 ]<br><code>mvn test</code></li>
<li>-e  [ 显示错误详细信息 ]<br><code>mvn -e test</code></li>
<li>site  [ 生成站点文件 ]<br><code>mvn site</code> ( 见 target/site 目录 )</li>
<li>package  [ 打包 ]<br><code>mvn package</code></li>
<li>install  [ 安装到本地仓库 ]<br><code>mvn install</code> ( 见本地仓库 ${groupId}/${artifactId} 目录 )</li>
<li>compile  [ 编译源代码 ]<br><code>mvn compile</code></li>
<li>test-compile  [ 编译测试代码 ]<br><code>mvn test-compile</code></li>
<li>clean  [ 清除目标目录产生的结果 ]<br><code>mvn clean</code></li>
<li>-Dmaven.test.skip  [ 跳过测试 ]<br><code>mvn -Dmaven.test.skip package</code></li>
<li>-Dmaven.test.failure.ignore  [ 忽略测试失败 ]<br><code>mvn -Dmaven.test.failure.ignore package</code></li>
<li>dependency:sources  [ 依赖包源码 ]<br><code>mvn dependency:sources</code></li>
<li>dependency:tree  [ 项目依赖树 ]<br><code>mvn dependency:tree</code></li>
<li>project-info-reports:dependencies  [ 项目依赖报告 ]<br><code>mvn project-info-reports:dependencies</code>( 见 target/site/dependencies.html )</li>
<li>help:effective-pom  [ 查看有效的 pom 配置 ]<br><code>mvn help:effective-pom</code> ( 暴露 super pom )</li>
<li>help:describe  [ 获取插件帮助 ]<br><code>mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull</code></li>
<li>dependency:resolve  [ 已解决的依赖列表 ]<br><code>mvn dependency:resolve</code></li>
<li>idea:idea  [ 转换成 idea 项目 ]<br><code>mvn idea:idea</code></li>
<li>eclipse:eclipse  [ 转换成 eclipse 项目 ]<br><code>mvn eclipse:eclipse</code></li>
<li>archetype:create  [ 创建 java 项目 ]<br><code>mvn archetype:create -DgroupId=org.lychie -DartifactId=myapp</code></li>
<li>archetype:create  [ 创建 web 项目 ]<br><code>mvn archetype:create -DgroupId=org.lychie -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-webapp</code></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要整理了Maven的一些常见操作和命令，未整理的部分日后再补充吧。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>







</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven小教]]></title>
      <url>http://vinoit.me/2016/08/18/maven-tutorial/</url>
      <content type="html"><![CDATA[<h4 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h4><p>Maven最令人印象深刻的也许是它所提供依赖管理，但是Maven的功能远不止这些，Maven是一个java项目构建工具(build tool)。通常来说，一个项目构建工具需要具备以下这些功能甚至更多:</p>
<ul>
<li>在条件允许的情况下能自动生成源代码。</li>
<li>根据源代码能自动生成文档</li>
<li>能编译源代码</li>
<li>对于java项目，要能将编译好的代码打包成JAR包，WAR包等。</li>
<li>能将打包后的文件部署在服务器、仓库或者其他地方。</li>
<li>。。。</li>
</ul>
<p>这些步骤虽然也可以人工手动完成，但是效率比不上构建工具，况且人工出错的概率更大。</p>
<h4 id="Maven总览–核心概念"><a href="#Maven总览–核心概念" class="headerlink" title="Maven总览–核心概念"></a>Maven总览–核心概念</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>Maven最核心的就是一个叫做<code>pom.xml</code>的文件，使用Maven构建项目时所需要的所有信息都包含在该文件中，例如项目的版本号，需要的依赖包等等。当你执行一条<code>mvn *</code>命令时，Maven需要根据<code>pom.xml</code>中的描述来进行操作。</p>
<h5 id="Build-Life-Cycles-Phases-and-Goals"><a href="#Build-Life-Cycles-Phases-and-Goals" class="headerlink" title="Build Life Cycles, Phases and Goals"></a>Build Life Cycles, Phases and Goals</h5><p>Maven的构建过程被分成几个生命周期，一个生命周期又被分为若干个阶段，同时一个阶段中又会有若干个目标(相当于一个特定任务)。一条Maven命令通常为<code>mvn *</code>,其中<code>*</code>的内容为某个生命周期的名字，或者某个阶段的名字，又或者某个目标的名字。这三者在后文会给出具体解释。</p>
<h5 id="Dependencies-and-Repositories"><a href="#Dependencies-and-Repositories" class="headerlink" title="Dependencies and Repositories"></a>Dependencies and Repositories</h5><p>所谓依赖就是项目中需要用到的一些第三方库(JAR files)，如果在本地仓库找不到需要的依赖，Maven会从中央仓库下载到本地仓库。具体内容在后文会涉及到。</p>
<h5 id="Build-Plugins"><a href="#Build-Plugins" class="headerlink" title="Build Plugins"></a>Build Plugins</h5><p>插件的作用是往构建时的阶段（Phases）中增添一些目标(Goals),相当于做一些额外的任务。Maven提供了一些标准插件，同时你也可以实现自己的插件。更多插件相关信息可查看官网，<a href="http://maven.apache.org/plugin-developers/index.html" target="_blank" rel="external">http://maven.apache.org/plugin-developers/index.html</a></p>
<h5 id="Build-Profiles"><a href="#Build-Profiles" class="headerlink" title="Build Profiles"></a>Build Profiles</h5><p>在开发过程中项目可能需要处于不同的环境，这时候<code>pom.xml</code>中的一些配置可能需要修改。<code>Profiles</code>的作用就是当你在<code>pom.xml</code>中声明了一个<code>&lt;profile&gt;&lt;/profile&gt;</code>标签对之后，标签对里面的内容可以用来替换原本的配置值，具体内容在后文会涉及到。</p>
<h4 id="Maven和Ant的区别"><a href="#Maven和Ant的区别" class="headerlink" title="Maven和Ant的区别"></a>Maven和Ant的区别</h4><p>Ant也是Apache的一个构建工具，两者之间的最大区别是:Ant必须要求指定具体动作，细化程度达到如拷贝一个文件之类的操作。而Maven只要告诉它要做什么，具体做法在Maven中已经预先在<code>Phases</code>和<code>Goals</code>中定义过了。Ant强调怎么去做，而Maven则强调做什么。</p>
<h4 id="Maven-pom-xml分析"><a href="#Maven-pom-xml分析" class="headerlink" title="Maven pom.xml分析"></a>Maven pom.xml分析</h4><p>pom是（Project Object Model）的缩写，每个Maven项目都有一个<code>pom.xml</code>与之对应，文件处于项目的根目录。当一个项目含有多个子项目时，主项目和每个子项目都对应一个<code>pom.xml</code>。此时既可以把整个项目一同构建，也可以只根据子项目的<code>pom.xml</code>来单独构建每个子项目。</p>
<p>文件内容描述了该Maven项目的本身信息，需要的依赖（JAR files），应该构建哪些内容，需要的资源等等。以下是一个最简化的<code>pom.xml</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></div><div class="line">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><code>modelVersion</code>元素指定你所使用的POM模型，4.0.0版本对应Maven 2.x或者3.x版本。</li>
<li><code>groupId</code>元素对于开源项目(e.g.中央仓库的依赖）来说必须是唯一的，因为Maven寻找依赖时必须根据groupId。对于大多数普通使用者来说，groupId和项目包名类似。如果是个网站项目，也可以是网站的域名。这里提一点，假如想让自己的项目变成一个Maven库，以上<code>pom.xml</code>的groupId为<code>com.vino</code>,则在Maven库中的文件目录存在形式为:<code>MAVEN_REPO/com/vino/</code>。</li>
<li><code>artifactId</code>元素包含着项目名。将项目打包时，包名就是该元素内的值。该值中的点号不会变成文件分隔符。假如我有2个项目，groupId都为<code>com.vino</code>, artifactId一个为<code>app1</code>，一个为<code>maven.app2</code>,当我将2个项目部署成本地Maven库时，目录形式为:<code>MAVEN_REPO/com/vino/app1/</code>、<code>MAVEN_REPO/com/vino/maven.app2/</code>。</li>
<li><code>version</code>元素表明当前项目的版本号，相当于在一个项目下面再划分了一个层次。</li>
</ul>
<p>使用上述<code>pom.xml</code>部署成本地Maven库的文件为:<code>MAVEN_REPO/com/vino/maven-app/1.0.0/maven-app-1.0.0.jar</code></p>
<h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><p>只要不是太小的项目，基本上都需要第三方的JAR包。但是这些JAR包一般都是有不同的版本的，如果手动更新、管理这些JAR包，必定又麻烦又费时。Maven内置了依赖管理，只需要在<code>pom.xml</code>中声明，在构建项目时Maven便会将依赖从中央仓库下载到你的本地仓库。如果这些第三方的依赖同时也需要一些其他依赖，Maven会将这些依赖统统下载到你的本地仓库。以下是使用的一个样例:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></div><div class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    </div><div class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>项目中需要的每个依赖，都放在一个<code>&lt;dependency&gt;&lt;/dependency&gt;</code>标签对中，并且用<code>groupId</code>,<code>artifactId</code>,<code>version</code>进行描述。下载到本地之后，两个依赖的目录形式为:<code>MAVEN_REPO/junit/junit/4.8.1/</code>、<code>MAVEN_REPO/org/jsoup/jsoup/1.7.1/</code>。目录内容中除了JAR包，还有一个该依赖的<code>pom.xml</code>文件和一些用于校对内容完整性的文件。</p>
<p><strong>将本地JAR包作为依赖</strong><br>有时候某些开源项目没有放在Maven的中央仓库，需要单独下载。这时候需要将下载到本地的JAR包作为一个项目依赖来使用，具体用法如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mydependency<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mydependency<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;/war/WEB-INF/lib/mydependency.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里需要注意的是: <code>groupId</code>和<code>artifactId</code>可以乱填（但一般是依赖的名字），<code>scope</code>必须填<code>system</code>,表明是本系统的文件，<code>version</code>同样可以乱填，<code>systemPath</code>就是JAR包的位置，<code>${basedir}</code>代表<code>pom.xml</code>所在的目录。</p>
<p><strong>快照依赖</strong><br>所谓快照依赖，就是一些仍处于开发状态的依赖。当使用快照依赖时，你不需要经常性地去手动更新版本号来获得最新的依赖。你可以设置一个时间间隔，Maven会自动的每隔一段时间将依赖下载的本地，即使中央仓库的依赖并未更新。但前提是，该依赖的版本号中的大版本号与<code>pom.xml</code>中的对应:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>假如中央仓库的版本号变成了2.0-SNAPSHOT,则Maven不会下载该依赖。</p>
<h4 id="中央仓库与远程仓库的区别"><a href="#中央仓库与远程仓库的区别" class="headerlink" title="中央仓库与远程仓库的区别"></a>中央仓库与远程仓库的区别</h4><p>中央仓库是Maven官方的一个仓库，而远程仓库放在一个其他的服务器上，Maven可以从该服务器下载依赖。github就可以作为一个远程仓库，当我们把开源项目以约定好的的形式放到到github上之后，可以通过如下方式引用:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>your-mvn-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.github.com/yourGitHubId/mvn-repository/master/releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="Maven-Build-Life-Cycles-Phases-and-Goals"><a href="#Maven-Build-Life-Cycles-Phases-and-Goals" class="headerlink" title="Maven Build Life Cycles, Phases and Goals"></a>Maven Build Life Cycles, Phases and Goals</h4><p>生命周期这个概念听上去感觉很模糊，可以把生命周期理解成一个完整的过程。Maven有3种内置的构建生命周期，相当于3种不同功能的过程:</p>
<ol>
<li>default</li>
<li>clean</li>
<li>site </li>
</ol>
<p>3者之间相互独立，分开执行。</p>
<p><code>clean</code>的功能是就是将已生成的资源文件，编译后文件，JAR包，WAR包等清除，使用方法为:<br><code>mvn clean</code>。</p>
<p><code>site</code>的功能是将当前项目的信息整理成一个文档，执行<code>mvn site</code>后，在项目的<code>target</code>目录下会生成一个<code>site</code>文件夹，其中的内容便是项目文档的html文件。</p>
<p><code>default</code>生命周期做的事就是Maven主要功能，无法直接执行<code>mvn default</code>，只能执行它的阶段(Phases)或者目标(Goals)。</p>
<p>它最常用的阶段(Phases)如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Build Phase</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">validate</td>
<td style="text-align:left">验证项目是否无错误，所有的必须的信息都具备了，包括所需要的依赖是否已经下载。</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:left">编译项目源代码</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:left">运行单元测试中的代码，这些测试的代码不应该没被打包或者部署。</td>
</tr>
<tr>
<td style="text-align:center">package</td>
<td style="text-align:left">将编译好的代码打包成某种格式，比如JAR或者WAR等</td>
</tr>
<tr>
<td style="text-align:center">install</td>
<td style="text-align:left">将package后的包安装到本地仓库，可以作为一个依赖来使用</td>
</tr>
<tr>
<td style="text-align:center">deploy</td>
<td style="text-align:left">将最终的包拷贝到远程仓库，供他人使用</td>
</tr>
</tbody>
</table>
<p>当我想使用<code>package</code>，只需在<code>pom.xml</code>目录执行<code>mvn package</code>,这时候在项目的<code>target</code>下会出现一个WAR包（如果是webapp）。但是我都没编译，怎么就可以打包了呢？事实上，当执行某个阶段命令时，该命令所属的生命周期之前的所有阶段步骤都会按照顺序被执行一遍。所以在<code>mvn package</code>被执行时，之前的命令（包括 mvn compile）已经执行过了。</p>
<p>现在构建阶段已经知道了是怎么回事，现在就剩下目标了，目标可以理解为构建阶段中的一个具体任务。比如<code>dependency:copy-dependencies</code>就是一个目标（任务），执行<code>mvn dependency:copy-dependencies</code>时,会在<code>target</code>目录下生成一个<code>dependency</code>文件夹，内容为该项目使用的所有依赖(JAR files)。</p>
<p>关于这三者的完整的信息可以查看官网，<a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="external">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>
<h4 id="Maven-Build-Profiles"><a href="#Maven-Build-Profiles" class="headerlink" title="Maven Build Profiles"></a>Maven Build Profiles</h4><p>上面提到过，profile可以简单地认为是一个环境。使用方法很简单，如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></div><div class="line">   http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vino<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">profile</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">activation</span>&gt;</span>...<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中的<code>activation</code>用来表明当前profile是否正在使用，如果正在使用，则该profile中的元素会覆盖掉原来的值。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是我整理的一些Maven相关的信息，主要是一些基础的原理性的内容。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之进程（二）]]></title>
      <url>http://vinoit.me/2016/08/16/linux-kernel-note-process-two/</url>
      <content type="html"><![CDATA[<h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><p>进程在运行时的所有信息，如进程优先级、地址空间、访问的文件等等，都是通过进程描述符来记录的。内核正是通过进程描述符来对进程进行管理。进程描述符的数据结构是<code>struct task_struct</code>,与进程相关的所有信息都包含在该数据结构中，可想而知该数据结构是十分复杂的。</p>
<p>在<a href="http://lxr.free-electrons.com/source/include/linux/sched.h#L1458" target="_blank" rel="external"><strong>这里</strong></a>可以查看<code>task_struct</code>的完整结构，下图示意性地描述了该数据结构：<br><img src="/images/linux-kernel-note/process-two-0.png" alt=""><br>在这里只讨论进程的某几个属性，其余属性在之后有关其他内容的文章中会逐渐涉及到，内核的学习需要联系的思维。</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>在<a href="http://lxr.free-electrons.com/source/include/linux/sched.h#L207" target="_blank" rel="external"><strong>这里</strong></a>可以查看进程的所有状态，下面是一些常见的状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TASK_RUNNING</td>
<td style="text-align:left">进程正在执行或者进程已经就绪，正在等待cpu时间片的调度。</td>
</tr>
<tr>
<td style="text-align:center">TASK_INTERRUPTIBLE</td>
<td style="text-align:left">进程因为等待一些条件而被挂起（阻塞）时的状态。此时的进程可以被硬中断、资源的释放、信号等事件（这些事件可以认为是等待的条件）唤醒，然后进程就会从该状态（阻塞）迅速转化成为就绪状态TASK_RUNNING。</td>
</tr>
<tr>
<td style="text-align:center">TASK_UNINTERRUPTIBLE</td>
<td style="text-align:left">意义与TASK_INTERRUPTIBLE类似，但是该状态的进程只有当等待的条件为true时才能被唤醒。一般情况下很少用到，但是在一些驱动程序中很有用。特别是对于驱动探测相关的硬件过程很重要，这个探测过程不能被一些其他的东西给中断，否则就会让进程进入不可预测的状态。</td>
</tr>
<tr>
<td style="text-align:center">__TASK_STOPPED</td>
<td style="text-align:left">进程停止执行，当进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后就会进入该状态。</td>
</tr>
<tr>
<td style="text-align:center">__TASK_TRACED</td>
<td style="text-align:left">表示进程被debugger等进程所暂停（<a href="/2016/08/12/how-debugger-work/">ptrac()调用与调试器相关</a>），此时任何一个信号都会让进程进入该状态</td>
</tr>
<tr>
<td style="text-align:center">EXIT_DEAD</td>
<td style="text-align:left">进程的执行被终止，但是其父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程成为僵尸进程</td>
</tr>
<tr>
<td style="text-align:center">EXIT_ZOMBIE</td>
<td style="text-align:left">进程的最终状态，由于父进程进行了wait4()或者waitpid()系统调用，进程被系统删除</td>
</tr>
</tbody>
</table>
<h4 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h4><p>类Unix操作系统通过进程标识符（PID）来标识一个进程(包括轻量级进程) ，每个进程的PID存放在进程描述符的pid字段中。PID是按顺序编号的，新创建的进程通常是前一个进程的PID+1。不过，32位系统的PID值在缺省情况中的上限为32767，64位是4194303，系统管理员可以通过修改<code>/proc/sys/kernel/pid_max</code>来改变这些值。</p>
<p>内核通过管理一个<code>pidmap_array</code>位图来记录当前已使用的PID，因为一个页框的大小为4KB,恰好为32767bit,所以32位体系结构中一个<code>pidmap_array</code>刚好占据一个单独的页。系统会一直保存这些页不被释放。</p>
<h4 id="标识当前进程"><a href="#标识当前进程" class="headerlink" title="标识当前进程"></a>标识当前进程</h4><p>在内核代码中，经常通过current宏来获得当前在CPU上运行的进程描述符指针，例如，current-&gt;pid返回当前正在执行的进程的PID。我们来看下current宏究竟干了什么：</p>
<p>(Linux/arch/tile/include/asm/current.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> current get_current()</span></div></pre></td></tr></table></figure>
<p>(Linux/include/asm-generic/current.h)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="number">__</span><span class="function">inline__ <span class="keyword">struct</span> task_struct *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">return</span> current_thread_info()-&gt;task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>current_thread_info()</code>返回一个<code>struct thread_info</code>结构的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> thread_info &#123;</div><div class="line">          <span class="keyword">struct</span> task_struct      *task;          <span class="comment">/* main task structure */</span></div><div class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span>           flags;          <span class="comment">/* low level flags */</span></div><div class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span>           status;         <span class="comment">/* thread-synchronous flags */</span></div><div class="line">          <span class="number">__u</span>32                   cpu;            <span class="comment">/* current CPU */</span></div><div class="line">          <span class="keyword">int</span>                     preempt_count;  <span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></div><div class="line">  </div><div class="line">          <span class="keyword">mm_segment_t</span>            addr_limit;     <span class="comment">/* thread address space:</span></div><div class="line">                                                     0-0xBFFFFFFF for user-thread</div><div class="line">                                                     0-0xFFFFFFFF for kernel-thread</div><div class="line">                                                  */</div><div class="line">  </div><div class="line">          <span class="number">__u</span>8                    supervisor_stack[<span class="number">0</span>];</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>返回的<code>thread_info</code>指针就是当前进程描述符中的thread_info字段的指针，而该结构中保存着所属进程的进程描述符指针。<code>为什么不直接把进程描述符指针记录在一个全局变量中？</code>早先的Linux版本的确是这么做的,通过强制引入一个全局静态变量current来标识正在运行进程的描述符。</p>
<p>既然现在是通过<code>thread_info</code>来标识当前进程的，那么如何获得该<code>thread_info</code>的地址呢？</p>
<p>Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区域内，一个是与进程描述符相关的小数据结构thread_info，叫做线程描述符。另一个是内核态的进程堆栈。</p>
<p>内核态的进程堆栈大小通常为8192个字节。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。当几乎没有可用的动态内存空间时，就会很难找到这两个连续页框，因为空闲空间可能存在大量碎片。因此，在80x86体系结构中，在编译时可以设置，以使内核堆栈和线程描述符跨越一个单独的页框。<br><img src="/images/linux-kernel-note/process-two-1.png" alt=""></p>
<p><code>esp</code>寄存器保存着内核态堆栈的栈顶地址，因为内核态堆栈和<code>thread_info</code>处于连续的2个页框，而<code>thread_info</code>处于页框的首地址，只需进行下列的汇编指令就能获得<code>thread_info</code>地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">movl $0xffffe000, %ecx</div><div class="line">andl $esp, %ecx</div><div class="line">movl %ecx, p</div></pre></td></tr></table></figure>
<p>其中变量p中的值便是<code>thread_info</code>的地址，而这3条汇编指令其实也就是<code>current_thread_info()</code>函数所做的事。</p>
<p>当进程切换到内核态之后，esp指针便保存内核栈的栈顶地址。内核直接通过寄存器的值，进行少许计算便能获得当前进程描述符，相比较于早先的全局静态变量，效率是明显提升了。</p>
<h4 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h4><p>对于<code>TASK_RUNNING</code>的进程，内核早先把所有的这些进程放到一个进程双向链表中，但是随着进程数量的增加，维护成本会越来越高。调度程序在扫描链表时花费的时间也随之线性上升。Linix2.6中，优先级相同的进程才会放在一个对应优先级的链表中。如果优先级有n个级别，那么就有n个运行队列。在多处理器系统中，每个CPU都有着n个这样的运行队列。</p>
<p>关于运行队列，在之后整理进程调度的文章中会再次涉及到。</p>
<p>对于<code>__TASK_STOPPED</code>、<code>EXIT_DEAD</code>、<code>EXIT_ZOMBIE</code>状态的进程，内核没有建立相应的双向链表。对于这些进程的访问比较简单，或者通过PID，或者通过特定父进程的子进程链表。</p>
<p>对于<code>TASK_INTERRUPTIBLE</code>、<code>TASK_UNINTERRUPTIBLE</code>状态的进程，由于这些进程所等待的条件并不是同一个。而且进程所提供的信息无法满足快速检索的需要，因此有了等待队列。</p>
<p>在这里讨论的等待队列都表示进程在特定事件上的等待。一个等待队列表示一组睡眠的进程，这些进程所等待的条件都是同一个。当条件满足时，内核会唤醒这些进程。然而，当两个或多个进程互斥的访问某个资源时，此时内核必须只能唤醒一个进程，其余的进程需要继续睡眠。</p>
<p>等待队列由双向链表组成，每个等待队列都有一个队列头:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">__</span>wait_queue_head &#123;</div><div class="line">         <span class="keyword">spinlock_t</span>              lock;<span class="comment">//自旋锁</span></div><div class="line">         <span class="keyword">struct</span> list_head        task_list;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>等待队列中的元素:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">__</span>wait_queue &#123;</div><div class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span>            flags;</div><div class="line">         <span class="keyword">void</span>                    *<span class="keyword">private</span>;<span class="comment">//指向进程描述符</span></div><div class="line">         <span class="keyword">wait_queue_func_t</span>       func;<span class="comment">//唤醒时需要调用的方法</span></div><div class="line">         <span class="keyword">struct</span> list_head        task_list;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p><code>struct list_head</code>在内核中是实现双向链表的关键，在这里不做讨论。</p>
<h4 id="根据PID找到进程描述符"><a href="#根据PID找到进程描述符" class="headerlink" title="根据PID找到进程描述符"></a>根据PID找到进程描述符</h4><p>Linux中有4个pid类型:</p>
<ul>
<li>PID：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。</li>
<li>TGID：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。</li>
<li>PGID：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。</li>
<li>SID：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。</li>
</ul>
<p>既然每个进程都有一个与之关联的PID，在进程描述符中的pid字段保存着PID值，如果通过遍历进程链表来比较PID值，虽然可行，但是相当低效。那么内核肯定维护着PID与进程描述符之间的某种映射关系。内核可以通过这种关系，快速地根据PID找到对应的进程描述符。</p>
<p>内核是通过hash表来解决这个问题的。在内核初始化的时候会动态地为一个散列表数组分配空间,数组长度和机器内存有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> hlist_head *pid_hash;</div></pre></td></tr></table></figure>
<p>初始化函数为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="number">__</span><span class="function">init <span class="title">pidhash_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>散列表数组的元素类型为 <code>struct hlist_head</code>，看下具体是什么:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_head &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *first;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中包含一个<code>struct hlist_node</code>类型的指针:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_node &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *next, **pprev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>struct hlist_node</code>中包含一个<code>struct hlist_node</code>类型的指针和<code>struct hlist_node*</code>类型的指针。</p>
<p>现在散列表和进程之间还没有建立联系，来看下进程中的<code>pids</code>(不是pid)字段的数据结构:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pid_link</div><div class="line"> &#123;</div><div class="line">         <span class="keyword">struct</span> hlist_node node;</div><div class="line">         <span class="keyword">struct</span> pid *pid;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p>
<p>再看下<code>struct pid</code>是什么东西:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pid</div><div class="line">&#123;</div><div class="line">        <span class="keyword">atomic_t</span> count;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</div><div class="line">        <span class="comment">/* lists of tasks that use this pid */</span></div><div class="line">        <span class="keyword">struct</span> hlist_head tasks[PIDTYPE_MAX];</div><div class="line">        <span class="keyword">struct</span> rcu_head rcu;</div><div class="line">        <span class="keyword">struct</span> upid numbers[<span class="number">1</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的<code>tasks</code>字段，这是一个<code>struct hlist_head</code>类型的数组，长度为pid类型数量，也就是4。</p>
<p>再看下其中的<code>struct upid</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> upid &#123;</div><div class="line">        <span class="comment">/* Try to keep pid_chain in the same cacheline as nr for find_vpid */</span></div><div class="line">        <span class="keyword">int</span> nr;<span class="comment">//用于计算hsah值</span></div><div class="line">        <span class="keyword">struct</span> pid_namespace *ns;</div><div class="line">        <span class="keyword">struct</span> hlist_node pid_chain;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下图用来帮助理解几者之间的联系:<br><img src="/images/linux-kernel-note/process-two-2.png" alt=""></p>
<ol>
<li>内核初始化期间为pid_hash数组分配好合适的空间。</li>
<li>当创建了一个新的进程之后，内核随之分配一个进程描述符，然后初始化其中的字段。</li>
<li>根据 task_struct-&gt;pids（struct pid_link类型）-&gt;pid-&gt;numbers(struct upid类型)-&gt;nr的值，调用hash函数，取模，然后定位到pid_hash数组中的某一项。</li>
<li>遍历该项的链表，如果其中没有一项的pid与新创建的相同（线程组的所有进程pid相同），则将该进程插入到链表尾。具体做法是将pids字段(struct pid_link类型)中的node插入到链表末尾。</li>
<li>如果存在一项pid与新创建的进程相同，说明是同一线程组的进程。则通过task_struct-&gt;pids（struct pid_link类型）-&gt;pid-&gt;numbers(struct upid类型)-&gt;pid_chain（struct hlist_node类型）,将其链接到已存在项的tasks数组中对应pid类型的链表中去，这样的链表一共有4条。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要讨论了进程描述符中的某几个属性，包括pid,进程状态。还简单介绍了current宏、进程链表以及如何通过pid快速找到对应进程描述符的地址。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>




</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之进程（一）]]></title>
      <url>http://vinoit.me/2016/08/15/linux-kernel-note-process-one/</url>
      <content type="html"><![CDATA[<h4 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h4><p>说起进程，真是既熟悉又陌生，感觉知道这个玩意儿，但是又不知该如何说起。按照UTLK中的说法，进程是任何多道程序设计的操作系统中的基本概念，<code>通常把进程定义为程序执行的一个实例</code>,貌似大多数OS教科书也是这么定义的。</p>
<p>从内核的角度来看，进程就是消耗系统资源（内存，CPU时间片等）的一个实体。因为每个进程都会有他的执行代码，内核通过调度，让不同的进程可以在CPU上分时执行代码，同时每个进程也都会占用相应的RAM资源。</p>
<h4 id="进程、轻量级进程、线程"><a href="#进程、轻量级进程、线程" class="headerlink" title="进程、轻量级进程、线程"></a>进程、轻量级进程、线程</h4><p>现代OS基本上都支持多线程应用程序–拥有很多相对独立执行流的用户程序共享应用程序的大部分数据结构，Linux也一样。在这样的系统中，一个进程由由多个用户线程组成，每个线程都代表进程的一个执行流。</p>
<p>Linux使用轻量级进程对多线程应用程序提供更好的支持。两个轻量进程程基本上可以共享一些资源，只要其中一个修改了共享资源，另一个就立即查看这种修改。实现多线程应用程序的一个简单方式就是把轻量级进程与每个线程关联起来。在Linux中，一个线程组基本上就是实现了多线程应用的一组轻量级进程。</p>
<p>下图描述了几者之间的关系：<br><img src="/images/linux-kernel-note/process-one-0.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">进程P0有四条执行流，也就是线程，</div><div class="line">主线程t0是它的第一个线程，与进程P0相关联，</div><div class="line">之后衍生出t1、t2、t3三个线程，这三个线程分别与轻量级进程P1、P2、P3相关联，</div><div class="line">所有的进程、轻量级进程、线程组成了线程组。</div><div class="line">轻量级进程也是进程，只不过它与某进程的某特定线程相关联，而且轻量级进程与原进程之间共享了大部分应用程序的数据结构。</div></pre></td></tr></table></figure></p>
<p>pid是进程标识符，tgid是线程组标识符。</p>
<p>每个进程都有自己的pid,同属于一个线程组的所有进程、轻量级进程有同样的tgid，且其为第一个线程所关联的pid。</p>
<p>上图中的所有轻量级进程和进程的tgid均为a,等同于进程的pid。<br>我们看下两个系统调用的实现，就能发现一些端倪（位于kernel/timer.c）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> current-&gt;tgid;</div><div class="line">  &#125;</div><div class="line"> <span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"> &#123;</div><div class="line">   <span class="keyword">return</span> current-&gt;pid;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>从代码里可以清楚的看到，getpid返回的是线程组标识符，gettgid返回的是进程标识符。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要整理了进程的定义以及进程、轻量级进程、线程在Linux中的关系。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之分页机制]]></title>
      <url>http://vinoit.me/2016/08/14/linux-kernel-note-page-mechanism/</url>
      <content type="html"><![CDATA[<p>一个逻辑地址经过<a href="/2016/08/13/linux-kernel-note-segment-mechanism/">分段机制</a>转换为一个线性地址之后，便需要分页单元将线性地址转换为实际的物理地址。</p>
<h4 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h4><p>从80386开始，所有的80x86处理器都支持分页。是否开启分页通过设置cr0寄存器的PG标志来决定，当PG为0时，表示不开启分页，此时线性地址呗解释为物理地址。</p>
<p>分页机制管理的对象是固定大小的存储块，称之为页(page)。分页机制把整个线性地址空间及整个物理地址空间都看成由页组成，在线性地址空间中的任何一页，可以映射为物理地址空间中的任何一页（我们把物理空间中的一页叫做一个页面或页框(page frame)）。</p>
<p>80386中每一页的大小都为4KB，每一页的起始地址都能被4K整除（低12位全为0）。因此，80386把4G的线性地址空间，划分为1M个页面。</p>
<p>把线性地址映射到物理地址的数据结构称为页表，页表存放在主存中，由内核进行适当的初始化。</p>
<h5 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h5><p>Intel处理器在处理一个32位的线性地址时，将其分成3部分（按照Little-Endian)：</p>
<ul>
<li>Directory（目录）：最高10位</li>
<li>Table(页表) ：中间10位</li>
<li>Offset(偏移量) ：最低12位</li>
</ul>
<p>线性地址的转换的流程如下：</p>
<ol>
<li>通过高10位定位到页目录中的某一项，获取一个页表。</li>
<li>通过中间10位定位到页表中的某一项，获取到一个页的起始地址</li>
<li>将低12位（偏移量）+ 步骤2中的得到的页起始地址，获得实际的物理地址。</li>
</ol>
<p>其中的页目录地址存放在cr3寄存器中。</p>
<p><img src="/images/linux-kernel-note/page-mechanism-0.png" alt=""></p>
<h5 id="为什么使用二级模式？"><a href="#为什么使用二级模式？" class="headerlink" title="为什么使用二级模式？"></a>为什么使用二级模式？</h5><p>如果使用一级页表，那么整个页表相当于一个拥有1M个元素的大数组，每个页表项占用的大小为4B，所以整个页表的大小为4M。然而每个活动进程都需要一个独立的页表，绝大多数进程都不会马上使用所有的进程地址空间，相比较直接分配一个映射所有地址空间的一级页表，需要时分配页表显然更加效率。二级模式只为进程实际使用的那些虚拟内存区分配页表，既提升了效率，也减少了内存的使用量。（PS：当使用二级页表时，如果为进程的所有虚拟内存区都分配了页表，这时候的内存使用量是增加的）</p>
<h5 id="页目录项结构"><a href="#页目录项结构" class="headerlink" title="页目录项结构"></a>页目录项结构</h5><p><img src="/images/linux-kernel-note/page-mechanism-1.gif" alt=""></p>
<ul>
<li>第31~12位是20位页表地址，由于页表地址的低12位总为0，所以用高20位指出32位页表地址就可以了。因此，一个页目录最多包含1024个页表地址。</li>
<li>第0位是存在位，如果P=1，表示页表地址指向的该页在内存中，如果P=0，表示不在内存中。</li>
<li>第1位是读/写位，第2位是用户/管理员位，这两位为页目录项提供硬件保护。当特权级为3的进程要想访问页面时，需要通过页保护检查，而特权级为0的进程就可以绕过页保护。</li>
<li>第3位是PWT（Page Write-Through）位，表示是否采用写透方式，写透方式就是既写内存（RAM）也写高速缓存,该位为1表示采用写透方式</li>
<li>第4位是PCD（Page Cache Disable）位，表示是否启用高速缓存,该位为1表示启用高速缓存。</li>
<li>第5位是访问位，当对页目录项进行访问时，A位=1。</li>
<li>第7位是Page Size标志，只适用于页目录项。如果置为1，页目录项指的是4MB的页面，请看后面的扩展分页。</li>
<li>第9~11位由操作系统专用，Linux也没有做特殊之用。</li>
</ul>
<h5 id="页表项结构"><a href="#页表项结构" class="headerlink" title="页表项结构"></a>页表项结构</h5><p><img src="/images/linux-kernel-note/page-mechanism-2.gif" alt=""><br>80386的每个页目录项指向一个页表，页表最多含有1024个页面项，每项4个字节，包含页面的起始地址和有关该页面的信息。页面的起始地址也是4K的整数倍，所以页面的低12位也留作它用。<br>第31~12位是20位物理页面地址，除第6位外第0～5位及9~11位的用途和页目录项一样，第6位是页面项独有的，当对涉及的页面进行写操作时，D位被置1。<br>4GB的内存只有一个页目录，它最多有1024个页目录项，每个页目录项又含有1024个页面项，因此，内存一共可以分成1024×1024=1M个页面。由于每个页面为4K个字节，所以，存储器的大小正好最多为4GB。</p>
<h5 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h5><p>扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。在扩展分页的情况下,分页机制把32位线性地址分成两个域：最高10位的目录域和其余22位的偏移量。</p>
<p>扩展分页地址转换过程如下：<br><img src="/images/linux-kernel-note/page-mechanism-3.png" alt=""></p>
<h5 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h5><p>硬件高速缓存中组相连映射是使用最多的，以下是组相连映射的流程图：<br><img src="/images/linux-kernel-note/page-mechanism-4.jpg" alt=""><br><img src="/images/linux-kernel-note/page-mechanism-5.jpg" alt=""></p>
<h5 id="转换后援缓冲器-TLB"><a href="#转换后援缓冲器-TLB" class="headerlink" title="转换后援缓冲器(TLB)"></a>转换后援缓冲器(TLB)</h5><p>因为在获取页地址时需要去慢速访问主存，而TLB缓存了线性地址和物理地址映射的关系，所以直接在SRAM中就可以获取到对应的物理地址，节省了时间。在多处理器系统中，每个CPU都有自己的TLB，叫做本地TLB。</p>
<h4 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h4><p>Linux使用了一个适合32位和64位系统的分页模型。<br><img src="/images/linux-kernel-note/page-mechanism-6.png" alt=""><br>上图的4种页表分别为:</p>
<ul>
<li>页全局目录</li>
<li>页上级目录</li>
<li>页中间目录</li>
<li>页表</li>
</ul>
<p>页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分成五个部分。图中没有显示位数，因为每一部分的大小与具体的计算机体系结构有关。</p>
<p>对于没有启用物理地址扩展的32位系统，两级页表已经足够了。从本质上说Linux通过使“页上级目录”位和“页中间目录”位全为0，彻底取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个合适的目录项而实现的。</p>
<p>启用了物理地址扩展的32 位系统使用了三级页表。Linux的页全局目录对应80×86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应80×86的页目录，Linux的页表对应80×86的页表。</p>
<p>最后，64位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从硬件的角度，32位地址被分成了三部份。不管理软件怎么做，最终落实到硬件，也只识别这3部分。</p>
<p>从软件的角度，由于多引入了两部份，也就是说，共有五部份。要让二层架构的硬件认识五部分，在地址划分的时候，将页上级目录和页中间目录的长度设置为0就可以了。</p>
<p>这样，操作系统见到的是五部份，硬件还是按它死板的三部份划分，软硬件又和谐了。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>






</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型（六）——final]]></title>
      <url>http://vinoit.me/2016/08/14/java-memeory-model-final/</url>
      <content type="html"><![CDATA[<p>与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ol>
<p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;                            <span class="comment">//普通变量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;                      <span class="comment">//final变量</span></div><div class="line">    <span class="keyword">static</span> FinalExample obj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span> <span class="params">()</span> </span>&#123;     <span class="comment">//构造函数</span></div><div class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></div><div class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span> <span class="params">()</span> </span>&#123;    <span class="comment">//写线程A执行</span></div><div class="line">        obj = <span class="keyword">new</span> FinalExample ();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;       <span class="comment">//读线程B执行</span></div><div class="line">        FinalExample object = obj;       <span class="comment">//读对象引用</span></div><div class="line">        <span class="keyword">int</span> a = object.i;                <span class="comment">//读普通域</span></div><div class="line">        <span class="keyword">int</span> b = object.j;                <span class="comment">//读final域</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法。下面我们通过这两个线程的交互来说明这两个规则。</p>
<h4 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h4><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p>
<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
<p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p>
<ol>
<li>构造一个FinalExample类型的对象；</li>
<li>把这个对象的引用赋值给引用变量obj。</li>
</ol>
<p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：<br><img src="/images/JMM/JMM-final-0.jpg" alt=""><br>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p>
<p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p>
<h4 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h4><p>读final域的重排序规则如下：</p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li>
</ul>
<p>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。</p>
<p>reader()方法包含三个操作：</p>
<ol>
<li>初次读引用变量obj;</li>
<li>初次读引用变量obj指向对象的普通域j。</li>
<li>初次读引用变量obj指向对象的final域i。</li>
</ol>
<p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：<br><img src="/images/JMM/JMM-final-1.png" alt=""><br>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p>
<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<h4 id="如果final域是引用类型"><a href="#如果final域是引用类型" class="headerlink" title="如果final域是引用类型"></a>如果final域是引用类型</h4><p>上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？</p>
<p>请看下列示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] intArray;                     <span class="comment">//final是引用类型</span></div><div class="line"><span class="keyword">static</span> FinalReferenceExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span> <span class="params">()</span> </span>&#123;        <span class="comment">//构造函数</span></div><div class="line">    intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];              <span class="comment">//1</span></div><div class="line">    intArray[<span class="number">0</span>] = <span class="number">1</span>;                   <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程A执行</span></div><div class="line">    obj = <span class="keyword">new</span> FinalReferenceExample ();  <span class="comment">//3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span> <span class="params">()</span> </span>&#123;          <span class="comment">//写线程B执行</span></div><div class="line">    obj.intArray[<span class="number">0</span>] = <span class="number">2</span>;                 <span class="comment">//4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;              <span class="comment">//读线程C执行</span></div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                    <span class="comment">//5</span></div><div class="line">        <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>];       <span class="comment">//6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里final域为一个引用类型，它引用一个int型的数组对象。对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：</p>
<ul>
<li>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ul>
<p>对上面的示例程序，我们假设首先线程A执行writerOne()方法，执行完后线程B执行writerTwo()方法，执行完后线程C执行reader ()方法。下面是一种可能的线程执行时序：<br><img src="/images/JMM/JMM-final-2.png" alt=""><br>在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p>
<p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p>
<h4 id="为什么final引用不能从构造函数内“逸出”"><a href="#为什么final引用不能从构造函数内“逸出”" class="headerlink" title="为什么final引用不能从构造函数内“逸出”"></a>为什么final引用不能从构造函数内“逸出”</h4><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;</div><div class="line"><span class="keyword">static</span> FinalReferenceEscapeExample obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</div><div class="line">    i = <span class="number">1</span>;                              <span class="comment">//1写final域</span></div><div class="line">    obj = <span class="keyword">this</span>;                          <span class="comment">//2 this引用在此“逸出”</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> FinalReferenceEscapeExample ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> reader &#123;</div><div class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;                     <span class="comment">//3</span></div><div class="line">        <span class="keyword">int</span> temp = obj.i;                 <span class="comment">//4</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：<br><img src="/images/JMM/JMM-final-3.png" alt=""><br>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p>
<h4 id="final语义在处理器中的实现"><a href="#final语义在处理器中的实现" class="headerlink" title="final语义在处理器中的实现"></a>final语义在处理器中的实现</h4><p>现在我们以x86处理器为例，说明final语义在处理器中的具体实现。</p>
<p>上面我们提到，写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障。</p>
<p>由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写final域需要的StoreStore障屏会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说在x86处理器中，final域的读/写不会插入任何内存屏障！</p>
<h4 id="JSR-133为什么要增强final的语义"><a href="#JSR-133为什么要增强final的语义" class="headerlink" title="JSR-133为什么要增强final的语义"></a>JSR-133为什么要增强final的语义</h4><p>在旧的Java内存模型中 ，最严重的一个缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整形final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为了1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变（参考文献2中有一个具体的例子，感兴趣的读者可以自行参考，这里就不赘述了）。</p>
<p>为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用），就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型（五）——锁]]></title>
      <url>http://vinoit.me/2016/08/14/java-memeory-model-lock/</url>
      <content type="html"><![CDATA[<h4 id="锁的释放-获取建立的happens-before-关系"><a href="#锁的释放-获取建立的happens-before-关系" class="headerlink" title="锁的释放-获取建立的happens before 关系"></a>锁的释放-获取建立的happens before 关系</h4><p>锁是java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>下面是锁释放-获取的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonitorExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;  <span class="comment">//1</span></div><div class="line">        a++;                             <span class="comment">//2</span></div><div class="line">    &#125;                                    <span class="comment">//3</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;  <span class="comment">//4</span></div><div class="line">        <span class="keyword">int</span> i = a;                       <span class="comment">//5</span></div><div class="line">        ……</div><div class="line">    &#125;                                    <span class="comment">//6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens before规则，这个过程包含的happens before 关系可以分为两类：</p>
<ul>
<li>根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li>
<li>根据监视器锁规则，3 happens before 4。<br>根据happens before 的传递性，2 happens before 5。</li>
</ul>
<p>上述happens before 关系的图形化表现形式如下：<br><img src="/images/JMM/JMM-lock-0.png" alt=""></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>上图表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p>
<h4 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h4><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如下：<br><img src="/images/JMM/JMM-lock-1.png" alt=""><br>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图：<br><img src="/images/JMM/JMM-lock-2.png" alt=""><br>对比锁释放-获取的内存语义与volatile写-读的内存语义，可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p>
<p>下面对锁释放和锁获取的内存语义做个总结：</p>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h4 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h4><p>本文将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();         <span class="comment">//获取锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        a++;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</div><div class="line">    lock.lock();        <span class="comment">//获取锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = a;</div><div class="line">        ……</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();  <span class="comment">//释放锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p>
<p>ReentrantLock的实现依赖于java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。 下面是ReentrantLock的类图（仅画出与本文相关的部分）：<br><img src="/images/JMM/JMM-lock-3.png" alt=""><br>ReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。</p>
<p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : lock()</div><div class="line">FairSync : lock()</div><div class="line">AbstractQueuedSynchronizer : acquire(int arg)</div><div class="line">ReentrantLock : tryAcquire(int acquires)</div></pre></td></tr></table></figure></p>
<p>在第4步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();   <span class="comment">//获取锁的开始，首先读volatile变量state</span></div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isFirst(current) &amp;&amp;</div><div class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面源代码中我们可以看出，加锁方法首先读volatile变量state。</p>
<p>在使用公平锁时，解锁方法unlock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : unlock()</div><div class="line">AbstractQueuedSynchronizer : release(int arg)</div><div class="line">Sync : tryRelease(int releases)</div></pre></td></tr></table></figure></p>
<p>在第3步真正开始释放锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);           <span class="comment">//释放锁的最后，写volatile变量state</span></div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源代码我们可以看出，在释放锁的最后写volatile变量state。</p>
<p>公平锁在释放锁的最后写volatile变量state；在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变的对获取锁的线程可见。</p>
<p>现在我们分析非公平锁的内存语义的实现。</p>
<p>非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。</p>
<p>使用公平锁时，加锁方法lock()的方法调用轨迹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReentrantLock : lock()</div><div class="line">NonfairSync : lock()</div><div class="line">AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</div></pre></td></tr></table></figure></p>
<p>在第3步真正开始加锁，下面是该方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法以原子操作的方式更新state变量，本文把java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p>
<p>这里我们分别从编译器和处理器的角度来分析,CAS如何同时具有volatile读和volatile写的内存语义。</p>
<p>前文我们提到过，编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现volatile读和volatile写的内存语义，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。</p>
<p>下面我们来分析在常见的intel x86处理器中，CAS是如何同时具有volatile读和volatile写的内存语义的。</p>
<p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></div><div class="line">                                              <span class="keyword">int</span> expected,</div><div class="line">                                              <span class="keyword">int</span> x);</div></pre></td></tr></table></figure>
<p>可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：<code>unsafe.cpp</code>，<code>atomic.cpp</code>和<code>atomicwindowsx86.inline.hpp</code>。这个本地方法的最终实现在openjdk的如下位置：<code>openjdk-7-fcs-src-b147-27jun2011\openjdk\hotspot\src\oscpu\windowsx86\vm\ atomicwindowsx86.inline.hpp</code>（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Adding a lock prefix to an instruction on MP machine</div><div class="line">// VC++ doesn't like the lock prefix to be on a single line</div><div class="line">// so we can't insert a label after the lock prefix.</div><div class="line">// By emitting a lock prefix, we can define a label after it.</div><div class="line">#define LOCK_IF_MP(mp) __asm cmp mp, 0  \</div><div class="line">                       __asm je L0      \</div><div class="line">                       __asm _emit 0xF0 \</div><div class="line">                       __asm L0:</div><div class="line"></div><div class="line">inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) &#123;</div><div class="line">  // alternative for InterlockedCompareExchange</div><div class="line">  int mp = os::is_MP();</div><div class="line">  __asm &#123;</div><div class="line">    mov edx, dest</div><div class="line">    mov ecx, exchange_value</div><div class="line">    mov eax, compare_value</div><div class="line">    LOCK_IF_MP(mp)</div><div class="line">    cmpxchg dword ptr [edx], ecx</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</p>
<p>intel的手册对lock前缀的说明如下：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和volatile写的内存语义。</p>
<p>经过上面的这些分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了。</p>
<p>现在对公平锁和非公平锁的内存语义做个总结：</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读这个volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新这个volatile变量,这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用volatile变量的写-读所具有的内存语义。</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ol>
<h4 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h4><p>由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：</p>
<ol>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ol>
<p>Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p>
<ol>
<li>首先，声明共享变量为volatile；</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ol>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：<br><img src="/images/JMM/JMM-lock-4.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核笔记之分段机制]]></title>
      <url>http://vinoit.me/2016/08/13/linux-kernel-note-segment-mechanism/</url>
      <content type="html"><![CDATA[<h4 id="为什么要有分段机制？"><a href="#为什么要有分段机制？" class="headerlink" title="为什么要有分段机制？"></a>为什么要有分段机制？</h4><ul>
<li><p>在8086处理器诞生之前，内存寻址方式就是直接访问物理地址,也就是所谓的实模式。8086处理器为了寻址1M的内存空间，把地址总线扩展到了20位。但是，ALU的宽度<code>只有16位</code>，也就是说，ALU不能计算20位的地址。为了解决这个问题，从而引入了分段机制。<br>为了支持分段，8086处理器设置了四个段寄存器：CS, DS, SS, ES.每个段寄存器都是16位的，都包含着相应段的基址，访存指令中的地址也是16位的。但是，在送入地址总线之前，CPU先把它与某个段寄存器内的值按以下方式相加：<br><code>实际物理地址 = （段寄存器地址 &lt;&lt; 4） + （指令访存地址）</code></p>
</li>
<li><p>80286处理器的地址总线为24位，寻址空间达16M，同时引入了保护模式（指令给出的地址不对应实际的物理地址）</p>
</li>
<li><p>80386处理器是一个32位处理器，ALU和地址总线都是32位的，寻址空间达 4G。它可以不通过分段机制，直接访问4G的内存空间。然而为了兼容前代的处理器，它必须同时支持实模式和保护模式。所以，80386在段寄存器的基础上构筑保护模式，并且保留16位的段寄存器。</p>
</li>
<li><p>从80386之后的处理器，架构基本相似，统称为IA32（32 Bit Intel Architecture）。</p>
</li>
</ul>
<h4 id="IA32架构下的内存寻址"><a href="#IA32架构下的内存寻址" class="headerlink" title="IA32架构下的内存寻址"></a>IA32架构下的内存寻址</h4><h5 id="IA32的三类地址"><a href="#IA32的三类地址" class="headerlink" title="IA32的三类地址"></a>IA32的三类地址</h5><ul>
<li>逻辑地址:<br>机器语言指令用这类地址指定一个操作数的地址或一条指令的地址，最原始的地址就是逻辑地址。</li>
<li>线性地址：<br>将逻辑地址经过分段机制转换之后，便得到了线性地址,每个线性地址都由一个段基址和段内偏移量组成。</li>
<li>物理地址：<br>线性地址经过分页单元的处理之后得到一个实际物理地址，也就是内存单元的实际地址，用于芯片级内存单元寻址。</li>
</ul>
<h5 id="MMU地址转化过程"><a href="#MMU地址转化过程" class="headerlink" title="MMU地址转化过程"></a>MMU地址转化过程</h5><p>以上3类地址是通过MMU（内存管理单元）来进行转换。其中MMU处理时包含2个过程，分段和分页。在这里简单的说明下具体过程：</p>
<blockquote>
<p>当一条机器指令给出一个地址时，这时候的地址便是逻辑地址。</p>
<p>为了得到线性地址，需要从相应的段寄存器中取出16位的段标识符（段选择符），通过这个段标识符可以得到一个段基址。然后将得到的段基址与指令中的地址相加，从而得到一个线性地址。</p>
<p>有了线性地址之后，再通过分页单元得到实际的物理地址。</p>
</blockquote>
<h5 id="IA32的段寄存器"><a href="#IA32的段寄存器" class="headerlink" title="IA32的段寄存器"></a>IA32的段寄存器</h5><p>IA32中有六个16位段寄存器：CS, DS, SS, ES，FS, GS.跟8086的段寄存器不同的是，这些寄存器存放的不再是某个段的基地址，而是某个段的选择符（Selector）。</p>
<h4 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h4><h5 id="段选择符和段寄存器"><a href="#段选择符和段寄存器" class="headerlink" title="段选择符和段寄存器"></a>段选择符和段寄存器</h5><p>段寄存器的唯一目的就是存放段选择符，段选择符是一个16位长的字段：<br><img src="/images/linux-kernel-note/segment-mechanism-0.jpg" alt=""></p>
<p>第01位表示的是请求者的特权，第2位是表指示器，用于指定所使用的描述符表。3~15位是一个索引号，定位到描述符表中的某一项段描述符。</p>
<h5 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h5><p>段描述符说白了就是用来描述段的特征，段描述表放在全局描述符表（GDT）或者局部描述符表（LDT），每个段描述符为8个字节大小。GDT的地址和大小存放在寄存器gdtr中，LDT的地址和大小存放在寄存器ldtr中。</p>
<p>有几种不同类型的段以及它们对应的段描述符，下面列出了Linux中广泛采用的类型：</p>
<p><strong>代码段描述符</strong></p>
<p>表示这个段描述符代表一个代码段，它可以放在GDT或LDT中。该描述符置S标志为1，并且为非系统段。</p>
<p><strong>数据段描述符</strong></p>
<p>表示这个段描述符代表一个数据段，它可以放在GDT或LDT中。该描述符置S标志为1，栈段是通过数据段实现的。</p>
<p><strong>任务状态段描述符（TSSD）</strong></p>
<p>表示这个段描述符代表一个任务状态段（Task State Segment，TSS），也就是说这个段用于保存处理器寄存器的内容。它只能出现在GDT中。根据相应的进程是否正在CPU上运行，其Type字段的值分别为11或9。这个描述符的S标志被置为0。</p>
<p><strong>局部描述符表描述符（LDTD）</strong></p>
<p>这个表示段描述符代表一个包含LDT的段，他置出现在GDT中。相应的Type字段的值为2，S标志被置为0。</p>
<p>下图为段描述符的字段表示：<br><img src="/images/linux-kernel-note/segment-mechanism-1.png" alt=""></p>
<p>相应字段的意义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Base</td>
<td style="text-align:left">包含段的首字节的线性地址</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:left">粒度标志，如果为0，则段大小以字节为单位，否则以4096字节的倍数计算</td>
</tr>
<tr>
<td style="text-align:center">Limit</td>
<td style="text-align:left">存放段最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在一个字节到1MB之间变化，否则，将在4KB到4GB之间变化</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:left">系统标志，如果被置为0，则这是一个系统段，否则为普通的代码段或者数据段</td>
</tr>
<tr>
<td style="text-align:center">Type</td>
<td style="text-align:left">描述了段的类型特征和它的存取权限</td>
</tr>
<tr>
<td style="text-align:center">DPL</td>
<td style="text-align:left">描述符特权等级字段，用于限制这个段的存取。它表示为访问这个段而要求的CPU最小的优先级，因此DPL设置为0的段只能当CPL为0时，也就是内核态才可以访问。DPL设为3则堆任何CPL值都是可访问的</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:left">Segment-Present标志，等于0表示段当前不在主存中。Linux总是把此标志设为1，因为Linux从来不把整个段交换到磁盘上去</td>
</tr>
<tr>
<td style="text-align:center">D或B</td>
<td style="text-align:left">称为D或B标志，取决于是代码段还是数据段，D和B的含义在两种情况下有区别，如果段偏移量的地址是32位长，就基本上把它设置为1，如果偏移量是16位长，则清零</td>
</tr>
<tr>
<td style="text-align:center">AVL</td>
<td style="text-align:left">可以由操作系统使用，但是被Linux忽略</td>
</tr>
</tbody>
</table>
<p>当指令给出一个地址后，硬件的处理顺序如下：</p>
<ol>
<li>根据指令类型选择好段选择符，检查段选择符的TI字段，决定使用GDT还是LDT，再从gftr寄存器或者ldtr寄存器中获得描述符表的地址。</li>
<li>使用段选择符的索引号，定位到段描述符，<code>描述符地址 = 索引号 * 8 + gdtr(ldtr)中的地址</code>。</li>
<li>将段描述符中的Base值与给出的地址相加，从而得到线性地址。</li>
<li>将线性地址通过分页单元换换成物理地址。</li>
</ol>
<p>其中的段描述符地址，在寄存器内容不变的情况下会保存在一个与段寄存器相关的不可编程寄存器中，相当于缓存了这个地址，于是就可以省去前面2个步骤。</p>
<h4 id="Linux中的分段"><a href="#Linux中的分段" class="headerlink" title="Linux中的分段"></a>Linux中的分段</h4><p> Linux的段式管理，事实上只是“哄骗”了一下硬件而已。从2.2版开始，Linux让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。但内核中也用到LDT，那只是在VM86模式中运行Wine，因为就是说在Linux上模拟运行Winodws软件或DOS软件的程序时才使用。</p>
<p> 在内核源码<code>include/asm-i386/segment.h</code>中定义了如下宏:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_CS        14</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_DEFAULT_USER_DS        15</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_BASE        12</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_CS                (GDT_ENTRY_KERNEL_BASE + 0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GDT_ENTRY_KERNEL_DS                (GDT_ENTRY_KERNEL_BASE + 1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)</span></div></pre></td></tr></table></figure>
<p> 把其中的宏替换成数值，则为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS 115      [00000000 1110  0  11]（用户代码段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS 123      [00000000 1111  0  11]（用户数据段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS 96     [00000000 1100  0  00]（内核代码段）</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS 104    [00000000 1101  0  00]（内核数据段）</span></div></pre></td></tr></table></figure>
<p> 方括号后是这四个段选择符的16位二制表示，它们的索引号和T1字段值也可以算出来了：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__USER_CS             index= 14   T1=0</div><div class="line">__USER_DS             index= 15   T1=0</div><div class="line">__KERNEL_CS           index= 12   T1=0</div><div class="line">__KERNEL_DS           index= 13   T1=0</div></pre></td></tr></table></figure>
<p> T1均为0，则表示都使用了GDT，再来看初始化GDT的内容中相应的12-15项(arch/i386/head.S)：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.quad <span class="number">0x00cf9a000000ffff</span>        <span class="comment">/* 0x60 kernel 4GB code at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cf92000000ffff</span>        <span class="comment">/* 0x68 kernel 4GB data at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cffa000000ffff</span>        <span class="comment">/* 0x73 user 4GB code at 0x00000000 */</span></div><div class="line">.quad <span class="number">0x00cff2000000ffff</span>        <span class="comment">/* 0x7b user 4GB data at 0x00000000 */</span></div></pre></td></tr></table></figure>
<p>按照前面段描述符表中的描述，可以把它们展开，发现其16-31位全为0，即四个段的基地址全为0。</p>
<p>这样，给定一个段内偏移地址，按照前面转换公式，0 + 段内偏移，转换为线性地址，可以得出重要的结论，<strong>在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>分段机制的存在主要是为了兼容前代处理器，而Linux巧妙的避开了硬件的死套路，有时候软硬件的结合的确很和谐。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型（四）——volatile]]></title>
      <url>http://vinoit.me/2016/08/13/java-memeory-model-volatile/</url>
      <content type="html"><![CDATA[<h4 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h4><p>当我们声明共享变量为volatile后，对这个变量的读/写将会很特别。理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>;  <span class="comment">//使用volatile声明64位的long型变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</div><div class="line">        vl = l;   <span class="comment">//单个volatile变量的写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</div><div class="line">        vl++;    <span class="comment">//复合（多个）volatile变量的读/写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> vl;   <span class="comment">//单个volatile变量的读</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> vl = <span class="number">0L</span>;               <span class="comment">// 64位的long型普通变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;     <span class="comment">//对单个的普通 变量的写用同一个监视器同步</span></div><div class="line">        vl = l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">//普通方法调用</span></div><div class="line">        <span class="keyword">long</span> temp = get();           <span class="comment">//调用已同步的读方法</span></div><div class="line">        temp += <span class="number">1L</span>;                  <span class="comment">//普通写操作</span></div><div class="line">        set(temp);                   <span class="comment">//调用已同步的写方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="comment">//对单个的普通变量的读用同一个监视器同步</span></div><div class="line">        <span class="keyword">return</span> vl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面示例程序所示，对一个volatile变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</p>
<p>简而言之，volatile变量自身具有下列特性：</p>
<ul>
<li>可见性: 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
<h4 id="volatile写-读建立的happens-before关系"><a href="#volatile写-读建立的happens-before关系" class="headerlink" title="volatile写-读建立的happens before关系"></a>volatile写-读建立的happens before关系</h4><p>上面讲的是volatile变量自身的特性，对程序员来说，volatile对线程的内存可见性的影响比volatile自身的特性更为重要，也更需要我们去关注。</p>
<p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。</p>
<p>从内存语义的角度来说，volatile与监视器锁有相同的效果：volatile写和监视器的释放有相同的内存语义；volatile读与监视器的获取有相同的内存语义。</p>
<p>请看下面使用volatile变量的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></div><div class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></div><div class="line">            ……</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据volatile规则，2 happens before 3。</li>
<li>根据happens before 的传递性规则，1 happens before 4。</li>
</ol>
<p>上述happens before 关系的图形化表现形式如下：<br><img src="/images/JMM/JMM-volatile-0.png" alt=""><br>在上图中，每一个箭头链接的两个节点，代表了一个happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens before保证。</p>
<p>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
<h4 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h4><p>volatile写的内存语义如下：</p>
<p><code>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</code></p>
<p>以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图：<br><img src="/images/JMM/JMM-volatile-1.png" alt=""></p>
<p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p>
<p>volatile读的内存语义如下：</p>
<p><code>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</code></p>
<p>下面是线程B读同一个volatile变量后，共享变量的状态示意图：<br><img src="/images/JMM/JMM-volatile-2.png" alt=""></p>
<p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把volatile写和volatile读这两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p>下面对volatile写和volatile读的内存语义做个总结：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<p>volatile内存语义的实现</p>
<p>下面，让我们来看看JMM如何实现volatile写/读的内存语义。</p>
<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：</p>
<table border="1px"><tr><td>是否能重排序</td><td colspan="3">第二个操作</td></tr><tr><td>第一个操作</td><td>普通读/写</td><td>volatile读</td><td>volatile写</td></tr><tr><td>普通读/写</td><td>&nbsp;</td><td>&nbsp;</td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td>&nbsp;</td><td>NO</td><td>NO</td></tr></table>

<p>举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上表我们可以看出：</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：<br><img src="/images/JMM/JMM-volatile-3.png" alt=""></p>
<p>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<p>这里比较有意思的是volatile写后面的StoreLoad屏障。这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里我们可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：<br><img src="/images/JMM/JMM-volatile-4.png" alt=""></p>
<p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = v1;           <span class="comment">//第一个volatile读</span></div><div class="line">        <span class="keyword">int</span> j = v2;           <span class="comment">// 第二个volatile读</span></div><div class="line">        a = i + j;            <span class="comment">//普通写</span></div><div class="line">        v1 = i + <span class="number">1</span>;          <span class="comment">// 第一个volatile写</span></div><div class="line">        v2 = j * <span class="number">2</span>;          <span class="comment">//第二个 volatile写</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    …                    <span class="comment">//其他方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：<br><img src="/images/JMM/JMM-volatile-5.png" alt=""></p>
<p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器常常会在这里插入一个StoreLoad屏障。</p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以x86处理器为例，上图中除最后的StoreLoad屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的volatile读和写，在 x86处理器平台可以优化成：<br><img src="/images/JMM/JMM-volatile-6.png" alt=""><br>前文提到过，x86处理器仅会对写-读操作做重排序。X86不会对读-读，读-写和写-写操作做重排序，因此在x86处理器中会省略掉这三种操作类型对应的内存屏障。在x86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在x86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p>
<h4 id="JSR-133为什么要增强volatile的内存语义"><a href="#JSR-133为什么要增强volatile的内存语义" class="headerlink" title="JSR-133为什么要增强volatile的内存语义"></a>JSR-133为什么要增强volatile的内存语义</h4><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：<br><img src="/images/JMM/JMM-volatile-7.png" alt=""><br>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile的写-读没有监视器的释放-获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和监视器的释放-获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。如果读者想在程序中用volatile代替监视器锁，请一定谨慎。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型（三）——顺序一致性]]></title>
      <url>http://vinoit.me/2016/08/13/java-memeory-model-sequential-consistency/</url>
      <content type="html"><![CDATA[<h4 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h4><p>当程序未正确同步时，就会存在数据竞争。java内存模型规范对数据竞争的定义如下：</p>
<ul>
<li>在一个线程中写一个变量</li>
<li>在另一个线程读同一个变量</li>
<li>而且写和读没有通过同步来排序</li>
</ul>
<p>当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果（前一章的示例正是如此）。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p>
<p>JMM对正确同步的多线程程序的内存一致性做了如下保证：</p>
<p><code>如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同（马上我们将会看到，这对于程序员来说是一个极强的保证）。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile和final）的正确使用。</code></p>
<h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>不管程序是否同步,所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
<p>顺序一致性内存模型为程序员提供的视图如下：<br><img src="/images/JMM/JMM-sequential-consistency-0.png" alt=""></p>
<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p>
<p>为了更好的理解，下面我们通过两个示意图来对顺序一致性模型的特性做进一步的说明。</p>
<p>假设有两个线程A和B并发执行。其中A线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。</p>
<p>假设这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：<br><img src="/images/JMM/JMM-sequential-consistency-1.png" alt=""><br>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：<br><img src="/images/JMM/JMM-sequential-consistency-2.png" alt=""><br>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>
<p>但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>
<h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>下面我们对前面的示例程序ReorderExample用监视器来同步，看看正确同步的程序如何具有顺序一致性。</p>
<p>请看下面的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">    a = <span class="number">1</span>;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (flag) &#123;</div><div class="line">        <span class="keyword">int</span> i = a;</div><div class="line">        ……</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面示例代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：<br><img src="/images/JMM/JMM-sequential-consistency-3.png" alt=""></p>
<p>在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p>
<p>从这里我们可以看到JMM在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p>
<h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在以清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。</p>
<p>JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。</p>
<p>和顺序一致性模型一样，未同步程序在JMM中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：</p>
<ol>
<li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ol>
<p>第3个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和I/O设备执行内存的读/写。下面让我们通过一个示意图来说明总线的工作机制：<br><img src="/images/JMM/JMM-sequential-consistency-4.png" alt=""></p>
<p>如上图所示，假设处理器A，B和C同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器A在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器A继续它的总线事务，而其它两个处理器则要等待处理器A的总线事务完成后才能开始再次执行内存访问。假设在处理器A执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器D向总线发起了总线事务，此时处理器D的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。</p>
<p>在一些32位的处理器上，如果要求对64位数据的读/写操作具有原子性，会有比较大的开销。为了照顾这种处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的读/写具有原子性。当JVM在这种处理器上运行时，会把一个64位long/ double型变量的读/写操作拆分为两个32位的读/写操作来执行。这两个32位的读/写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的读/写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：<br><img src="/images/JMM/JMM-sequential-consistency-5.png" alt=""></p>
<p>如上图所示，假设处理器A写一个long型变量，同时处理器B要读这个long型变量。处理器A中64位的写操作被拆分为两个32位的写操作，且这两个32位的写操作被分配到不同的写事务中执行。同时处理器B中64位的读操作被拆分为两个32位的读操作，且这两个32位的读操作被分配到同一个的读事务中执行。当处理器A和B按上图的时序来执行时，处理器B将看到仅仅被处理器A“写了一半“的无效值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[调试器基本工作原理]]></title>
      <url>http://vinoit.me/2016/08/12/how-debugger-work/</url>
      <content type="html"><![CDATA[<p>在开发的过程中调试是必不可少的步骤，相应的IDE就能帮我们轻松搞定。但是调试背后的原理我觉得有必要了解，本文描述的是一些调试器方面的基本原理，不当之处欢迎指出。</p>
<h4 id="ptrace-系统调用"><a href="#ptrace-系统调用" class="headerlink" title="ptrace()系统调用"></a>ptrace()系统调用</h4><p>Linux下的调试器实现的主要组成部分就是<code>ptrace()</code>,这是一个功能众多且相当复杂的工具，能允许一个进程控制另一个进程的运行，而且可以监视和渗入到进程内部。其中这2个进程是父子进程的关系，调试的进程是父进程，被调试的则是子进程。</p>
<p>OS X下<code>ptrace()</code>的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">int</span> request, <span class="keyword">pid_t</span> pid, <span class="keyword">caddr_t</span> addr, <span class="keyword">int</span> data)</span></span>;</div></pre></td></tr></table></figure>
<p>其中man手册如此描述参数：</p>
<p><code>The request argument specifies what operation is being performed; the
meaning of the rest of the arguments depends on the operation, but except for one special case noted below,  all ptrace() calls are made by the tracing process, and the pid argument specifies the process ID of the traced process.</code></p>
<p>也就是说<code>request</code>参数表示操作的类型，其他3个参数在不同的操作下意义可能不同，<code>pid</code>永远指向<strong>被调试</strong>的进程。<br><code>request</code>可以有以下值：</p>
<ul>
<li>PT_TRACE_ME</li>
<li>PT_DENY_ATTACH</li>
<li>PT_CONTINUE</li>
<li>PT_STEP</li>
<li>PT_KILL</li>
<li>PT_ATTACH</li>
<li>PT_ATTACHEXC</li>
<li>PT_DETACH </li>
</ul>
<p>某些值由父进程使用，某些则由子进程使用，比如<code>PT_TRACE_ME</code>由子进程调用，从命名上也可以看出来(追踪我)。其中的具体含义可以查看man手册，此处就不多解释了。</p>
<h4 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h4><p>从高层设计来说，我们要写一个程序，它产生一个子进程用来执行一个用户指定的命令，而父进程跟踪这个子进程。首先，main函数是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> child_pid;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Expected a program name as argument\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    child_pid = fork();</div><div class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</div><div class="line">        run_target(argv[<span class="number">1</span>]);<span class="comment">//子进程执行需要被追踪的指令</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>)</div><div class="line">        run_debugger(child_pid);<span class="comment">//父进程追踪子进程</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        perror(<span class="string">"fork"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中<code>run_target(char arg)</code>函数的核心内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ptrace(PT_TRACE_ME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">execl(arg, arg, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>首先执行ptrace系统调用，request值为PT_TRACE_ME，表明进程期待被父进程追踪，这时候一旦调用了<code>execl()</code>,进程被停止运行，然后接收到一个SIGTRAP信号，并等待父进程的操作。</p>
<p>父进程<code>run_debugger()</code>函数的核心内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wait(&amp;wait_status);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (WIFSTOPPED(wait_status)) &#123;</div><div class="line">        <span class="comment">/* Make the child execute another instruction */</span></div><div class="line">        <span class="keyword">if</span> (ptrace(PT_STEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">            perror(<span class="string">"ptrace"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></div><div class="line">        wait(&amp;wait_status);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>循环外面的<code>wait()</code>调用阻塞父进程，直到有子进程停止运行。此时执行while循环的内容，如果子进程由于发送的信号而停止运行，WIFSTOPPED就返回true。循环内的代码就做了2件事，首先调用<code>ptrace()</code>,request值为PT_STEP，使得pid为child_pid的进程单步执行下一条指令。然后再次调用<code>wait()</code>,阻塞等待子进程停止。依次循环，直到子进程结束。</p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>在调试的时候我们可以在期望的地方打上断点，程序运行到断点处自动停止运行。这在Linux中是通过中断机制来实现的，将断点处的指令用<code>int 3</code>来替代，int指令可以产生一个中断，后面的数字是中断号，每个中断号都对应一个处理例程，3号例程专门用来处理调试时的断点。</p>
<p>要在被调试进程中的某个目标地址上设定一个断点，调试器需要做下面两件事情：</p>
<ol>
<li><p>保存目标地址上的数据</p>
</li>
<li><p>将目标地址上的第一个字节替换为int 3指令</p>
</li>
</ol>
<p>然后，当调试器向操作系统请求开始运行进程时，进程最终一定会碰到int 3指令。此时进程停止，操作系统将发送一个信号。这时就是调试器(父进程)再次出马的时候了，接收到一个其子进程（或被跟踪进程）停止的信号，然后调试器要做下面几件事：</p>
<ol>
<li><p>在目标地址上用原来的指令替换掉int 3</p>
</li>
<li><p>将被跟踪进程中的指令指针向后递减1。这么做是必须的，因为现在指令指针指向的是已经执行过的int 3之后的下一条指令。</p>
</li>
<li><p>由于进程此时仍然是停止的，用户可以同被调试进程进行某种形式的交互。这里调试器可以让你查看变量的值，检查调用栈等等。</p>
</li>
<li><p>当用户希望进程继续运行时，调试器负责将断点再次加到目标地址上（由于在第一步中断点已经被移除了），除非用户希望取消断点。</p>
</li>
</ol>
<h4 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h4><p>当你在某些函数的入口处设置断点时，调试器如何知道该在哪里停止目标进程的运行呢？当你希望查看一个变量的值时，调试器又是如何找到它并展示给你呢？答案就是——调试信息。</p>
<p><strong>调试信息是在编译器生成机器码的时候一起产生的。它代表着可执行程序和源代码之间的关系。这个信息以预定义的格式进行编码，并同机器码<code>一起存储</code>。</strong>许多年以来，针对不同的平台和可执行文件，人们发明了许多这样的编码格式。其中一种最重要的格式就是DWARF，作为Linux以及其他类Unix平台上的ELF可执行文件的调试信息格式，如今的DWARF可以说是无处不在。</p>
<p>通过下面的C代码构建一个名为traceprog2的可执行文件来做下实验:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stuff</span><span class="params">(<span class="keyword">int</span> my_arg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> my_local = my_arg + <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; my_local; ++i)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    do_stuff(<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过objdump –h导出ELF可执行文件中的段头信息，我们注意到其中有几个段的名字是以.debug_打头的，这些就是DWARF格式的调试段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">26</span> .debug_aranges <span class="number">00000020</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001037</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">27</span> .debug_pubnames <span class="number">00000028</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001057</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">28</span> .debug_info   <span class="number">000000</span>cc  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">0000107f</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">29</span> .debug_abbrev <span class="number">0000008</span>a  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">0000114b</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">30</span> .debug_line   <span class="number">0000006b</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">000011</span>d5</div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">31</span> .debug_frame  <span class="number">00000044</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001240</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">32</span> .debug_str    <span class="number">000000</span>ae  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001284</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div><div class="line"><span class="number">33</span> .debug_loc    <span class="number">00000058</span>  <span class="number">00000000</span>  <span class="number">00000000</span>  <span class="number">00001332</span></div><div class="line">                 CONTENTS, READONLY, DEBUGGING</div></pre></td></tr></table></figure>
<p>每行的第一个数字表示每个段的大小，而最后一个数字表示距离ELF文件开始处的偏移量。调试器就是利用这个信息来从可执行文件中读取相关的段信息，从而找到可执行程序和源代码之间的关系。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java实现的订单号生成工具类]]></title>
      <url>http://vinoit.me/2016/07/05/java-ordernum-generate/</url>
      <content type="html"><![CDATA[<p>分享一个自己在项目里写的订单号生成工具类，不当之处望各位指出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.project.utils;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Vino on 16/5/7.</div><div class="line"> * 订单生成规则:</div><div class="line"> * 正常情况下:年(2位)+月(2位)+日(2位)+秒(5位)+循环自增值(3位)+随机码(2位)共16位</div><div class="line"> * 非正常情况下:年(2位)+月(2位)+日(2位)+秒(5位)+随机码(5位)共16位</div><div class="line"> * 注:非正常情况在同时开启1W个线程的情况下并未发生</div><div class="line"> * 业务编码(1位)：自营、通用件、全车件待定</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNumGen</span> </span>&#123;</div><div class="line">    <span class="comment">//循环自增上限,超出则从初始值开始</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxLoop = <span class="number">999</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initNum  = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger atomicInteger;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: DCL获取单例atomicInteger</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger <span class="title">getAtomicInteger</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (atomicInteger == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (OrderNumGen.class) &#123;</div><div class="line">                <span class="keyword">if</span> (atomicInteger == <span class="keyword">null</span>)</div><div class="line">                    atomicInteger = <span class="keyword">new</span> AtomicInteger(initNum);<span class="comment">//初始值为100</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> atomicInteger;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: 订单号生成</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取单例</span></div><div class="line">        AtomicInteger atomicInteger = getAtomicInteger();</div><div class="line">        <span class="comment">//原子性自增并返回自增前的值</span></div><div class="line">        <span class="keyword">int</span> nextValue = atomicInteger.getAndIncrement();</div><div class="line">        <span class="comment">//若循环次数已超过上限</span></div><div class="line">        <span class="keyword">if</span> (nextValue &gt; maxLoop) &#123;</div><div class="line">            <span class="comment">//CAS更新值成功</span></div><div class="line">            <span class="keyword">if</span> (atomicInteger.compareAndSet(nextValue + <span class="number">1</span>, initNum)) &#123;</div><div class="line">                atomicInteger.getAndIncrement();</div><div class="line">                <span class="keyword">return</span> getNextNormally(initNum);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">//CAS更新值失败</span></div><div class="line">                <span class="comment">//重新获取</span></div><div class="line">                nextValue = atomicInteger.getAndIncrement();</div><div class="line">                <span class="keyword">if</span> (nextValue &lt;= maxLoop)</div><div class="line">                    <span class="keyword">return</span> getNextNormally(nextValue);</div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//非正常情况下</span></div><div class="line">                    <span class="keyword">return</span> getNextUnNormally();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getNextNormally(nextValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getNextNormally</span><span class="params">(<span class="keyword">int</span> nextValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> randomNum=(<span class="keyword">int</span>)(Math.random()*<span class="number">90</span>)+<span class="number">10</span>;<span class="comment">//2位随机码</span></div><div class="line">        <span class="keyword">return</span> Long.valueOf(getDateNum()+nextValue+randomNum);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getNextUnNormally</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> randomNum = (<span class="keyword">int</span>)(Math.random()*<span class="number">90000</span>)+<span class="number">10000</span>;<span class="comment">//5位随机码</span></div><div class="line">        <span class="keyword">return</span> Long.valueOf(getDateNum()+randomNum);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * author: Vino</div><div class="line">     * date: 2016/5/8</div><div class="line">     * function: 获取订单号中的时间部分</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDateNum</span><span class="params">()</span></span>&#123;</div><div class="line">        Date date = <span class="keyword">new</span> Date();</div><div class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyMMddHHmmss"</span>);</div><div class="line">        String sTime = simpleDateFormat.format(date);</div><div class="line">        Integer nSecond = Integer.valueOf(sTime.substring(<span class="number">6</span>,<span class="number">8</span>)) * <span class="number">60</span> * <span class="number">60</span> +Integer.valueOf(sTime.substring(<span class="number">8</span>,<span class="number">10</span>)) * <span class="number">60</span></div><div class="line">                + Integer.valueOf(sTime.substring(<span class="number">10</span>,<span class="number">12</span>));</div><div class="line">        String sSecond = String.valueOf(nSecond);</div><div class="line">        <span class="keyword">if</span>(sSecond.length() &lt; <span class="number">5</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>,j = sSecond.length(); i &gt; j; i--)&#123;</div><div class="line">                sSecond = <span class="string">"0"</span> + sSecond;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sTime.substring(<span class="number">0</span>,<span class="number">6</span>)+sSecond;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux slab机制中的colouroff]]></title>
      <url>http://vinoit.me/2016/06/29/linux-slab-colour/</url>
      <content type="html"><![CDATA[<h4 id="slab简介"><a href="#slab简介" class="headerlink" title="slab简介"></a>slab简介</h4><p>slab分配器是Linux内存管理中非常重要和复杂的一部分，其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内碎片，而且处理速度也太慢。而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统。slab分配对象时，会使用最近释放的对象内存块，因此其驻留在CPU高速缓存的概率较高。</p>
<h4 id="slab数据结构"><a href="#slab数据结构" class="headerlink" title="slab数据结构"></a>slab数据结构</h4><p>用于描述和管理cache的数据结构是struct kmem_cache，在struct kmem_cache中有一个struct kmem_list3*nodelists[<code>MAX_NUMNODES</code>]，<br>每个nodelists中都有着3条slab双向链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kmem_list3 &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_partial; <span class="comment">/*slab链表，包含空闲对象和已分配对象的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_full;   <span class="comment">/*slab链表，只包含非空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">struct</span> list_head slabs_free;   <span class="comment">/*slab链表，只包含空闲的slab描述符*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;    <span class="comment">/*高速缓存中空闲对象的个数*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;       <span class="comment">/*空闲对象的上限*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;       <span class="comment">/*下一个slab使用的颜色*/</span>  </div><div class="line">    <span class="keyword">spinlock_t</span> list_lock;  </div><div class="line">    <span class="keyword">struct</span> array_cache *shared; <span class="comment">/* shared per node */</span>  </div><div class="line">    <span class="keyword">struct</span> array_cache **alien; <span class="comment">/* on other nodes */</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;    <span class="comment">/* updated without locking */</span>  </div><div class="line">    <span class="keyword">int</span> free_touched;       <span class="comment">/* updated without locking */</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>（其中的<code>MAX_NUMNODES</code>在UMA机制中为1，Linux把物理内存划分为三个层次来管理：存储节点（Node）、管理区（Zone）和页面（Page）。UMA对应一致存储结构，它只需要一个Node就可以描述当前系统中的物理内存）。</p>
<p>每个slab由一个或多个页框组成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> slab &#123;  </div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;  <span class="comment">/*用于将slab链入kmem_list3的链表*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff;<span class="comment">/*该slab的着色偏移*/</span>  </div><div class="line">    <span class="keyword">void</span> *s_mem;            <span class="comment">/*指向slab中的第一个对象*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;     <span class="comment">/*已分配出去的对象*/</span>  </div><div class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;     <span class="comment">/*下一个空闲对象的下标*/</span>  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;  <span class="comment">/*节点标识号*/</span>  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>其中的colouroff代表的是什么呢？</strong></p>
<h4 id="为什么要colouroff"><a href="#为什么要colouroff" class="headerlink" title="为什么要colouroff?"></a>为什么要colouroff?</h4><p>比如cache line 32 字节,  字节0-31一次从内存写入/读取, 字节32-63一次从内存写入/读取…..</p>
<p>另外cache对应到内存位置不是任意的</p>
<p>Cache 地址0 对应到 内存地址0 , 32 ,64 ….</p>
<p>Cache 地址1 对应到 内存地址1 , 33 ,65 ….</p>
<p>…</p>
<p>一个slab大小肯定是整数页,所以起始地址末12位为零, 即都于cache0 对应.</p>
<p>然后2个slab的每一个obj大小一样, 所以2个slab每个obj都对应相同的cache line.</p>
<p>这样2个位置相同的obj都要频繁访问,比较容易使cache来回刷新,效率降低.</p>
<p>着色就是在第二个slab的起始位置空一个cache line出来, 这样2个slab每个obj对应的cache错开一个, 这样2个位置相同的obj即使频繁访问,也不会用一个相同cache line.</p>
<h4 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h4><p>一个L1 DATA CACHE相当于一块小的内存，<code>我们假设它为16K大</code>，它会与一般物理内存交互。<br>它和内存交互一般一次传输16个字节(32个字节),也就是:  </p>
<p>CACHE 字节0-15一次写到/读取物理内存 ，字节16-31一次写到/读取物理内存.32-47 … …  </p>
<p>这些一次被传输的字节被称为cache line。  </p>
<p><strong>注意!!!这里的cache line中的cache指的是cpu中的L1 DATA CACHE ,而不是slab算法中的结构cache,这两个容易混淆。下面提到的cache都是指L1 DATA CACHE,而不是slab算法中的结构cache</strong>  </p>
<hr>
<h4 id="cache-line对齐和colouroff"><a href="#cache-line对齐和colouroff" class="headerlink" title="cache line对齐和colouroff"></a>cache line对齐和colouroff</h4><p>另外，cache写到物理内存的位置不是任意的，<br>我们假定内存为64K,那么cache地址0的数值只能和物理内存的地址0, 16K, 32K交互；cache地址1的数值只能和物理内存的地址1, 16K+1, 32K+1交互<br>。。。 。。。cache地址16K-1的数值只能和物理内存的地址6K-1, 16K+16K-1, 32K+16K -1交互  </p>
<p>这说明了两点:  </p>
<p>(1)假设对象A的一个字段长为16个字节，如果它放在物理地址 0-15,那么它将和cache的第一个cache line 交互，如果放在物理地址 8-23,那么<br>如果CPU要访问这个字段，必须将第一个和第二个cache line 都读入，才能获得这个字段的信息，显然这样速度慢，所以一般字段需要<code>cache line对齐</code>，<br>在这里就是16个字节对齐。  </p>
<p>(2)关于colouroff  </p>
<p>一般一个对象某些字段访问频繁些。<br>假定一个cache(这个cache指slab的cache,不是上面提到CPU的L1 DATA CACHE)占用5个页面也就是20K.<br>假定其中对象大小为32个字节，前16个字节访问频繁许多。  </p>
<p>假定对象A起始于物理地址0，对象C起始于31,对象B起始于物理地址16K,那么对象A，对象B的前16个字节都和第一个cache line 交互，后16个字节都和第二个cache line 交互<br>对象C前16个字节与第3个cache交互。  </p>
<p>我们假定内核访问A后就访问B,再访问A,交错进行，并且前16个字节次数都是50次，后16个为10次。C也是。  </p>
<p>这样第一个cache line 要交互100次，第二个20次，一共120次。  </p>
<p>如果让对象B向后移动16个字节，也就是对象B的前16个字节与第二个cache line 交互，后16个与第3个交互。<br>那么第一个为2次，因为只有开头结尾2次要与内存交互，其它每次都在L1 DATACACHE 中写就可以了。第2个cache line为20次左右(后面的只须在CACHE中读写),第3个cache line为20次，<br>3个line一共才41次，你不妨仔细模拟一下。  </p>
<p>所以进行错位能降低CACHE的交互次数，从而提高CPU处理速度能力。  </p>
<p>这个错位(也就是上面的16个字节)就是colouroff.</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的冷热页机制概述]]></title>
      <url>http://vinoit.me/2016/06/28/linux-cold-hot-page/</url>
      <content type="html"><![CDATA[<h4 id="什么是冷热页？"><a href="#什么是冷热页？" class="headerlink" title="什么是冷热页？"></a>什么是冷热页？</h4><p>在Linux Kernel的物理内存管理的<a href="/2016/06/28/linux-buddy-system/">Buddy System</a>中，引入了冷热页的概念。冷页表示该空闲页已经不再高速缓存中了(一般是指L2 Cache)，热页表示该空闲页仍然在高速缓存中。冷热页是针对于每CPU的，每个zone中，都会针对于所有的CPU初始化一个冷热页的per-cpu-pageset.</p>
<h4 id="为什么要有冷热页？"><a href="#为什么要有冷热页？" class="headerlink" title="为什么要有冷热页？"></a>为什么要有冷热页？</h4><p>作用有3点：</p>
<ul>
<li><p>Buddy Allocator在分配order为0的空闲页的时候，如果分配一个热页，那么由于该页已经存在于L2 Cache中了。CPU写访问的时候，不需要先把内存中的内容读到Cache中，然后再写。如果分配一个冷页，说明该页不在L2 Cache中。一般情况下，尽可能用热页，是容易理解的。什么时候用冷页呢？While allocating a physical page frame, there is a bit specifying whether we would like a hot or a cold page (that is, a page likely to be in the CPU cache, or a page not likely to be there). If the page will be used by the CPU, a hot page will be faster. If the page will be used for device <code>DMA</code> the CPU cache would be invalidated anyway, and a cold page does not waste precious cache contents.<br>简单翻译一下：当内核分配<code>一个</code>物理页框时，有一些规范来约束我们是分配热页还是冷页。当页框是CPU使用的，则分配热页。当页框是DMA设备使用的，则分配冷页。因为DMA设备不会用到CPU高速缓存，所以没必要使用热页。</p>
</li>
<li><p>Buddy System在给某个进程分配某个zone中空闲页的时候，首先需要用自旋锁锁住该zone,然后分配页。这样，如果多个CPU上的进程同时进行分配页，便会竞争。引入了per-cpu-set后，当多个CPU上的进程同时分配页的时候，竞争便不会发生，提高了效率。另外当释放单个页面时，空闲页面首先放回到per-cpu-pageset中，以减少zone中自旋锁的使用。当页面缓存中的页面数量超过阀值时，再将页面放回到伙伴系统中。</p>
</li>
<li><p>使用每CPU冷热页还有一个好处是，能保证某个页一直黏在1个CPU上，这有助于提高Cache的命中率。</p>
</li>
</ul>
<h4 id="冷热页的数据结构"><a href="#冷热页的数据结构" class="headerlink" title="冷热页的数据结构"></a>冷热页的数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> per_cpu_pages &#123;</div><div class="line">        <span class="keyword">int</span> count;              <span class="comment">// number of pages in the list</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> high;               <span class="comment">// high watermark, emptying needed</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> batch;              <span class="comment">// chunk size for buddy add/remove</span></div><div class="line"></div><div class="line">         <span class="comment">// Lists of pages, one per migrate type stored on the pcp-lists</span></div><div class="line">         每个CPU在每个zone上都有MIGRATE_PCPTYPES个冷热页链表（根据迁移类型划分）</div><div class="line">         <span class="keyword">struct</span> list_head lists[MIGRATE_PCPTYPES];</div><div class="line"></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>在Linux中，对于UMA的架构，冷热页是在一条链表上进行管理。热页在前，冷页在后。CPU每释放一个order为0的页，如果per-cpu-pageset中的页数少于其指定的阈值，便会将释放的页插入到冷热页链表的开始处。这样，之前插入的热页便会随着其后热页源源不断的插入向后移动，其页由热变冷的几率便大大增加。</p>
<h4 id="怎样分配冷热页"><a href="#怎样分配冷热页" class="headerlink" title="怎样分配冷热页"></a>怎样分配冷热页</h4><p>在分配order为0页的时候(冷热页机制只处理单页分配的情况)，先找到合适的zone,然后根据需要的<code>migratetype</code>类型定位冷热页链表（每个zone，对于每个cpu,有3条冷热页链表，对应于：MIGRATE_UNMOVABLE、MIGRATE_RECLAIMABLE、MIGRATE_MOVABLE）。若需要热页，则从链表头取下一页（此页最“热”）；若需要冷页，则从链表尾取下一页（此页最“冷”）。</p>
<p>分配函数（关键部分已添加注释）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Really, prep_compound_page() should be called from __rmqueue_bulk().  But</div><div class="line"> * we cheat by calling it from here, in the order &gt; 0 path.  Saves a branch</div><div class="line"> * or two.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span></span></div><div class="line"><span class="keyword">struct</span> page *<span class="title">buffered_rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></div><div class="line">            <span class="keyword">struct</span> zone *zone, <span class="keyword">int</span> order, <span class="keyword">gfp_t</span> gfp_flags,</div><div class="line">            <span class="keyword">int</span> migratetype)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">    <span class="keyword">struct</span> page *page;</div><div class="line">    <span class="comment">//分配标志是__GFP_COLD才分配冷页</span></div><div class="line">    <span class="keyword">int</span> cold = !!(gfp_flags &amp; <span class="number">__</span>GFP_COLD);</div><div class="line"></div><div class="line">again:</div><div class="line">    <span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</div><div class="line">        <span class="keyword">struct</span> per_cpu_pages *pcp;</div><div class="line">        <span class="keyword">struct</span> list_head *<span class="built_in">list</span>;</div><div class="line"></div><div class="line">        local_irq_save(flags);</div><div class="line">        pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</div><div class="line">        <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</div><div class="line">        <span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</div><div class="line">          <span class="comment">//如果缺少页，则从Buddy System中分配。</span></div><div class="line">            pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</div><div class="line">                    pcp-&gt;batch, <span class="built_in">list</span>,</div><div class="line">                    migratetype, cold);</div><div class="line">            <span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</div><div class="line">                <span class="keyword">goto</span> failed;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cold)</div><div class="line">        <span class="comment">//分配冷页时，从链表尾部分配，list为链表头，list-&gt;prev表示链表尾</span></div><div class="line">            page = list_entry(<span class="built_in">list</span>-&gt;prev, <span class="keyword">struct</span> page, lru);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="comment">//分配热页时，从链表头分配</span></div><div class="line">            page = list_entry(<span class="built_in">list</span>-&gt;next, <span class="keyword">struct</span> page, lru);</div><div class="line">       <span class="comment">//分配完一个页框后从冷热页链表中删去该页</span></div><div class="line">        list_del(&amp;page-&gt;lru);</div><div class="line">        pcp-&gt;count--;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果order!=0(页框数&gt;1)，则不从冷热页链表中分配</span></div><div class="line">        <span class="keyword">if</span> (unlikely(gfp_flags &amp; <span class="number">__</span>GFP_NOFAIL)) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * __GFP_NOFAIL is not to be used in new code.</div><div class="line">             *</div><div class="line">             * All __GFP_NOFAIL callers should be fixed so that they</div><div class="line">             * properly detect and handle allocation failures.</div><div class="line">             *</div><div class="line">             * We most definitely don't want callers attempting to</div><div class="line">             * allocate greater than order-1 page units with</div><div class="line">             * __GFP_NOFAIL.</div><div class="line">             */</div><div class="line">            WARN_ON_ONCE(order &gt; <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        spin_lock_irqsave(&amp;zone-&gt;lock, flags);</div><div class="line">        page = <span class="number">__</span>rmqueue(zone, order, migratetype);</div><div class="line">        spin_unlock(&amp;zone-&gt;lock);</div><div class="line">        <span class="keyword">if</span> (!page)</div><div class="line">            <span class="keyword">goto</span> failed;</div><div class="line">        <span class="number">__</span>mod_zone_page_state(zone, NR_FREE_PAGES, -(<span class="number">1</span> &lt;&lt; order));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="number">__</span>count_zone_vm_events(PGALLOC, zone, <span class="number">1</span> &lt;&lt; order);</div><div class="line">    zone_statistics(preferred_zone, zone, gfp_flags);</div><div class="line">    local_irq_restore(flags);</div><div class="line"></div><div class="line">    VM_BUG_ON(bad_range(zone, page));</div><div class="line">    <span class="keyword">if</span> (prep_new_page(page, order, gfp_flags))</div><div class="line">        <span class="keyword">goto</span> again;</div><div class="line">    <span class="keyword">return</span> page;</div><div class="line"></div><div class="line">failed:</div><div class="line">    local_irq_restore(flags);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linuxarm-%E4%B8%AD%E7%9A%84%E5%86%B7%E7%83%AD%E9%A1%B5/" target="_blank" rel="external">认识Linux/ARM 中的冷热页</a></li>
<li>Linux源码</li>
</ul>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的Buddy System]]></title>
      <url>http://vinoit.me/2016/06/28/linux-buddy-system/</url>
      <content type="html"><![CDATA[<h4 id="什么是Buddy-System"><a href="#什么是Buddy-System" class="headerlink" title="什么是Buddy System?"></a>什么是Buddy System?</h4><p>Buddy System是Linux Kernel 进行物理内存页管理的一个子系统。在Buddy System中，管理的一个基本单位是block，每一个block有若干个连续的物理页组成，物理页的个数为2^n，这个n在buddy system中被称为order。<code>相同order的block，挂载一条双向链表上。</code>当某个block空闲时，只要发现对应的伙伴也是空闲的，就和伙伴组成一个页数为2^（n+1）的block，挂载在order为(n+1)的双向链表上，换句话说一个页数为2^n的block，是由两个页数为2^（n-1）的伙伴block组成的。因此，一个block的伙伴肯定是和这个block在 <strong>物理地址上是连续</strong> 的。在Linux中，order的默认的取值范围是[0,10]。</p>
<p>linux中用<code>struct zone</code>来描述一个内存管理区(<em>ZONE_DMA:0~16MB  ZONE_NORMAL:16MB~896MB  ZONE_HIGHMEM:896MB~end</em>)<br>其中的struct free_area中的<code>每一个元素</code>表示的是由相同order的block构成的<code>双向链表</code>。free_area[i]表示该free_area处的链表的order为i。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> zone &#123;  </div><div class="line">    ...  </div><div class="line">         ...      </div><div class="line">    <span class="keyword">struct</span> free_area    free_area[MAX_ORDER];  </div><div class="line">    ...  </div><div class="line">    ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> free_area &#123;  </div><div class="line">  <span class="comment">//每个free_area内有MIGRATE_TYPES个双向链表，根据迁移类型划分()*迁移类型请查看文末*）。</span></div><div class="line">  <span class="comment">//free_list和struct page中的lru相连</span></div><div class="line">    <span class="keyword">struct</span> list_head    free_list[MIGRATE_TYPES];  </div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_free;  <span class="comment">//空闲块数量</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在buddy system中，存入一个页会进行一次伙伴整合的迭代操作，直到不能再合并为止。那么，如何查找某个block的伙伴呢？在Linux中，一个block的伙伴信息记录在该block的<code>第一个物理页</code>的<code>struct page</code>上。也就是说，假若一个页在伙伴系统中，page-&gt;private的值为n,则后面连续的2^(n-1)个页面就在buddy system中。一个页面在buddy System中，就代表了该页是空闲的，可以被分配。</p>
<h4 id="查找伙伴"><a href="#查找伙伴" class="headerlink" title="查找伙伴"></a>查找伙伴</h4><p>内核代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mm/page_alloc.c</div><div class="line">		buddy_idx = <span class="number">__f</span>ind_buddy_index(page_idx, order);</div><div class="line">		buddy = page + (buddy_idx - page_idx);</div></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></div><div class="line"><span class="number">__f</span>ind_buddy_index(<span class="keyword">unsigned</span> <span class="keyword">long</span> page_idx, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> page_idx ^ (<span class="number">1</span> &lt;&lt; order);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找一个页数为2^n的block的伙伴计算方法是buddy_index=page_index^(1&lt;&lt;n)(此处的^表示异或)，buddy_index 表示伙伴块首页的页索引，page_index是该block首页的页索引，n代表order。</p>
<p>举例：<br><img src="/images/linux/linux-buddy-system-2.png" alt=""></p>
<p><img src="/images/linux/linux-buddy-system-3.png" alt=""></p>
<h4 id="从buddy-System中分配页"><a href="#从buddy-System中分配页" class="headerlink" title="从buddy System中分配页"></a>从buddy System中分配页</h4><p>buddy System用来管理空闲的物理内存，接受进程的内存页申请。Linux提供给用户进程申请内存的接口函数中包含两个参数：一个是<code>GFP_***</code>，另一个是<code>order</code>。前者表示分配标志信息，从标志中可以知道进程要从哪个zone中申请物理内存，并在内存紧缺的情况下指导内存何时回收内存；后者表示需要分配2^order个连续的物理页。<br>buddy system根据参数order，在要求的zone中查找对应的链表。若该order的双向链表非空，则把该双向链表上的第一个block从buddy system中脱链，同时更新该双向链表上的block的数量，完成内存分配。若该order的双向链表为空，则查找order+1的双向链表，如果order+1的双向链表为空，则查找order+2的双向链表，直到查找到。假设查找到了第n个双向链表(n&gt;order)，由于查找到的连续物理内存页的数量大于order，因此将该block一分为二，将后半部分block挂载到2^(n-1)的双向链表上，将前半部分再一分为二，将前半部分的后半部分挂载到2^(n-2)的双向链表上，将前半部分的前半部分再一分为二。。。直到与请求的order相等为止。</p>
<h4 id="释放页到buddy-System"><a href="#释放页到buddy-System" class="headerlink" title="释放页到buddy System"></a>释放页到buddy System</h4><p>当非空闲的页被进程释放后，需要把页放回到伙伴系统中。由于block是作为一个整体被申请的，因此其释放也是以block为单位。若该block有2^n个连续的物理页，在释放的时候，根据buddy_index = page_index^(1&lt;&lt;n)查找该block的order为n的伙伴。若查找到伙伴，则将两个order为n的block合并为一个order为n+1的block。同时再查找order为n+1 block的伙伴，若找到则两个order为n+1的block继续合并…直到其不能合并为止，插入到最终order的双向链表的最前端。释放的迭代过程是分配页的逆过程.</p>
<h4 id="linux中的迁移类型"><a href="#linux中的迁移类型" class="headerlink" title="linux中的迁移类型"></a>linux中的迁移类型</h4><p>在2.6.24之前的内核版本中，free_area结构中只有一个free_list数组，而从2.6.24开始，free_area结构中存有MIGRATE_TYPES个free_list,这些数组是根据页框的移动性来划分的，为什么要进行这样的划分呢?实际上也是为了减少碎片而提出的，我们考虑下面的情况：</p>
<p><img src="/images/linux/linux-buddy-system-0.png" alt=""><br>图中一共有32个页，只分配出了4个页框，但是能够分配的最大连续内存也只有8个页框(因为伙伴系统分配出去的内存必须是2的整数次幂个页框)，内核解决这种问题的办法就是将不同类型的页进行分组。分配出去的页面可分为三种类型：</p>
<ul>
<li>不可移动页(Non-movable pages)：这类页在内存当中有固定的位置，不能移动。内核的核心分配的内存大多属于这种类型</li>
<li>可回收页(Reclaimable pages)：这类页不能直接移动，但可以删除，其内容页可以从其他地方重新生成，例如，映射自文件的数据属于这种类型，针对这种页，内核有专门的页面回收处理</li>
<li>可移动页:这类页可以随意移动，用户空间应用程序所用到的页属于该类别。它们通过页表来映射，如果他们复制到新的位置，页表项也会相应的更新，应用程序不会注意到任何改变。</li>
</ul>
<p>假如上图中大部分页都是可移动页，而分配出去的四个页都是不可移动页，由于不可移动页插在了其他类型页的中间，就导致了无法从原本空闲的连续内存区中分配较大的内存块。考虑下图的情况:<br><img src="/images/linux/linux-buddy-system-1.png" alt=""></p>
<p>将可回收页和不可移动页分开，这样虽然在不可移动页的区域当中无法分配大块的连续内存，但是可回收页的区域却没有受其影响，可以分配大块的连续内存。</p>
<p><code>内核对于迁移类型的定义如下:</code></p>
<mmzone.h>

<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_UNMOVABLE     0  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_RECLAIMABLE   1  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_MOVABLE       2  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_PCPTYPES      3 <span class="comment">/* the number of types on the pcp lists */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_RESERVE       3  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_ISOLATE       4 <span class="comment">/* can't allocate from here */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MIGRATE_TYPES         5</span></div></pre></td></tr></table></figure>
<p>前三种类型已经介绍过</p>
<p><code>MIGRATE_PCPTYPES</code>是per_cpu_pageset，即用来表示每CPU页框高速缓存的数据结构中的链表的迁移类型数目</p>
<p><code>MIGRATE_RESERVE</code>是在前三种的列表中都没用可满足分配的内存块时，就可以从MIGRATE_RESERVE分配</p>
<p><code>MIGRATE_ISOLATE</code>用于跨越NUMA节点移动物理内存页，在大型系统上，它有益于将物理内存页移动到接近于是用该页最频繁地CPU</p>
<p><code>MIGRATE_TYPES</code>表示迁移类型的数目<br>当一个指定的迁移类型所对应的链表中没有空闲块时，将会按以下定义的顺序到其他迁移类型的链表中寻找</p>
<p>参考：</p>
<ul>
<li><a href="http://blog.tek-life.com/%E8%AE%A4%E8%AF%86linux%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-buddy-system/" target="_blank" rel="external">认识Linux物理内存管理系统–Buddy System</a></li>
<li><a href="http://blog.csdn.net/vanbreaker/article/details/7605367" target="_blank" rel="external">Linux伙伴系统(一)–伙伴系统的概述</a></li>
<li><a href="http://rick_stone.leanote.com/post/%E5%86%85%E5%AD%98%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%9F%A5%E6%89%BE%E4%BC%99%E4%BC%B4" target="_blank" rel="external">内存伙伴系统之查找伙伴算法</a></li>
</ul>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
</mmzone.h>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[当···时发生了什么？]]></title>
      <url>http://vinoit.me/2016/06/13/what-happens-when/</url>
      <content type="html"><![CDATA[<p><strong>当你在浏览器中输入 google.com 并且按下回车之后发生了什么？</strong></p>
<h4 id="按下”g”键"><a href="#按下”g”键" class="headerlink" title="按下”g”键"></a>按下”g”键</h4><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 <code>&quot;google.com&quot;</code>，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 <code>&quot;google.com&quot;</code> 建议给你。</p>
<h4 id="回车键按下"><a href="#回车键按下" class="headerlink" title="回车键按下"></a>回车键按下</h4><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>
<h5 id="USB键盘："><a href="#USB键盘：" class="headerlink" title="USB键盘："></a>USB键盘：</h5><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压<br>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内<br>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供<br>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包<br>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）<br>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p>
<h5 id="虚拟键盘（触屏设备）："><a href="#虚拟键盘（触屏设备）：" class="headerlink" title="虚拟键盘（触屏设备）："></a>虚拟键盘（触屏设备）：</h5><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标<br>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮<br>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息<br>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p>
<h4 id="产生中断-非USB键盘"><a href="#产生中断-非USB键盘" class="headerlink" title="产生中断[非USB键盘]"></a>产生中断[非USB键盘]</h4><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>
<h4 id="Windows-一个-WM-KEYDOWN-消息被发往应用程序"><a href="#Windows-一个-WM-KEYDOWN-消息被发往应用程序" class="headerlink" title="(Windows)一个 WM_KEYDOWN 消息被发往应用程序"></a>(Windows)一个 WM_KEYDOWN 消息被发往应用程序</h4><p>HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>
<p>Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>
<p>Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p>
<p>当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p>
<h4 id="Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序"><a href="#Mac-OS-X-一个-KeyDown-NSEvent被发往应用程序" class="headerlink" title="(Mac OS X)一个 KeyDown NSEvent被发往应用程序"></a>(Mac OS X)一个 KeyDown NSEvent被发往应用程序</h4><p>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p>
<h4 id="GNU-Linux-Xorg-服务器监听键码值"><a href="#GNU-Linux-Xorg-服务器监听键码值" class="headerlink" title="(GNU/Linux)Xorg 服务器监听键码值"></a>(GNU/Linux)Xorg 服务器监听键码值</h4><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>
<h4 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h4><p>浏览器通过 URL 能够知道下面的信息：</p>
<blockquote>
<ul>
<li>Protocol “http”<br>使用HTTP协议</li>
<li>Resource “/“<br>请求的资源是主页(index)</li>
</ul>
</blockquote>
<h4 id="输入的是-URL-还是搜索的关键字？"><a href="#输入的是-URL-还是搜索的关键字？" class="headerlink" title="输入的是 URL 还是搜索的关键字？"></a>输入的是 URL 还是搜索的关键字？</h4><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>
<h4 id="检查-HSTS-列表···"><a href="#检查-HSTS-列表···" class="headerlink" title="检查 HSTS 列表···"></a>检查 HSTS 列表···</h4><p>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站<br>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</p>
<h4 id="转换非-ASCII-的-Unicode-字符"><a href="#转换非-ASCII-的-Unicode-字符" class="headerlink" title="转换非 ASCII 的 Unicode 字符"></a>转换非 ASCII 的 Unicode 字符</h4><p>浏览器检查输入是否含有不是 <code>a-z， A-Z，0-9， -</code> 或者 <code>.</code> 的字符<br>这里主机名是 <code>google.com</code>，所以没有非ASCII的字符，如果有的话，浏览器会对主机名部分使用 Punycode 编码</p>
<h4 id="DNS-查询···"><a href="#DNS-查询···" class="headerlink" title="DNS 查询···"></a>DNS 查询···</h4><ul>
<li>浏览器检查域名是否在缓存当中</li>
<li>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询</li>
<li><code>gethostbyname</code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同</li>
<li>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li>
<li>查询本地 DNS 服务器</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li>
</ul>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>要想发送 ARP 广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>
<ul>
<li><p>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC<br>如果缓存没有命中：</p>
</li>
<li><p>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</p>
</li>
<li>查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层 ARP 请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ARP Request:</div><div class="line"></div><div class="line">Sender MAC: interface:mac:address:here</div><div class="line">Sender IP: interface.ip.goes.here</div><div class="line">Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)</div><div class="line">Target IP: target.ip.goes.here</div></pre></td></tr></table></figure>
<p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<p>直连：</p>
<ul>
<li><p>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。<br>集线器：</p>
</li>
<li><p>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。<br>交换机：</p>
</li>
<li><p>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</p>
</li>
<li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li>
<li>如果路由器也“连接”在其中，它会返回一个 ARP Reply</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ARP Reply:</div><div class="line"></div><div class="line">Sender MAC: target:mac:address:here</div><div class="line">Sender IP: target.ip.goes.here</div><div class="line">Target MAC: interface:mac:address:here</div><div class="line">Target IP: interface.ip.goes.here</div></pre></td></tr></table></figure>
<p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>
<ul>
<li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li>
<li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li>
</ul>
<h4 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h4><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET 和 SOCK_STREAM 。</p>
<ul>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。</li>
<li><p>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。<br>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>
</li>
<li><p>以太网</p>
</li>
<li>WiFi</li>
<li>蜂窝数据网络<br>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。</li>
</ul>
<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>
<ul>
<li><p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</p>
</li>
<li><p><em>服务器端接收到 SYN 包，如果它可以建立连接：</em></p>
<ul>
<li>服务器端选择它自己的初始序列号</li>
<li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li>
<li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li>
</ul>
</li>
<li><em>客户端通过发送下面一个封包来确认这次连接：</em><ul>
<li>自己的序列号+1</li>
<li>接收端 ACK+1</li>
<li>设置 ACK 位</li>
</ul>
</li>
<li><em>数据通过下面的方式传输：</em><ul>
<li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li>
<li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li>
</ul>
</li>
<li><em>关闭连接时：</em><ul>
<li>要关闭连接的一方发送一个 FIN 包</li>
<li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li>
<li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li>
</ul>
</li>
</ul>
<h4 id="UDP-数据包"><a href="#UDP-数据包" class="headerlink" title="UDP 数据包"></a>UDP 数据包</h4><h4 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h4><ul>
<li>客户端发送一个 <code>Client hello</code> 消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。</li>
<li>服务器端向客户端返回一个 <code>Server hello</code> 消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li>
<li>客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li>
<li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li>
<li>客户端发送一个 <code>Finished</code> 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li>
<li>服务器端生成自己的 <code>hash</code> 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <code>Finished</code> 消息，也使用协商好的对称密钥加密</li>
<li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li>
</ul>
<h4 id="TCP-数据包"><a href="#TCP-数据包" class="headerlink" title="TCP 数据包"></a>TCP 数据包</h4><h4 id="HTTP-协议···"><a href="#HTTP-协议···" class="headerlink" title="HTTP 协议···"></a>HTTP 协议···</h4><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>
<p>如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求:</p>
<p><code>GET / HTTP/1.1
Host: google.com
[其他头部]</code></p>
<p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合<code>HTTP</code>协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反<code>HTTP</code>协议标准的bug，同时浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 GET 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。</p>
<p>HTTP/1.1 定义了“关闭连接”的选项 <code>&quot;close&quot;</code>，发送者使用这个选项指示这次连接在响应结束之后会断开:</p>
<p><code>Connection:close</code><br>不支持持久连接的<code>HTTP/1.1</code> 必须在每条消息中都包含 <code>&quot;close&quot;</code> 选项。</p>
<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>
<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>
<p><code>200 OK
[响应头部]</code></p>
<p>然后是一个换行，接下来有效载荷(payload)，也就是<code>www.google.com</code>的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。</p>
<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>
<p><code>304 Not Modified
[响应头部]</code></p>
<p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>
<p>在解析完 HTM L之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code>会变成 <code>GET /$(相对www.google.com的URL) HTTP/1.1</code>。</p>
<p>如果HTML引入了 <code>www.google.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code>头部会变成另外的域名。</p>
<h4 id="HTTP-服务器请求处理"><a href="#HTTP-服务器请求处理" class="headerlink" title="HTTP 服务器请求处理"></a>HTTP 服务器请求处理</h4><p>HTTPD(HTTP Daemon)在服务器端处理请求/相应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li><p>HTTPD 接收请求</p>
</li>
<li><p><em>服务器把请求拆分为以下几个参数：</em></p>
<ul>
<li>HTTP 请求方法(GET, POST, HEAD, PUT 和 DELETE)。在访问 Google 这种情况下，使用的是 GET 方法</li>
<li>域名：google.com</li>
<li>请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</li>
</ul>
</li>
<li><p>服务器验证其上已经配置了 google.com 的虚拟主机</p>
</li>
<li><p>服务器验证 google.com 接受 GET 方法</p>
</li>
<li><p>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</p>
</li>
<li><p>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</p>
</li>
<li><p>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</p>
</li>
<li><p>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</p>
</li>
</ul>
<h4 id="浏览器背后的故事"><a href="#浏览器背后的故事" class="headerlink" title="浏览器背后的故事"></a>浏览器背后的故事</h4><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>
<ul>
<li>解析 HTML，CSS，JS</li>
<li>渲染——构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li>
</ul>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>
<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>
<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>
<ul>
<li>一个地址栏</li>
<li>后退和前进按钮</li>
<li>书签选项</li>
<li>刷新和停止按钮</li>
<li>主页按钮</li>
</ul>
<h5 id="浏览器高层架构"><a href="#浏览器高层架构" class="headerlink" title="浏览器高层架构"></a>浏览器高层架构</h5><p>组成浏览器的组件有：</p>
<ul>
<li>用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li>
<li>浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作</li>
<li>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li>
<li>网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li>
<li>UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li>
<li>Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码</li>
<li>数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li>
</ul>
<h4 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h4><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>
<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>
<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>
<h5 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h5><p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>
<ul>
<li>语言本身的“宽容”特性</li>
<li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li>
<li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li>
</ul>
<p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
<h5 id="解析结束之后"><a href="#解析结束之后" class="headerlink" title="解析结束之后"></a>解析结束之后</h5><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>
<p>此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。</p>
<p>注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。</p>
<p>执行同步 Javascript 代码。</p>
<h4 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h4><p>根据 CSS词法和句法 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容<br>每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象<br>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</p>
<h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><ul>
<li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li>
<li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度</li>
<li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li>
<li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li>
<li>使用上面的计算结果构建每个节点的坐标</li>
<li>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code>或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/" target="_blank" rel="external">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work" target="_blank" rel="external">http://www.w3.org/Style/CSS/current-work</a></li>
<li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li>
<li>页面上的每个层都被分配了纹理(?)</li>
<li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制</li>
<li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li>
<li>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li>
</ul>
<h4 id="GPU-渲染"><a href="#GPU-渲染" class="headerlink" title="GPU 渲染"></a>GPU 渲染</h4><ul>
<li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li>
<li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li>
</ul>
<h4 id="Window-Server"><a href="#Window-Server" class="headerlink" title="Window Server"></a>Window Server</h4><p><strong>后期渲染与用户引发的处理</strong></p>
<p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<p><strong>原文地址：<a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">https://github.com/skyline75489/what-happens-when-zh_CN</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解JVM中class文件结构--实例讲解]]></title>
      <url>http://vinoit.me/2016/05/23/java-classfile-structure-example/</url>
      <content type="html"><![CDATA[<p>本文通过一个简单的例子来讲解class文件结构,<strong>某些具体结构概念和信息需结合我之前的两篇博文<a href="/2016/05/22/java-classfile-structure-concept/">《理解JVM中class文件结构–概念部分》</a>，<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a></strong>，建议可以通过上面的两篇博文先了解这方面的一些知识再看本文。<br>java代码（jdk7）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/21.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> testInt;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        testInt = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应class文件(十六进制)：<br><img src="/images/jvm/java-classfile-structure-example-0.PNG" alt=""><br>接下来的顺序和class文件结构顺序一致</p>
<h4 id="u4-magic"><a href="#u4-magic" class="headerlink" title="u4 magic;"></a><code>u4 magic;</code></h4><p>文件位置<code>0x0-0x3</code>为魔数 CA FE BA BE ,固定不变。</p>
<h4 id="u2-minor-version"><a href="#u2-minor-version" class="headerlink" title="u2 minor_version;"></a><code>u2 minor_version;</code></h4><p>文件位置<code>0x4-0x5</code>为副版本号，值为0x0000。</p>
<h4 id="u2-major-version"><a href="#u2-major-version" class="headerlink" title="u2 major_version;"></a><code>u2 major_version;</code></h4><p>文件位置<code>0x6-0x7</code>为主版本号，值为0x0033。</p>
<h4 id="u2-constant-pool-count"><a href="#u2-constant-pool-count" class="headerlink" title="u2 constant_pool_count;"></a><code>u2 constant_pool_count;</code></h4><p>文件位置<code>0x8-0x9</code>为常量池计数器，值为0x0015，十进制为21。</p>
<h4 id="反编译后的常量池信息"><a href="#反编译后的常量池信息" class="headerlink" title="反编译后的常量池信息"></a>反编译后的常量池信息</h4><p>此时通过<code>javap -v</code> 命令反编译class文件，查看常量池信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #4.#17         //  java/lang/Object."&lt;init&gt;":()V</div><div class="line">   #2 = Fieldref           #3.#18         //  pac1/TestClass.testInt:I</div><div class="line">   #3 = Class              #19            //  pac1/TestClass</div><div class="line">   #4 = Class              #20            //  java/lang/Object</div><div class="line">   #5 = Utf8               testInt</div><div class="line">   #6 = Utf8               I</div><div class="line">   #7 = Utf8               &lt;init&gt;</div><div class="line">   #8 = Utf8               ()V</div><div class="line">   #9 = Utf8               Code</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               LocalVariableTable</div><div class="line">  #12 = Utf8               this</div><div class="line">  #13 = Utf8               Lpac1/TestClass;</div><div class="line">  #14 = Utf8               test</div><div class="line">  #15 = Utf8               SourceFile</div><div class="line">  #16 = Utf8               TestClass.java</div><div class="line">  #17 = NameAndType        #7:#8          //  "&lt;init&gt;":()V</div><div class="line">  #18 = NameAndType        #5:#6          //  testInt:I</div><div class="line">  #19 = Utf8               pac1/TestClass</div><div class="line">  #20 = Utf8               java/lang/Object</div></pre></td></tr></table></figure></p>
<p>常量池中一共有20项，这也证明了<code>u2 constant_pool_count</code>的值为常量池项目数+1。<br>在class文件中各项之间<code>没有任何填充</code>或<code>对齐</code>作为各项间的分隔符号，紧接着的便是常量池项。</p>
<h4 id="cp-info-constant-pool-constant-pool-count-1"><a href="#cp-info-constant-pool-constant-pool-count-1" class="headerlink" title="cp_info constant_pool[constant_pool_count-1];"></a><code>cp_info constant_pool[constant_pool_count-1];</code></h4><h5 id="常量池项1"><a href="#常量池项1" class="headerlink" title="常量池项1"></a>常量池项1</h5><p><strong>通过常量池项1来学习常量池</strong></p>
<p>通过常量池项的通用格式可知，文件位置<code>0x10</code>为常量池项的tagbyte,值为0x0A,查看常量池的 tag 项说明可知常量池项1类型为CONSTANT_Methodref。</p>
<p>接着通过查看CONSTANT_Methodref_info 结构具体信息，文件位置<code>0x11-0x12</code>为CONSTANT_Methodref的class_index,为常量池项中某一项的索引，类型必须是CONSTANT_Class。值为0x0004,指向常量池项4，通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_Class类型的。</p>
<p>文件位置<code>0x13-0x14</code>为CONSTANT_Methodref的name_and_type_index，同样指向常量池中的一项，类型必须是CONSTANT_NameAndType。值为0x0011,指向常量池项17，通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_NameAndType类型的。</p>
<p><strong>在这里把和常量池项1有关的所有常量池项（1-&gt; 4,17 -&gt; 20,7,8）都讲一下</strong></p>
<h6 id="常量池项4"><a href="#常量池项4" class="headerlink" title="常量池项4"></a>常量池项4</h6><p>常量池项4在文件的开始位置是<code>0x17</code>，属于常量池项4的tagbyte,值为0x07,是CONSTANT_Class类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_Class_info 结构具体信息，文件位置<code>0x18-0x19</code>为CONSTANT_Class的 name_index，指向常量池中的某一项，类型必须是CONSTANT_Utf8，表示字符串常量的值。值为0x0014,指向常量池项20，通过查看上面反编译后的常量池信息，可以看到常量池项20是CONSTANT_Utf8类型的。</p>
<h6 id="常量池项20"><a href="#常量池项20" class="headerlink" title="常量池项20"></a>常量池项20</h6><p>常量池项20在文件的开始位置是<code>0xbf</code>,属于常量池项20的tagbyte,值为0x01,是CONSTANT_Utf8类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_Utf8_info 结构具体信息，文件位置<code>0xc0-0xc1</code>为CONSTANT_Utf8的length，表示字符串常量的长度，值为0x0010,长度为16个字节。</p>
<p>文件位置<code>0xc2-0xd1</code>为具体内容，通过ascii码转换之后的值便是<code>java/lang/Object</code>,和反编译后的常量池信息一致。</p>
<h6 id="常量池项17"><a href="#常量池项17" class="headerlink" title="常量池项17"></a>常量池项17</h6><p>常量池项17在文件的开始位置是<code>0xa4</code>,属于常量池项17的tagbyte,值为0x0c,是CONSTANT_NameAndType类型的，和反编译后的常量池信息一致。</p>
<p>接着通过查看CONSTANT_NameAndType_info 结构具体信息，文件位置<code>0xa5-0xa6</code>为CONSTANT_NameAndType的name_index，指向常量池项的某一项，类型必须为CONSTANT_Utf8，表示字符串常量的值。值为0x0007,指向常量池项7。通过查看上面反编译后的常量池信息，可以看到常量池项7是CONSTANT_Utf8类型的。</p>
<p>文件位置<code>0xa7-0xa8</code>为CONSTANT_NameAndType的descriptor_index，指向常量池项的某一项，类型必须为CONSTANT_Utf8，表示字符串常量的值。此字符串为方法描述符，具体可参考《JVM规范》。此处的值为0x0008,指向常量池项8。通过查看上面反编译后的常量池信息，可以看到常量池项8是CONSTANT_Utf8类型的。</p>
<h6 id="常量池项7和8"><a href="#常量池项7和8" class="headerlink" title="常量池项7和8"></a>常量池项7和8</h6><p>常量池项7和8均为CONSTANT_Utf8类型的,分析方法和常量池项20一样。</p>
<h6 id="常量池项1总结"><a href="#常量池项1总结" class="headerlink" title="常量池项1总结"></a>常量池项1总结</h6><p>常量池项1是CONSTANT_Methodref类型，表示一个方法的应用。通过查看上面反编译后的常量池信息，可以发现此方法为java/lang/Object.”<init>“:()V，但其中涉及到对其他多个常量池项的引用。一个方法是由类名和方法名决定的，所以分别引用了CONSTANT_Class和CONSTANT_NameAndType，其中CONSTANT_NameAndType表示一个方法名。然后CONSTANT_Class和CONSTANT_NameAndType又分别需要字符串信息来描述，所以又引用了CONSTANT_Utf8类型的项。</init></p>
<p><strong>其他常量池项可以按照这个方式来分析。</strong></p>
<h4 id="u2-access-flags"><a href="#u2-access-flags" class="headerlink" title="u2 access_flags"></a><code>u2 access_flags</code></h4><p>文件位置<code>0xd2-0xd3</code>表示的是access_flags，值为0x0021,通过查看access_flags的取值范围和相应含义表，得知该值的含义是ACC_PUBLIC（可以被包的类外访问。）和ACC_SUPER（当用到 invokespecial 指令时，需要特殊处理的父类方法。）和反编译之后的文件中的<code>flags: ACC_PUBLIC, ACC_SUPER</code>一致。其中invokespecial指令调用了<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>。</p>
<h4 id="u2-this-class"><a href="#u2-this-class" class="headerlink" title="u2 this_class"></a><code>u2 this_class</code></h4><p>文件位置<code>0xd4-0xd5</code>表示的是u2 this_class，为本类的引用，指向常量池中的某一项，类型必须为CONSTANT_Class。值为0x0003,表示指向常量池项3。通过查看上面反编译后的常量池信息，可以看到常量池项3是CONSTANT_Class类型的,最终值为pac1/TestClass。</p>
<h4 id="u2-super-class"><a href="#u2-super-class" class="headerlink" title="u2 super_class"></a><code>u2 super_class</code></h4><p>文件位置<code>0xd6-0xd7</code>表示的是u2 super_class，为父类的引用，指向常量池中的某一项，类型必须为CONSTANT_Class。值为0x0004,表示指向常量池项4。通过查看上面反编译后的常量池信息，可以看到常量池项4是CONSTANT_Class类型的,最终值为java/lang/Object,Object是所有类的父类。</p>
<h4 id="u2-interfaces-count"><a href="#u2-interfaces-count" class="headerlink" title="u2 interfaces_count"></a><code>u2 interfaces_count</code></h4><p>文件位置<code>0xd8-0xd9</code>表示的是u2 interfaces_count，为接口计数器。值为0x0000,表示没有实现任何接口。所以接下来便不会有<code>u2 interfaces[interfaces_count]</code>（接口表）的字节信息。</p>
<h4 id="u2-fields-count"><a href="#u2-fields-count" class="headerlink" title="u2 fields_count"></a><code>u2 fields_count</code></h4><p>文件位置<code>0xda-0xdb</code>表示的是u2 fields_count，为字段计数器。值为0x0001,表示有一个字段。</p>
<h4 id="field-info-fields-fields-count"><a href="#field-info-fields-fields-count" class="headerlink" title="field_info fields[fields_count]"></a><code>field_info fields[fields_count]</code></h4><p>接下来便是表示字段信息的字节，文件位置<code>0xdc-0xdd</code>表示的是字段的access_flags，值为0x0000。查看字段 access_flags 标记列表及其含义表后发现没有含义是用0x0000表示的。因为源代码中字段前面没有任何修饰符，表示默认访问权限。access_flags 是一种掩码标志，0x0000表示没有一个是命中的。</p>
<p>文件位置<code>0xde-0xdf</code>表示的是字段信息的name_index,指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为字段名。值为0x0005,指向常量池项5，通过查看上面反编译后的常量池信息，可以看到常量池项5是CONSTANT_Utf8类型的,最终值为testInt，和源代码的字段名一致。</p>
<p>文件位置<code>0xe0-0xe1</code>表示的是字段信息的descriptor_index,指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为字段名。值为0x0006,指向常量池项6，通过查看上面反编译后的常量池信息，可以看到常量池项6是CONSTANT_Utf8类型的,最终值为I,表示int类型。更多基本类型字符解释可查看<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>中的字段基本类型字符解释表。</p>
<p>文件位置<code>0xe2-0xe3</code>表示的是字段信息的attributes_count，此处指为0。如果字段前面用了final或者字段被注解修饰等，则值便不为0，接下来便是各个属性的描述字节。具体属性信息可参看《JVM规范》。</p>
<h4 id="u2-methods-count"><a href="#u2-methods-count" class="headerlink" title="u2 methods_count"></a><code>u2 methods_count</code></h4><p>文件位置<code>0xe4-0xe5</code>表示的是u2 methods_count，为方法计数器。值为0x0002,表示有2个方法。</p>
<h4 id="method-info-methods-methods-count"><a href="#method-info-methods-methods-count" class="headerlink" title="method_info methods[methods_count]"></a><code>method_info methods[methods_count]</code></h4><p>文件位置<code>0xe6-0xe7</code>表示的是第一个方法的access_flags,值为0x0001,通过查看方法 access_flags 标记列表及其含义表可知，该方法为ACC_PUBLIC（public，方法可以从包外访问）。</p>
<p>文件位置<code>0xe8-0xe9</code>表示的是第一个方法的name_index，指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为方法名。值为0x0007,指向常量池项7，通过查看上面反编译后的常量池信息，可以看到常量池项7是CONSTANT_Utf8类型的,最终值为<code>&lt;init&gt;</code>。</p>
<p>文件位置<code>0xea-0xeb</code>表示的是第一个方法的descriptor_index，指向常量池中的某一项，必须是CONSTANT_Utf8类型的，为方法名。值为0x0008,指向常量池项8，通过查看上面反编译后的常量池信息，可以看到常量池项8是CONSTANT_Utf8类型的,最终值为<code>()V</code>。</p>
<p>文件位置<code>0xec-0xed</code>表示的是第一个方法的attributes_count,为方法属性计数器。值为0x0001,表明有一个属性。</p>
<p>接下来的是表示属性信息的字节，<code>查看属性的通用格式后</code>，文件位置<code>0xee-0xef</code>表示的是第一个方法中属性信息的attribute_name_index，为属性名索引，指向常量池中的某一项，必须是CONSTANT_Utf8类型的。值为0x0009,指向常量池项9，通过查看上面反编译后的常量池信息，可以看到常量池项9是CONSTANT_Utf8类型的,最终值为<code>Code</code>。Code属性的属性名固定为“Code”。</p>
<p>文件位置<code>0xf0-0xf3</code>表示属性信息的attribute_length，值为0x0000002f,说明当前属性的长度为47，不包括开始的6个字节（attribute_name_index 和 attribute_length所占用的长度）。</p>
<p>文件位置<code>0xf4-0xf5</code>表示属性信息的max_stack，为操作数栈的最大深度值，jvm运行时根据该值分配栈帧。此处值为0x0001,说明此方法调用时分配的最大栈帧为1个字节。</p>
<p>文件位置<code>0xf6-0xf7</code>表示属性信息的max_locals，为局部变量表最大存储空间，单位是slot。此处值为0x0001,说明此方法局部变量的最大存储空间为1个字节。</p>
<p>文件位置<code>0xf8-0xfb</code>表示属性信息的code_length，为具体的字节码长度。此处值为0x00000005,说明此方法具体字节码长度为5个字节。接下来的5个字节的内容就是具体的字节码。</p>
<p><strong>剩下的一些属性信息可以按照这个方法，对照属性表来分析。</strong></p>
<h4 id="u2-attributes-count-amp-attribute-info-attributes-attributes-count"><a href="#u2-attributes-count-amp-attribute-info-attributes-attributes-count" class="headerlink" title="u2 attributes_count &amp; attribute_info attributes[attributes_count]"></a><code>u2 attributes_count</code> &amp; <code>attribute_info attributes[attributes_count]</code></h4><p>u2 attributes_count 和 attribute_info attributes[attributes_count] 和方法里的属性分析原理一样。</p>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解JVM中class文件结构--具体结构信息]]></title>
      <url>http://vinoit.me/2016/05/22/java-classfile-structure-detail/</url>
      <content type="html"><![CDATA[<p>本文描述的是class结构的具体信息，排版顺序按照class结构。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="通用格式"><a href="#通用格式" class="headerlink" title="通用格式"></a>通用格式</h5><p>所有的常量池项都具有如下通用格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cp_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u1 info[];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="常量池的-tag-项说明"><a href="#常量池的-tag-项说明" class="headerlink" title="常量池的 tag 项说明"></a>常量池的 tag 项说明</h5><table>
<thead>
<tr>
<th style="text-align:left">常量类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Class</td>
<td>7</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Fieldref</td>
<td>9</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Methodref</td>
<td>10</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InterfaceMethodref</td>
<td>11</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_String</td>
<td>8</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Integer</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Float</td>
<td>4</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Long</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Double</td>
<td>6</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_NameAndType</td>
<td>12</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Utf8</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodHandle</td>
<td>15</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodType</td>
<td>16</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InvokeDynamic</td>
<td>18</td>
</tr>
</tbody>
</table>
<h5 id="CONSTANT-Class-info-结构"><a href="#CONSTANT-Class-info-结构" class="headerlink" title="CONSTANT_Class_info 结构"></a>CONSTANT_Class_info 结构</h5><p>CONSTANT_Class_info 结构用于表示类或接口，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Class_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-Fieldref-info-结构"><a href="#CONSTANT-Fieldref-info-结构" class="headerlink" title="CONSTANT_Fieldref_info 结构"></a>CONSTANT_Fieldref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Fieldref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Methodref-info-结构"><a href="#CONSTANT-Methodref-info-结构" class="headerlink" title="CONSTANT_Methodref_info 结构"></a>CONSTANT_Methodref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Methodref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-InterfaceMethodref-info-结构"><a href="#CONSTANT-InterfaceMethodref-info-结构" class="headerlink" title="CONSTANT_InterfaceMethodref_info 结构"></a>CONSTANT_InterfaceMethodref_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_InterfaceMethodref_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 class_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-String-info-结构"><a href="#CONSTANT-String-info-结构" class="headerlink" title="CONSTANT_String_info 结构"></a>CONSTANT_String_info 结构</h5><p>CONSTANT_String_info 用于表示 java.lang.String 类型的常量对象，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_String_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 string_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-Integer-info-结构"><a href="#CONSTANT-Integer-info-结构" class="headerlink" title="CONSTANT_Integer_info  结构"></a>CONSTANT_Integer_info  结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Integer_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Float-info-结构"><a href="#CONSTANT-Float-info-结构" class="headerlink" title="CONSTANT_Float_info 结构"></a>CONSTANT_Float_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Float_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Long-info-结构"><a href="#CONSTANT-Long-info-结构" class="headerlink" title="CONSTANT_Long_info 结构"></a>CONSTANT_Long_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Long_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 high_bytes;</div><div class="line">    u4 low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-Double-info-结构"><a href="#CONSTANT-Double-info-结构" class="headerlink" title="CONSTANT_Double_info 结构"></a>CONSTANT_Double_info 结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Double_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u4 high_bytes;</div><div class="line">    u4 low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="CONSTANT-NameAndType-info-结构"><a href="#CONSTANT-NameAndType-info-结构" class="headerlink" title="CONSTANT_NameAndType_info 结构"></a>CONSTANT_NameAndType_info 结构</h5><p>CONSTANT_NameAndType_info 结构用于表示字段或方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CONSTANT_NameAndType_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 name_index; //name_index 项的值必须是对常量池的有效索引， 常量池在该索引处的项必须是</div><div class="line">    CONSTANT_Utf8_info（ §4.4.7）结构，这个结构要么表示特殊的方法名&lt;init&gt;，要么表示一个有效</div><div class="line">    的字段或方法的非限定名（ Unqualified Name）。</div><div class="line"></div><div class="line">    u2 descriptor_index;//descriptor_index 项的值必须是对常量池的有效索引， 常量池在该索引</div><div class="line">    处的项必须是CONSTANT_Utf8_info结构。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法描述符具体格式可参考《JVM规范》。</p>
<h5 id="CONSTANT-Utf8-info-结构"><a href="#CONSTANT-Utf8-info-结构" class="headerlink" title="CONSTANT_Utf8_info 结构"></a>CONSTANT_Utf8_info 结构</h5><p>CONSTANT_Utf8_info 结构用于表示字符串常量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_Utf8_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 length;</div><div class="line">    u1 bytes[length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-MethodHandle-info-结构"><a href="#CONSTANT-MethodHandle-info-结构" class="headerlink" title="CONSTANT_MethodHandle_info 结构"></a>CONSTANT_MethodHandle_info 结构</h5><p>CONSTANT_MethodHandle_info 结构用于表示方法句柄，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CONSTANT_MethodHandle_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u1 reference_kind;//reference_kind 项的值必须在 1 至 9 之间（包括 1 和 9），它决定了方法句柄的类型。</div><div class="line">    方法句柄类型的值表示方法句柄的字节码行为。</div><div class="line"></div><div class="line">    u2 reference_index;//reference_index 项的值必须是对常量池的有效索引。</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-MethodType-info-结构"><a href="#CONSTANT-MethodType-info-结构" class="headerlink" title="CONSTANT_MethodType_info 结构"></a>CONSTANT_MethodType_info 结构</h5><p>CONSTANT_MethodType_info 结构用于表示方法类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CONSTANT_MethodType_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="CONSTANT-InvokeDynamic-info-结构"><a href="#CONSTANT-InvokeDynamic-info-结构" class="headerlink" title="CONSTANT_InvokeDynamic_info 结构"></a>CONSTANT_InvokeDynamic_info 结构</h5><p>CONSTANT_InvokeDynamic_info 用于表示 invokedynamic 指令所使用到的引导方法<br>（ Bootstrap Method）、 引导方法使用到动态调用名称（ Dynamic Invocation Name）、 参<br>数和请求返回类型、以及可以选择性的附加被称为静态参数（ Static Arguments） 的常量序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CONSTANT_InvokeDynamic_info &#123;</div><div class="line">    u1 tag;</div><div class="line">    u2 bootstrap_method_attr_index;</div><div class="line">    u2 name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="access-flags的取值范围和相应含义表"><a href="#access-flags的取值范围和相应含义表" class="headerlink" title="access_flags的取值范围和相应含义表"></a>access_flags的取值范围和相应含义表</h4><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>可以被包的类外访问。</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>不允许有子类。</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td>0x0020</td>
<td>当用到 invokespecial 指令时，需要特殊处理的父类方法。</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识定义的是接口而不是类。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td>不能被实例化。</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识并非 Java 源码生成的代码。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识注解类型</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td>标识枚举类型</td>
</tr>
</tbody>
</table>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>field_info 结构格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">field_info &#123;</div><div class="line">    u2 access_flags;</div><div class="line">    u2 name_index;</div><div class="line">    u2 descriptor_index;</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="字段-access-flags-标记列表及其含义"><a href="#字段-access-flags-标记列表及其含义" class="headerlink" title="字段 access_flags 标记列表及其含义"></a>字段 access_flags 标记列表及其含义</h5><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，表示字段可以从任何包访问。</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，表示字段仅能该类自身调用。</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，表示字段可以被子类调用。</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td>0x0008</td>
<td>static，表示静态字段。</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>final，表示字段定义后值无法修改</td>
</tr>
<tr>
<td style="text-align:left">ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile，表示字段是易变的。</td>
</tr>
<tr>
<td style="text-align:left">ACC_TRANSIENT</td>
<td>0x0080</td>
<td>transient，表示字段不会被序列</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>表示字段由编译器自动产生。</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td>enum，表示字段为枚举类型</td>
</tr>
</tbody>
</table>
<h5 id="基本类型字符解释表"><a href="#基本类型字符解释表" class="headerlink" title="基本类型字符解释表"></a>基本类型字符解释表</h5><table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">B</td>
<td>byte</td>
<td>有符号字节型数</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td>char</td>
<td>Unicode 字符， UTF-16 编码</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td>int</td>
<td>整型数</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td>long</td>
<td>长整数</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td>short</td>
<td>有符号短整数</td>
</tr>
<tr>
<td style="text-align:left">Z</td>
<td>boolean</td>
<td>布尔值 true/false</td>
</tr>
<tr>
<td style="text-align:left">L Classname;</td>
<td>reference</td>
<td>一个名为<classname>的实例</classname></td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td>reference</td>
<td>一个一维数组</td>
</tr>
</tbody>
</table>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>method_info 结构格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">method_info &#123;</div><div class="line">    u2 access_flags;</div><div class="line">    u2 name_index;</div><div class="line">    u2 descriptor_index;</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="方法-access-flags-标记列表及其含义"><a href="#方法-access-flags-标记列表及其含义" class="headerlink" title="方法 access_flags 标记列表及其含义"></a>方法 access_flags 标记列表及其含义</h5><table>
<thead>
<tr>
<th style="text-align:left">标记名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法只能本类中访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td>final，方法不能被重写（覆盖）</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNCHRONIZED</td>
<td>0x0020</td>
<td>synchronized，方法由管程同步</td>
</tr>
<tr>
<td style="text-align:left">ACC_BRIDGE</td>
<td>0x0040</td>
<td>bridge，方法由编译器产生</td>
</tr>
<tr>
<td style="text-align:left">ACC_VARARGS</td>
<td>0x0080</td>
<td>表示方法带有变长参数</td>
</tr>
<tr>
<td style="text-align:left">ACC_NATIVE</td>
<td>0x0100</td>
<td>native，方法引用非 java 语言的本地方法</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td>abstract，方法没有具体实现</td>
</tr>
<tr>
<td style="text-align:left">ACC_STRICT</td>
<td>0x0800</td>
<td>strictfp，方法使用 FP-strict 浮点格式</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>方法在源文件中不出现，由编译器产生</td>
</tr>
</tbody>
</table>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。<br>关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。</p>
<h5 id="属性的通用格式如下："><a href="#属性的通用格式如下：" class="headerlink" title="属性的通用格式如下："></a>属性的通用格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute_info &#123;</div><div class="line">    u2 attribute_name_index;   //属性名索引</div><div class="line">    u4 attribute_length;       //属性长度</div><div class="line">    u1 info[attribute_length]; //属性的具体内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ConstantValue-属性"><a href="#ConstantValue-属性" class="headerlink" title="ConstantValue 属性"></a>ConstantValue 属性</h5><p>ConstantValue 属性表示一个常量字段的值。位于 field_info结构的属性表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ConstantValue_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 constantvalue_index;//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是long型的，在常量池中便是CONSTANT_Long）</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Deprecated-属性"><a href="#Deprecated-属性" class="headerlink" title="Deprecated 属性"></a>Deprecated 属性</h5><p>Deprecated 属性是在 JDK 1.1 为了支持注释中的关键词@deprecated 而引入的。<br>Deprecated 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Deprecated_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Code-属性"><a href="#Code-属性" class="headerlink" title="Code 属性"></a>Code 属性</h5><p>Code 属性的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“</div><div class="line">    u4 attribute_length; //属性值长度，为整个属性表长度-6</div><div class="line">    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值分配栈帧</div><div class="line">    u2 max_locals;  //局部变量表最大存储空间，单位是slot</div><div class="line">    u4 code_length; // 字节码指令的个数</div><div class="line">    u1 code[code_length]; // 具体的字节码指令</div><div class="line">    u2 exception_table_length; //异常的个数</div><div class="line">    &#123;   u2 start_pc;</div><div class="line">        u2 end_pc;</div><div class="line">        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。</div><div class="line">        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理</div><div class="line">    &#125; exception_table[exception_table_length]; //具体的异常内容</div><div class="line">    u2 attributes_count;     //属性的个数</div><div class="line">    attribute_info attributes[attributes_count]; //具体的属性内容</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>其中slot为局部变量中的最小单位。boolean、 byte、 char、 short、 float、 reference和 returnAddress 等小于等于32位的用一个slot表示，double,long这些大于32位的用2个slot表示</li>
</ul>
<h5 id="InnerClasses-属性"><a href="#InnerClasses-属性" class="headerlink" title="InnerClasses 属性"></a>InnerClasses 属性</h5><p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个<br>CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的<br>ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。<br>InnerClasses 属性是在 JDK 1.1 中为了支持内部类和内部接口而引入的,位于 ClassFile结构的属性表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">InnerClasses_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_classes;</div><div class="line">    &#123;   u2 inner_class_info_index;</div><div class="line">        u2 outer_class_info_index;</div><div class="line">        u2 inner_name_index;</div><div class="line">        u2 inner_class_access_flags;</div><div class="line">    &#125; classes[number_of_classes];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LineNumberTable-属性"><a href="#LineNumberTable-属性" class="headerlink" title="LineNumberTable 属性"></a>LineNumberTable 属性</h5><p>LineNumberTable 属性是可选变长属性，位于 Code结构的属性表。它被调试<br>器用于确定源文件中行号表示的内容在 Java 虚拟机的 code[]数组中对应的部分。在 Code 属性<br>的属性表中， LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable<br>属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件<br>的行一一对应。<br>LineNumberTable 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LineNumberTable_attribute &#123;</div><div class="line">    u2 attribute_name_index;//属性名称在常量池的索引，指向一个 CONSTANT_Utf8_info结构。</div><div class="line">    u4 attribute_length;//属性长度</div><div class="line">    u2 line_number_table_length;//线性表长度</div><div class="line">    &#123;   u2 start_pc;</div><div class="line">        u2 line_number;</div><div class="line">      &#125; line_number_table[line_number_table_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="LocalVariableTable-属性"><a href="#LocalVariableTable-属性" class="headerlink" title="LocalVariableTable 属性"></a>LocalVariableTable 属性</h5><p>LocalVariableTable 是可选变长属性，位于 Code属性的属性表中。它被调<br>试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，<br>LocalVariableTable 属性可以按照任意顺序出现。 Code 属性中的每个局部变量最多只能有一<br>个 LocalVariableTable 属性。<br>LocalVariableTable 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LocalVariableTable_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 local_variable_table_length</div><div class="line">    &#123; u2 start_pc;</div><div class="line">      u2 length;</div><div class="line">      u2 name_index;</div><div class="line">      u2 descriptor_index;</div><div class="line">      u2 index;</div><div class="line">    &#125; local_variable_table[local_variable_table_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Signature-属性"><a href="#Signature-属性" class="headerlink" title="Signature 属性"></a>Signature 属性</h5><p>Signature 属性是可选的定长属性，位于 ClassFile， field_info<br>或 method_info结构的属性表中。在 Java 语言中，任何类、 接口、 初始化方法或成<br>员的泛型签名如果包含了类型变量（ Type Variables） 或参数化类型（ Parameterized<br>Types），则 Signature 属性会为它记录泛型签名信息。<br>Signature 属性格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Signature_attribute &#123;</div><div class="line">    u2 attribute_name_index;//属性名称在常量池中的索引，指向一个 CONSTANT_Utf8_info结构。</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 signature_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>slot是虚拟机未局部变量分配内存使用的最小单位。对于byte/char/float/int/short/boolean/returnAddress等长度不超过32位的局部变量，每个占用1个Slot；对于long和double这两种64位的数据类型则需要2个Slot来存放。</li>
<li>实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。</li>
<li>max_locals，不是所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。</li>
<li>虚拟机规范限制严格方法不允许超过65535个字节码，否则拒绝编译。</li>
</ul>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解JVM中class文件结构--概念部分]]></title>
      <url>http://vinoit.me/2016/05/22/java-classfile-structure-concept/</url>
      <content type="html"><![CDATA[<h4 id="什么是class文件"><a href="#什么是class文件" class="headerlink" title="什么是class文件"></a>什么是class文件</h4><p>java源代码（后缀名是.java）经过编译器编译之后会生成class文件（后缀名是.class），每一个 Class 文件都对应着唯一一个类或接口的定义信息，但是相对地， 类或接口并不一定都得定义在文件里，我们只是通俗地将任意一个有效的类或接口所应当满足的格式称为“ Class 文件格式”， 即使它不一定以磁盘文件的形式存在。</p>
<p>每个 Class 文件都是由 8 字节为单位的字节流组成，所有的 16 位、 32 位和 64 位长度的数据将被构造成 2 个、 4 个和 8 个 8 字节单位来表示。多字节数据项总是按照 <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">Big-Endian</a>的顺序进行存储。<br>JVM规范还定义了一组私有数据类型来表示 Class 文件的内容，它们包括 <code>u1， u2 和 u4</code>，分别代表了 <code>1、 2 和 4</code>个字节的无符号。</p>
<p>为了避免与类的字段、 类的实例等概念产生混淆， 在此把用于描述类结构格式的内容定义为<code>项</code>（ Item）。在 Class 文件中，各项按照<code>严格顺序连续存放</code>的， 它们之间没有任何填充或对齐作为各项间的分隔符号。</p>
<p><code>表</code>（ Table） 是由任意数量的可变长度的<code>项</code>组成，用于表示Class 文件内容的一系列复合结构。</p>
<h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>每一个 Class 文件对应于一个如下所示的 ClassFile 结构体：</p>
<p>ClassFile :<br>    <code>u4 magic;</code><br>    <strong>魔数值固定为 0xCAFEBABE,不会改变，唯一作用是确定这个文件是否为一个能被虚拟机所接受的 Class 文件。</strong><br>    <code>u2 minor_version;</code><strong>副版本号</strong><br>    <code>u2 major_version;</code><strong>主版本号</strong><br>    <strong>主副版本号共同构成了 Class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m。一个 Java 虚拟机实例只能支持特定范围内的主版本号。</strong><br>    <code>u2 constant_pool_count;</code><br>    <strong>常量池计数器，constant_pool_count 的值等于 constant_pool 表中的成员数加 1。constant_pool 表的索引值只有在大于 0 且小于 constant_pool_count 时才会被认为是有效的。（0表示不引用常量池的任一项）</strong><br>    <code>cp_info constant_pool[constant_pool_count-1];</code><br>    <strong>常量池，constant_pool 是一种表结构， 它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，  称为“ tagbyte”。常量池的索引范围是 1 至 constant_pool_count−1。（索引1表示第一个常量项）具体结构信息可查看我的另<br>    一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 access_flags;</code><br>    <strong>访问标志， access_flags 是一种掩码标志， 用于表示某个类或者接口的访问权限及基础属性。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 this_class;</code><br>    <strong>类索引， this_class 的值必须是对 constant_pool 表中项目的一个有效索引值。constant_pool 表在这个索引处的项必须为 CONSTANT_Class_info 类型常量。</strong><br>    <code>u2 super_class;</code><br>    <strong>父类索引，对于类来说， super_class 的值必须为 0 或者是对 constant_pool 表中项目的一个有效索引值。 如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为 CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。</strong><br>    <code>u2 interfaces_count;</code><br>    <strong>接口计数器， interfaces_count 的值表示当前类或接口的直接父接口数量。</strong><br>    <code>u2 interfaces[interfaces_count];</code><br>    <strong>接口表， interfaces[]数组中的每个成员的值必须是一个对 constant_pool 表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 类型常量,成员所表示的接口顺序和对应的源代码中给定的接口顺序（ 从左至右）<br>    一样。</strong><br>    <code>u2 fields_count;</code><br>    <strong>字段计数器， fields_count 的值表示当前 Class 文件 fields[]数组的成员个数。</strong><br>    <code>field_info fields[fields_count];</code><br>    <strong>字段表， fields[]数组中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述。fields[]数组描述当前类或接口声明的所有字段，但<em>不包括</em>从父类或父接口继承的部分。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 methods_count;</code><br>    <strong>方法计数器， methods_count 的值表示当前 Class 文件 methods[]数组的成员个数。</strong><br>    <code>method_info methods[methods_count];</code><br>    <strong>方法表， methods[]数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。methods[]数组只描述当前类或接口中声明的方法，<code>不包括</code>从父类或父接口继承的方法。具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong><br>    <code>u2 attributes_count;</code><br>    <strong>属性计数器， attributes_count 的值表示当前 Class 文件 attributes 表的成员个数。attributes 表中每一项都是一个attribute_info 结构的数据项。</strong><br>    <code>attribute_info attributes[attributes_count];</code><br>    <strong>属性表，和字段表、方法表中属性表中的内容<em>有所区别</em>。（某些属性只能用于class,某些属性只能用于字段或者方法，例如ConstantValue 属性用于字段，Code 属性用于方法）具体结构信息可查看我的另一篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>对应tag。</strong></p>
<p><code>以下是JVM规范SE7中的原文：</code><br>JVM规范里， Class 文件结构中的 attributes 表的项包括下列定义的属性：InnerClasses、EnclosingMethod、Synthetic 、Signature、SourceFile，SourceDebugExtension、 Deprecated、 RuntimeVisibleAnnotations、 RuntimeInvisibleAnnotations以及BootstrapMethods属性。对于支持 Class 文件格式版本号为 49.0 或更高的 Java虚拟机实现，必须正确识别并读取 attributes表中的Signature、 RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。<br>对于支持 Class 文件格式版本号为 51.0 或更高的Java 虚拟机实现，必须正确识别并读取 attributes 表中的BootstrapMethods属性。<br>本规范要求任一 Java 虚拟机实现可以自动忽略Class文件的 attributes 表中的若干（ 甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响 Class 文件的语义，只能提供附加的描述信息。<br><code>概括一下：虚拟机可以忽视某些属性，不同版本的虚拟机实例中所需的属性有所区别，你也可以实现自己的属性，但是只能作为附加信息，不能对原语义做出修改。</code></p>
<p>以上结构便是整个class文件，建议和我的另两篇博文<a href="/2016/05/22/java-classfile-structure-detail/">《理解JVM中class文件结构–具体结构信息》</a>以及<a href="/2016/05/23/java-classfile-structure-example/">《理解JVM中class文件结构–实例讲解》</a>结合的来看。</p>
<ul>
<li>参考《JVM规范SE7》</li>
</ul>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型（二）——重排序]]></title>
      <url>http://vinoit.me/2016/05/21/java-memeory-model-reorder/</url>
      <content type="html"><![CDATA[<h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td style="text-align:left">写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td style="text-align:left">读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量。</td>
</tr>
</tbody>
</table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> pi  = <span class="number">3.14</span>;    <span class="comment">//A</span></div><div class="line"><span class="keyword">double</span> r   = <span class="number">1.0</span>;     <span class="comment">//B</span></div><div class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">//C</span></div></pre></td></tr></table></figure></p>
<p>上面三个操作的数据依赖关系如下图所示：<br><img src="/images/JMM/JMM-reorder-0.png" alt=""><br>如上图所示，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。下图是该程序的两种执行顺序：<br><img src="/images/JMM/JMM-reorder-1.png" alt=""><br>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h4 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h4><p>根据happens- before的程序顺序规则，上面计算圆的面积的示例代码存在三个happens- before关系：</p>
<p>1.A happens- before B；<br>2.B happens- before C；<br>3.A happens- before C；<br>这里的第3个happens- before关系，是根据happens- before的传递性推导出来的。</p>
<p>这里A happens- before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。</p>
<h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">      <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">            a = <span class="number">1</span>;                   <span class="comment">//1</span></div><div class="line">            flag = <span class="keyword">true</span>;             <span class="comment">//2</span></div><div class="line">      &#125;</div><div class="line">      <span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i =  a * a;        <span class="comment">//4</span></div><div class="line">            ……</div><div class="line">          &#125;</div><div class="line">      &#125;       </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入？</p>
<p><code>答案是：不一定能看到。</code></p>
<p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图：<br><img src="/images/JMM/JMM-reorder-2.png" alt=""><br>如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！</p>
<p><code>※注：本文统一用红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。</code></p>
<p>下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作3和操作4重排序后，程序的执行时序图：<br><img src="/images/JMM/JMM-reorder-2.png" alt=""><br>在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux内存分配的原理--molloc/brk/mmap]]></title>
      <url>http://vinoit.me/2016/05/20/linux-memory-alloc/</url>
      <content type="html"><![CDATA[<p>内存分配的原理__进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<h4 id="如何查看进程发生缺页中断的次数？"><a href="#如何查看进程发生缺页中断的次数？" class="headerlink" title="如何查看进程发生缺页中断的次数？"></a>如何查看进程发生缺页中断的次数？</h4><p>用<code>ps -o majflt,minflt -C program</code>命令查看。</p>
<p>majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。这两个数值表示一个进程自启动以来所发生的缺页中断的次数。</p>
<p>发生缺页中断后，执行了那些操作？</p>
<h4 id="当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作："><a href="#当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：" class="headerlink" title="当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作："></a>当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：</h4><ol>
<li><p>检查要访问的虚拟地址是否合法</p>
</li>
<li><p>查找/分配一个物理页</p>
</li>
<li><p>填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）</p>
</li>
<li><p>建立映射关系（虚拟地址到物理地址）</p>
</li>
</ol>
<p>重新执行发生缺页中断的那条指令</p>
<p>如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。</p>
<h4 id="内存分配原理"><a href="#内存分配原理" class="headerlink" title="内存分配原理"></a>内存分配原理</h4><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p>
<ul>
<li><p>brk是将数据段(.data)的最高地址指针_edata往高地址推；</p>
</li>
<li><p>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
</li>
</ul>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p>
<p>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p>
<h5 id="下面以一个例子来说明内存分配的原理："><a href="#下面以一个例子来说明内存分配的原理：" class="headerlink" title="下面以一个例子来说明内存分配的原理："></a>下面以一个例子来说明内存分配的原理：</h5><p>情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：<br><img src="/images/linux/linux-memory-alloc-0.jpg" alt=""><br>1.进程启动的时候，其（虚拟）内存空间的初始布局如图1-(1)所示。</p>
<p>其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。</p>
<p><code>_edata</code>指针（glibc里面定义）指向数据段的最高地址。</p>
<p>2.进程调用<code>A=malloc(30K)</code>以后，内存空间如图1-(2)：</p>
<p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p>
<p>你可能会问：只要把<code>_edata+30K</code>就完成内存分配了？</p>
<p>事实是这样的，<code>_edata+30K</code>只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</p>
<p>3.进程调用<code>B=malloc(40K)</code>以后，内存空间如图1-(3)。</p>
<p>情况二、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：<br><img src="/images/linux/linux-memory-alloc-1.jpg" alt=""></p>
<p>4.进程调用<code>C=malloc(200K)</code>以后，内存空间如图2-(4)：</p>
<p>默认情况下，malloc函数分配内存，如果请求内存大于128K（可由<code>M_MMAP_THRESHOLD</code>选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</p>
<p>这样子做主要是因为::<br>brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。<br>当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。</p>
<p>5.进程调用<code>D=malloc(100K)</code>以后，内存空间如图2-(5)；</p>
<p>6.进程调用<code>free(C</code>)以后，C对应的虚拟内存和物理内存一起释放如图2-(6)。<br><img src="/images/linux/linux-memory-alloc-2.jpg" alt=""></p>
<p>7.进程调用free(B)以后，如图3-(7)所示：</p>
<p>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？</p>
<p>当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。</p>
<p>8.进程调用free(D)以后，如图3-(8)所示：</p>
<p>B和D连接起来，变成一块140K的空闲内存。</p>
<p>9.默认情况下：</p>
<p>当最高地址空间的空闲内存超过128K（可由<code>M_TRIM_THRESHOLD</code>选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图3-(9)所示。</p>
<hr>
<h4 id="mmap-样例"><a href="#mmap-样例" class="headerlink" title="mmap 样例"></a>mmap 样例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,l;</div><div class="line">	<span class="keyword">char</span> *mp;</div><div class="line">	mp = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">1000000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</div><div class="line">	*mp = <span class="string">'A'</span>;</div><div class="line">	munmap(mp, <span class="number">1000000</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,l;</div><div class="line">	<span class="keyword">int</span> fd;</div><div class="line">	<span class="keyword">char</span> *mp;</div><div class="line"></div><div class="line">	fd = open(<span class="string">"/tmp/mmap"</span>, O_CREAT|O_RDWR, <span class="number">00777</span>);</div><div class="line">	lseek(fd, <span class="number">100</span>, SEEK_SET);</div><div class="line">	write(fd, <span class="string">""</span>, <span class="number">1</span>);</div><div class="line">	mp = <span class="built_in">malloc</span>(<span class="number">1000000</span>);</div><div class="line">	mp = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">100</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</div><div class="line">	i = *mp;</div><div class="line">	*mp = <span class="string">'A'</span>;</div><div class="line">	munmap(mp, <span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解JVM加载class原理--class加载的时机]]></title>
      <url>http://vinoit.me/2016/05/19/when-jvm-load-class/</url>
      <content type="html"><![CDATA[<h3 id="java的动态性"><a href="#java的动态性" class="headerlink" title="java的动态性"></a>java的动态性</h3><p>Java 语言是一种具有动态性的解释型编程语言，当指定程序运行的时候， Java 虚拟机就将编译生成的 . class 文件按照需求和一定的规则加载进内存，并组织成为一个完整的 Java 应用程序。 Java 语言把每个单独的类 Class 和接口 Implements 编译成单独的一个 . class 文件，这些文件对于 Java 运行环境来说就是一个个可以动态加载的单元。正是因为 Java 的这种特性，我们可以在不重新编译其它代码的情况下，只编译需要修改的单元，并把修改文件编译后的 . class 文件放到 Java 的路径当中， 等到下次该 Java 虚拟机器重新激活时，这个逻辑上的 Java 应用程序就会因为加载了新修改的 .class 文件，自己的功能也做了更新，这就是 Java 的动态性。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（using）、和卸载（Unloading）七个阶段。其中验证、准备和解析三个部分统称为连接（Linking），这七个阶段的发生顺序如下图所示：<br> <img src="/images/jvm/when-jvm-load-class-0.PNG" alt=""><br> 如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始。</p>
<p>类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>Java虚拟机规范没有强制性约束在什么时候开始类加载过程，但是对于初始化阶段，虚拟机规范则严格规定了有且只有四种情况必需立即对类进行“初始化”（而加载、验证、准备阶段则必需在此之前开始），这四种情况归类如下：<br>1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或者设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）时、以及调用一个类的静态方法的时候。<br>2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要触发父类的初始化。<br>4.当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法的类），虚拟机会先初始化这个类。</p>
<p>对于这四种触发类进行初始化的场景，在java虚拟机规范中限定了“有且只有”这四种场景会触发。这四种场景的行为称为对类的<code>主动引用</code>，除此以外的所有引用类的方式都不会触发类的初始化，称为<code>被动引用</code>。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>下面通过三个实例来说明被动引用：</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p> 父类SuperClass.java<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子类SubClass.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(SubClass.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure></p>
<p>由结果可以看出只输出了“SuperClass init！”，没有输出“SubClass init！”。这是因为对于静态字段，只有直接定义该字段的类才会被初始化，因此当我们通过子类来引用父类中定义的静态字段时，只会触发父类的初始化，而不会触发子类的初始化。</p>
<h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>父类SuperClass.java如上一个示例一样<br>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">      SuperClass[] scs = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>输出结果为空</code><br>没有输出“SuperClass init！”说明没有触发类com.chenzhou.classloading.SuperClass的初始化阶段，但是这段代码会触发“[Lcom.chenzhou.classloading.SuperClass”类的初始化阶段。这个类是由虚拟机自动生成的，该创建动作由newarray触发。<code>从这里可以看出，对象的数组在java里面是一个单独的类型。</code></p>
<h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>常量类ConstClass.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          System.out.println(ConstClass.HELLOWORLD);  </div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>输出：hello world</code><br>上面的示例代码运行后也没有输出“SuperClass init！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，<code>但是在编译阶段将此常量的值“hello world”存储到了NotInitialization类的常量池中</code>，对于常量ConstClass.HELLOWORLD的引用实际上都被转化为NotInitialization类对自身常量池的引用了。实际上NotInitialization的Class文件之中已经不存在ConstClass类的符号引用入口了。</p>
<h3 id="接口加载与类加载的区别"><a href="#接口加载与类加载的区别" class="headerlink" title="接口加载与类加载的区别"></a>接口加载与类加载的区别</h3><p>接口的加载过程与类加载的区别在于当类在初始化时要求其父类都已经初始化过了，但是一个接口在初始化时，并不要求其父类都完成了初始化，只有在真正用到父类接口的时候（如引用父接口的常量）才会初始化。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>主类NotInitialization.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pac1;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by vino on 2016/5/19.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          <span class="keyword">new</span> SubClass();</div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line">SubClass init!</div></pre></td></tr></table></figure></p>
<p>如果此时的父类是一个接口，则只输出<code>SubClass init!</code>。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>

</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM内存模型及垃圾收集策略解析]]></title>
      <url>http://vinoit.me/2016/05/19/jvm-gc-tactics/</url>
      <content type="html"><![CDATA[<p><code>本文涉及的JDK版本 &lt;= 1.6</code></p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>Java虚拟机的内存模型分为五个部分，分别是：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。</p>
<p>这五个区域既然是存储空间，那么为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。</p>
<p>这个垃圾收集者就是平常我们所说的“垃圾收集器”，那么垃圾收集器在何时清扫内存？清扫哪些数据？这就是接下来我们要解决的问题。</p>
<p>程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，也就是每条线程都拥有这三块区域，而且会随着线程的创建而创建，线程的结束而销毁。那么，垃圾收集器在何时清扫这三块区域的问题就解决了。</p>
<p>此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，方法的结束而出栈，并且每个栈帧中的本地变量表都是在类被加载的时候就确定的。因此以上三个区域的垃圾收集工作具有确定性，垃圾收集器能够清楚地知道何时清扫这三块区域中的哪些数据。</p>
<p>然而，堆和方法区中的内存清理工作就没那么容易了。<br>堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。</p>
<p>堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。</p>
<p>方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。<br>因此，堆和方法区的内存回收具有不确定性。</p>
<h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><p>JVM堆一般又可以分为以下三部分：<br><img src="/images/jvm/jvm-gc-tactics-0.jpg" alt=""></p>
<ul>
<li>Perm</li>
</ul>
<p>Perm代主要保存class,method,filed对象，这部门的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p>
<ul>
<li>Tenured</li>
</ul>
<p>Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p>
<ul>
<li>Young</li>
</ul>
<p>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Young区间变满的时候，minor GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p>
<h4 id="Sizing-the-Generations"><a href="#Sizing-the-Generations" class="headerlink" title="Sizing the Generations"></a>Sizing the Generations</h4><p>JVM提供了相应的参数来对内存大小进行配置。正如上面描述，JVM中堆被分为了3个大的区间，同时JVM也提供了一些选项对Young,Tenured的大小进行控制。<br><img src="/images/jvm/jvm-gc-tactics-1.jpg" alt=""></p>
<ul>
<li>Total Heap</li>
</ul>
<p><code>-Xms:</code>指定了JVM初始启动以后初始化内存</p>
<p><code>-Xmx：</code>指定JVM堆得最大内存，在JVM启动以后，会分配<code>-Xmx</code>参数指定大小的内存给JVM，但是不一定全部使用，JVM会根据-Xms参数来调节真正用于JVM的内存</p>
<p><code>-Xmx -Xms</code>之差就是三个Virtual空间的大小</p>
<ul>
<li>Young Generation</li>
</ul>
<p><code>-XX:NewRatio=8</code>意味着tenured 和 young的比值8：1，这样eden+2*survivor=1/9</p>
<p>堆内存</p>
<p><code>-XX:SurvivorRatio=32</code>意味着eden和一个survivor的比值是32：1，这样一个Survivor就占Young区的1/34.</p>
<p><code>-Xmn</code> 参数设置了年轻代的大小</p>
<ul>
<li>Perm Generation</li>
</ul>
<p><code>-XX:PermSize=16M -XX:MaxPermSize=64M</code></p>
<p>Thread Stack</p>
<p><code>-XX:Xss=128K</code></p>
<h4 id="堆栈分离的好处"><a href="#堆栈分离的好处" class="headerlink" title="堆栈分离的好处"></a>堆栈分离的好处</h4><p>如果从JAVA内存模型的角度去理解面向对象的设计，我们就会发现对象它完美的表示了堆和栈，对象的数据放在堆中，而我们编写的那些方法一般都是运行在栈中，因此面向对象的设计是一种非常完美的设计方式，它完美的统一了数据存储和运行。</p>
<h3 id="JAVA垃圾收集器"><a href="#JAVA垃圾收集器" class="headerlink" title="JAVA垃圾收集器"></a>JAVA垃圾收集器</h3><h4 id="常见的垃圾收集策略"><a href="#常见的垃圾收集策略" class="headerlink" title="常见的垃圾收集策略"></a>常见的垃圾收集策略</h4><p><img src="/images/jvm/jvm-gc-tactics-2.jpg" alt=""></p>
<p>所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面得不可到达主要是指应用程序已经没有内存块的引用了，而在JAVA中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。</p>
<h5 id="Reference-Counting-引用计数）"><a href="#Reference-Counting-引用计数）" class="headerlink" title="Reference Counting(引用计数）"></a>Reference Counting(引用计数）</h5><p>  引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。</p>
<p><code>优点：</code><br>简单，直接，不需要暂停整个应用<br><code>缺点：</code><br>1.需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作，比如每次将对象赋值给新的引用，或者者对象的引用超出了作用域等。<br>2.不能处理循环引用的问题</p>
<h5 id="跟踪收集器"><a href="#跟踪收集器" class="headerlink" title="跟踪收集器"></a>跟踪收集器</h5><p>跟踪收集器首先要暂停整个应用程序，然后开始从根对象扫描整个堆，判断扫描的对象是否有对象引用，这里面有三个问题需要搞清楚：<br><img src="/images/jvm/jvm-gc-tactics-3.jpg" alt=""><br>1．如果每次扫描整个堆，那么势必让GC的时间变长，从而影响了应用本身的执行。因此在JVM里面采用了分代收集，在新生代收集的时候minor gc只需要扫描新生代，而不需要扫描老生代。</p>
<p>2．JVM采用了分代收集以后，minor gc只扫描新生代，但是minor gc怎么判断是否有老生代的对象引用了新生代的对象，JVM采用了卡片标记的策略，卡片标记将老生代分成了一块一块的，划分以后的每一个块就叫做一个卡片，JVM采用卡表维护了每一个块的状态，当JAVA程序运行的时候，如果发现老生代对象引用或者释放了新生代对象的引用，那么就JVM就将卡表的状态设置为脏状态，这样每次minor gc的时候就会只扫描被标记为脏状态的卡片，而不需要扫描整个堆。具体如下图：<br>3．GC在收集一个对象的时候会判断是否有引用指向对象，在JAVA中的引用主要有四种：Strong reference,Soft reference,Weak reference,Phantom reference.</p>
<ul>
<li>Strong Reference</li>
</ul>
<p>强引用是JAVA中默认采用的一种方式，我们平时创建的引用都属于强引用。如果一个对象没有强引用，那么对象就会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      Object referent = <span class="keyword">new</span> Object();  </div><div class="line">      Object strongReference = referent;  </div><div class="line">      referent = <span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNotNull(strongReference);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Soft Reference</li>
</ul>
<p>软引用的对象在GC的时候不会被回收，只有当内存不够用的时候才会真正的回收，因此软引用适合缓存的场合，这样使得缓存中的对象可以尽量的再内存中待长久一点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      String  str =  <span class="string">"test"</span>;  </div><div class="line">      SoftReference&lt;String&gt; softreference = <span class="keyword">new</span> SoftReference&lt;String&gt;(str);  </div><div class="line">      str=<span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNotNull(softreference.get());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Weak reference</li>
</ul>
<p>弱引用有利于对象更快的被回收，假如一个对象没有强引用只有弱引用，那么在GC后，这个对象肯定会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span></span>&#123;  </div><div class="line">      String  str =  <span class="string">"test"</span>;  </div><div class="line">      WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);  </div><div class="line">      str=<span class="keyword">null</span>;  </div><div class="line">      System.gc();  </div><div class="line">      assertNull(weakReference.get());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>Phantom reference</li>
</ul>
<h6 id="Mark-Sweep-Collector-标记-清除收集器）"><a href="#Mark-Sweep-Collector-标记-清除收集器）" class="headerlink" title="Mark-Sweep Collector(标记-清除收集器）"></a>Mark-Sweep Collector(标记-清除收集器）</h6><p>标记清除收集器最早由Lisp的发明人于1960年提出，标记清除收集器停止所有的工作，从根扫描每个活跃的对象，然后标记扫描过的对象，标记完成以后，清除那些没有被标记的对象。</p>
<p><code>优点：</code><br>1.解决循环引用的问题<br>2.不需要编译器的配合，从而就不执行额外的指令<br><code>缺点：</code><br>1.每个活跃的对象都要进行扫描，收集暂停的时间比较长。</p>
<h6 id="Copying-Collector-复制收集器）"><a href="#Copying-Collector-复制收集器）" class="headerlink" title="Copying Collector(复制收集器）"></a>Copying Collector(复制收集器）</h6><p>复制收集器将内存分为两块一样大小空间，某一个时刻，只有一个空间处于活跃的状态，当活跃的空间满的时候，GC就会将活跃的对象复制到未使用的空间中去，原来不活跃的空间就变为了活跃的空间。复制收集器具体过程可以参考下图：<br><img src="/images/jvm/jvm-gc-tactics-4.jpg" alt=""><br><code>优点：</code><br>1.只扫描可以到达的对象，不需要扫描所有的对象，从而减少了应用暂停的时间<br><code>缺点：</code><br>1.需要额外的空间消耗，某一个时刻，总是有一块内存处于未使用状态<br>2.复制对象需要一定的开销</p>
<h6 id="Mark-Compact-Collector-标记-整理收集器）"><a href="#Mark-Compact-Collector-标记-整理收集器）" class="headerlink" title="Mark-Compact Collector(标记-整理收集器）"></a>Mark-Compact Collector(标记-整理收集器）</h6><p>标记整理收集器汲取了标记清除和复制收集器的优点，它分两个阶段执行，在第一个阶段，首先扫描所有活跃的对象，并标记所有活跃的对象，第二个阶段首先清除未标记的对象，然后将活跃的的对象复制到堆得底部。标记整理收集器的过程示意图请参考下图：Mark-compact策略极大的减少了内存碎片，并且不需要像Copy Collector一样需要两倍的空间。<br><img src="/images/jvm/jvm-gc-tactics-5.jpg" alt=""></p>
<h4 id="JVM的垃圾收集策略"><a href="#JVM的垃圾收集策略" class="headerlink" title="JVM的垃圾收集策略"></a>JVM的垃圾收集策略</h4><p>GC的执行时要耗费一定的CPU资源和时间的，因此在JDK1.2以后，JVM引入了分代收集的策略，其中对新生代采用<code>&quot;Copying Collector&quot;</code>策略，而对老生代采用了<code>“Mark-Compact&quot;</code>的策略。其中新生代的垃圾收集器命名为<code>“minor gc”</code>，老生代的GC命名为<code>&quot;Full Gc</code> 或者<code>Major GC&quot;</code>.其中用<code>System.gc()</code>强制执行的是<code>Full Gc</code>.</p>
<h5 id="新生代垃圾收集"><a href="#新生代垃圾收集" class="headerlink" title="新生代垃圾收集"></a>新生代垃圾收集</h5><p>在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。</p>
<p>通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。</p>
<p>但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。</p>
<h5 id="什么是分配担保？"><a href="#什么是分配担保？" class="headerlink" title="什么是分配担保？"></a>什么是分配担保？</h5><p>当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发MinorGC，对该区域的废弃对象进行回收。但如果MinorGC过后只有少量对象被回收，仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。</p>
<h5 id="老年代垃圾收集"><a href="#老年代垃圾收集" class="headerlink" title="老年代垃圾收集"></a>老年代垃圾收集</h5><p>老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。</p>
<h5 id="方法区垃圾收集"><a href="#方法区垃圾收集" class="headerlink" title="方法区垃圾收集"></a>方法区垃圾收集</h5><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</p>
<p>加载该类的ClassLoader已经被回收。</p>
<p>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class及-XX:+TraceClassLoading、 -XX:+TraceClassUnLoading</code>查看类的加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<p>参考</p>
<ul>
<li><a href="http://developer.51cto.com/art/201002/184385_all.htm" target="_blank" rel="external">http://developer.51cto.com/art/201002/184385_all.htm</a></li>
</ul>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解Java内存模型（一）——基础]]></title>
      <url>http://vinoit.me/2016/05/19/java-memory-model-basis/</url>
      <content type="html"><![CDATA[<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>
<h3 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h3><p>在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：<br><img src="/images/JMM/JMM-0.png" alt=""><br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：<br><img src="/images/JMM/JMM-1.png" alt=""><br>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="/images/JMM/JMM-2.png" alt=""><br>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h3 id="处理器重排序与内存屏障指令"><a href="#处理器重排序与内存屏障指令" class="headerlink" title="处理器重排序与内存屏障指令"></a>处理器重排序与内存屏障指令</h3><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！为了具体说明，请看下面示例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Process A</th>
<th style="text-align:left">Process B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = 1; //A1 <br> x = b; //A2</td>
<td style="text-align:left">b = 2; //B1 <br> y = a; //B2</td>
</tr>
<tr>
<td style="text-align:left">初始状态：a = b = 0 <br> 处理器允许执行后得到结果：x = y = 0</td>
<td style="text-align:left">(合并行)</td>
</tr>
</tbody>
</table>
<p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到x = y = 0的结果。具体的原因如下图所示：<br><img src="/images/JMM/JMM-3.png" alt=""><br>这里处理器A和处理器B可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x = y = 0的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器A的内存操作顺序被重排序了（处理器B的情况和处理器A一样，这里就不赘述了）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操做重排序。</p>
<p>下面是常见处理器允许的重排序类型的列表：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>Load-Load</th>
<th>Load-Store</th>
<th>Store-Store</th>
<th>Store-Load</th>
<th>数据依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sparc-TSO</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">X86</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p>
<p>从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。</p>
<ul>
<li><p>注1：sparc-TSO是指以TSO(Total Store Order)内存模型运行时，sparc处理器的特性。</p>
</li>
<li><p>注2：上表中的x86包括x64及AMD64。</p>
</li>
<li><p>注3：由于ARM处理器的内存模型与PowerPC处理器的内存模型非常类似，本文将忽略它。</p>
</li>
<li><p>注4：数据依赖性后文会专门说明。</p>
</li>
</ul>
<p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td style="text-align:left">StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储。</td>
</tr>
<tr>
<td style="text-align:left">LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td style="text-align:left">StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）。JSR-133提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的happens-before规则如下：</p>
<ul>
<li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。</li>
</ul>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before的定义很微妙，后文会具体说明happens-before为什么要这么定义。</p>
<p>happens-before与JMM的关系如下图所示：<br><img src="/images/JMM/JMM-4.png" alt=""><br>如上图所示，一个happens-before规则通常对应于多个编译器重排序规则和处理器重排序规则。对于java程序员来说，happens-before规则简单易懂，它避免程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入解析String#intern]]></title>
      <url>http://vinoit.me/2016/05/18/java-intern-in-depth-analysis/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。</p>
<p>8种基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li>
</ul>
<p>接下来我们主要来谈一下String#intern方法。</p>
<h3 id="intern-的实现原理"><a href="#intern-的实现原理" class="headerlink" title="intern 的实现原理"></a>intern 的实现原理</h3><p>首先深入看一下它的实现原理。</p>
<h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a canonical representation for the string object.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * A pool of strings, initially empty, is maintained privately by the</div><div class="line"> * class &lt;code&gt;String&lt;/code&gt;.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * When the intern method is invoked, if the pool already contains a</div><div class="line"> * string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by</div><div class="line"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</div><div class="line"> * returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the</div><div class="line"> * pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * It follows that for any two strings &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;,</div><div class="line"> * &lt;code&gt;s.intern()&amp;nbsp;==&amp;nbsp;t.intern()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</div><div class="line"> * if and only if &lt;code&gt;s.equals(t)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * All literal strings and string-valued constant expressions are</div><div class="line"> * interned. String literals are defined in section 3.10.5 of the</div><div class="line"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</div><div class="line"> *          guaranteed to be from a pool of unique strings.</div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>String#intern方法中看到，这个方法是一个 native 的方法，但注释写的非常明了。“如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p>
<h4 id="native代码"><a href="#native代码" class="headerlink" title="native代码"></a>native代码</h4><p>在 jdk7后，oracle 接管了 JAVA 的源码后就不对外开放了，根据 jdk 的主要开发人员声明 openJdk7 和 jdk7 使用的是同一分主代码，只是分支代码会有些许的变动。所以可以直接跟踪 openJdk7 的源码来探究 intern 的实现。</p>
<h5 id="native实现代码"><a href="#native实现代码" class="headerlink" title="native实现代码:"></a>native实现代码:</h5><p><code>\openjdk7\jdk\src\share\native\java\lang\String.c</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Java_java_lang_String_intern(JNIEnv *env, jobject <span class="keyword">this</span>)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> JVM_InternString(env, <span class="keyword">this</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\prims\jvm.h</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* java.lang.String</div><div class="line">*/  </div><div class="line"><span class="function">JNIEXPORT jstring JNICALL  </span></div><div class="line"><span class="title">JVM_InternString</span><span class="params">(JNIEnv *env, jstring str)</span>;</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\prims\jvm.cpp</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// String support ///////////////////////////////////////////////////////////////////////////  </span></div><div class="line">JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))  </div><div class="line">  JVMWrapper(<span class="string">"JVM_InternString"</span>);  </div><div class="line">  JvmtiVMObjectAllocEventCollector oam;  </div><div class="line">  <span class="keyword">if</span> (str == NULL) <span class="keyword">return</span> NULL;  </div><div class="line">  oop string = JNIHandles::resolve_non_null(str);  </div><div class="line">  oop result = StringTable::intern(string, CHECK_NULL);</div><div class="line">  <span class="keyword">return</span> (jstring) JNIHandles::make_local(env, result);  </div><div class="line">JVM_END</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">oop StringTable::intern(Handle string_or_null, jchar* name,  </div><div class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;  </div><div class="line">  unsigned <span class="keyword">int</span> hashValue = java_lang_String::hash_string(name, len);  </div><div class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);  </div><div class="line">  oop string = the_table()-&gt;lookup(index, name, len, hashValue);  </div><div class="line">  <span class="comment">// Found  </span></div><div class="line">  <span class="keyword">if</span> (string != NULL) <span class="keyword">return</span> string;  </div><div class="line">  <span class="comment">// Otherwise, add to symbol to table  </span></div><div class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, string_or_null, name, len,  </div><div class="line">                                hashValue, CHECK_NULL);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>\openjdk7\hotspot\src\share\vm\classfile\symbolTable.cpp</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">oop StringTable::lookup(<span class="keyword">int</span> index, jchar* name,  </div><div class="line">                        <span class="keyword">int</span> len, unsigned <span class="keyword">int</span> hash) &#123;  </div><div class="line">  <span class="keyword">for</span> (HashtableEntry&lt;oop&gt;* l = bucket(index); l != NULL; l = l-&gt;next()) &#123;  </div><div class="line">    <span class="keyword">if</span> (l-&gt;hash() == hash) &#123;  </div><div class="line">      <span class="keyword">if</span> (java_lang_String::equals(l-&gt;literal(), name, len)) &#123;  </div><div class="line">        <span class="keyword">return</span> l-&gt;literal();  </div><div class="line">      &#125;  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> NULL;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的大体实现结构就是:<br>JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容。默认大小是1009。</p>
<p>要注意的是，String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
<p>在 jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：</p>
<p><code>-XX:StringTableSize=99991</code></p>
<h3 id="jdk6-和-jdk7-下-intern-的区别"><a href="#jdk6-和-jdk7-下-intern-的区别" class="headerlink" title="jdk6 和 jdk7 下 intern 的区别"></a>jdk6 和 jdk7 下 intern 的区别</h3><p>相信很多 JAVA 程序员都做做类似 <code>String s = new String(&quot;abc&quot;)</code>这个语句创建了几个对象的题目。 这种题目主要就是为了考察程序员对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。</p>
<p>来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    s.intern();</div><div class="line">    String s2 = <span class="string">"1"</span>;</div><div class="line">    System.out.println(s == s2);</div><div class="line"></div><div class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    s3.intern();</div><div class="line">    String s4 = <span class="string">"11"</span>;</div><div class="line">    System.out.println(s3 == s4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jdk6 下false false</div><div class="line">jdk7 下false true</div></pre></td></tr></table></figure></p>
<p>具体为什么稍后再解释，然后将<code>s3.intern();</code>语句下调一行，放到<code>String s4 = &quot;11&quot;;</code>后面。将<code>s.intern();</code>放到<code>String s2 = &quot;1&quot;;</code>后面。是什么结果呢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    String s2 = <span class="string">"1"</span>;</div><div class="line">    s.intern();</div><div class="line">    System.out.println(s == s2);</div><div class="line"></div><div class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</div><div class="line">    String s4 = <span class="string">"11"</span>;</div><div class="line">    s3.intern();</div><div class="line">    System.out.println(s3 == s4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jdk6 下false false</div><div class="line">jdk7 下false false</div></pre></td></tr></table></figure></p>
<h4 id="jdk6中的解释"><a href="#jdk6中的解释" class="headerlink" title="jdk6中的解释"></a>jdk6中的解释</h4><p><img src="/images/java/java-intern-in-depth-analysis-0.png" alt=""><br><code>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</code></p>
<p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern方法也是没有任何关系的。</p>
<h4 id="jdk7中的解释"><a href="#jdk7中的解释" class="headerlink" title="jdk7中的解释"></a>jdk7中的解释</h4><p>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p>
<p>正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。<br><img src="/images/java/java-intern-in-depth-analysis-1.png" alt=""></p>
<ul>
<li>在第一段代码中，先看 s3和s4字符串。String s3 = new String(“1”) + new String(“1”);，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的new String(“1”)我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li>
<li>接下来s3.intern();这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li>
<li>最后String s4 = “11”; 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 s3 == s4 是 true。</li>
<li>再看 s 和 s2 对象。 String s = new String(“1”); 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。</li>
<li>接下来String s2 = “1”; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。<br><img src="/images/java/java-intern-in-depth-analysis-2.png" alt=""></li>
<li>来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern(); 的顺序是放在String s4 = “11”;后了。这样，首先执行String s4 = “11”;声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern();时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。</li>
<li><p>第二段代码中的 s 和 s2 代码中，s.intern();，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(“1”);的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p>
</li>
<li><p>将String常量池 从 Perm 区移动到了 Java Heap区</p>
</li>
<li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。<h3 id="使用intern"><a href="#使用intern" class="headerlink" title="使用intern"></a>使用intern</h3><h4 id="intern-正确使用例子"><a href="#intern-正确使用例子" class="headerlink" title="intern 正确使用例子"></a>intern 正确使用例子</h4>接下来我们来看一下一个比较常见的使用String#intern方法的例子。</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">1000</span> * <span class="number">10000</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Integer[] DB_DATA = <span class="keyword">new</span> Integer[<span class="number">10</span>];</div><div class="line">    Random random = <span class="keyword">new</span> Random(<span class="number">10</span> * <span class="number">10000</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DB_DATA.length; i++) &#123;</div><div class="line">        DB_DATA[i] = random.nextInt();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</div><div class="line">        <span class="comment">//arr[i] = new String(String.valueOf(DB_DATA[i % DB_DATA.length]));</span></div><div class="line">         arr[i] = <span class="keyword">new</span> String(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println((System.currentTimeMillis() - t) + <span class="string">"ms"</span>);</div><div class="line">    System.gc();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行的参数是：-Xmx2g -Xms2g -Xmn1500M 上述代码是一个演示代码，其中有两条语句不一样，一条是使用 intern，一条是未使用 intern。结果如下图</p>
<p><code>2160ms</code><br><img src="/images/java/java-intern-in-depth-analysis-3.png" alt=""><br><code>826ms</code><br><img src="/images/java/java-intern-in-depth-analysis-4.png" alt=""><br>通过上述结果，我们发现不使用 intern 的代码生成了1000w 个字符串，占用了大约640m 空间。 使用了 intern 的代码生成了1345个字符串，占用总空间 133k 左右。其实通过观察程序中只是用到了10个字符串，所以准确计算后应该是正好相差100w 倍。虽然例子有些极端，但确实能准确反应出 intern 使用后产生的巨大空间节省。</p>
<p>细心的同学会发现使用了 intern 方法后时间上有了一些增长。这是因为程序中每次都是用了 new String 后，然后又进行 intern 操作的耗时时间，这一点如果在内存空间充足的情况下确实是无法避免的，但我们平时使用时，内存空间肯定不是无限大的，不使用 intern 占用空间导致 jvm 垃圾回收的时间是要远远大于这点时间的。 毕竟这里使用了1000w次intern 才多出来1秒钟多的时间。</p>
<h4 id="intern-不当使用"><a href="#intern-不当使用" class="headerlink" title="intern 不当使用"></a>intern 不当使用</h4><p>看过了 intern 的使用和 intern 的原理等，我们来看一个不当使用 intern 操作导致的问题。</p>
<p>在使用 fastjson 进行接口读取的时候，我们发现在读取了近70w条数据后，我们的日志打印变的非常缓慢，每打印一次日志用时30ms左右，如果在一个请求中打印2到3条日志以上会发现请求有一倍以上的耗时。在重新启动 jvm 后问题消失。继续读取接口后，问题又重现。接下来我们看一下出现问题的过程。</p>
<h5 id="根据-log4j-打印日志查找问题原因"><a href="#根据-log4j-打印日志查找问题原因" class="headerlink" title="根据 log4j 打印日志查找问题原因"></a>根据 log4j 打印日志查找问题原因</h5><p>在使用<code>log4j#info</code>打印日志的时候时间非常长。所以使用 housemd 软件跟踪 info 方法的耗时堆栈。</p>
<ul>
<li>trace SLF4JLogger.</li>
<li>trace AbstractLoggerWrapper:</li>
<li>trace AsyncLogger<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">org/apache/logging/log4j/core/async/AsyncLogger.actualAsyncLog(RingBufferLogEvent)                sun.misc.Launcher$AppClassLoader@<span class="number">109</span>aca82            <span class="number">1</span>            <span class="number">1</span>ms    org.apache.logging.log4j.core.async.AsyncLogger@<span class="number">19</span>de86bb  </div><div class="line">org/apache/logging/log4j/core/async/AsyncLogger.location(String)                                  sun.misc.Launcher$AppClassLoader@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">30</span>ms    org.apache.logging.log4j.core.async.AsyncLogger@<span class="number">19</span>de86bb  </div><div class="line">org/apache/logging/log4j/core/async/AsyncLogger.log(Marker, String, Level, Message, Throwable)    sun.misc.Launcher$AppClassLoader@<span class="number">109</span>aca82            <span class="number">1</span>           <span class="number">61</span>ms    org.apache.logging.log4j.core.async.AsyncLogger@<span class="number">19</span>de86bb</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代码出在 <code>AsyncLogger.location</code> 这个方法上. 里边主要是调用了 <code>return Log4jLogEvent.calcLocation(fqcnOfLogger);</code>和<code>Log4jLogEvent.calcLocation()</code></p>
<p><code>Log4jLogEvent.calcLocation()</code>的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StackTraceElement <span class="title">calcLocation</span><span class="params">(<span class="keyword">final</span> String fqcnOfLogger)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (fqcnOfLogger == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">final</span> StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();  </div><div class="line">    <span class="keyword">boolean</span> next = <span class="keyword">false</span>;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> StackTraceElement element : stackTrace) &#123;  </div><div class="line">        <span class="keyword">final</span> String className = element.getClassName();  </div><div class="line">        <span class="keyword">if</span> (next) &#123;  </div><div class="line">            <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </div><div class="line">                <span class="keyword">continue</span>;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> element;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span> (fqcnOfLogger.equals(className)) &#123;  </div><div class="line">            next = <span class="keyword">true</span>;  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NOT_AVAIL.equals(className)) &#123;  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过跟踪发现是 <code>Thread.currentThread().getStackTrace();</code> 的问题。</p>
<h5 id="跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern"><a href="#跟踪Thread-currentThread-getStackTrace-的-native-代码，验证String-intern" class="headerlink" title="跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern"></a>跟踪Thread.currentThread().getStackTrace()的 native 代码，验证String#intern</h5><p><code>Thread.currentThread().getStackTrace();native</code>的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;  </div><div class="line">        <span class="comment">// check for getStackTrace permission  </span></div><div class="line">        SecurityManager security = System.getSecurityManager();  </div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;  </div><div class="line">            security.checkPermission(  </div><div class="line">                SecurityConstants.GET_STACK_TRACE_PERMISSION);  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// optimization so we do not call into the vm for threads that  </span></div><div class="line">        <span class="comment">// have not yet started or have terminated  </span></div><div class="line">        <span class="keyword">if</span> (!isAlive()) &#123;  </div><div class="line">            <span class="keyword">return</span> EMPTY_STACK_TRACE;  </div><div class="line">        &#125;        StackTraceElement[][] stackTraceArray = dumpThreads(<span class="keyword">new</span> Thread[] &#123;<span class="keyword">this</span>&#125;);  </div><div class="line">        StackTraceElement[] stackTrace = stackTraceArray[<span class="number">0</span>];  </div><div class="line">        <span class="comment">// a thread that was alive during the previous isAlive call may have  </span></div><div class="line">        <span class="comment">// since terminated, therefore not having a stacktrace.  </span></div><div class="line">        <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;  </div><div class="line">            stackTrace = EMPTY_STACK_TRACE;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> stackTrace;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="comment">// Don't need JVM help for current thread  </span></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Exception()).getStackTrace();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</div></pre></td></tr></table></figure></p>
<p>下载 openJdk7的源码查询 jdk 的 native 实现代码，列表如下【这里因为篇幅问题，不详细罗列涉及到的代码，有兴趣的可以根据文件名称和行号查找相关代码】：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\openjdk7\jdk\src\share\native\java\lang\Thread.c</div><div class="line">\openjdk7\hotspot\src\share\vm\prims\jvm.h line:294:</div><div class="line">\openjdk7\hotspot\src\share\vm\prims\jvm.cpp line:4382-4414:</div><div class="line">\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:235-267:</div><div class="line">\openjdk7\hotspot\src\share\vm\services\threadService.cpp line:566-577:</div><div class="line">\openjdk7\hotspot\src\share\vm\classfile\javaClasses.cpp line:1635-[1651,1654,1658]:</div></pre></td></tr></table></figure></p>
<p>完成跟踪了底层的 jvm 源码后发现，是下边的三条代码引发了整个程序的变慢问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">oop classname = StringTable::intern((<span class="keyword">char</span>*) str, CHECK_0);  </div><div class="line">oop methodname = StringTable::intern(method-&gt;name(), CHECK_0);  </div><div class="line">oop filename = StringTable::intern(source, CHECK_0);</div></pre></td></tr></table></figure></p>
<p>这三段代码是获取类名、方法名、和文件名。因为类名、方法名、文件名都是存储在字符串常量池中的，所以每次获取它们都是通过String#intern方法。但没有考虑到的是默认的 StringPool 的长度是1009且不可变的。因此一旦常量池中的字符串达到的一定的规模后，性能会急剧下降。</p>
<h5 id="fastjson-不当使用-String-intern"><a href="#fastjson-不当使用-String-intern" class="headerlink" title="fastjson 不当使用 String#intern"></a>fastjson 不当使用 String#intern</h5><p>导致这个 intern 变慢的原因是因为 fastjson 对String#intern方法的使用不当造成的。跟踪 fastjson 中的实现代码发现，<br><code>com.alibaba.fastjson.parser.JSONScanner#scanFieldSymbol()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ch == <span class="string">'\"'</span>) &#123;</div><div class="line">    bp = index;</div><div class="line">    <span class="keyword">this</span>.ch = ch = buf[bp];</div><div class="line">    strVal = symbolTable.addSymbol(buf, start, index - start - <span class="number">1</span>, hash);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>com.alibaba.fastjson.parser.SymbolTable#addSymbol():</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Constructs a new entry from the specified symbol information and next entry reference.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, <span class="keyword">int</span> hash, Entry next)</span></span>&#123;</div><div class="line">    characters = <span class="keyword">new</span> <span class="keyword">char</span>[length];</div><div class="line">    System.arraycopy(ch, offset, characters, <span class="number">0</span>, length);</div><div class="line">    symbol = <span class="keyword">new</span> String(characters).intern();</div><div class="line">    <span class="keyword">this</span>.next = next;</div><div class="line">    <span class="keyword">this</span>.hashCode = hash;</div><div class="line">    <span class="keyword">this</span>.bytes = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>fastjson 中对所有的 json 的 key 使用了 intern 方法，缓存到了字符串常量池中，这样每次读取的时候就会非常快，大大减少时间和空间。而且 json 的 key 通常都是不变的。这个地方没有考虑到大量的 json key 如果是变化的，那就会给字符串常量池带来很大的负担。</p>
<p>这个问题 fastjson 在1.1.24版本中已经将这个漏洞修复了。程序加入了一个最大的缓存大小，超过这个大小后就不会再往字符串常量池中放了。</p>
<p>[1.1.24版本的com.alibaba.fastjson.parser.SymbolTable#addSymbol() Line:113]代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE           = <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (size &gt;= MAX_SIZE) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer, offset, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个问题是70w 数据量时候的引发的，如果是几百万的数据量的话可能就不只是30ms 的问题了。因此在使用系统级提供的String#intern方式一定要慎重！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文大体的描述了 String#intern和字符串常量池的日常使用，jdk 版本的变化和String#intern方法的区别，以及不恰当使用导致的危险等内容，让大家对系统级别的 String#intern有一个比较深入的认识。让我们在使用和接触它的时候能避免出现一些 bug，增强系统的健壮性。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>以下是几个比较关键的几篇博文。感谢！</p>
<ul>
<li>Save Memory by Using String Intern in Java</li>
<li>Java String array: is there a size of method?</li>
<li>Understanding String Table Size in HotSpot</li>
<li>How is Java’s String#intern() method implemented?</li>
<li>JDK7里的String.intern的变化</li>
</ul>
<p>原文地址：<a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">http://tech.meituan.com/in_depth_understanding_string_intern.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java参数传递（值传递还是引用传递）]]></title>
      <url>http://vinoit.me/2016/05/18/java-parameters-transfer/</url>
      <content type="html"><![CDATA[<p>Java中的参数传递机制一直以来大家都争论不休，究竟是“传值”还是“传址（传引用）”，争论的双方各执一词，互不相让。不但“菜鸟”们一头雾水，一些“老鸟”也只知道结果却说不出所以然来。我相信看过下面的内容后，你就会明白一些。</p>
<p>先看基本类型作为参数传递的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</div><div class="line">    System.out.println(<span class="string">"Before change, n = "</span> + n);</div><div class="line">    changeData(n);</div><div class="line">    System.out.println(<span class="string">"After changeData(n), n = "</span> + n);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(<span class="keyword">int</span> nn)</span> </span>&#123;</div><div class="line">   n = <span class="number">10</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我想这个例子大家都明白，基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的，输出的结果证明了这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, n = 3</div><div class="line">After changeData(n), n = 3</div></pre></td></tr></table></figure></p>
<p>那么，我们现在来看看对象作为参数传递的例子，这也是大家争论的地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello "</span>);</div><div class="line">          System.out.println(<span class="string">"Before change, sb = "</span> + sb);</div><div class="line">          changeData(sb);</div><div class="line">          System.out.println(<span class="string">"After changeData(n), sb = "</span> + sb);</div><div class="line">    &#125;                                                                      </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</div><div class="line">          strBuf.append(<span class="string">"World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, sb = Hello</div><div class="line">After changeData(n), sb = Hello World!</div></pre></td></tr></table></figure></p>
<p>从结果来看，sb的值被改变了，那么是不是可以说：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。从上面例子的输出结果来看，这样解释是合理。</p>
<p>现在我们对上面的例子稍加改动一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">          StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello "</span>);</div><div class="line">          System.out.println(<span class="string">"Before change, sb = "</span> + sb);</div><div class="line">          changeData(sb);</div><div class="line">          System.out.println(<span class="string">"After changeData(n), sb = "</span> + sb);</div><div class="line">    &#125;                                                                                                                                                                                                                     </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</div><div class="line">           strBuf = <span class="keyword">new</span> StringBuffer(<span class="string">"Hi "</span>);</div><div class="line">           strBuf.append(<span class="string">"World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按照上面例子的经验：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。你会认为应该输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, sb = Hello</div><div class="line">After changeData(n), sb = Hi World!</div></pre></td></tr></table></figure></p>
<p>但运行一下这个程序，你会发现结果是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before change, sb = Hello</div><div class="line">After changeData(n), sb = Hello</div></pre></td></tr></table></figure></p>
<p>这就是让人迷惑的地方，对象作为参数传递时，同样是在方法内改变了对象的值，为什么有的是改变了原对象的值，而有的并没有改变原对象的值呢？这时候究竟是“传值”还是“传引用”呢？</p>
<p>下面就让我们仔细分析一下，来揭开这中间的奥秘吧。</p>
<p>先看Test2这个程序：</p>
<p><code>StringBuffer sb = new StringBuffer(&quot;Hello &quot;);</code></p>
<p>这一句执行完后，就会在内存的堆里生成一个sb对象，请看图1：<br><img src="/images/java/java-parameter-transfer-0.jpg" alt=""><br>如图1所示，sb是一个引用，里面存放的是一个地址“@3a”（这个“@3a”是我举的代表内存地址的例子，你只需知道是个内存地址就行了），而这个地址正是“Hello ”这个字符串在内存中的地址。<br><code>changeData(sb);</code><br>执行这一句后，就把<code>sb</code>传给了<code>changeData</code>方法中的<code>StringBuffer strBuf</code>，由于<code>sb</code>中存放的是地址，所以，<code>strBuf</code>中也将存放相同的地址，请看图2：<br><img src="/images/java/java-parameter-transfer-1.jpg" alt=""><br>此时，<code>sb</code>和<code>strBuf</code>中由于存放的内存地址相同，因此都指向了“Hello”。</p>
<p><code>strBuf.append(&quot;World!&quot;);</code></p>
<p>执行<code>changeData</code>方法中的这一句后，改变了<code>strBuf</code>指向的内存中的值，如下图3所示：<br><img src="/images/java/java-parameter-transfer-2.jpg" alt=""><br>所以，Test2 这个程序最后会输出：</p>
<p><code>After changeData(n), sb = Hello World!</code></p>
<p>再看看Test3这个程序。</p>
<p>在没有执行到<code>changeData</code>方法的<code>strBuf = new StringBuffer(“Hi “);</code>之前，对象在内存中的图和上例中“图2”是一样的，而执行了<code>strBuf = new StringBuffer(“Hi “);</code>之后，则变成了：<br><img src="/images/java/java-parameter-transfer-3.jpg" alt=""><br>此时，<code>strBuf</code>中存放的不再是指向“Hello”的地址，而是指向“Hi ”的地址“@3b” （同样“@3b”是个例子）了，<code>new</code>操作符操作成功后总会在内存中新开辟一块存储区域。</p>
<p><code>strBuf.append(&quot;World!&quot;);</code></p>
<p>而执行完这句后，<br><img src="/images/java/java-parameter-transfer-4.jpg" alt=""><br>通过上图可以看到，由于sb和strBuf中存放地址不一样了，所以虽然strBuf指向的内存中的值改变了，但sb指向的内存中值并不会变，因此也就输出了下面的结果：</p>
<p><code>After changeData(n), sb = Hello</code></p>
<p>因此，你只要按上面的方法去分析，就会发现String对象和基本类型一样，一般情况下作为参数传递，在方法内改变了值，而原对象是不会被改变的。</p>
<p>综上所述，我们就会明白，在Java中对象作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。</p>
<p>你可以试着按上面的画图法分析一下下面例子的结果，看看运行结果与你分析的结果是否一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello "</span>);</div><div class="line">      System.out.println(<span class="string">"Before change, sb = "</span> + sb);</div><div class="line">      changeData(sb);</div><div class="line">      System.out.println(<span class="string">"After changeData(n), sb = "</span> + sb);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</div><div class="line">      StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">"Hi "</span>);</div><div class="line">      strBuf = sb2;</div><div class="line">      sb2.append(<span class="string">"World!"</span>);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提示：</p>
<p>执行完<code>strBuf = sb2；</code>后：<br><img src="/images/java/java-parameter-transfer-5.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java类静态域、块，非静态域、块，构造函数的初始化顺序]]></title>
      <url>http://vinoit.me/2016/05/18/java-init-order/</url>
      <content type="html"><![CDATA[<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>面试的时候，经常会遇到这样的考题：给你两个类的代码，它们之间是继承的关系，每个类里只有构造器方法和一些变量，</p>
<p>构造器里可能还有一段代码对变量值进行了某种运算，另外还有一些将变量值输出到控制台的代码，然后让我们判断输出的<br>结果。这实际上是在考查我们对于继承情况下类的初始化顺序的了解。<br>我们大家都知道，对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序以此是<br>（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。<br>我们也可以通过下面的测试代码来验证这一点：<br>Java代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialOrderTest</span> </span>&#123;               </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;          </div><div class="line">    <span class="comment">// 变量          </span></div><div class="line">    <span class="keyword">public</span> String field = <span class="string">"变量"</span>;                  </div><div class="line">    <span class="comment">// 静态初始化块        </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(staticField);  </div><div class="line">        System.out.println(<span class="string">"静态初始化块"</span>);  </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 初始化块              </span></div><div class="line">    &#123;          </div><div class="line">        System.out.println(field);  </div><div class="line">        System.out.println(<span class="string">"初始化块"</span>);        </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 构造器          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"构造器"</span>);     </div><div class="line">    &#125;                  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">new</span> InitialOrderTest();              </div><div class="line">    &#125;          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行以上代码，我们会得到如下的输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">静态变量  </div><div class="line">静态初始化块  </div><div class="line">变量  </div><div class="line">初始化块  </div><div class="line">构造器</div></pre></td></tr></table></figure></p>
<p>这与上文中说的完全符合。<br>那么对于继承情况下又会怎样呢？我们仍然以一段测试代码来获取最终结果：<br>Java代码 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;              </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;              </div><div class="line">    <span class="comment">// 变量          </span></div><div class="line">    <span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;                  </div><div class="line">    <span class="comment">// 静态初始化块              </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(p_StaticField);                  </div><div class="line">        System.out.println(<span class="string">"父类--静态初始化块"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 初始化块              </span></div><div class="line">    &#123;          </div><div class="line">        System.out.println(p_Field);          </div><div class="line">        System.out.println(<span class="string">"父类--初始化块"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 构造器          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"父类--构造器"</span>);              </div><div class="line">    &#125;         </div><div class="line">&#125;                  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;              </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;              </div><div class="line">    <span class="comment">// 变量          </span></div><div class="line">    <span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;              </div><div class="line">    <span class="comment">// 静态初始化块              </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(s_StaticField);                  </div><div class="line">        System.out.println(<span class="string">"子类--静态初始化块"</span>);          </div><div class="line">    &#125;          </div><div class="line">    <span class="comment">// 初始化块   </span></div><div class="line">    &#123;          </div><div class="line">        System.out.println(s_Field);          </div><div class="line">        System.out.println(<span class="string">"子类--初始化块"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 构造器          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"子类--构造器"</span>);              </div><div class="line">    &#125;                  </div><div class="line">    <span class="comment">// 程序入口          </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                  </div><div class="line">        <span class="keyword">new</span> SubClass();             </div><div class="line">    &#125;          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行一下上面的代码，结果马上呈现在我们的眼前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">父类--静态变量  </div><div class="line">父类--静态初始化块  </div><div class="line">子类--静态变量  </div><div class="line">子类--静态初始化块  </div><div class="line">父类--变量  </div><div class="line">父类--初始化块  </div><div class="line">父类--构造器  </div><div class="line">子类--变量  </div><div class="line">子类--初始化块  </div><div class="line">子类--构造器</div></pre></td></tr></table></figure>
<p>现在，结果已经不言自明了。大家可能会注意到一点，那就是，并不是父类完全初始化完毕后才进行子类的初始化，<br>实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。<br>那么对于静态变量和静态初始化块之间、变量和初始化块之间的先后顺序又是怎样呢？<br>是否静态变量总是先于静态初始化块，变量总是先于初始化块就被初始化了呢？实际上这取决于它们在类中出现的先后顺序。<br>我们以静态变量和静态初始化块为例来进行说明。 同样，我们还是写一个类来进行测试：    </p>
<p>Java代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOrder</span> </span>&#123;          </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestA a = <span class="keyword">new</span> TestA();                       </div><div class="line">    <span class="comment">// 静态初始化块              </span></div><div class="line">    <span class="keyword">static</span> &#123;          </div><div class="line">        System.out.println(<span class="string">"静态初始化块"</span>);              </div><div class="line">    &#125;                       </div><div class="line">    <span class="comment">// 静态变量          </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestB b = <span class="keyword">new</span> TestB();                  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                  </div><div class="line">        <span class="keyword">new</span> TestOrder();              </div><div class="line">    &#125;          </div><div class="line">&#125;                  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;              </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"Test--A"</span>);              </div><div class="line">    &#125;          </div><div class="line">&#125;                  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;              </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;          </div><div class="line">        System.out.println(<span class="string">"Test--B"</span>);              </div><div class="line">    &#125;          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的代码，会得到如下的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Test--A  </div><div class="line">静态初始化块  </div><div class="line">Test--B</div></pre></td></tr></table></figure></p>
<p>大家可以随意改变变量a、变量b以及静态初始化块的前后位置，就会发现输出结果随着它们在类中出现的前后顺序而改变，<br>这就说明静态变量和静态初始化块是依照他们在类中的定义顺序进行初始化的。同样，变量和初始化块也遵循这个规律。<br>了解了继承情况下类的初始化顺序之后，如何判断最终输出结果就迎刃而解了。  </p>
<p>测试函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticCon</span> </span>&#123;   </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;  </div><div class="line">      <span class="keyword">static</span> &#123;    </div><div class="line">        a = <span class="number">10</span>;  </div><div class="line">          System.out.println(<span class="string">"父类的静态代码块在执行a="</span> + a);   </div><div class="line">    &#125;     </div><div class="line">    &#123;    </div><div class="line">        a = <span class="number">8</span>;  </div><div class="line">          System.out.println(<span class="string">"父类的非静态代码块在执行a="</span> + a);   </div><div class="line">    &#125;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TestStaticCon</span><span class="params">()</span> </span>&#123;   </div><div class="line"></div><div class="line">        <span class="keyword">this</span>(<span class="string">"a在父类带参构造方法中的值："</span> + TestStaticCon.a); <span class="comment">// 调用另外一个构造方法    </span></div><div class="line">        System.out.println(a);    </div><div class="line">        System.out.println(<span class="string">"父类无参构造方法在执行a="</span> + a);   </div><div class="line">    &#125;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">TestStaticCon</span><span class="params">(String n)</span> </span>&#123;    </div><div class="line">        System.out.println(n);    </div><div class="line">        System.out.println(a);  </div><div class="line">      &#125;  </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </div><div class="line">        TestStaticCon tsc = <span class="keyword">null</span>;  </div><div class="line">          System.out.println(<span class="string">"!!!!!!!!!!!!!!!!!!!!!"</span>);    </div><div class="line">        tsc = <span class="keyword">new</span> TestStaticCon();   </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">父类的非静态代码块在执行a=10</div><div class="line">!!!!!!!!!!!!!!!!!!!!!</div><div class="line">父类的非静态代码块在执行a=8</div><div class="line">a在父类带参构造方法中的值：10</div><div class="line">8</div><div class="line">8</div><div class="line">父类无参构造方法在执行a=8</div></pre></td></tr></table></figure></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。且执行顺序为静态代码块——非静态代码块—-构造函数。<br>扩展：静态代码块  与  静态方法：<br>一般情况下,如果有些代码必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的;<br>需要在项目启动的时候就初始化,在不创建对象的情况下,其他程序来调用的时候,需要使用静态方法,这种代码是被动执行的.<br>两者的区别就是:静态代码块是自动执行的;  静态方法是被调用的时候才执行的.  </p>
<p>作用:静态代码块可用来初始化一些项目最常用的变量或对象;静态方法可用作不创建对象也可能需要执行的代码</p>
<h4 id="阿里笔试题"><a href="#阿里笔试题" class="headerlink" title="阿里笔试题"></a>阿里笔试题</h4><p>求下面这段代码的输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test1 t1 = <span class="keyword">new</span> Test1(<span class="string">"t1"</span>);  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test1 t2 = <span class="keyword">new</span> Test1(<span class="string">"t2"</span>);  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = print(<span class="string">"i"</span>);  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">99</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = print(<span class="string">"j"</span>);  </div><div class="line">    &#123;  </div><div class="line">        print(<span class="string">"构造块"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        print(<span class="string">"静态块"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test1</span><span class="params">(String str)</span></span>&#123;  </div><div class="line">        System.out.println((++k)+<span class="string">":"</span>+str+<span class="string">"    i="</span>+i+<span class="string">"    n="</span>+n);  </div><div class="line">        ++i;++n;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(String str)</span></span>&#123;  </div><div class="line">        System.out.println((++k)+<span class="string">":"</span>+str+<span class="string">"    i="</span>+i+<span class="string">"    n="</span>+n);  </div><div class="line">        ++n;  </div><div class="line">        <span class="keyword">return</span> ++i;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// TODO Auto-generated method stub  </span></div><div class="line">        Test1 t = <span class="keyword">new</span> Test1(<span class="string">"init"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">j    i=0    n=0</div><div class="line">构造块    i=1    n=1</div><div class="line">t1    i=2    n=2</div><div class="line">j    i=3    n=3</div><div class="line">构造块    i=4    n=4</div><div class="line">t2    i=5    n=5</div><div class="line">i    i=6    n=6</div><div class="line">静态块    i=7    n=99</div><div class="line">j    i=8    n=100</div><div class="line">构造块    i=9    n=101</div><div class="line">init    i=10    n=102</div></pre></td></tr></table></figure></p>
<p>原文：<a href="http://ini.iteye.com/blog/2007835" target="_blank" rel="external">http://ini.iteye.com/blog/2007835</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 虚拟内存和物理内存的理解]]></title>
      <url>http://vinoit.me/2016/05/17/linux-vm-rm/</url>
      <content type="html"><![CDATA[<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><ol>
<li>每个进程都有自己独立的4G内存空间，各个进程的内存空间具有类似的结构。</li>
<li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间，哪些数据在哪里，都由进程控制表中的task_struct记录，task_struct中记录中一条链表，记录中内存空间的分配情况，哪些地址有数据，哪些地址无数据，哪些可读，哪些可写，都可以通过这个链表记录。</li>
<li>每个进程已经分配的内存空间，都与对应的磁盘空间映射。<br><img src="/images/linux/linux-vm-rm-0.png" alt=""></li>
</ol>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><ol>
<li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址。</li>
<li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li>
<li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录。</li>
<li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。</li>
<li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常。</li>
<li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。<br><img src="/images/linux/linux-vm-rm-1.png" alt=""></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>优点：</p>
<ol>
<li>既然每个进程的内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处</li>
<li>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</li>
<li>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</li>
</ol>
<p>另外，事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如<code>.text</code> <code>.data</code>段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如<code>malloc</code>时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<h4 id="补充理解"><a href="#补充理解" class="headerlink" title="补充理解"></a>补充理解</h4><p>虚拟存储器涉及三个概念： 虚拟存储空间，磁盘空间，内存空间<br><img src="/images/linux/linux-vm-rm-2.png" alt=""><br>可以认为虚拟空间都被映射到了磁盘空间中，（事实上也是按需要映射到磁盘空间上，通过mmap），并且由页表记录映射位置，当访问到某个地址的时候，通过页表中的有效位，可以得知此数据是否在内存中，如果不是，则通过缺页异常，将磁盘对应的数据拷贝到内存中，如果没有空闲内存，则选择牺牲页面，替换其他页面。</p>
<p><code>mmap</code>是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过<code>manmap</code>可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这也是一种读写磁盘文件的方法，也是一种进程共享数据的方法 共享内存</p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p>在内核态申请内存比在用户态申请内存要更为直接，它没有采用用户态那种延迟分配内存技术。内核认为一旦有内核函数申请内存，那么就必须立刻满足该申请内存的请求，并且这个请求一定是正确合理的。相反，对于用户态申请内存的请求，内核总是尽量延后分配物理内存，用户进程总是先获得一个虚拟内存区的使用权，最终通过缺页异常获得一块真正的物理内存。</p>
<h4 id="物理内存的内核映射"><a href="#物理内存的内核映射" class="headerlink" title="物理内存的内核映射"></a>物理内存的内核映射</h4><p>IA32架构中内核虚拟地址空间只有1GB大小（从3GB到4GB），因此可以直接将1GB大小的物理内存（即常规内存）映射到内核地址空间，但超出1GB大小的物理内存（即高端内存）就不能映射到内核空间。为此，内核采取了下面的方法使得内核可以使用所有的物理内存。</p>
<p>1). 高端内存不能全部映射到内核空间，也就是说这些物理内存没有对应的线性地址。不过，内核为每个物理页框都分配了对应的页框描述符，所有的页框描述符都保存在mem_map数组中，因此每个页框描述符的线性地址都是固定存在的。内核此时可以使用alloc_pages()和alloc_page()来分配高端内存，因为这些函数返回页框描述符的线性地址。</p>
<p>2). 内核地址空间的后128MB专门用于映射高端内存，否则，没有线性地址的高端内存不能被内核所访问。这些高端内存的内核映射显然是暂时映射的，否则也只能映射128MB的高端内存。当内核需要访问高端内存时就临时在这个区域进行地址映射，使用完毕之后再用来进行其他高端内存的映射。</p>
<p>由于要进行高端内存的内核映射，因此直接能够映射的物理内存大小只有896MB，该值保存在high_memory中。内核地址空间的线性地址区间如下图所示：<br><img src="/images/linux/linux-vm-rm-3.png" alt=""><br>从图中可以看出，内核采用了三种机制将高端内存映射到内核空间：永久内核映射，固定映射和vmalloc机制。</p>
<h4 id="物理内存管理机制"><a href="#物理内存管理机制" class="headerlink" title="物理内存管理机制"></a>物理内存管理机制</h4><p>基于物理内存在内核空间中的映射原理，物理内存的管理方式也有所不同。内核中物理内存的管理机制主要有伙伴算法，slab高速缓存和vmalloc机制。其中伙伴算法和slab高速缓存都在物理内存映射区分配物理内存，而vmalloc机制则在高端内存映射区分配物理内存。</p>
<p><code>伙伴算法</code><br>伙伴算法负责大块连续物理内存的分配和释放，以页框为基本单位。该机制可以避免外部碎片。</p>
<p><code>per-CPU页框高速缓存</code><br>内核经常请求和释放单个页框，该缓存包含预先分配的页框，用于满足本地CPU发出的单一页框请求。</p>
<p><code>slab缓存</code><br>slab缓存负责小块物理内存的分配，并且它也作为高速缓存，主要针对内核中经常分配并释放的对象。</p>
<p><code>vmalloc机制</code><br>vmalloc机制使得内核通过连续的线性地址来访问非连续的物理页框，这样可以最大限度的使用高端物理内存。</p>
<h4 id="物理内存的分配"><a href="#物理内存的分配" class="headerlink" title="物理内存的分配"></a>物理内存的分配</h4><p>内核发出内存申请的请求时，根据内核函数调用接口将启用不同的内存分配器。</p>
<h5 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h5><p>分区页框分配器 (zoned page frame allocator) ,处理对连续页框的内存分配请求。分区页框管理器分为两大部分:前端的管理区分配器和伙伴系统，如下图：<br><img src="/images/linux/linux-vm-rm-4.png" alt=""><br>管理区分配器负责搜索一个能满足请求页框块大小的管理区。在每个管理区中,具体的页框分配工作由伙伴系统负责。为了达到更好的系统性能,单个页框的申请工作直接通过per-CPU页框高速缓存完成。</p>
<p>该分配器通过几个函数和宏来请求页框,它们之间的封装关系如下图所示。<br><img src="/images/linux/linux-vm-rm-5.png" alt=""><br>这些函数和宏将核心的分配函数<code>__alloc_pages_nodemask()</code>封装,形成满足不同分配需求的分配函数。其中，<code>alloc_pages()</code>系列函数返回物理内存首页框描述符，<code>__get_free_pages()</code>系列函数返回内存的线性地址。</p>
<h5 id="slab分配器"><a href="#slab分配器" class="headerlink" title="slab分配器"></a>slab分配器</h5><p>slab 分配器最初是为了解决物理内存的内部碎片而提出的，它将内核中常用的数据结构看做对象。slab分配器为每一种对象建立高速缓存。内核对该对象的分配和释放均是在这块高速缓存中操作。一种对象的slab分配器结构图如下：<br><img src="/images/linux/linux-vm-rm-6.png" alt=""><br>可以看到每种对象的高速缓存是由若干个slab组成，每个slab是由若干个页框组成的。虽然slab分配器可以分配比单个页框更小的内存块，但它所需的所有内存都是通过<code>伙伴算法</code>分配的。</p>
<p>slab高速缓存分专用缓存和通用缓存。专用缓存是对特定的对象，比如为内存描述符创建高速缓存。通用缓存则是针对一般情况，适合分配任意大小的物理内存，其接口即为<code>kmalloc()</code>。</p>
<h5 id="非连续内存区的分配"><a href="#非连续内存区的分配" class="headerlink" title="非连续内存区的分配"></a>非连续内存区的分配</h5><p>内核通过<code>vmalloc()</code>来申请非连续的物理内存，若申请成功，该函数返回连续内存区的起始地址，否则，返回<code>NULL</code>。<code>vmalloc()</code>和<code>kmalloc()</code>申请的内存有所不同，<code>kmalloc()</code>所申请内存的线性地址与物理地址都是连续的，而<code>vmalloc()</code>所申请的内存线性地址连续而物理地址则是离散的，两个地址之间通过内核页表进行映射。 <code>vmalloc()</code>的工作方式理解起来很简单：<br>1). 寻找一个新的连续线性地址空间；<br>2). 依次分配一组非连续的页框；<br>3). 为线性地址空间和非连续页框建立映射关系，即修改内核页表；</p>
<p><code>vmalloc()</code>的内存分配原理与用户态的内存分配相似，都是通过连续的虚拟内存来访问离散的物理内存，并且虚拟地址和物理地址之间是通过页表进行连接的，通过这种方式可以有效的使用物理内存。但是应该注意的是，<code>vmalloc()</code>申请物理内存时是立即分配的，因为内核认为这种内存分配请求是正当而且紧急的；相反，用户态有内存请求时，内核总是尽可能的延后，毕竟用户态跟内核态不在一个特权级。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《深入理解计算机系统》学习整理--cpu加载数据（初阶）]]></title>
      <url>http://vinoit.me/2016/05/17/computer-system-roaming/</url>
      <content type="html"><![CDATA[<p>断断续续地将《深入理解计算机系统》这本书看了一下，不管多少，对计算机系统的认识是有了一个质的提升。想把学习当中的一些收获记录下来，打算写一个系列的文章，从而一步一步的来更好的认识计算机系统。该文章的目的是了解cpu是怎么加载数据的，具体细节留着以后整理。</p>
<h4 id="从一条汇编指令开始"><a href="#从一条汇编指令开始" class="headerlink" title="从一条汇编指令开始"></a>从一条汇编指令开始</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movl (%ebp) %edx</div></pre></td></tr></table></figure>
<p><code>%ebp</code> 和 <code>%edx</code>这两个都是寄存器文件，处于CPU中，如图<br><img src="/images/computer-system/computer-system-all.PNG" alt=""><br>每个cpu中都有着有限数量的寄存器在，一个IA32的处理器中包含一组8个存储32位值得寄存器。<br>一般每个寄存器都会存放特定的数据，例如<code>%esp</code>是用来存放栈指针的，<code>%ebp</code>是用来存放帧指针的。</p>
<p><code>movl A B</code>指令是将A的数据移动到B（覆盖B的数据），<code>(%ebp)</code>中括号的作用是取得主存中地址为<code>%ebp</code>的值的数据。也就是说先取得<code>%ebp</code>的值，然后将该值作为一个地址，去内存中找到这个地址，获取数据，然后将这个数据赋给<code>%edx</code>。</p>
<p>现在来看看这个过程具体是什么样的：</p>
<h4 id="获取虚拟地址"><a href="#获取虚拟地址" class="headerlink" title="获取虚拟地址"></a>获取虚拟地址</h4><p>在系统的运行着的每一个进程（程序），它们所接触的都是一个虚拟内存地址，假如系统内存为4G，那么每一个进程在运行时，它都会认为自己拥有着所有的4G内存。假如这些都是物理内存地址，那么每个进程在不经意间都可能会去修改其他进程的数据，造成数据丢失。所以我们从<code>%ebp</code>中获取到了一个虚拟地址。</p>
<h4 id="翻译虚拟地址"><a href="#翻译虚拟地址" class="headerlink" title="翻译虚拟地址"></a>翻译虚拟地址</h4><p>获取到虚拟地址之后，需要将虚拟地址转换为物理地址。这时候用到了页表和TLB，这个时候如果页表命中，则将物理地址返回。如果不命中，将产生缺页异常，需要从磁盘中获取数据，并将数据加载到主存，然后将对应地址记录到页表中。接着翻译机制再从页表中获取物理地址。具体细节以后再整理。</p>
<h4 id="根据物理地址获取数据"><a href="#根据物理地址获取数据" class="headerlink" title="根据物理地址获取数据"></a>根据物理地址获取数据</h4><p>cache中存放着主存中的数据，如果缓存命中，则直接将缓存中的数据返回。如果不命中，则cache从主存中获取值，存放到本地（cache）。cpu再向cache发送一次请求，cache将数据发给cpu。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上是一个很粗糙的cpu加载数据的流程，但是基本上几个核心都提到了，以后整理细节的时候就根据这个流程来了。</p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的文件描述符与打开文件之间的关系]]></title>
      <url>http://vinoit.me/2016/05/17/linux-fd-file/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。<code>POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。</code>标准文件描述符图如下：<br><img src="/images/linux/linux-fd-file-0.png" alt=""><br>文件描述与打开的文件对应模型如下图：<br><img src="/images/linux/linux-fd-file-1.png" alt=""></p>
<h4 id="文件描述限制"><a href="#文件描述限制" class="headerlink" title="文件描述限制"></a>文件描述限制</h4><p>在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用<code>sysctl -a | grep fs.file-max</code>命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用<code>ulimit -n</code>命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看<a href="http://blog.csdn.net/kumu_linux/article/details/7877770。" target="_blank" rel="external">http://blog.csdn.net/kumu_linux/article/details/7877770。</a></p>
<h4 id="文件描述符合打开文件之间的关系"><a href="#文件描述符合打开文件之间的关系" class="headerlink" title="文件描述符合打开文件之间的关系"></a>文件描述符合打开文件之间的关系</h4><p>每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。</p>
<ol>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ol>
<p>进程级的描述符表的每一条目记录了单个文件描述符的相关信息。</p>
<ul>
<li>控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即<code>close-on-exec</code>标志）</li>
<li>对打开文件句柄的引用</li>
</ul>
<p>内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示：<br>当前文件偏移量（调用<code>read()</code>和<code>write()</code>时更新，或使用<code>lseek()</code>直接修改）</p>
<pre><code>1. 当前文件偏移量（调用`read()`和`write()`时更新，或使用`lseek()`直接修改）
2. 打开文件时所使用的状态标识（即，`open()`的flags参数）
3. 文件访问模式（如调用`open()`时所设置的只读模式、只写模式或读写模式）
4. 与信号驱动相关的设置
5. 对该文件i-node对象的引用
6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限
7. 一个指针，指向该文件所持有的锁列表
8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
</code></pre><p>下图展示了文件描述符、打开的文件句柄以及i-node之间的关系，图中，两个进程拥有诸多打开的文件描述符。<br><img src="/images/linux/linux-fd-file-2.png" alt=""><br>在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用<code>dup()</code>、<code>dup2()</code>、<code>fcntl()</code>或者对同一个文件多次调用了<code>open()</code>函数而形成的。<br>   进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用<code>fork()</code>后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。<br>   此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了<code>open()</code>调用。同一个进程两次打开同一个文件，也会发生类似情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>1. 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
2. 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
3. 要获取和修改打开的文件标志（例如：`O_APPEND、O_NONBLOCK`和`O_ASYNC`），可执行`fcntl()`的`F_GETFL`和`F_SETFL`操作，其对作用域的约束与上一条颇为类似。
4. 文件描述符标志（即，`close-on-exec`）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符
</code></pre><p>原文地址：<a href="http://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="external">http://blog.csdn.net/cywosp/article/details/38965239</a></p>
<p>参考<br>[1] <a href="http://blog.chinaunix.net/uid-20633888-id-2747146.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20633888-id-2747146.html</a><br>[2] <a href="http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html" target="_blank" rel="external">http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html</a><br>[3] <a href="http://blog.csdn.net/kumu_linux/article/details/7877770" target="_blank" rel="external">http://blog.csdn.net/kumu_linux/article/details/7877770</a><br>[4] 《Linux/UNIX系统编程手册》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解git分支-远程分支]]></title>
      <url>http://vinoit.me/2016/05/16/git-branch-remote/</url>
      <content type="html"><![CDATA[<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote (remote)来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
<p>它们以 (remote)/(branch) 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支；但是在服务器上的分支会指向 origin/iss53 的提交。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。</p>
<h4 id="“origin”-并无特殊含义"><a href="#“origin”-并无特殊含义" class="headerlink" title="“origin” 并无特殊含义"></a>“origin” 并无特殊含义</h4><p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。<br><img src="/images/git/remote-branches-1.png" alt=""></p>
<h4 id="克隆之后的服务器与本地仓库"><a href="#克隆之后的服务器与本地仓库" class="headerlink" title="克隆之后的服务器与本地仓库"></a>克隆之后的服务器与本地仓库</h4><p>如果你在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动。<br><img src="/images/git/remote-branches-2.png" alt=""></p>
<h4 id="本地与远程的工作可以分叉"><a href="#本地与远程的工作可以分叉" class="headerlink" title="本地与远程的工作可以分叉"></a>本地与远程的工作可以分叉</h4><p>如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动origin/master 指针指向新的、更新后的位置。<br><img src="/images/git/remote-branches-3.png" alt=""></p>
<h4 id="git-fetch-更新你的远程仓库引用"><a href="#git-fetch-更新你的远程仓库引用" class="headerlink" title="git fetch 更新你的远程仓库引用"></a>git fetch 更新你的远程仓库引用</h4><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为整个 URL 的缩写。<br><img src="/images/git/remote-branches-4.png" alt=""></p>
<h4 id="添加另一个远程仓库"><a href="#添加另一个远程仓库" class="headerlink" title="添加另一个远程仓库"></a>添加另一个远程仓库</h4><p>现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支teamone/master 指向 teamone 的 master 分支。<br><img src="/images/git/remote-branches-5.png" alt=""></p>
<h3 id="远程跟踪分支-teamone-master"><a href="#远程跟踪分支-teamone-master" class="headerlink" title="远程跟踪分支 teamone/master"></a>远程跟踪分支 teamone/master</h3><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git push origin serverfix</div><div class="line">Counting objects: 24, done.</div><div class="line">Delta compression using up to 8 threads.</div><div class="line">Compressing objects: 100% (15/15), done.</div><div class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.</div><div class="line">Total 24 (delta 2), reused 0 (delta 0)</div><div class="line">To https://github.com/schacon/simplegit</div><div class="line"> * [new branch]      serverfix -&gt; serverfix</div></pre></td></tr></table></figure></p>
<p>这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分，但是现在可以先把它放在儿。 你也可以运行 git push origin serverfix:serverfix，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的awesomebranch 分支。</p>
<h5 id="如何避免每次输入密码"><a href="#如何避免每次输入密码" class="headerlink" title="如何避免每次输入密码"></a>如何避免每次输入密码</h5><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p>
<p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config –global credential.helper cache 来设置它。</p>
<p>想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。</p>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin</div><div class="line">remote: Counting objects: 7, done.</div><div class="line">remote: Compressing objects: 100% (2/2), done.</div><div class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</div><div class="line">Unpacking objects: 100% (3/3), done.</div><div class="line">From https://github.com/schacon/simplegit</div><div class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</div></pre></td></tr></table></figure></p>
<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix指针。</p>
<p>可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的serverfix 分支上工作，可以将其建立在远程跟踪分支之上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b serverfix origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;serverfix&apos;</div></pre></td></tr></table></figure></p>
<p>这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。</p>
<h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;serverfix&apos;</div></pre></td></tr></table></figure></p>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b sf origin/serverfix</div><div class="line">Branch sf set up to track remote branch serverfix from origin.</div><div class="line">Switched to a new branch &apos;sf&apos;</div></pre></td></tr></table></figure></p>
<p>现在，本地分支 sf 会自动从 origin/serverfix 拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -u origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch serverfix from origin.</div></pre></td></tr></table></figure></p>
<p>###　上游快捷方式<br>当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代git merge origin/master。</p>
<p>如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git branch -vv</div><div class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</div><div class="line">  master    1ae2a45 [origin/master] deploying index fix</div><div class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</div><div class="line">  testing   5ea463a trying something new</div></pre></td></tr></table></figure></p>
<p>这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 2 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。</p>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：$ git fetch –all; git branch -vv</p>
<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 –delete 选项的 git push命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin --delete serverfix</div><div class="line">To https://github.com/schacon/simplegit</div><div class="line"> - [deleted]         serverfix</div></pre></td></tr></table></figure></p>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解git对象]]></title>
      <url>http://vinoit.me/2016/05/16/git-object/</url>
      <content type="html"><![CDATA[<h5 id="首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下："><a href="#首次提交，提交一个简单的文件-a-txt-，commit-之后的图如下：" class="headerlink" title="首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下："></a>首次提交，提交一个简单的文件 a.txt ，commit 之后的图如下：</h5><p> <img src="/images/git/git-object-0.png" alt=""><br> 如图所示，生成了 3 个对象，一个 commit 对象，一个 tree 对象，一个 blob 对象。图上蓝底是 commit 对象，灰底的是 tree 对象，白底的是 blob 对象，每个对象节点的标题是对象的 key (SHA 摘要)缩略表示。<br> 对于 commit 对象，tree 内容表示这个 commit 对应根目录的 tree 对象，parent 表示父 commit 节点，通常commit 只有一个父节点，也可能没有（首次提交时 parent 为空），也可能有多个（合并节点），commit 对象还保存了 commit message 等信息。<br> 对于 tree 对象，里面的内容包含了文件名，文件对应的 blob 对象的 key，或者是目录名和目录对应 tree 对象的 key。<br> 对于 blob 对象，表示一个实际文件对象的内容，但不包括文件名，文件名是在 tree 对象里存的。</p>
<p> 这个图怎么得到的呢？主要是两个命令：</p>
<ul>
<li>通过 git log 命令获取最新 commit 的 key</li>
<li>通过 git cat-file -p <object key=""> 获取 key 对应 object 的内容，根据 object 里的内容，继续探索，就可以访问到所有关联 object</object></li>
</ul>
<h5 id="第-2-次提交，修改了-a-txt-文件："><a href="#第-2-次提交，修改了-a-txt-文件：" class="headerlink" title="第 2 次提交，修改了 a.txt 文件："></a>第 2 次提交，修改了 a.txt 文件：</h5><p><img src="/images/git/git-object-1.png" alt=""><br>因为 a.txt 文件已经修改，生成了一个新的 blob 对象，tree 对象和 commit 对象。如图所示，commit 对象之间是有关联的，新提交的 commit 对象的 parent 是上一次提交的 commit 对象。</p>
<h5 id="第-3-次提交，这次已稍微复杂一点，增加一个新文件-b-txt-，一个新目录-lib-，lib-里增加一个文件-c-txt"><a href="#第-3-次提交，这次已稍微复杂一点，增加一个新文件-b-txt-，一个新目录-lib-，lib-里增加一个文件-c-txt" class="headerlink" title="第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt"></a>第 3 次提交，这次已稍微复杂一点，增加一个新文件 b.txt ，一个新目录 lib ，lib 里增加一个文件 c.txt</h5><p><img src="/images/git/git-object-2.png" alt=""><br>如图所示，目录是有一个 tree 对象表示的，里面的内容指明了目录包含的文件或子目录。</p>
<h5 id="第-4-次提交，这次弄出一个新的分支-test1，并且在新分支中做了一次-commit"><a href="#第-4-次提交，这次弄出一个新的分支-test1，并且在新分支中做了一次-commit" class="headerlink" title="第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit"></a>第 4 次提交，这次弄出一个新的分支 test1，并且在新分支中做了一次 commit</h5><p><img src="/images/git/git-object-3.png" alt=""><br>0c5ca 对应的 commit 对象就是生成的分支 test1 中的。分支在 Git 中是一个非常轻量化的操作，建立分支甚至都不增加新的对象。</p>
<h5 id="第-5-次提交，这次涉及到一个合并操作，图已经变得比较复杂了"><a href="#第-5-次提交，这次涉及到一个合并操作，图已经变得比较复杂了" class="headerlink" title="第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了"></a>第 5 次提交，这次涉及到一个合并操作，图已经变得比较复杂了</h5><p><img src="/images/git/git-object-4.png" alt=""><br>def18 就是合并后的 commit 对象。合并生成了一个新的commit ，这个 commit 的 parent 有两个，指向合并的两个原分支对应的 commit 上。</p>
<p>作者:vincent (谢文威)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git操作手册|命令速查表]]></title>
      <url>http://vinoit.me/2016/05/16/git-operate-command/</url>
      <content type="html"><![CDATA[<p>这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。<br>本文分为以下几个部分：</p>
<ol>
<li>Git与SVN差异</li>
<li>Git常用命令</li>
<li>Git进阶指南</li>
</ol>
<h2 id="Git与SVN差异"><a href="#Git与SVN差异" class="headerlink" title="Git与SVN差异"></a>Git与SVN差异</h2><p>Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。</p>
<p>Git 和 SVN 思想最大的差别有四个：</p>
<ul>
<li>去中心化</li>
<li>直接记录快照，而非差异</li>
<li>不一样的分支概念</li>
<li>三个文件状态</li>
</ul>
<h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心</p>
<p><img src="/images/git/git.gif" alt=""></p>
<p>图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。</p>
<h3 id="直接记录快照，而非差异"><a href="#直接记录快照，而非差异" class="headerlink" title="直接记录快照，而非差异"></a>直接记录快照，而非差异</h3><p>Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：</p>
<p>SVN：<br><img src="/images/git/svn.png" alt=""></p>
<p>Git:<br><img src="/images/git/git.png" alt=""><br>Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。</p>
<h3 id="不一样的分支概念异"><a href="#不一样的分支概念异" class="headerlink" title="不一样的分支概念异"></a>不一样的分支概念异</h3><p>Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。</p>
<h3 id="三个文件状态"><a href="#三个文件状态" class="headerlink" title="三个文件状态"></a>三个文件状态</h3><p>在Git中文件有三种状态：</p>
<ul>
<li>已提交（committed）：该文件被安全地保存在了本地数据库</li>
<li>已修改（modified）：修改了某个文件，但还没有保存</li>
<li>已暂存（staged）：把已修改的文件放下下次保存的清单中</li>
</ul>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>复制一个已创建的仓库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone ssh://user@domain.com/repo.git</div></pre></td></tr></table></figure></p>
<p>创建一个新的本地仓库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<h3 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h3><p>显示工作路径下已修改的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>显示与上次提交版本文件的不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure></p>
<p>把当前所有修改添加到下次提交中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add</div></pre></td></tr></table></figure></p>
<p>把对某个文件的修改添加到下次提交中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -p &lt;file&gt;</div></pre></td></tr></table></figure></p>
<p>提交本地的所有修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -a</div></pre></td></tr></table></figure></p>
<p>提交之前已标记的变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit</div></pre></td></tr></table></figure></p>
<p>附加消息提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &apos;message here&apos;</div></pre></td></tr></table></figure></p>
<p>提交，并将提交时间设置为之前的某个日期:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit --date=&quot;`date --date=&apos;n day ago&apos;`&quot; -am &quot;Commit Message&quot;</div></pre></td></tr></table></figure></p>
<h3 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h3><p>请勿修改已发布的提交记录!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit --amend</div></pre></td></tr></table></figure></p>
<p>把当前分支中未提交的修改移动到其他分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line">git checkout branch2</div><div class="line">git stash pop</div></pre></td></tr></table></figure></p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>从当前目录的所有文件中查找文本内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git grep &quot;Hello&quot;</div></pre></td></tr></table></figure></p>
<p>在某一版本中搜索文本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git grep &quot;Hello&quot; v2.5</div></pre></td></tr></table></figure></p>
<h3 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h3><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure></p>
<p>显示所有提交（仅显示提交的hash和message）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --oneline</div></pre></td></tr></table></figure></p>
<p>显示某个用户的所有提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --author=&quot;username&quot;</div></pre></td></tr></table></figure></p>
<p>显示某个文件的所有修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -p &lt;file&gt;</div></pre></td></tr></table></figure></p>
<p>谁，在什么时间，修改了文件的什么内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame &lt;file&gt;</div></pre></td></tr></table></figure></p>
<h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>列出所有的分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure></p>
<p>切换分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>创建并切换到新分支:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>基于当前分支创建新分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch &lt;new-branch&gt;</div></pre></td></tr></table></figure></p>
<p>基于远程分支创建新的可追溯的分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</div></pre></td></tr></table></figure></p>
<p>删除本地分支:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>给当前版本打标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag &lt;tag-name&gt;</div></pre></td></tr></table></figure></p>
<h3 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h3><p>列出当前配置的远程端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure></p>
<p>显示远程端的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote show &lt;remote&gt;</div></pre></td></tr></table></figure></p>
<p>添加新的远程端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add &lt;remote&gt; &lt;url&gt;</div></pre></td></tr></table></figure></p>
<p>下载远程端版本，但不合并到HEAD中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch &lt;remote&gt;</div></pre></td></tr></table></figure></p>
<p>下载远程端版本，并自动与HEAD版本合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote pull &lt;remote&gt; &lt;url&gt;</div></pre></td></tr></table></figure></p>
<p>将远程端版本合并到本地版本中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull origin master</div></pre></td></tr></table></figure></p>
<p>将本地版本发布到远程端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push remote &lt;remote&gt; &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>删除远程端分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</div><div class="line">或</div><div class="line">git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</div></pre></td></tr></table></figure></p>
<p>发布标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push --tags</div></pre></td></tr></table></figure></p>
<h3 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h3><p>将分支合并到当前HEAD中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>退出重置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase --abort</div></pre></td></tr></table></figure></p>
<p>解决冲突后继续重置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase --continue</div></pre></td></tr></table></figure></p>
<p>使用配置好的merge tool 解决冲突：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mergetool</div></pre></td></tr></table></figure></p>
<p>在编辑器中手动解决冲突后，标记文件为已解决冲突:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add &lt;resolved-file&gt;</div><div class="line">git rm &lt;resolved-file&gt;</div></pre></td></tr></table></figure></p>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>放弃工作目录下的所有修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD</div></pre></td></tr></table></figure></p>
<p>移除缓存区的所有文件（i.e. 撤销上次git add）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD</div></pre></td></tr></table></figure></p>
<p>放弃某个文件的所有本地修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout HEAD &lt;file&gt;</div></pre></td></tr></table></figure></p>
<p>重置一个提交（通过创建一个截然不同的新提交）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git revert &lt;commit&gt;</div></pre></td></tr></table></figure></p>
<p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard &lt;commit&gt;</div></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset &lt;commit&gt;</div></pre></td></tr></table></figure></p>
<p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --keep &lt;commit&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Git进阶指南"><a href="#Git进阶指南" class="headerlink" title="Git进阶指南"></a>Git进阶指南</h2><h3 id="问：如何修改-origin-仓库信息？"><a href="#问：如何修改-origin-仓库信息？" class="headerlink" title="问：如何修改 origin 仓库信息？"></a>问：如何修改 origin 仓库信息？</h3><h4 id="1、添加-origin-仓库信息"><a href="#1、添加-origin-仓库信息" class="headerlink" title="1、添加 origin 仓库信息"></a>1、添加 origin 仓库信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin &lt;git仓库地址&gt;</div></pre></td></tr></table></figure>
<h4 id="2、查看-origin-仓库信息"><a href="#2、查看-origin-仓库信息" class="headerlink" title="2、查看 origin 仓库信息"></a>2、查看 origin 仓库信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#以下三种方式均可</div><div class="line">git config get --remote.origin.url</div><div class="line">git remote -v</div><div class="line">git remote show origin</div></pre></td></tr></table></figure>
<h4 id="3、删除-origin-仓库信息"><a href="#3、删除-origin-仓库信息" class="headerlink" title="3、删除 origin 仓库信息"></a>3、删除 origin 仓库信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div></pre></td></tr></table></figure>
<h3 id="问：如何配置-git-ssh-keys-？"><a href="#问：如何配置-git-ssh-keys-？" class="headerlink" title="问：如何配置 git ssh keys ？"></a>问：如何配置 git ssh keys ？</h3><p>在本地生成 ssh 私钥 / 公钥 文件<br>将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台<br>测试 git ssh 连接是否成功<br>接下来以添加 github ssh keys 为例，请注意替换 github 文件名。</p>
<p>注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#运行以下命令，一直回车，文件名可随意指定</div><div class="line">ssh-keygen -t rsa -b 4096 -C &quot;kaiye@macbook&quot; -f ~/.ssh/github</div><div class="line"></div><div class="line">#如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain</div><div class="line">ssh-add -K ~/.ssh/github</div><div class="line"></div><div class="line">#将 pub 公钥的内容粘贴到线上网站的后台</div><div class="line">cat ~/.ssh/github.pub</div><div class="line"></div><div class="line">#测试 git ssh 是否连接成功</div><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<h3 id="问：如何撤销修改？"><a href="#问：如何撤销修改？" class="headerlink" title="问：如何撤销修改？"></a>问：如何撤销修改？</h3><p>修改包含四种情况，需单独区分。</p>
<h4 id="1、新建的文件和目录，且从未提交至版本库"><a href="#1、新建的文件和目录，且从未提交至版本库" class="headerlink" title="1、新建的文件和目录，且从未提交至版本库"></a>1、新建的文件和目录，且从未提交至版本库</h4><p>此类文件的状态为 Untracked files ，撤销方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clean -fd</div></pre></td></tr></table></figure></p>
<p>其中,”.”表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。</p>
<h4 id="2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）"><a href="#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）" class="headerlink" title="2、提交过版本库，但未提交至暂存区的文件（未执行 git add）"></a>2、提交过版本库，但未提交至暂存区的文件（未执行 git add）</h4><p>此类文件的状态为<code>Changes not staged for commit</code>，撤销方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout .</div></pre></td></tr></table></figure></p>
<h4 id="3、已提交至暂存区的文件"><a href="#3、已提交至暂存区的文件" class="headerlink" title="3、已提交至暂存区的文件"></a>3、已提交至暂存区的文件</h4><p>此类文件的状态为 Changes to be committed，撤销方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset .</div></pre></td></tr></table></figure></p>
<p>执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。</p>
<h4 id="4、已提交至版本库（执行了-git-commit）"><a href="#4、已提交至版本库（执行了-git-commit）" class="headerlink" title="4、已提交至版本库（执行了 git commit）"></a>4、已提交至版本库（执行了 git commit）</h4><p>每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">git reset &lt;版本号&gt;</div></pre></td></tr></table></figure></p>
<p>如果需要「回滚至上一次提交」，可直接使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset head~1</div></pre></td></tr></table></figure></p>
<p>执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。</p>
<h4 id="5、如果回滚了之后又不想回滚了怎么办？"><a href="#5、如果回滚了之后又不想回滚了怎么办？" class="headerlink" title="5、如果回滚了之后又不想回滚了怎么办？"></a>5、如果回滚了之后又不想回滚了怎么办？</h4><p>如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。</p>
<p>如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。</p>
<h3 id="问：遇到冲突了怎么解决？"><a href="#问：遇到冲突了怎么解决？" class="headerlink" title="问：遇到冲突了怎么解决？"></a>问：遇到冲突了怎么解决？</h3><p>两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。</p>
<h4 id="1、最快的办法"><a href="#1、最快的办法" class="headerlink" title="1、最快的办法"></a>1、最快的办法</h4><p>大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 使用当前分支 HEAD 版本，通常是冲突源文件的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记部分，======= 的上方</div><div class="line">git checkout --ours &lt;文件名&gt;</div><div class="line"></div><div class="line"> # 使用合并分支版本，通常是源冲突文件的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记部分</div><div class="line"> git checkout --theirs &lt;文件名&gt;</div><div class="line"></div><div class="line"># 标记为解决状态加入暂存区</div><div class="line">git add &lt;文件名&gt;</div></pre></td></tr></table></figure></p>
<h4 id="2、最通用的办法"><a href="#2、最通用的办法" class="headerlink" title="2、最通用的办法"></a>2、最通用的办法</h4><p>用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。</p>
<p>在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。</p>
<h4 id="3、最好的习惯"><a href="#3、最好的习惯" class="headerlink" title="3、最好的习惯"></a>3、最好的习惯</h4><p>有三个好的习惯，可以减少代码的冲突：<br>在开始修改代码前先 git pull 一下；<br>将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；<br>通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性</p>
<h4 id="4、最复杂的情况"><a href="#4、最复杂的情况" class="headerlink" title="4、最复杂的情况"></a>4、最复杂的情况</h4><p>如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。</p>
<p>它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。</p>
<p>rebase 大概的操作步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 将当前分支的版本追加到从远程 pull 回来的节点之后</div><div class="line">git pull --rebase</div><div class="line"></div><div class="line"># 若发生冲突，则按以上其他方法进行解决，解决后继续</div><div class="line">git rebase --continue</div><div class="line"></div><div class="line"># 直到所有冲突得以解决，待项目最后上线前再执行</div><div class="line">git push origin</div><div class="line"></div><div class="line"># 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可</div><div class="line">git rebase --skip</div></pre></td></tr></table></figure></p>
<h3 id="问：如何在不提交修改的前提下，执行-pull-merge-等操作？"><a href="#问：如何在不提交修改的前提下，执行-pull-merge-等操作？" class="headerlink" title="问：如何在不提交修改的前提下，执行 pull / merge 等操作？"></a>问：如何在不提交修改的前提下，执行 pull / merge 等操作？</h3><p>有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。</p>
<p>这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。</p>
<p>以下是 git stash 常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 查看 stash 队列中已暂存了多少 WIP</div><div class="line">git stash list</div><div class="line"></div><div class="line"># 恢复上一次的 WIP 状态，并从队列中移除</div><div class="line">git stash pop</div><div class="line"></div><div class="line"># 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失</div><div class="line">git stash</div><div class="line"></div><div class="line"># 恢复指定编号的 WIP，同时从队列中移除</div><div class="line">git stash pop stash@&#123;num&#125;</div><div class="line"></div><div class="line"># 恢复指定编号的 WIP，但不从队列中移除</div><div class="line">git stash apply stash@&#123;num&#125;</div></pre></td></tr></table></figure></p>
<h3 id="问：如何在-git-log-中查看修改的文件列表？"><a href="#问：如何在-git-log-中查看修改的文件列表？" class="headerlink" title="问：如何在 git log 中查看修改的文件列表？"></a>问：如何在 git log 中查看修改的文件列表？</h3><p>默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --name-status --oneline</div></pre></td></tr></table></figure></p>
<p>每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.ls &apos;log --name-status --oneline --graph&apos;</div></pre></td></tr></table></figure></p>
<p>运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.st &apos;status --porcelain&apos;</div></pre></td></tr></table></figure></p>
<p>更多 git log 参数，可通过 git help log 查看手册。</p>
<p>如果是看上一次提交的版本日志，直接运行 git show 即可。</p>
<p>此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。</p>
<h3 id="问：git-submodule-update-时出错怎么解决？"><a href="#问：git-submodule-update-时出错怎么解决？" class="headerlink" title="问：git submodule update 时出错怎么解决？"></a>问：git submodule update 时出错怎么解决？</h3><p>例如，在执行 git submodule update 时有以下错误信息：</p>
<blockquote>
<p>fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5<br>Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’</p>
</blockquote>
<p>在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。</p>
<p>解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master -u</div></pre></td></tr></table></figure></p>
<p>支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config core.quotepath off</div></pre></td></tr></table></figure></p>
<p>常用的打 tag 操作，更多请查看《Git 基础 - 打标签》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 列出所有本地 tag</div><div class="line">git tag   </div><div class="line"></div><div class="line"># 本地新增一个 tag，推送至 origin 服务器</div><div class="line">git tag -a v1.0.0 -m &apos;tag description&apos;</div><div class="line">git push origin v1.0.0</div><div class="line"></div><div class="line"># 删除本地与 origin tag</div><div class="line">git tag -d v1.0.0</div><div class="line">git push origin --delete v1.0.0</div></pre></td></tr></table></figure></p>
<p>使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 新建分支 branch1，并切换过去</div><div class="line">git checkout -b branch1</div><div class="line"></div><div class="line"># 查看所有本地与远程分支</div><div class="line">git branch -a</div><div class="line"></div><div class="line"># 修改完成后，切换回 master 分支，将 branch1 分支合并进来</div><div class="line">git checkout master</div><div class="line">git merge branch1</div><div class="line"></div><div class="line"># 删除已完成合并的分支 branch1</div><div class="line">git branch -d branch1</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>Pro Git 简体中文版</li>
<li>Git权威指南</li>
<li>命令行man手册</li>
</ol>
<blockquote>
<p>原文地址<a href="http://www.ezlippi.com/blog/2016/02/git-guide.html" target="_blank" rel="external">http://www.ezlippi.com/blog/2016/02/git-guide.html</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建个人博客]]></title>
      <url>http://vinoit.me/2016/05/16/hexo-create-blog/</url>
      <content type="html"><![CDATA[<p>不得不说，hexo给程序猿提供了一种高逼格的写作方式。配置也比较方便，而且目录、Rss和sitemap都是自动生成，你只需花几个小时就能掌握用hexo来编写博客。</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>安装hexo之前请确保机器上已正确安装、配置了git,node.js,如果出现npm安装太慢，请更换npm源:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm config set registry https://registry.npm.taobao.org</div><div class="line">npm info underscore （如果上面配置正确这个命令会有字符串response）</div></pre></td></tr></table></figure>
<ul>
<li>安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir hexoblog  #创建一个文件夹</div><div class="line">cd hexoblog</div><div class="line">npm install -g hexo-cli</div><div class="line">npm install hexo --save</div></pre></td></tr></table></figure>
<ul>
<li>创建博客</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init</div></pre></td></tr></table></figure>
<ul>
<li>生成静态站点文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure>
<ul>
<li>运行服务器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>启动成功的话浏览器输入<code>http://localhost:4000/</code><br>应该能看到默认的页面</p>
<ul>
<li>安装hexo插件：自动生成sitemap,Rss，部署到git等，建议安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-index --save</div><div class="line">npm install hexo-generator-archive --save</div><div class="line">npm install hexo-generator-category --save</div><div class="line">npm install hexo-generator-tag --save</div><div class="line">npm install hexo-server --save</div><div class="line">npm install hexo-deployer-git --save</div><div class="line">npm install hexo-deployer-heroku --save</div><div class="line">npm install hexo-deployer-rsync --save</div><div class="line">npm install hexo-deployer-openshift --save</div><div class="line">npm install hexo-renderer-marked@0.2 --save</div><div class="line">npm install hexo-renderer-stylus@0.2 --save</div><div class="line">npm install hexo-generator-feed@1 --save</div><div class="line">npm install hexo-generator-sitemap@1 --save</div></pre></td></tr></table></figure>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>部署到Github前需要配置_config.yml文件</p>
<p>添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/vinoZHU/vinoZHU.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>然后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h2 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a>fancybox</h2><p>本篇博客开头的图片是这样实现的，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: hexo搭建个人博客</div><div class="line">date: 2016-05-16 11:21:13</div><div class="line">tags: hexo</div><div class="line">categories: hexo</div><div class="line">photos:</div><div class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>本博客采用了iissnan的Next主题，他的博客有详细的安装教程，这里贴下链接<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">next</a>，其中对next主题的设置讲的很详细了，我在这就不多讲了。</p>
<p>参考：<a href="http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html" target="_blank" rel="external">Jekyll迁移到Hexo搭建个人博客</a></p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown基础语法学习]]></title>
      <url>http://vinoit.me/2016/05/16/learn-markdown-basic/</url>
      <content type="html"><![CDATA[<h2 id="优点-emsp-emsp"><a href="#优点-emsp-emsp" class="headerlink" title="优点&emsp;&emsp;"></a>优点&emsp;&emsp;</h2><p><strong>总结 Markdown 的优点如下</strong>：</p>
<ul>
<li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li>
<li>让你专注于文字而不是排版。</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li>
<li>Markdown 的标记语法有极好的可读性。</li>
</ul>
<h2 id="语法介绍-emsp-emsp"><a href="#语法介绍-emsp-emsp" class="headerlink" title="语法介绍&emsp;&emsp;"></a>语法介绍&emsp;&emsp;</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。</p>
<p>而在 Markdown 中，你只需要在文本前面加上 <code>#</code> 即可，同理、你<br>还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加  <code>#</code> 即可，标题字号相应降低。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div><div class="line">##### 五级标题</div><div class="line">###### 六级标题</div></pre></td></tr></table></figure></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*   Red</div><div class="line">*   Green</div><div class="line">*   Blue</div></pre></td></tr></table></figure></p>
<p>等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+   Red</div><div class="line">+   Green</div><div class="line">+   Blue</div></pre></td></tr></table></figure></p>
<p>也等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-   Red</div><div class="line">-   Green</div><div class="line">-   Blue</div></pre></td></tr></table></figure></p>
<p>有序列表则使用数字接着一个英文句点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.  Bird</div><div class="line">2.  McHale</div><div class="line">3.  Parish</div></pre></td></tr></table></figure></p>
<p>其中数字的数值大小并不影响最后的结果</p>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* * *</div><div class="line"></div><div class="line">***</div><div class="line"></div><div class="line">*****</div><div class="line"></div><div class="line">- - -</div><div class="line"></div><div class="line">---------------------------------------</div></pre></td></tr></table></figure></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 <code>&gt;</code> 就好了，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; 引用的文字</div></pre></td></tr></table></figure></p>
<p>最终显示的就是：</p>
<blockquote>
<p>引用的文字</p>
</blockquote>
<h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*这是斜体* ， **这是粗体**</div></pre></td></tr></table></figure></p>
<p>最终显示的就是：<br><em>这是斜体</em> ， <strong>这是粗体</strong></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| Tables        | Are           | Cool  |</div><div class="line">| ------------- |:-------------:| -----:|</div><div class="line">| col 3 is      | right-aligned | $1600 |</div><div class="line">| col 2 is      | centered      |   $12 |</div><div class="line">| zebra stripes | are neat      |    $1 |</div></pre></td></tr></table></figure></p>
<p>显示效果：</p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<p>相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dog | bird | cat</div><div class="line">----|------|----</div><div class="line">foo | foo  | foo</div><div class="line">bar | bar  | bar</div><div class="line">baz | baz  | baz</div></pre></td></tr></table></figure></p>
<p>显示效果：</p>
<table>
<thead>
<tr>
<th>dog</th>
<th>bird</th>
<th>cat</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>foo</td>
<td>foo</td>
</tr>
<tr>
<td>bar</td>
<td>bar</td>
<td>bar</td>
</tr>
<tr>
<td>baz</td>
<td>baz</td>
<td>baz</td>
</tr>
</tbody>
</table>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><p>行内链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[link text](link.address.here)</div></pre></td></tr></table></figure>
</li>
<li><p>行外链接</p>
</li>
</ul>
<p>方便在文中多个地方引用相同的链接，集中管理，文本内容查看也整洁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[link_name][link_id]</div><div class="line">[link_id]: http://link.address.here &quot;注释: 要加 http:// 不然会解析为本地路径&quot;</div></pre></td></tr></table></figure></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>和链接模式类似，只要在前面添加一个 <code>!</code> 叹号即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">![inline text](/path/to/img.jpg &quot;Optional title&quot;)</div><div class="line"></div><div class="line">![outline text][id]</div><div class="line">[id]: url/to/image  &quot;Optional title attribute&quot;</div></pre></td></tr></table></figure></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>行内的一小段代码，可以使用反引号（在TAB上面的那位）来将其包起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">``There is a back door here.``</div></pre></td></tr></table></figure></p>
<p>整段代码可以用三个反引号</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上几种格式是比较常用的格式，Markdown 还有其他语法，如想了解和学习更多，可以参考<a href="http://wowubuntu.com/markdown/#link" target="_blank" rel="external">《Markdown 语法说明 (简体中文版)》</a></p>
<blockquote>
<font color="Darkorange">如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开始我的hexo之旅]]></title>
      <url>http://vinoit.me/2016/05/16/start-my-blog/</url>
      <content type="html"><![CDATA[<h2 id="第一次hexo之旅-emsp-emsp"><a href="#第一次hexo之旅-emsp-emsp" class="headerlink" title="第一次hexo之旅&emsp;&emsp;"></a>第一次hexo之旅&emsp;&emsp;</h2><p>之前一直用博客园来记录学习的过程，虽说比较方便，只需无脑地写到文本框就行了，但是内心一直是想搞一个独立博客的。前几天在github上fork了一份hexo的博客源码，还没了解hexo是怎么用的就直接在源码上改了起来，花了一个周末把博客内容改成了自己的，但是改的都是代码，这样就没有一个可持续的效果。于是乎就开始研究了这个hexo,花了一天时间把博客配了一下，同时也了解了整个博客发布的流程，学习了一下markdown语法，瞬间觉得写博客变成了一种享受，以后可以好好写了。</p>
<p>顺便贴一下我的<a href="http://www.cnblogs.com/vinozly/" target="_blank" rel="external">博客园地址</a> ,记录了我之前的学习过程，有兴趣的同学可以去看看，嘻嘻^^。</p>
]]></content>
    </entry>
    
  
  
</search>
