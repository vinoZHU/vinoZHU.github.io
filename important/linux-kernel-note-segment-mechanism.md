---
title: linux内核笔记之分段机制
date: 2016-08-13 15:59:27
tags: 
- Linux
- 内核
categories: Linux
---
#### 为什么要有分段机制？
* 在8086处理器诞生之前，内存寻址方式就是直接访问物理地址,也就是所谓的实模式。8086处理器为了寻址1M的内存空间，把地址总线扩展到了20位。但是，ALU的宽度`只有16位`，也就是说，ALU不能计算20位的地址。为了解决这个问题，从而引入了分段机制。
为了支持分段，8086处理器设置了四个段寄存器：CS, DS, SS, ES.每个段寄存器都是16位的，都包含着相应段的基址，访存指令中的地址也是16位的。但是，在送入地址总线之前，CPU先把它与某个段寄存器内的值按以下方式相加：
`实际物理地址 = （段寄存器地址 << 4） + （指令访存地址）`

* 80286处理器的地址总线为24位，寻址空间达16M，同时引入了保护模式（指令给出的地址不对应实际的物理地址）
* 80386处理器是一个32位处理器，ALU和地址总线都是32位的，寻址空间达 4G。它可以不通过分段机制，直接访问4G的内存空间。然而为了兼容前代的处理器，它必须同时支持实模式和保护模式。所以，80386在段寄存器的基础上构筑保护模式，并且保留16位的段寄存器。

* 从80386之后的处理器，架构基本相似，统称为IA32（32 Bit Intel Architecture）。

#### IA32架构下的内存寻址

##### IA32的三类地址

- 逻辑地址:
机器语言指令用这类地址指定一个操作数的地址或一条指令的地址，最原始的地址就是逻辑地址。
- 线性地址：
将逻辑地址经过分段机制转换之后，便得到了线性地址,每个线性地址都由一个段基址和段内偏移量组成。
- 物理地址：
线性地址经过分页单元的处理之后得到一个实际物理地址，也就是内存单元的实际地址，用于芯片级内存单元寻址。

##### MMU地址转化过程
以上3类地址是通过MMU（内存管理单元）来进行转换。其中MMU处理时包含2个过程，分段和分页。在这里简单的说明下具体过程：

> 当一条机器指令给出一个地址时，这时候的地址便是逻辑地址。
> 
> 为了得到线性地址，需要从相应的段寄存器中取出16位的段标识符（段选择符），通过这个段标识符可以得到一个段基址。然后将得到的段基址与指令中的地址相加，从而得到一个线性地址。
> 
> 有了线性地址之后，再通过分页单元得到实际的物理地址。
 
##### IA32的段寄存器
IA32中有六个16位段寄存器：CS, DS, SS, ES，FS, GS.跟8086的段寄存器不同的是，这些寄存器存放的不再是某个段的基地址，而是某个段的选择符（Selector）。

#### 硬件中的分段

##### 段选择符和段寄存器
段寄存器的唯一目的就是存放段选择符，段选择符是一个16位长的字段：
![](/images/linux-kernel-note/segment-mechanism-0.jpg)

第01位表示的是请求者的特权，第2位是表指示器，用于指定所使用的描述符表。3~15位是一个索引号，定位到描述符表中的某一项段描述符。

##### 段描述符
段描述符说白了就是用来描述段的特征，段描述表放在全局描述符表（GDT）或者局部描述符表（LDT），每个段描述符为8个字节大小。GDT的地址和大小存放在寄存器gdtr中，LDT的地址和大小存放在寄存器ldtr中。

有几种不同类型的段以及它们对应的段描述符，下面列出了Linux中广泛采用的类型：

**代码段描述符**

表示这个段描述符代表一个代码段，它可以放在GDT或LDT中。该描述符置S标志为1，并且为非系统段。

**数据段描述符**

表示这个段描述符代表一个数据段，它可以放在GDT或LDT中。该描述符置S标志为1，栈段是通过数据段实现的。

**任务状态段描述符（TSSD）**

表示这个段描述符代表一个任务状态段（Task State Segment，TSS），也就是说这个段用于保存处理器寄存器的内容。它只能出现在GDT中。根据相应的进程是否正在CPU上运行，其Type字段的值分别为11或9。这个描述符的S标志被置为0。

**局部描述符表描述符（LDTD）**

这个表示段描述符代表一个包含LDT的段，他置出现在GDT中。相应的Type字段的值为2，S标志被置为0。

下图为段描述符的字段表示：
![](/images/linux-kernel-note/segment-mechanism-1.png)

相应字段的意义如下：


| 字段名       | 说明         |
| :-------------: |:-------------|
| Base  | 包含段的首字节的线性地址 |
| G     | 粒度标志，如果为0，则段大小以字节为单位，否则以4096字节的倍数计算 |
| Limit | 存放段最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在一个字节到1MB之间变化，否则，将在4KB到4GB之间变化 |
| S     | 系统标志，如果被置为0，则这是一个系统段，否则为普通的代码段或者数据段 |
| Type  | 描述了段的类型特征和它的存取权限 |
| DPL   | 描述符特权等级字段，用于限制这个段的存取。它表示为访问这个段而要求的CPU最小的优先级，因此DPL设置为0的段只能当CPL为0时，也就是内核态才可以访问。DPL设为3则堆任何CPL值都是可访问的 |
| P     | Segment-Present标志，等于0表示段当前不在主存中。Linux总是把此标志设为1，因为Linux从来不把整个段交换到磁盘上去 |
| D或B  | 称为D或B标志，取决于是代码段还是数据段，D和B的含义在两种情况下有区别，如果段偏移量的地址是32位长，就基本上把它设置为1，如果偏移量是16位长，则清零 |
| AVL  | 可以由操作系统使用，但是被Linux忽略 |

当指令给出一个地址后，硬件的处理顺序如下：

1. 根据指令类型选择好段选择符，检查段选择符的TI字段，决定使用GDT还是LDT，再从gftr寄存器或者ldtr寄存器中获得描述符表的地址。
2. 使用段选择符的索引号，定位到段描述符，`描述符地址 = 索引号 * 8 + gdtr(ldtr)中的地址`。
3. 将段描述符中的Base值与给出的地址相加，从而得到线性地址。
4. 将线性地址通过分页单元换换成物理地址。

其中的段描述符地址，在寄存器内容不变的情况下会保存在一个与段寄存器相关的不可编程寄存器中，相当于缓存了这个地址，于是就可以省去前面2个步骤。

#### Linux中的分段
 Linux的段式管理，事实上只是“哄骗”了一下硬件而已。从2.2版开始，Linux让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。但内核中也用到LDT，那只是在VM86模式中运行Wine，因为就是说在Linux上模拟运行Winodws软件或DOS软件的程序时才使用。
 
 在内核源码`include/asm-i386/segment.h`中定义了如下宏:
 
 ```c
#define GDT_ENTRY_DEFAULT_USER_CS        14
#define __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)
#define GDT_ENTRY_DEFAULT_USER_DS        15
#define __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)
#define GDT_ENTRY_KERNEL_BASE        12
#define GDT_ENTRY_KERNEL_CS                (GDT_ENTRY_KERNEL_BASE + 0)
#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)
#define GDT_ENTRY_KERNEL_DS                (GDT_ENTRY_KERNEL_BASE + 1)
#define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)
 ```
 把其中的宏替换成数值，则为：
 
 ```c
#define __USER_CS 115      [00000000 1110  0  11]（用户代码段）
#define __USER_DS 123      [00000000 1111  0  11]（用户数据段）
#define __KERNEL_CS 96     [00000000 1100  0  00]（内核代码段）
#define __KERNEL_DS 104    [00000000 1101  0  00]（内核数据段）
 ```
 方括号后是这四个段选择符的16位二制表示，它们的索引号和T1字段值也可以算出来了：
 
 ```
__USER_CS             index= 14   T1=0
__USER_DS             index= 15   T1=0
__KERNEL_CS           index= 12   T1=0
__KERNEL_DS           index= 13   T1=0
 ```
 T1均为0，则表示都使用了GDT，再来看初始化GDT的内容中相应的12-15项(arch/i386/head.S)：
 
 ```c
        .quad 0x00cf9a000000ffff        /* 0x60 kernel 4GB code at 0x00000000 */
        .quad 0x00cf92000000ffff        /* 0x68 kernel 4GB data at 0x00000000 */
        .quad 0x00cffa000000ffff        /* 0x73 user 4GB code at 0x00000000 */
        .quad 0x00cff2000000ffff        /* 0x7b user 4GB data at 0x00000000 */
 ```
按照前面段描述符表中的描述，可以把它们展开，发现其16-31位全为0，即四个段的基地址全为0。

这样，给定一个段内偏移地址，按照前面转换公式，0 + 段内偏移，转换为线性地址，可以得出重要的结论，**在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。**

#### 总结
分段机制的存在主要是为了兼容前代处理器，而Linux巧妙的避开了硬件的死套路，有时候软硬件的结合的确很和谐。

><font color= Darkorange>如若觉得本文尚可，欢迎转载交流,转载请在正文明显处注明原文地址，谢谢！</font>
