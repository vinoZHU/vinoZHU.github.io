---
title: linux内核笔记之分页机制
date: 2016-08-14 15:07:15
tags: 
- Linux
- 内核
categories: Linux
---
一个逻辑地址经过[分段机制](/2016/08/13/linux-kernel-note-segment-mechanism/)转换为一个线性地址之后，便需要分页单元将线性地址转换为实际的物理地址。

#### 硬件中的分页

从80386开始，所有的80x86处理器都支持分页。是否开启分页通过设置cr0寄存器的PG标志来决定，当PG为0时，表示不开启分页，此时线性地址呗解释为物理地址。

分页机制管理的对象是固定大小的存储块，称之为页(page)。分页机制把整个线性地址空间及整个物理地址空间都看成由页组成，在线性地址空间中的任何一页，可以映射为物理地址空间中的任何一页（我们把物理空间中的一页叫做一个页面或页框(page frame)）。

80386中每一页的大小都为4KB，每一页的起始地址都能被4K整除（低12位全为0）。因此，80386把4G的线性地址空间，划分为1M个页面。

把线性地址映射到物理地址的数据结构称为页表，页表存放在主存中，由内核进行适当的初始化。

##### 常规分页
Intel处理器在处理一个32位的线性地址时，将其分成3部分（按照Little-Endian)：

- Directory（目录）：最高10位
- Table(页表) ：中间10位
- Offset(偏移量) ：最低12位

线性地址的转换的流程如下：

1. 通过高10位定位到页目录中的某一项，获取一个页表。
2. 通过中间10位定位到页表中的某一项，获取到一个页的起始地址
3. 将低12位（偏移量）+ 步骤2中的得到的页起始地址，获得实际的物理地址。

其中的页目录地址存放在cr3寄存器中。

![](/images/linux-kernel-note/page-mechanism-0.png)

##### 为什么使用二级模式？
如果使用一级页表，那么整个页表相当于一个拥有1M个元素的大数组，每个页表项占用的大小为4B，所以整个页表的大小为4M。然而每个活动进程都需要一个独立的页表，绝大多数进程都不会马上使用所有的进程地址空间，相比较直接分配一个映射所有地址空间的一级页表，需要时分配页表显然更加效率。二级模式只为进程实际使用的那些虚拟内存区分配页表，既提升了效率，也减少了内存的使用量。（PS：当使用二级页表时，如果为进程的所有虚拟内存区都分配了页表，这时候的内存使用量是增加的）

##### 页目录项结构
![](/images/linux-kernel-note/page-mechanism-1.gif)

- 第31~12位是20位页表地址，由于页表地址的低12位总为0，所以用高20位指出32位页表地址就可以了。因此，一个页目录最多包含1024个页表地址。
- 第0位是存在位，如果P=1，表示页表地址指向的该页在内存中，如果P=0，表示不在内存中。
- 第1位是读/写位，第2位是用户/管理员位，这两位为页目录项提供硬件保护。当特权级为3的进程要想访问页面时，需要通过页保护检查，而特权级为0的进程就可以绕过页保护。
- 第3位是PWT（Page Write-Through）位，表示是否采用写透方式，写透方式就是既写内存（RAM）也写高速缓存,该位为1表示采用写透方式
- 第4位是PCD（Page Cache Disable）位，表示是否启用高速缓存,该位为1表示启用高速缓存。
- 第5位是访问位，当对页目录项进行访问时，A位=1。
- 第7位是Page Size标志，只适用于页目录项。如果置为1，页目录项指的是4MB的页面，请看后面的扩展分页。
- 第9~11位由操作系统专用，Linux也没有做特殊之用。

##### 页表项结构
![](/images/linux-kernel-note/page-mechanism-2.gif)
80386的每个页目录项指向一个页表，页表最多含有1024个页面项，每项4个字节，包含页面的起始地址和有关该页面的信息。页面的起始地址也是4K的整数倍，所以页面的低12位也留作它用。
第31~12位是20位物理页面地址，除第6位外第0～5位及9~11位的用途和页目录项一样，第6位是页面项独有的，当对涉及的页面进行写操作时，D位被置1。
4GB的内存只有一个页目录，它最多有1024个页目录项，每个页目录项又含有1024个页面项，因此，内存一共可以分成1024×1024=1M个页面。由于每个页面为4K个字节，所以，存储器的大小正好最多为4GB。

##### 扩展分页
扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。在扩展分页的情况下,分页机制把32位线性地址分成两个域：最高10位的目录域和其余22位的偏移量。

扩展分页地址转换过程如下：
![](/images/linux-kernel-note/page-mechanism-3.png)

##### 硬件高速缓存
硬件高速缓存中组相连映射是使用最多的，以下是组相连映射的流程图：
![](/images/linux-kernel-note/page-mechanism-4.jpg)
![](/images/linux-kernel-note/page-mechanism-5.jpg)

##### 转换后援缓冲器(TLB)
因为在获取页地址时需要去慢速访问主存，而TLB缓存了线性地址和物理地址映射的关系，所以直接在SRAM中就可以获取到对应的物理地址，节省了时间。在多处理器系统中，每个CPU都有自己的TLB，叫做本地TLB。

#### Linux中的分页
Linux使用了一个适合32位和64位系统的分页模型。
![](/images/linux-kernel-note/page-mechanism-6.png)
上图的4种页表分别为:

- 页全局目录
- 页上级目录
- 页中间目录
- 页表

页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分成五个部分。图中没有显示位数，因为每一部分的大小与具体的计算机体系结构有关。

对于没有启用物理地址扩展的32位系统，两级页表已经足够了。从本质上说Linux通过使“页上级目录”位和“页中间目录”位全为0，彻底取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位系统和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个合适的目录项而实现的。

启用了物理地址扩展的32 位系统使用了三级页表。Linux的页全局目录对应80×86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应80×86的页目录，Linux的页表对应80×86的页表。

最后，64位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。

#### 总结
从硬件的角度，32位地址被分成了三部份。不管理软件怎么做，最终落实到硬件，也只识别这3部分。

从软件的角度，由于多引入了两部份，也就是说，共有五部份。要让二层架构的硬件认识五部分，在地址划分的时候，将页上级目录和页中间目录的长度设置为0就可以了。

这样，操作系统见到的是五部份，硬件还是按它死板的三部份划分，软硬件又和谐了。

<font color= Darkorange>尊重他人劳动,转载请在正文明显处注明原文地址。</font>






